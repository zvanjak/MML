/////////////////////////////////////////////////////////////////////////////////////
//  __ __ __ __ _                                                                  //
// |  |  |  |  | |    Minimal Math Library for Modern C++                          //
// | | | | | | | |__  version 1.1                                                  //
// |_| |_|_| |_|____| https://github.com/zvanjak/mml                               //
//                                                                                 //
// Copyright: 2023 - 2025, Zvonimir Vanjak (with Claude Sonnet assistance)         //
//                                                                                 //
//  License:     Licensed under MML dual-license (see LICENSE.md)                  //
//               - Free for non-commercial use                                     //
//               - Commercial license available                                    //
//                                                                                 //
// This is a single-header version of MML - all headers combined into one file.    //
// For the multi-header version, see the mml/ directory.                           //
/////////////////////////////////////////////////////////////////////////////////////

#ifndef MML_SINGLE_HEADER
#define MML_SINGLE_HEADER

#define __STDCPP_WANT_MATH_SPEC_FUNCS__ 1

// Standard library headers
#include <stdexcept>
#include <initializer_list>
#include <memory>
#include <functional>
#include <type_traits>

#include <string>
#include <vector>
#include <array>
#include <list>
#include <tuple>
#include <map>
#include <set>

#include <fstream>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <filesystem>

#include <algorithm>
#include <numeric>
#include <cmath>
#include <limits>
#include <complex>
#include <numbers>
#include <regex>
#include <cstdint>

#include <random>
#include <chrono>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <future>
#include <queue>


#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#else
#include <unistd.h>
#include <sys/wait.h>
#endif

// HAJDUK ZIVI VJECNO!!!


///////////////////////////   mml/MMLPrecision.h   ///////////////////////////

namespace MML
{
	// Template struct for precision values
	template<typename T>
	struct PrecisionValues;

	// Specialization for float
	template<>
	struct PrecisionValues<float>
	{
		static constexpr float ComplexAreEqualTolerance = 1e-6f;
		static constexpr float ComplexAreEqualAbsTolerance = 1e-6f;

		static constexpr float MatrixIsEqualTolerance = 1e-6f;
		static constexpr float VectorIsEqualTolerance = 1e-6f;

		static constexpr float Pnt2CartIsEqualTolerance = 1e-6f;
		static constexpr float Pnt2PolarIsEqualTolerance = 1e-6f;
		static constexpr float Pnt3CartIsEqualTolerance = 1e-6f;
		static constexpr float Pnt3SphIsEqualTolerance = 1e-6f;
		static constexpr float Pnt3CylIsEqualTolerance = 1e-6f;

		static constexpr float Vec2CartIsEqualTolerance = 1e-6f;
		static constexpr float Vec3CartIsEqualTolerance = 1e-6f;
		static constexpr float Vec3CartIsParallelTolerance = 1e-6f;

		static constexpr float Vec3SphIsEqualTolerance = 1e-6f;

		static constexpr float Line3DAreEqualTolerance = 1e-6f;
		static constexpr float Line3DIsPointOnLineTolerance = 1e-6f;
		static constexpr float Line3DIsPerpendicularTolerance = 1e-6f;
		static constexpr float Line3DIsParallelTolerance = 1e-6f;
		static constexpr float Line3DIntersectionTolerance = 1e-6f;

		static constexpr float Plane3DIsPointOnPlaneTolerance = 1e-6f;

		static constexpr float Triangle3DIsPointInsideTolerance = 1e-6f;	static constexpr float Triangle3DIsRightTolerance = 1e-6f;
	static constexpr float Triangle3DIsIsoscelesTolerance = 1e-6f;
	static constexpr float Triangle3DIsEquilateralTolerance = 1e-6f;
		static constexpr float IsMatrixSymmetricTolerance = 1e-6f;
		static constexpr float IsMatrixDiagonalTolerance = 1e-6f;
		static constexpr float IsMatrixUnitTolerance = 1e-6f;
		static constexpr float IsMatrixOrthogonalTolerance = 1e-6f;

		static constexpr float RankAlgEPS = 1e-10f;

		// Numerical computation thresholds
		static constexpr float NumericalZeroThreshold = 1e-12f;      // For checking near-zero values
		static constexpr float QuaternionZeroThreshold = 1e-12f;     // Quaternion singularity detection
		static constexpr float SurfaceNormalThreshold = 1e-12f;      // Surface normal magnitude threshold
		static constexpr float DerivativeStepSize = 1e-6f;           // Default step for numerical derivatives
		static constexpr float DefaultTolerance = 1e-6f;             // General purpose tolerance
		static constexpr float DefaultToleranceRelaxed = 1e-8f;      // Relaxed tolerance for geometric tests

		// Algorithm-specific thresholds
		static constexpr float EigenSolverZeroThreshold = 1e-12f;    // Eigenvalue solver zero detection
		static constexpr float PolynomialCoeffZeroThreshold = 1e-10f; // Polynomial coefficient zero check
		static constexpr float MatrixElementZeroThreshold = 1e-12f;  // Matrix element near-zero check
		static constexpr float DeterminantZeroThreshold = 1e-12f;    // Determinant zero detection
		static constexpr float DivisionSafetyThreshold = 1e-25f;     // Safe division threshold
		static constexpr float OrthogonalityTolerance = 1e-8f;       // Orthogonal vector check tolerance
		static constexpr float LinearDependenceTolerance = 1e-10f;   // Linear dependence check tolerance
	};

	// Specialization for double
	template<>
	struct PrecisionValues<double>
	{
		static constexpr double ComplexAreEqualTolerance = 1e-10;
		static constexpr double ComplexAreEqualAbsTolerance = 1e-10;

		static constexpr double MatrixIsEqualTolerance = 1e-10;
		static constexpr double VectorIsEqualTolerance = 1e-10;

		static constexpr double Pnt2CartIsEqualTolerance = 1e-10;
		static constexpr double Pnt2PolarIsEqualTolerance = 1e-10;
		static constexpr double Pnt3CartIsEqualTolerance = 1e-10;
		static constexpr double Pnt3SphIsEqualTolerance = 1e-10;
		static constexpr double Pnt3CylIsEqualTolerance = 1e-10;

		static constexpr double Vec2CartIsEqualTolerance = 1e-10;
		static constexpr double Vec3CartIsEqualTolerance = 1e-10;
		static constexpr double Vec3CartIsParallelTolerance = 1e-10;

		static constexpr double Vec3SphIsEqualTolerance = 1e-10;

		static constexpr double Line3DAreEqualTolerance = 1e-10;
		static constexpr double Line3DIsPointOnLineTolerance = 1e-10;
		static constexpr double Line3DIsPerpendicularTolerance = 1e-10;
		static constexpr double Line3DIsParallelTolerance = 1e-10;
		static constexpr double Line3DIntersectionTolerance = 1e-10;

		static constexpr double Plane3DIsPointOnPlaneTolerance = 1e-10;

		static constexpr double Triangle3DIsPointInsideTolerance = 1e-10f;	static constexpr double Triangle3DIsRightTolerance = 1e-10;
	static constexpr double Triangle3DIsIsoscelesTolerance = 1e-10;
	static constexpr double Triangle3DIsEquilateralTolerance = 1e-10;
		static constexpr double IsMatrixSymmetricTolerance = 1e-10;
		static constexpr double IsMatrixDiagonalTolerance = 1e-10;
		static constexpr double IsMatrixUnitTolerance = 1e-10;
		static constexpr double IsMatrixOrthogonalTolerance = 1e-10;

		static constexpr double RankAlgEPS = 1e-12f;

		// Numerical computation thresholds
		static constexpr double NumericalZeroThreshold = 1e-12;      // For checking near-zero values
		static constexpr double QuaternionZeroThreshold = 1e-12;     // Quaternion singularity detection
		static constexpr double SurfaceNormalThreshold = 1e-12;      // Surface normal magnitude threshold
		static constexpr double DerivativeStepSize = 1e-6;           // Default step for numerical derivatives
		static constexpr double DefaultTolerance = 1e-6;             // General purpose tolerance
		static constexpr double DefaultToleranceRelaxed = 1e-8;      // Relaxed tolerance for geometric tests

		// Algorithm-specific thresholds
		static constexpr double EigenSolverZeroThreshold = 1e-15;    // Eigenvalue solver zero detection
		static constexpr double PolynomialCoeffZeroThreshold = 1e-12; // Polynomial coefficient zero check
		static constexpr double MatrixElementZeroThreshold = 1e-15;  // Matrix element near-zero check
		static constexpr double DeterminantZeroThreshold = 1e-15;    // Determinant zero detection
		static constexpr double DivisionSafetyThreshold = 1e-30;     // Safe division threshold
		static constexpr double OrthogonalityTolerance = 1e-10;      // Orthogonal vector check tolerance
		static constexpr double LinearDependenceTolerance = 1e-12;   // Linear dependence check tolerance
	};

	// Specialization for long double
	template<>
	struct PrecisionValues<long double>
	{
		static constexpr long double ComplexAreEqualTolerance = 1e-15L;
		static constexpr long double ComplexAreEqualAbsTolerance = 1e-15L;

		static constexpr long double MatrixIsEqualTolerance = 1e-15L;
		static constexpr long double VectorIsEqualTolerance = 1e-15L;

		static constexpr long double Pnt2CartIsEqualTolerance = 1e-15;
		static constexpr long double Pnt2PolarIsEqualTolerance = 1e-15;
		static constexpr long double Pnt3CartIsEqualTolerance = 1e-15;
		static constexpr long double Pnt3SphIsEqualTolerance = 1e-15;
		static constexpr long double Pnt3CylIsEqualTolerance = 1e-15;

		static constexpr long double Vec2CartIsEqualTolerance = 1e-15;
		static constexpr long double Vec3CartIsEqualTolerance = 1e-15;
		static constexpr long double Vec3CartIsParallelTolerance = 1e-15;

		static constexpr long double Vec3SphIsEqualTolerance = 1e-15;

		static constexpr long double Line3DAreEqualTolerance = 1e-15;
		static constexpr long double Line3DIsPointOnLineTolerance = 1e-15;
		static constexpr long double Line3DIsPerpendicularTolerance = 1e-15;
		static constexpr long double Line3DIsParallelTolerance = 1e-15;
		static constexpr long double Line3DIntersectionTolerance = 1e-15;

		static constexpr long double Plane3DIsPointOnPlaneTolerance = 1e-15;

		static constexpr long double Triangle3DIsPointInsideTolerance = 1e-15f;	static constexpr long double Triangle3DIsRightTolerance = 1e-12L;
	static constexpr long double Triangle3DIsIsoscelesTolerance = 1e-12L;
	static constexpr long double Triangle3DIsEquilateralTolerance = 1e-12L;
		static constexpr long double IsMatrixSymmetricTolerance = 1e-15;
		static constexpr long double IsMatrixDiagonalTolerance = 1e-15;
		static constexpr long double IsMatrixUnitTolerance = 1e-15;
		static constexpr long double IsMatrixOrthogonalTolerance = 1e-15;

		static constexpr long double RankAlgEPS = 1e-13f;

		// Numerical computation thresholds
		static constexpr long double NumericalZeroThreshold = 1e-12L;      // For checking near-zero values
		static constexpr long double QuaternionZeroThreshold = 1e-12L;     // Quaternion singularity detection
		static constexpr long double SurfaceNormalThreshold = 1e-12L;      // Surface normal magnitude threshold
		static constexpr long double DerivativeStepSize = 1e-6L;           // Default step for numerical derivatives
		static constexpr long double DefaultTolerance = 1e-6L;             // General purpose tolerance
		static constexpr long double DefaultToleranceRelaxed = 1e-8L;      // Relaxed tolerance for geometric tests

		// Algorithm-specific thresholds
		static constexpr long double EigenSolverZeroThreshold = 1e-18L;    // Eigenvalue solver zero detection
		static constexpr long double PolynomialCoeffZeroThreshold = 1e-15L; // Polynomial coefficient zero check
		static constexpr long double MatrixElementZeroThreshold = 1e-18L;  // Matrix element near-zero check
		static constexpr long double DeterminantZeroThreshold = 1e-18L;    // Determinant zero detection
		static constexpr long double DivisionSafetyThreshold = 1e-35L;     // Safe division threshold
		static constexpr long double OrthogonalityTolerance = 1e-12L;      // Orthogonal vector check tolerance
		static constexpr long double LinearDependenceTolerance = 1e-15L;   // Linear dependence check tolerance
	};
}




///////////////////////////   mml/MMLBase.h   ///////////////////////////

#define __STDCPP_WANT_MATH_SPEC_FUNCS__ 1

// MML headers first (catches missing includes in them)

// Standard headers - only what MMLBase.h actually uses

// HAJDUK ZIVI VJECNO!!!

typedef double						 Real; // default real type

// other possibilites:
// typedef float						 Real;
// typedef long double       Real;
// typedef __float128				 Real;    // only for GCC!

// Macro for type-safe numeric literals that match Real type
// This ensures literals like 0.0, 1.0 match the current Real precision
#ifndef REAL
#define REAL(x) static_cast<Real>(x)
#endif

// Complex must have the same underlaying type as Real
typedef std::complex<Real> Complex; // default complex type

namespace MML 
{

  // Generic absolute value functions
  template <class Type> static Real Abs(const Type &a) { return std::abs(a); }
  template <class Type> static Real Abs(const std::complex<Type> &a) {
    return hypot(a.real(), a.imag());
  }


  inline bool isWithinAbsPrec(Real a, Real b, Real eps) {
    return std::abs(a - b) < eps;
  }
  inline bool isWithinRelPrec(Real a, Real b, Real eps) {
    return std::abs(a - b) < eps * std::max(Abs(a), Abs(b));
  }

  template <class T> inline T POW2(const T &a) {
    const T &t = a;
    return t * t;
  }
  template <class T> inline T POW3(const T &a) {
    const T &t = a;
    return t * t * t;
  }
  template <class T> inline T POW4(const T &a) {
    const T &t = a * a;
    return t * t;
  }
  template <class T> inline T POW5(const T &a) {
    const T &t = a;
    return t * t * t * t * t;
  }

  ////////////                  Constants                ////////////////
  namespace Constants {
    // Mathematical constants with maximum double precision (C++17 compatible)
    // These values match std::numbers from C++20 to full double precision
    static inline constexpr double PI         = 3.14159265358979323846;  // pi
    static inline constexpr double INV_PI     = 0.31830988618379067154;  // 1/pi
    static inline constexpr double INV_SQRTPI = 0.56418958354775628695;  // 1/sqrt(pi)

    static inline constexpr double E          = 2.71828182845904523536;  // e
    static inline constexpr double LN2        = 0.69314718055994530942;  // ln(2)
    static inline constexpr double LN10       = 2.30258509299404568402;  // ln(10)

    static inline constexpr double SQRT2      = 1.41421356237309504880;  // sqrt(2)
    static inline constexpr double SQRT3      = 1.73205080756887729353;  // sqrt(3)

    // Precision constants - use Real type for consistency with library's floating-point type
    static inline const Real Eps = std::numeric_limits<Real>::epsilon();
    static inline const Real PosInf = std::numeric_limits<Real>::infinity();
    static inline const Real NegInf = -std::numeric_limits<Real>::infinity();
  } // namespace Constants

  // a * x^2 + b * x + c = 0
  inline int SolveQuadratic(Real a, Real b, Real c, Complex &x1, Complex &x2) {
    Real D = b * b - 4 * a * c;
    if (D >= 0) {
      Real sqrtD = sqrt(D);
      x1 = (-b + sqrtD) / (2 * a);
      x2 = (-b - sqrtD) / (2 * a);
      return 2;
    } else {
      Complex sqrtD = std::sqrt(Complex(D));
      x1 = (-b + sqrtD) / (2 * a);
      x2 = (-b - sqrtD) / (2 * a);
      return 0;
    }
  }
  inline void SolveQuadratic(const Complex &a, const Complex &b, const Complex &c,
                            Complex &x1, Complex &x2) {
    Complex D = b * b - Real(4.0) * a * c;
    Complex sqrtD = std::sqrt(D);
    x1 = (-b + sqrtD) / (Real(2.0) * a);
    x2 = (-b - sqrtD) / (Real(2.0) * a);
  }
  // Solving cubic equation a * x^3 + b * x^2 + c * x + d = 0
  inline int SolveCubic(Real a, Real b, Real c, Real d, Complex &x1, Complex &x2,
                        Complex &x3) {
    // Normalize the coefficients
    Real A = b / a;
    Real B = c / a;
    Real C = d / a;

    // Calculate the discriminant
    Real Q = (Real(3.0) * B - POW2(A)) / Real(9.0);
    Real R =
        (Real(9.0) * A * B - Real(27.0) * C - Real(2.0) * POW3(A)) / Real(54.0);
    Real D = POW3(Q) + POW2(R); // Discriminant

    if (D >= 0) // Complex or duplicate roots
    {
      Real S = std::cbrt(R + std::sqrt(D));
      Real T = std::cbrt(R - std::sqrt(D));

      x1 = -A / Real(3.0) + (S + T); // Real root
      x2 = -A / Real(3.0) - (S + T) / Real(2.0) +
          Complex(0, std::sqrt(Real(3.0)) * (S - T) / Real(2.0)); // Complex root
      x3 = -A / Real(3.0) - (S + T) / Real(2.0) -
          Complex(0, std::sqrt(Real(3.0)) * (S - T) / Real(2.0)); // Complex root

      return 1;
    } else // Three real roots
    {
      Real theta = std::acos(R / std::sqrt(-POW3(Q)));
      x1 =
          Real(2.0) * std::sqrt(-Q) * std::cos(theta / Real(3.0)) - A / Real(3.0);
      x2 = Real(2.0) * std::sqrt(-Q) *
              std::cos((theta + Real(2.0) * Constants::PI) / Real(3.0)) -
          A / Real(3.0);
      x3 = Real(2.0) * std::sqrt(-Q) *
              std::cos((theta + Real(4.0) * Constants::PI) / Real(3.0)) -
          A / Real(3.0);

      return 3;
    }
  }
  // Solving quartic equation a * x^4 + b * x^3 + c * x^2 + d * x + e = 0
  inline void SolveQuartic(Real a, Real b, Real c, Real d, Real e, Complex &x1,
                          Complex &x2, Complex &x3, Complex &x4) {
    // Degenerate: reduce to cubic
    if (std::abs(a) < Constants::Eps) {
      SolveCubic(b, c, d, e, x1, x2, x3);
      x4 = Complex(0);
      return;
    }

    // Normalize coefficients
    Real A = b / a;
    Real B = c / a;
    Real C = d / a;
    Real D = e / a;

    // Depressed quartic y = x + A/4: y^4 + P y^2 + Q y + R = 0
    Real AA = A * A;
    Real P = B - Real(3.0) * AA / Real(8.0);
    Real Q = C - Real(0.5) * A * B + AA * A / Real(8.0);
    Real R = D - Real(0.25) * A * C + AA * B / Real(16.0) -
            Real(3.0) * AA * AA / Real(256.0);

    // Special case: biquadratic (Q â‰ˆ 0) -> solve t^2 + P t + R = 0 where t = y^2
    if (std::abs(Q) <= Constants::Eps) {
      Complex t1, t2;
      SolveQuadratic(Complex(Real(1.0)), Complex(P), Complex(R), t1, t2);

      x1 = std::sqrt(t1) - A / Real(4.0);
      x2 = -std::sqrt(t1) - A / Real(4.0);
      x3 = std::sqrt(t2) - A / Real(4.0);
      x4 = -std::sqrt(t2) - A / Real(4.0);
      return;
    }

    // General case (Ferrari)
    Complex z1, z2, z3;
    SolveCubic(Real(1.0), -P / Real(2.0), -R,
              R * P / Real(2.0) - Q * Q / Real(8.0), z1, z2, z3);

    auto U_from = [P](const Complex &z) {
      return std::sqrt(Complex(Real(2.0)) * z - P);
    };

    // Choose z to maximize |U| to avoid division by small numbers
    Complex candidates[3] = {z1, z2, z3};
    Complex z = candidates[0];
    Complex U = U_from(z);
    for (int i = 1; i < 3; ++i) {
      Complex Ui = U_from(candidates[i]);
      if (std::abs(Ui) > std::abs(U)) {
        z = candidates[i];
        U = Ui;
      }
    }

    Complex W = Q / (Complex(Real(2.0)) * U);

    // Solve two quadratics in y
    Complex y1, y2, y3, y4;
    SolveQuadratic(Complex(Real(1.0)), U, z - W, y1, y2);
    SolveQuadratic(Complex(Real(1.0)), -U, z + W, y3, y4);

    // Back-substitute x = y - A/4
    x1 = y1 - A / Real(4.0);
    x2 = y2 - A / Real(4.0);
    x3 = y3 - A / Real(4.0);
    x4 = y4 - A / Real(4.0);
  }

  // is_simple_numeric helper
  template <typename T> struct is_simple_numeric : std::is_arithmetic<T> {};

  template <typename T>
  struct is_simple_numeric<std::complex<T>> : std::is_arithmetic<T> {};

  // Helper variable template (C++14 and later)
  template <typename T>
  inline constexpr bool is_MML_simple_numeric = is_simple_numeric<T>::value;

  ///////////////////////////////////////////////////////////////////////////////
  //                      ALGORITHM RESULT STRUCTURES
  ///////////////////////////////////////////////////////////////////////////////

  /// Result structure for numerical integration algorithms
  /// Provides convergence status and diagnostics
  /// @note For production code, check error_estimate and converged fields!
  struct IntegrationResult {
    Real value;          ///< Computed integral value
    Real error_estimate; ///< Estimated absolute error
    int iterations;      ///< Number of iterations/refinements performed
    bool converged;      ///< True if convergence criteria met

    /// Implicit conversion to Real for backward compatibility
    /// @warning Silently discards error_estimate, iterations, and converged!
    /// @deprecated Prefer explicit .value access in new code
    operator Real() const { return value; }

    /// Constructor for easy initialization
    IntegrationResult(Real val = 0.0, Real err = 0.0, int iter = 0,
                      bool conv = true)
        : value(val), error_estimate(err), iterations(iter), converged(conv) {}
  };

  /// Result structure for root finding algorithms
  /// Provides convergence status and diagnostics
  /// @note For production code, check function_value and converged fields!
  struct RootFindingResult {
    Real root;           ///< Found root value
    Real function_value; ///< f(root) - should be near zero
    int iterations;      ///< Number of iterations performed
    bool converged;      ///< True if convergence criteria met

    /// Implicit conversion to Real for backward compatibility
    /// @warning Silently discards function_value, iterations, and converged!
    /// @deprecated Prefer explicit .root access in new code
    operator Real() const { return root; }

    RootFindingResult(Real r = 0.0, Real fval = 0.0, int iter = 0,
                      bool conv = true)
        : root(r), function_value(fval), iterations(iter), converged(conv) {}
  };

  struct AlgorithmContext {
    // Integration parameters (using PrecisionValues for consistency)
    Real trapezoidIntegrationEPS = REAL(1.0e-4);
    Real simpsonIntegrationEPS = REAL(1.0e-5);
    Real rombergIntegrationEPS = PrecisionValues<Real>::DefaultTolerance;
    Real workIntegralPrecision = REAL(1e-05);
    Real lineIntegralPrecision = REAL(1e-05);

    int trapezoidIntegrationMaxSteps = 20;
    int simpsonIntegrationMaxSteps = 20;
    int rombergIntegrationMaxSteps = 20;
    int rombergIntegrationUsedPnts = 5;

    // Root finding parameters
    int bisectionMaxSteps = 50;
    int newtonRaphsonMaxSteps = 20;
    int brentMaxSteps = 100;  // Brent typically needs more steps but converges reliably

    // ODE solver parameters
    int odeSolverMaxSteps = 100000;

    static AlgorithmContext &Get() {
      thread_local static AlgorithmContext ctx;
      return ctx;
    }
  };

  // Thread-safe configuration contexts
  struct PrintContext {
    int vectorWidth = 15;
    int vectorPrecision = 10;
    int vectorNWidth = 15;
    int vectorNPrecision = 10;

    static PrintContext &Get() {
      thread_local static PrintContext ctx;
      return ctx;
    }
  };  

  // Backward compatible Defaults namespace (now thread-safe via thread_local
  // contexts)
  namespace Defaults {
    // Output defaults (thread-safe - changed from static globals to thread_local)
    // Usage: Defaults::VectorPrintWidth = 20; (now thread-safe!)
    static inline int &VectorPrintWidth = PrintContext::Get().vectorWidth;
    static inline int &VectorPrintPrecision = PrintContext::Get().vectorPrecision;
    static inline int &VectorNPrintWidth = PrintContext::Get().vectorNWidth;
    static inline int &VectorNPrintPrecision = PrintContext::Get().vectorNPrecision;

    //////////               Default precisions             ///////////
    // Use the precision values based on the Real type
    static inline const double ComplexAreEqualTolerance =
        PrecisionValues<Real>::ComplexAreEqualTolerance;
    static inline const double ComplexAreEqualAbsTolerance =
        PrecisionValues<Real>::ComplexAreEqualAbsTolerance;
    static inline const double VectorIsEqualTolerance =
        PrecisionValues<Real>::VectorIsEqualTolerance;
    static inline const double MatrixIsEqualTolerance =
        PrecisionValues<Real>::MatrixIsEqualTolerance;

    static inline const double Pnt2CartIsEqualTolerance =
        PrecisionValues<Real>::Pnt2CartIsEqualTolerance;
    static inline const double Pnt2PolarIsEqualTolerance =
        PrecisionValues<Real>::Pnt2PolarIsEqualTolerance;
    static inline const double Pnt3CartIsEqualTolerance =
        PrecisionValues<Real>::Pnt3CartIsEqualTolerance;
    static inline const double Pnt3SphIsEqualTolerance =
        PrecisionValues<Real>::Pnt3SphIsEqualTolerance;
    static inline const double Pnt3CylIsEqualTolerance =
        PrecisionValues<Real>::Pnt3CylIsEqualTolerance;

    static inline const double Vec2CartIsEqualTolerance =
        PrecisionValues<Real>::Vec2CartIsEqualTolerance;
    static inline const double Vec3CartIsEqualTolerance =
        PrecisionValues<Real>::Vec3CartIsEqualTolerance;
    static inline const double Vec3CartIsParallelTolerance =
        PrecisionValues<Real>::Vec3CartIsParallelTolerance;

    static inline const double Vec3SphIsEqualTolerance =
        PrecisionValues<Real>::Vec3SphIsEqualTolerance;

    static inline const double Line3DAreEqualTolerance =
        PrecisionValues<Real>::Line3DAreEqualTolerance;
    static inline const double Line3DIsPointOnLineTolerance =
        PrecisionValues<Real>::Line3DIsPointOnLineTolerance;
    static inline const double Line3DIsPerpendicularTolerance =
        PrecisionValues<Real>::Line3DIsPerpendicularTolerance;
    static inline const double Line3DIsParallelTolerance =
        PrecisionValues<Real>::Line3DIsParallelTolerance;
    static inline const double Line3DIntersectionTolerance =
        PrecisionValues<Real>::Line3DIntersectionTolerance;

    static inline const double Plane3DIsPointOnPlaneTolerance =
        PrecisionValues<Real>::Plane3DIsPointOnPlaneTolerance;

    static inline const double Triangle3DIsPointInsideTolerance =
        PrecisionValues<Real>::Triangle3DIsPointInsideTolerance;
    static inline const double Triangle3DIsRightTolerance =
        PrecisionValues<Real>::Triangle3DIsRightTolerance;
    static inline const double Triangle3DIsIsoscelesTolerance =
        PrecisionValues<Real>::Triangle3DIsIsoscelesTolerance;
    static inline const double Triangle3DIsEquilateralTolerance =
        PrecisionValues<Real>::Triangle3DIsEquilateralTolerance;

    static inline const double IsMatrixSymmetricTolerance =
        PrecisionValues<Real>::IsMatrixSymmetricTolerance;
    static inline const double IsMatrixDiagonalTolerance =
        PrecisionValues<Real>::IsMatrixDiagonalTolerance;
    static inline const double IsMatrixUnitTolerance =
        PrecisionValues<Real>::IsMatrixUnitTolerance;
    static inline const double IsMatrixOrthogonalTolerance =
        PrecisionValues<Real>::IsMatrixOrthogonalTolerance;

    static inline const double RankAlgEPS = PrecisionValues<Real>::RankAlgEPS;

    // Algorithm parameters (thread-safe - changed from static constants to
    // thread_local) Usage: Defaults::TrapezoidIntegrationEPS = 1e-6; (now
    // thread-safe and mutable!)
    static inline Real &TrapezoidIntegrationEPS =
        AlgorithmContext::Get().trapezoidIntegrationEPS;
    static inline Real &SimpsonIntegrationEPS =
        AlgorithmContext::Get().simpsonIntegrationEPS;
    static inline Real &RombergIntegrationEPS =
        AlgorithmContext::Get().rombergIntegrationEPS;
    static inline Real &WorkIntegralPrecision =
        AlgorithmContext::Get().workIntegralPrecision;
    static inline Real &LineIntegralPrecision =
        AlgorithmContext::Get().lineIntegralPrecision;

    static inline int &BisectionMaxSteps =
        AlgorithmContext::Get().bisectionMaxSteps;
    static inline int &NewtonRaphsonMaxSteps =
        AlgorithmContext::Get().newtonRaphsonMaxSteps;
    static inline int &BrentMaxSteps =
        AlgorithmContext::Get().brentMaxSteps;

    static inline int &TrapezoidIntegrationMaxSteps =
        AlgorithmContext::Get().trapezoidIntegrationMaxSteps;
    static inline int &SimpsonIntegrationMaxSteps =
        AlgorithmContext::Get().simpsonIntegrationMaxSteps;
    static inline int &RombergIntegrationMaxSteps =
        AlgorithmContext::Get().rombergIntegrationMaxSteps;
    static inline int &RombergIntegrationUsedPnts =
        AlgorithmContext::Get().rombergIntegrationUsedPnts;

    static inline int &ODESolverMaxSteps =
        AlgorithmContext::Get().odeSolverMaxSteps;
  } // namespace Defaults
} // namespace MML

///////////////////////////   mml/MMLExceptions.h   ///////////////////////////


namespace MML
{
	//////////             Vector error exceptions            ///////////
	class VectorInitializationError : public std::invalid_argument
	{
		int _size1;
	public:
		VectorInitializationError(std::string inMessage, int size1) 
			: std::invalid_argument(inMessage), _size1(size1) { }
		
		int size() const noexcept { return _size1; }
	};
	
	class VectorDimensionError : public std::invalid_argument
	{
		int _size1, _size2;
	public:
		VectorDimensionError(std::string inMessage, int size1, int size2) 
			: std::invalid_argument(inMessage), _size1(size1), _size2(size2) { }
		
		int expected() const noexcept { return _size1; }
		int actual() const noexcept { return _size2; }
	};
	
	class VectorAccessBoundsError : public std::out_of_range
	{
		int _i, _n;
	public:
		VectorAccessBoundsError(std::string inMessage, int i, int n) 
			: std::out_of_range(inMessage), _i(i), _n(n) { }
		
		int index() const noexcept { return _i; }
		int size() const noexcept { return _n; }
	};

	//////////             Matrix error exceptions            ///////////
	class MatrixAllocationError : public std::out_of_range
	{
		int _rows, _cols;
	public:
		MatrixAllocationError(std::string inMessage, int rows, int cols) 
			: std::out_of_range(inMessage), _rows(rows), _cols(cols) { }
		
		int rows() const noexcept { return _rows; }
		int cols() const noexcept { return _cols; }
	};
	class MatrixAccessBoundsError : public std::out_of_range
	{
		int _i, _j, _rows, _cols;
	public:
		MatrixAccessBoundsError(std::string inMessage, int i, int j, int rows, int cols) 
			: std::out_of_range(inMessage), _i(i), _j(j), _rows(rows), _cols(cols) { }
		
		int row() const noexcept { return _i; }
		int col() const noexcept { return _j; }
		int rows() const noexcept { return _rows; }
		int cols() const noexcept { return _cols; }
	};
	class MatrixDimensionError : public std::invalid_argument
	{
		int _rows1, _cols1, _rows2, _cols2;
	public:
		// Constructor with just a message (for simple error cases)
		explicit MatrixDimensionError(std::string inMessage) 
			: std::invalid_argument(inMessage), _rows1(-1), _cols1(-1), _rows2(-1), _cols2(-1) { }
		
		// Constructor with full dimension info (for dimension mismatch errors)
		MatrixDimensionError(std::string inMessage, int r1, int c1, int r2, int c2) 
			: std::invalid_argument(inMessage), _rows1(r1), _cols1(c1), _rows2(r2), _cols2(c2) { }
		
		int expected_rows() const noexcept { return _rows1; }
		int expected_cols() const noexcept { return _cols1; }
		int actual_rows() const noexcept { return _rows2; }
		int actual_cols() const noexcept { return _cols2; }
	};
	class SingularMatrixError : public std::domain_error
	{
		double _determinant;
		int _pivot_row;
	public:
		SingularMatrixError(std::string inMessage, double det = 0.0, int pivot_row = -1) 
			: std::domain_error(inMessage), _determinant(det), _pivot_row(pivot_row) { }
		
		double determinant() const noexcept { return _determinant; }
		int pivot_row() const noexcept { return _pivot_row; }
	};

	//////////             Integration exceptions            ///////////
	class IntegrationTooManySteps : public std::domain_error
	{
		int _steps;
		double _achieved_precision;
		double _required_precision;
	public:
		IntegrationTooManySteps(std::string inMessage, int steps = 0, 
		                       double achieved = 0.0, double required = 0.0) 
			: std::domain_error(inMessage), _steps(steps), 
			  _achieved_precision(achieved), _required_precision(required) { }
		
		int steps() const noexcept { return _steps; }
		double achieved_precision() const noexcept { return _achieved_precision; }
		double required_precision() const noexcept { return _required_precision; }
	};

	//////////           Interpolation exceptions            ///////////
	class RealFuncInterpInitError: public std::domain_error
	{
	public:
		RealFuncInterpInitError(std::string inMessage) : std::domain_error(inMessage)
		{ }
	};

	class RealFuncInterpRuntimeError: public std::runtime_error
	{
	public:
		RealFuncInterpRuntimeError(std::string inMessage) : std::runtime_error(inMessage)
		{ }
	};

	////////////             Tensor exceptions             /////////////
	class TensorCovarContravarNumError : public std::invalid_argument
	{
		int _numContra, _numCo;
	public:
		TensorCovarContravarNumError(std::string inMessage, int size1, int size2) 
			: std::invalid_argument(inMessage), _numContra(size1), _numCo(size2) { }
		
		int num_contravariant() const noexcept { return _numContra; }
		int num_covariant() const noexcept { return _numCo; }
	};
	class TensorCovarContravarArithmeticError : public std::invalid_argument
	{
		int _numContra, _numCo;
		int _bContra, _bCo;
	public:
		TensorCovarContravarArithmeticError(std::string inMessage, int contra, int co, int b_contra, int b_co) 
			: std::invalid_argument(inMessage), _numContra(contra), _numCo(co), _bContra(b_contra), _bCo(b_co) { }
		
		int num_contravariant() const noexcept { return _numContra; }
		int num_covariant() const noexcept { return _numCo; }
		int other_contravariant() const noexcept { return _bContra; }
		int other_covariant() const noexcept { return _bCo; }
	};
	class TensorIndexError : public std::invalid_argument
	{
	public:
		TensorIndexError(std::string inMessage) : std::invalid_argument(inMessage)
		{ }
	};    

	//////////           Root finding exceptions            ///////////
	class RootFindingError: public std::runtime_error
	{
	public:
		RootFindingError(std::string inMessage) : std::runtime_error(inMessage)
		{ }
	};

	//////////            ODE solver exceptions             ///////////
	class ODESolverError: public std::runtime_error
	{
	public:
		ODESolverError(std::string inMessage) : std::runtime_error(inMessage)
		{ }
	};

	//////////            Statistics exceptions             ///////////
	class StatisticsError : public std::runtime_error
	{
	public:
		StatisticsError(std::string inMessage) : std::runtime_error(inMessage)
		{
		}
	};

	//////////      Numerical method exceptions             ///////////
	class NumericalMethodError : public std::runtime_error
	{
	public:
		NumericalMethodError(std::string inMessage) : std::runtime_error(inMessage)
		{ }
	};
	
	class MatrixNumericalError : public std::runtime_error
	{
	public:
		MatrixNumericalError(std::string inMessage) : std::runtime_error(inMessage)
		{ }
	};

	//////////          Convergence exceptions              ///////////
	class ConvergenceError : public std::runtime_error
	{
		int _iterations;
		double _residual;
	public:
		ConvergenceError(std::string inMessage, int iterations = 0, double residual = 0.0) 
			: std::runtime_error(inMessage), _iterations(iterations), _residual(residual) { }
		
		int iterations() const noexcept { return _iterations; }
		double residual() const noexcept { return _residual; }
	};

	//////////            Geometry exceptions               ///////////
	class GeometryError : public std::domain_error
	{
	public:
		GeometryError(std::string inMessage) : std::domain_error(inMessage)
		{ }
	};

	//////////           Quaternion exceptions              ///////////
	class QuaternionError : public std::domain_error
	{
	public:
		QuaternionError(std::string inMessage) : std::domain_error(inMessage)
		{ }
	};

	//////////             File I/O exceptions              ///////////
	class FileIOError : public std::runtime_error
	{
		std::string _filename;
	public:
		FileIOError(std::string inMessage, std::string filename = "") 
			: std::runtime_error(inMessage), _filename(filename) { }
		
		const std::string& filename() const noexcept { return _filename; }
	};

	//////////            Fourier exceptions                ///////////
	class FourierError : public std::invalid_argument
	{
	public:
		FourierError(std::string inMessage) : std::invalid_argument(inMessage)
		{ }
	};

	//////////          Visualization exceptions            ///////////
	class VisualizerError : public std::runtime_error
	{
	public:
		VisualizerError(std::string inMessage) : std::runtime_error(inMessage)
		{ }
	};

	//////////        Curve Fitting exceptions              ///////////
	class CurveFittingError : public std::invalid_argument
	{
	public:
		CurveFittingError(std::string inMessage) : std::invalid_argument(inMessage)
		{ }
	};

	//////////             Data I/O exceptions              ///////////
	class DataError : public std::runtime_error
	{
	public:
		DataError(std::string inMessage) : std::runtime_error(inMessage)
		{ }
	};

}


///////////////////////////   mml/MMLVisualizators.h   ///////////////////////////

// Standard headers - include what we use

// Cross-platform executable extension
#ifdef _WIN32
static constexpr const char *EXECUTABLE_EXT = ".exe";
#else
static constexpr const char *EXECUTABLE_EXT = "";
#endif

// Helper to get environment variable without compiler warnings
// Note: C++20 still doesn't provide a standard alternative to std::getenv()
inline const char *GetEnv(const char *name) noexcept {
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

  const char *result = std::getenv(name);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

  return result;
}

namespace MML
{

  // Matrix printing format options
  struct MatrixPrintFormat {
    int width = 10;               // Field width for each element
    int precision = 3;            // Number of decimal places
    bool scientific = false;      // Use scientific notation (e.g., 1.23e+05)
    bool fixed = true;            // Use fixed-point notation
    bool showHeader = true;       // Show "Rows: N Cols: M" header
    bool showBrackets = true;     // Show [ ] brackets around rows
    bool compactMode = false;     // Single line for small matrices
    std::string delimiter = ", "; // Delimiter between elements

    // Predefined formats
    static MatrixPrintFormat Default() {
      return MatrixPrintFormat{10, 3, false, true, true, true, false, ", "};
    }

    static MatrixPrintFormat Compact() {
      return MatrixPrintFormat{8, 2, false, true, false, true, true, ", "};
    }

    static MatrixPrintFormat Scientific() {
      return MatrixPrintFormat{12, 6, true, false, true, true, false, ", "};
    }

    static MatrixPrintFormat HighPrecision() {
      return MatrixPrintFormat{15, 10, false, true, true, true, false, ", "};
    }

    static MatrixPrintFormat NoDelimiter() {
      return MatrixPrintFormat{10, 3, false, true, true, true, false, " "};
    }
  };

  ///////////////////////////////////////////////////////////////////////////////
  //                    LINUX VISUALIZER BACKEND SELECTION
  ///////////////////////////////////////////////////////////////////////////////

  ///////////////////////////////////////////////////////////////////////////////
  //          PROJECT PATH RESOLUTION (REQUIRED BY BACKEND SYSTEM)
  ///////////////////////////////////////////////////////////////////////////////

  // Get project root path from environment or use current directory as fallback
  inline std::string GetProjectPath() {
    // 1. Try environment variable
    if (const char *envPath = GetEnv("MML_PROJECT_PATH")) {
      return std::string(envPath);
    }

    // 2. Try to find project root by looking for characteristic directories
    std::filesystem::path current = std::filesystem::current_path();
    while (current.has_parent_path()) {
      if (std::filesystem::exists(current / "mml") &&
          std::filesystem::exists(current / "results") &&
          std::filesystem::exists(current / "tools")) {
        return current.string();
      }
      current = current.parent_path();
    }

    // 3. Fallback to current directory
    return std::filesystem::current_path().string();
  }

  ///////////////////////////////////////////////////////////////////////////////
  //          UNIFIED CROSS-PLATFORM VISUALIZER BACKEND SYSTEM
  ///////////////////////////////////////////////////////////////////////////////

  /// Visualizer backend options (Windows and Linux)
  /// Enables runtime selection of visualization backend on both platforms
  enum class VisualizerBackend {
    WPF,  ///< Windows Presentation Foundation (Windows only, highest quality)
    Qt,   ///< Qt5/Qt6 (Cross-platform, feature-rich)
    FLTK, ///< Fast Light Toolkit (Cross-platform, lightweight)
    Auto  ///< Platform-specific default (WPF on Windows, Qt on Linux)
  };

  namespace detail {
    /// Global state for unified visualizer backend selection
    inline VisualizerBackend& GetUnifiedBackendState() {
      static VisualizerBackend backend = VisualizerBackend::Auto;
      return backend;
    }
  }

  /// Check if a visualizer backend is available on the current platform
  /// @param backend The backend to check (WPF, Qt, FLTK, or Auto)
  /// @return true if the backend is available, false otherwise
  inline bool IsBackendAvailable(VisualizerBackend backend) {
    std::string projectPath = GetProjectPath();
    
#ifdef _WIN32
    if (backend == VisualizerBackend::WPF) {
      return std::filesystem::exists(projectPath + "/tools/visualizers/win/WPF");
    } else if (backend == VisualizerBackend::Qt) {
      return std::filesystem::exists(projectPath + "/tools/visualizers/win/Qt");
    } else if (backend == VisualizerBackend::FLTK) {
      return std::filesystem::exists(projectPath + "/tools/visualizers/win/FLTK");
    } else if (backend == VisualizerBackend::Auto) {
      return true;  // Auto always available (selects default)
    }
#elif defined(__linux__)
    if (backend == VisualizerBackend::WPF) {
      return false;  // WPF is Windows-only
    } else if (backend == VisualizerBackend::Qt) {
      return std::filesystem::exists(projectPath + "/tools/visualizers/linux/Qt");
    } else if (backend == VisualizerBackend::FLTK) {
      return std::filesystem::exists(projectPath + "/tools/visualizers/linux/FLTK");
    } else if (backend == VisualizerBackend::Auto) {
      return true;  // Auto always available (selects default)
    }
#endif
    
    return false;
  }

  /// Set the visualizer backend at runtime
  /// @param backend The backend to use (WPF, Qt, FLTK, or Auto)
  /// @note If the selected backend is not available, defaults to Auto
  inline void SetVisualizerBackend(VisualizerBackend backend) {
    if (backend != VisualizerBackend::Auto && !IsBackendAvailable(backend)) {
      std::cerr << "Warning: Selected visualizer backend not available. "
                << "Using Auto selection.\n";
      backend = VisualizerBackend::Auto;
    }
    detail::GetUnifiedBackendState() = backend;
  }

  /// Get the currently selected visualizer backend
  /// Checks (in order):
  ///   1. Environment variable MML_VISUALIZER_BACKEND
  ///   2. Runtime API setting via SetVisualizerBackend()
  ///   3. Platform-specific default (WPF on Windows, Qt on Linux)
  /// 
  /// Environment variable examples:
  ///   Windows: set MML_VISUALIZER_BACKEND=Qt
  ///   Linux:   export MML_VISUALIZER_BACKEND=FLTK
  /// 
  /// @return Current backend selection (never returns Auto, always resolves to concrete backend)
  inline VisualizerBackend GetVisualizerBackend() {
    // 1. Check environment variable for override
    if (const char* envBackend = GetEnv("MML_VISUALIZER_BACKEND")) {
      std::string backend(envBackend);
      // Convert to uppercase for case-insensitive comparison
      std::transform(backend.begin(), backend.end(), backend.begin(), ::toupper);
      
      if (backend == "WPF")  return VisualizerBackend::WPF;
      if (backend == "QT" || backend == "QT5" || backend == "QT6") 
        return VisualizerBackend::Qt;
      if (backend == "FLTK") return VisualizerBackend::FLTK;
      if (backend == "AUTO") return VisualizerBackend::Auto;
    }
    
    // 2. Get runtime setting
    VisualizerBackend backend = detail::GetUnifiedBackendState();
    
    // 3. Resolve Auto to platform default
    if (backend == VisualizerBackend::Auto) {
#ifdef _WIN32
      return VisualizerBackend::WPF;  // Default to WPF on Windows
#elif defined(__linux__)
      return VisualizerBackend::Qt;   // Default to Qt on Linux
#else
      return VisualizerBackend::FLTK; // FLTK for other platforms
#endif
    }
    
    return backend;
  }

  // Get Windows WPF visualizer path (hardcoded structure)
  // tools/visualizers/win/WPF/<lowercase_dir>/<ExeName>.exe
  inline std::string GetWPFVisualizerPath(const std::string &name,
                                          const std::string &wpfDir) {
    std::string projectPath = GetProjectPath();
  #ifdef _WIN32
    return projectPath + "/tools/visualizers/win/WPF/" + wpfDir + "/" + name +
          ".exe";
  #else
    return ""; // Not available on non-Windows
  #endif
  }

  // Global paths with lazy evaluation
  inline std::string GetGlobalPath() {
    static std::string path = GetProjectPath();
    return path;
  }

  inline std::string GetResultFilesPath() {
    return GetGlobalPath() + "/results/";
  }

  ///////////////////////////////////////////////////////////////////////////////
  //          GENERIC VISUALIZER PATH DISPATCHER
  ///////////////////////////////////////////////////////////////////////////////

  /// Helper: Convert visualizer name to WPF directory name
  /// WPF uses lowercase directory names with underscores
  /// Example: "MML_RealFunctionVisualizer" -> "real_function_visualizer"
  inline std::string ConvertToWPFDirName(const std::string& visualizerName) {
    // Special-case mappings to existing WPF directory names
    if (visualizerName == "MML_ParticleVisualizer2D") return "particle_2d_visualizer";
    if (visualizerName == "MML_ParticleVisualizer3D") return "particle_3d_visualizer";
    if (visualizerName == "MML_ParametricCurve2D_Visualizer") return "parametric_curve_2d_visualizer";
    if (visualizerName == "MML_ParametricCurve3D_Visualizer") return "parametric_curve_3d_visualizer";
    if (visualizerName == "MML_VectorField2D_Visualizer") return "vector_field_2d_visualizer";
    if (visualizerName == "MML_VectorField3D_Visualizer") return "vector_field_3d_visualizer";
    if (visualizerName == "MML_ScalarFunction2D_Visualizer") return "scalar_function_2d_visualizer";
    if (visualizerName == "MML_RealFunctionVisualizer") return "real_function_visualizer";

    std::string result = visualizerName;
    
    // Remove "MML_" prefix if present
    if (result.find("MML_") == 0) {
      result = result.substr(4);
    }
    
    // Convert to lowercase and replace capital letters with underscore + lowercase
    std::string converted;
    for (size_t i = 0; i < result.length(); ++i) {
      if (std::isupper(result[i])) {
        if (i > 0 && result[i-1] != '_') {
          converted += '_';
        }
        converted += std::tolower(result[i]);
      } else {
        converted += result[i];
      }
    }
    
    // Remove duplicate underscores
    std::string final;
    char prev = '\0';
    for (char c : converted) {
      if (c != '_' || prev != '_') {
        final += c;
      }
      prev = c;
    }
    
    return final;
  }

  /// Generic visualizer path resolution with backend dispatch
  /// Constructs the full path to a visualizer executable based on:
  ///   - Visualizer name (e.g., "MML_RealFunctionVisualizer")
  ///   - Selected backend (from GetVisualizerBackend())
  ///   - Current platform (Windows/Linux)
  /// 
  /// @param visualizerName Base name of the visualizer executable
  /// @param backend Backend to use (if not specified, uses GetVisualizerBackend())
  /// @return Full path to the visualizer executable
  inline std::string GetVisualizerPath(const std::string& visualizerName, 
                                       VisualizerBackend backend = VisualizerBackend::Auto) {
    std::string projectPath = GetProjectPath();
    
    // Resolve Auto to actual backend
    if (backend == VisualizerBackend::Auto) {
      backend = GetVisualizerBackend();
    }
    
#ifdef _WIN32
    if (backend == VisualizerBackend::WPF) {
      // WPF has subdirectory structure: tools/visualizers/win/WPF/<dir>/<name>.exe
      std::string wpfDir = ConvertToWPFDirName(visualizerName);
      return projectPath + "/tools/visualizers/win/WPF/" + wpfDir + "/" + 
             visualizerName + ".exe";
    } else if (backend == VisualizerBackend::Qt) {
      // Qt structure: tools/visualizers/win/Qt/<name>/<name>.exe
      return projectPath + "/tools/visualizers/win/Qt/" + visualizerName + "/" +
             visualizerName + ".exe";
    } else if (backend == VisualizerBackend::FLTK) {
      // FLTK flat structure: tools/visualizers/win/FLTK/<name>_FLTK.exe
      return projectPath + "/tools/visualizers/win/FLTK/" + 
             visualizerName + "_FLTK.exe";
    }
#elif defined(__linux__)
    if (backend == VisualizerBackend::Qt) {
      // Qt structure: tools/visualizers/linux/Qt/<name>_Qt
      return projectPath + "/tools/visualizers/linux/Qt/" + 
             visualizerName + "_Qt";
    } else if (backend == VisualizerBackend::FLTK) {
      // FLTK structure: tools/visualizers/linux/FLTK/<name>_FLTK
      return projectPath + "/tools/visualizers/linux/FLTK/" + 
             visualizerName + "_FLTK";
    }
#endif
    
    // Should never reach here if backend selection is working correctly
    throw VisualizerError("Visualizer backend not supported on this platform: " + 
                             visualizerName);
  }

  ///////////////////////////////////////////////////////////////////////////////
  //          SPECIFIC VISUALIZER PATH FUNCTIONS (USING DISPATCHER)
  ///////////////////////////////////////////////////////////////////////////////

  // Visualizer paths - cross-platform support
  inline std::string GetRealFuncVisualizerPath() {
    return GetVisualizerPath("MML_RealFunctionVisualizer");
  }

  inline std::string GetSurfaceVisualizerPath() {
    return GetVisualizerPath("MML_ScalarFunction2D_Visualizer");
  }

  inline std::string GetParametricCurve2DVisualizerPath() {
    return GetVisualizerPath("MML_ParametricCurve2D_Visualizer");
  }

  inline std::string GetParametricCurve3DVisualizerPath() {
    return GetVisualizerPath("MML_ParametricCurve3D_Visualizer");
  }

  inline std::string GetVectorField2DVisualizerPath() {
    return GetVisualizerPath("MML_VectorField2D_Visualizer");
  }

  inline std::string GetVectorField3DVisualizerPath() {
    return GetVisualizerPath("MML_VectorField3D_Visualizer");
  }

  inline std::string GetParticle2DVisualizerPath() {
    return GetVisualizerPath("MML_ParticleVisualizer2D");
  }

  inline std::string GetParticle3DVisualizerPath() {
    return GetVisualizerPath("MML_ParticleVisualizer3D");
  }

} // namespace MML


///////////////////////////   mml/interfaces/IInterval.h   ///////////////////////////


namespace MML
{
	// group
	class IInterval
	{
	public:
		virtual Real getLowerBound() const = 0;
		virtual Real getUpperBound() const = 0;
		virtual Real getLength() const = 0;

		virtual bool isContinuous() const = 0;
		virtual bool contains(Real x) const = 0;

		virtual void GetEquidistantCovering(int numPoints, std::vector<Real>& points) const = 0;

		virtual ~IInterval() {}
	};
}

///////////////////////////   mml/interfaces/ITensor.h   ///////////////////////////


namespace MML
{
	enum TensorIndexType { CONTRAVARIANT, COVARIANT };
    
	template<int N>
	class ITensor2
	{
	public:
		virtual int   NumContravar() const = 0;
		virtual int   NumCovar() const = 0;

		virtual Real  operator()(int i, int j) const = 0;
		virtual Real& operator()(int i, int j) = 0;
	};

	template<int N>
	class ITensor3
	{
	public:
		virtual int   NumContravar() const = 0;
		virtual int   NumCovar() const = 0;

		virtual Real  operator()(int i, int j, int k) const = 0;
		virtual Real& operator()(int i, int j, int k) = 0;
	};

	template<int N>
	class ITensor4
	{
	public:
		virtual int   NumContravar() const = 0;
		virtual int   NumCovar() const = 0;

		virtual Real  operator()(int i, int j, int k, int l) const = 0;
		virtual Real& operator()(int i, int j, int k, int l) = 0;
	};

	template<int N>
	class ITensor5
	{
	public:
		virtual int   NumContravar() const = 0;
		virtual int   NumCovar() const = 0;

		virtual Real  operator()(int i, int j, int k, int l, int m) const = 0;
		virtual Real& operator()(int i, int j, int k, int l, int m) = 0;
	};
}



///////////////////////////   mml/base/Intervals.h   ///////////////////////////



namespace MML
{
	// TODO - finalize intervals properly (and use them in test beds)
	///////////////////////////////////////////////   Interfaces    ///////////////////////////////////////////
	enum class EndpointType
	{
		OPEN,
		CLOSED,
		NEG_INF,
		POS_INF
	};

	class Interval;  // Forward declaration

	class BaseInterval : public IInterval
	{
		friend class Interval;  // Allow Interval to access protected members
		
	protected:
		Real _lower, _upper;
		EndpointType _lowerType, _upperType;

		BaseInterval(Real lower, EndpointType lowerType, Real upper, EndpointType upperType) : _lower(lower), _lowerType(lowerType), _upper(upper), _upperType(upperType) { }
	public:
		virtual ~BaseInterval() {}

		Real getLowerBound() const { return _lower; }
		Real getUpperBound() const { return _upper; }
		Real getLength()     const { return _upper - _lower; }

		virtual bool isContinuous()  const { return true; }     // we suppose continuous intervals by default

		void GetEquidistantCovering(int numPoints, std::vector<Real>& points) const
		{ 
			points.clear();
			if (numPoints <= 0) return;

			// Handle infinite endpoints
			Real lower = _lower;
			Real upper = _upper;

			// For infinite bounds, use practical limits
			if (_lowerType == EndpointType::NEG_INF)
				lower = -1e10;
			if (_upperType == EndpointType::POS_INF)
				upper = 1e10;

			if (numPoints == 1) {
				points.push_back((lower + upper) / 2.0);
				return;
			}

			Real delta = (upper - lower) / (numPoints - 1);
			
			for (int i = 0; i < numPoints; i++)
			{
				Real x = lower + i * delta;
				
				// Adjust for open endpoints
				if (i == 0 && _lowerType == EndpointType::OPEN)
					x += delta * 0.001;  // Small epsilon inside
				if (i == numPoints - 1 && _upperType == EndpointType::OPEN)
					x -= delta * 0.001;  // Small epsilon inside
					
				points.push_back(x);
			}
		}
	};

	class CompleteRInterval : public BaseInterval
	{
	public:
		CompleteRInterval() : BaseInterval(-std::numeric_limits<double>::max(), EndpointType::NEG_INF, std::numeric_limits<double>::max(), EndpointType::POS_INF) { }
		bool contains(Real x) const { return true; }
	};
	class CompleteRWithReccuringPointHoles : public BaseInterval
	{
		Real _hole0, _holeDelta;
	public:
		CompleteRWithReccuringPointHoles(Real hole0, Real holeDelta) : BaseInterval(-std::numeric_limits<double>::max(), EndpointType::NEG_INF, std::numeric_limits<double>::max(), EndpointType::POS_INF)
		{
			_hole0 = hole0;
			_holeDelta = holeDelta;
		}

		bool contains(Real x) const {


			if (x == _hole0)
				return false;

			Real diff = (x - _hole0) / _holeDelta;
			if (diff == (int)diff)
				return false;

			return true;
		}
		bool isContinuous() const { return false; }
	};
	class OpenInterval : public BaseInterval
	{
		// for equidistant covering
		Real _lowerRealDif = REAL(0.0000001);
	public:
		OpenInterval(Real lower, Real upper) : BaseInterval(lower, EndpointType::OPEN, upper, EndpointType::OPEN) { }
		bool contains(Real x) const { return (x > _lower) && (x < _upper); }
	};
	class OpenClosedInterval : public BaseInterval
	{
	public:
		OpenClosedInterval(Real lower, Real upper) : BaseInterval(lower, EndpointType::OPEN, upper, EndpointType::CLOSED) { }
		bool contains(Real x) const { return (x > _lower) && (x <= _upper); }
	};
	class ClosedInterval : public BaseInterval
	{
	public:
		ClosedInterval(Real lower, Real upper) : BaseInterval(lower, EndpointType::CLOSED, upper, EndpointType::CLOSED) { }

		bool contains(Real x) const {
			return (x >= _lower) && (x <= _upper);
		}
	};
	class ClosedIntervalWithReccuringPointHoles : public BaseInterval
	{
		Real _hole0, _holeDelta;
	public:
		ClosedIntervalWithReccuringPointHoles(Real lower, Real upper, Real hole0, Real holeDelta)
			: BaseInterval(lower, EndpointType::CLOSED, upper, EndpointType::CLOSED)
		{
			_hole0 = hole0;
			_holeDelta = holeDelta;
		}

		bool contains(Real x) const {
			// check for hole!
			if (x == _hole0)
				return false;

			Real diff = (x - _hole0) / _holeDelta;
			if (diff == (int)diff)
				return false;

			return (x >= _lower) && (x <= _upper);
		}
		bool isContinuous() const { return false; }
	};
	class ClosedOpenInterval : public BaseInterval
	{
	public:
		ClosedOpenInterval(Real lower, Real upper) : BaseInterval(lower, EndpointType::CLOSED, upper, EndpointType::OPEN) { }

		bool contains(Real x) const {
			return (x >= _lower) && (x < _upper);
		}
	};
	class NegInfToOpenInterval : public BaseInterval
	{
	public:
		NegInfToOpenInterval(Real upper) : BaseInterval(-std::numeric_limits<double>::max(), EndpointType::NEG_INF, upper, EndpointType::OPEN) { }

		bool contains(Real x) const {
			return x < _upper;
		}
	};
	class NegInfToClosedInterval : public BaseInterval
	{
	public:
		NegInfToClosedInterval(Real upper) : BaseInterval(-std::numeric_limits<double>::max(), EndpointType::NEG_INF, upper, EndpointType::CLOSED) { }

		bool contains(Real x) const {
			return x <= _upper;
		}
	};
	class OpenToInfInterval : public BaseInterval
	{
	public:
		OpenToInfInterval(Real lower) : BaseInterval(lower, EndpointType::OPEN, std::numeric_limits<double>::max(), EndpointType::POS_INF) { }

		bool contains(Real x) const {
			return x > _lower;
		}
	};
	class ClosedToInfInterval : public BaseInterval
	{
	public:
		ClosedToInfInterval(Real lower) : BaseInterval(lower, EndpointType::CLOSED, std::numeric_limits<double>::max(), EndpointType::POS_INF) { }

		bool contains(Real x) const {
			return x >= _lower;
		}
	};

	class Interval : public IInterval
	{
		Real _lower, _upper;
		std::vector<std::shared_ptr<BaseInterval>> _intervals;
	public:
		Interval() {}
		Interval(std::initializer_list<BaseInterval*> intervals)
		{
			for (BaseInterval* interval : intervals)
			{
				_intervals.emplace_back(std::shared_ptr<BaseInterval>(interval));
			}

			// sortirati po lower bound
			// i redom provjeriti presijecanja
		}

		template<class _IntervalType>
		Interval& AddInterval(const _IntervalType& interval)
		{
			_intervals.emplace_back(std::make_shared<_IntervalType>(interval));
			return *this;
		}

		static Interval Intersection(const BaseInterval& a, const BaseInterval& b)
		{
			Interval ret;
			
			// Find intersection bounds
			Real lower = std::max(a._lower, b._lower);
			Real upper = std::min(a._upper, b._upper);
			
			// Check if intervals actually intersect
			if (lower > upper)
				return ret;  // Empty intersection
				
			// Determine endpoint types
			EndpointType lowerType, upperType;
			
			if (lower == a._lower && lower == b._lower)
				lowerType = (a._lowerType == EndpointType::CLOSED && b._lowerType == EndpointType::CLOSED) ? EndpointType::CLOSED : EndpointType::OPEN;
			else if (lower == a._lower)
				lowerType = a._lowerType;
			else
				lowerType = b._lowerType;
				
			if (upper == a._upper && upper == b._upper)
				upperType = (a._upperType == EndpointType::CLOSED && b._upperType == EndpointType::CLOSED) ? EndpointType::CLOSED : EndpointType::OPEN;
			else if (upper == a._upper)
				upperType = a._upperType;
			else
				upperType = b._upperType;
				
			// Create appropriate interval based on endpoint types
			if (lowerType == EndpointType::CLOSED && upperType == EndpointType::CLOSED)
				ret.AddInterval(ClosedInterval(lower, upper));
			else if (lowerType == EndpointType::OPEN && upperType == EndpointType::CLOSED)
				ret.AddInterval(OpenClosedInterval(lower, upper));
			else if (lowerType == EndpointType::CLOSED && upperType == EndpointType::OPEN)
				ret.AddInterval(ClosedOpenInterval(lower, upper));
			else
				ret.AddInterval(OpenInterval(lower, upper));
				
			return ret;
		}
		static Interval Difference(const BaseInterval& a, const BaseInterval& b)
		{
			Interval ret;
			
			// If b doesn't intersect a, return a
			if (b._upper <= a._lower || b._lower >= a._upper)
			{
				// Return copy of a based on its endpoint types
				if (a._lowerType == EndpointType::CLOSED && a._upperType == EndpointType::CLOSED)
					ret.AddInterval(ClosedInterval(a._lower, a._upper));
				else if (a._lowerType == EndpointType::OPEN && a._upperType == EndpointType::CLOSED)
					ret.AddInterval(OpenClosedInterval(a._lower, a._upper));
				else if (a._lowerType == EndpointType::CLOSED && a._upperType == EndpointType::OPEN)
					ret.AddInterval(ClosedOpenInterval(a._lower, a._upper));
				else
					ret.AddInterval(OpenInterval(a._lower, a._upper));
				return ret;
			}
			
			// Case: b completely contains a
			if (b._lower <= a._lower && b._upper >= a._upper)
				return ret;  // Empty set
				
			// Case: b cuts left part of a  
			if (b._lower <= a._lower && b._upper < a._upper)
			{
				EndpointType newLowerType = (b._upperType == EndpointType::CLOSED) ? EndpointType::OPEN : EndpointType::CLOSED;
				if (newLowerType == EndpointType::CLOSED && a._upperType == EndpointType::CLOSED)
					ret.AddInterval(ClosedInterval(b._upper, a._upper));
				else if (newLowerType == EndpointType::OPEN && a._upperType == EndpointType::CLOSED)
					ret.AddInterval(OpenClosedInterval(b._upper, a._upper));
				else if (newLowerType == EndpointType::CLOSED && a._upperType == EndpointType::OPEN)
					ret.AddInterval(ClosedOpenInterval(b._upper, a._upper));
				else
					ret.AddInterval(OpenInterval(b._upper, a._upper));
			}
			// Case: b cuts right part of a
			else if (b._lower > a._lower && b._upper >= a._upper)
			{
				EndpointType newUpperType = (b._lowerType == EndpointType::CLOSED) ? EndpointType::OPEN : EndpointType::CLOSED;
				if (a._lowerType == EndpointType::CLOSED && newUpperType == EndpointType::CLOSED)
					ret.AddInterval(ClosedInterval(a._lower, b._lower));
				else if (a._lowerType == EndpointType::OPEN && newUpperType == EndpointType::CLOSED)
					ret.AddInterval(OpenClosedInterval(a._lower, b._lower));
				else if (a._lowerType == EndpointType::CLOSED && newUpperType == EndpointType::OPEN)
					ret.AddInterval(ClosedOpenInterval(a._lower, b._lower));
				else
					ret.AddInterval(OpenInterval(a._lower, b._lower));
			}
			// Case: b is completely inside a (splits a into two intervals)
			else
			{
				// Left part: [a.lower, b.lower)
				EndpointType leftUpperType = (b._lowerType == EndpointType::CLOSED) ? EndpointType::OPEN : EndpointType::CLOSED;
				if (a._lowerType == EndpointType::CLOSED && leftUpperType == EndpointType::CLOSED)
					ret.AddInterval(ClosedInterval(a._lower, b._lower));
				else if (a._lowerType == EndpointType::OPEN && leftUpperType == EndpointType::CLOSED)
					ret.AddInterval(OpenClosedInterval(a._lower, b._lower));
				else if (a._lowerType == EndpointType::CLOSED && leftUpperType == EndpointType::OPEN)
					ret.AddInterval(ClosedOpenInterval(a._lower, b._lower));
				else
					ret.AddInterval(OpenInterval(a._lower, b._lower));
					
				// Right part: (b.upper, a.upper]
				EndpointType rightLowerType = (b._upperType == EndpointType::CLOSED) ? EndpointType::OPEN : EndpointType::CLOSED;
				if (rightLowerType == EndpointType::CLOSED && a._upperType == EndpointType::CLOSED)
					ret.AddInterval(ClosedInterval(b._upper, a._upper));
				else if (rightLowerType == EndpointType::OPEN && a._upperType == EndpointType::CLOSED)
					ret.AddInterval(OpenClosedInterval(b._upper, a._upper));
				else if (rightLowerType == EndpointType::CLOSED && a._upperType == EndpointType::OPEN)
					ret.AddInterval(ClosedOpenInterval(b._upper, a._upper));
				else
					ret.AddInterval(OpenInterval(b._upper, a._upper));
			}
			
			return ret;
		}
		static Interval Complement(const BaseInterval& a)
		{
			Interval ret;
			
			// Handle special cases with infinity
			if (a._lowerType == EndpointType::NEG_INF && a._upperType == EndpointType::POS_INF)
				return ret;  // Complement of R is empty
				
			// Add interval from -inf to lower bound
			if (a._lowerType != EndpointType::NEG_INF)
			{
				if (a._lowerType == EndpointType::CLOSED)
					ret.AddInterval(NegInfToOpenInterval(a._lower));
				else
					ret.AddInterval(NegInfToClosedInterval(a._lower));
			}
			
			// Add interval from upper bound to +inf
			if (a._upperType != EndpointType::POS_INF)
			{
				if (a._upperType == EndpointType::CLOSED)
					ret.AddInterval(OpenToInfInterval(a._upper));
				else
					ret.AddInterval(ClosedToInfInterval(a._upper));
			}
			
			return ret;
		}
		Real getLowerBound() const 
		{ 
			if (_intervals.empty())
				return 0;
			Real minLower = _intervals[0]->getLowerBound();
			for (const auto& interval : _intervals)
				minLower = std::min(minLower, interval->getLowerBound());
			return minLower;
		}
		Real getUpperBound() const 
		{ 
			if (_intervals.empty())
				return 0;
			Real maxUpper = _intervals[0]->getUpperBound();
			for (const auto& interval : _intervals)
				maxUpper = std::max(maxUpper, interval->getUpperBound());
			return maxUpper;
		}
		Real getLength() const 
		{ 
			Real totalLength = 0;
			for (const auto& interval : _intervals)
				totalLength += interval->getLength();
			return totalLength;
		}

		bool isContinuous()  const { return false; }
		bool contains(Real x) const
		{
			// check for each interval if it contains x
			for (auto& interval : _intervals)
			{
				if (interval->contains(x))
					return true;
			}
			return false;
		}
		bool contains(const BaseInterval& other) const 
		{
			// Check if all points in 'other' are contained in at least one of our intervals
			// For simplicity, we check if other's bounds are contained
			for (const auto& interval : _intervals)
			{
				if (interval->contains(other.getLowerBound()) && 
				    interval->contains(other.getUpperBound()))
					return true;
			}
			return false;
		}
		
		bool intersects(const BaseInterval& other) const 
		{
			// Check if any of our intervals intersect with 'other'
			for (const auto& interval : _intervals)
			{
				// Two intervals intersect if one contains a point from the other
				if (interval->getLowerBound() <= other.getUpperBound() && 
				    interval->getUpperBound() >= other.getLowerBound())
					return true;
			}
			return false;
		}

		void GetEquidistantCovering(int numPoints, std::vector<Real>& points) const 
		{ 
			points.clear();
			if (_intervals.empty() || numPoints <= 0) return;
			
			// Distribute points across all intervals based on their relative lengths
			Real totalLength = getLength();
			if (totalLength <= 0) return;
			
			for (const auto& interval : _intervals)
			{
				int intervalPoints = std::max(1, (int)(numPoints * interval->getLength() / totalLength));
				std::vector<Real> intervalPointsVec;
				interval->GetEquidistantCovering(intervalPoints, intervalPointsVec);
				points.insert(points.end(), intervalPointsVec.begin(), intervalPointsVec.end());
			}
		}
	};
}


///////////////////////////   mml/base/StandardFunctions.h   ///////////////////////////
#define __STDCPP_WANT_MATH_SPEC_FUNCS__ 1



namespace MML
{
	namespace Functions
	{
		// Basic math functions - templated to support all numeric types (Real, Complex, float, long double, etc.)
		// These delegate to std:: functions which handle type-specific implementations
		template<typename T>
		static inline T Sin(T x) { return std::sin(x); }
		template<typename T>
		static inline T Cos(T x) { return std::cos(x); }
		template<typename T>
		static inline T Sec(T x) { return T{1} / std::cos(x); }
		template<typename T>
		static inline T Csc(T x) { return T{1} / std::sin(x); }
		template<typename T>
		static inline T Tan(T x) { return std::tan(x); }
		template<typename T>
		static inline T Ctg(T x) { return T{1} / std::tan(x); }

		template<typename T>
		static inline T Exp(T x) { return std::exp(x); }
		template<typename T>
		static inline T Log(T x) { return std::log(x); }
		template<typename T>
		static inline T Log10(T x) { return std::log10(x); }
		template<typename T>
		static inline T Sqrt(T x) { return std::sqrt(x); }
		template<typename T>
		static inline T Pow(T x, T y) { return std::pow(x, y); }

		template<typename T>
		static inline T Sinh(T x) { return std::sinh(x); }
		template<typename T>
		static inline T Cosh(T x) { return std::cosh(x); }
		template<typename T>
		static inline T Sech(T x) { return T{1} / std::cosh(x); }
		template<typename T>
		static inline T Csch(T x) { return T{1} / std::sinh(x); }
		template<typename T>
		static inline T Tanh(T x) { return std::tanh(x); }
		template<typename T>
		static inline T Ctgh(T x) { return T{1} / std::tanh(x); }

		template<typename T>
		static inline T Asin(T x) { return std::asin(x); }
		template<typename T>
		static inline T Acos(T x) { return std::acos(x); }
		template<typename T>
		static inline T Atan(T x) { return std::atan(x); }

		template<typename T>
		static inline T Asinh(T x) { return std::asinh(x); }
		template<typename T>
		static inline T Acosh(T x) { return std::acosh(x); }
		template<typename T>
		static inline T Atanh(T x) { return std::atanh(x); }

		// Special functions - Real only (std:: library limitation)
		static inline Real Erf(Real x) { return std::erf(x); }
		static inline Real Erfc(Real x) { return std::erfc(x); }

		static inline Real TGamma(Real x) { return std::tgamma(x); }
		static inline Real LGamma(Real x) { return std::lgamma(x); }
		static inline Real RiemannZeta(Real x) { return std::riemann_zeta(x); }

		static inline Real Hermite(unsigned int n, Real x) { return std::hermite(n, x); }
		static inline Real Legendre(unsigned int n, Real x) { return std::legendre(n, x); }
		static inline Real Laguerre(unsigned int n, Real x) { return std::laguerre(n, x); }
		static inline Real SphBessel(unsigned int n, Real x) { return std::sph_bessel(n, x); }
		static inline Real SphLegendre(int n1, int n2, Real x) { return std::sph_legendre(n1, n2, x); }

		// Elliptic integrals (incomplete and complete)
		static inline Real Ellint_1(Real k, Real phi) { return std::ellint_1(k, phi); }
		static inline Real Ellint_2(Real k, Real phi) { return std::ellint_2(k, phi); }
		static inline Real Ellint_3(Real k, Real n, Real phi) { return std::ellint_3(k, n, phi); }
		static inline Real Comp_ellint_1(Real x) { return std::comp_ellint_1(x); }
		static inline Real Comp_ellint_2(Real x) { return std::comp_ellint_2(x); }
		static inline Real Comp_ellint_3(Real k, Real n) { return std::comp_ellint_3(k, n); }

		// Bessel functions
		static inline Real CylBesselJ(Real n, Real x) { return std::cyl_bessel_j(n, x); }
		static inline Real CylBesselI(Real n, Real x) { return std::cyl_bessel_i(n, x); }
		static inline Real CylBesselK(Real n, Real x) { return std::cyl_bessel_k(n, x); }
		static inline Real CylNeumann(Real n, Real x) { return std::cyl_neumann(n, x); }

		// Spherical Neumann function
		static inline Real SphNeumann(unsigned int n, Real x) { return std::sph_neumann(n, x); }

		// Associated Legendre and Laguerre polynomials
		static inline Real AssocLegendre(unsigned int l, unsigned int m, Real x) { return std::assoc_legendre(l, m, x); }
		static inline Real AssocLaguerre(unsigned int n, unsigned int m, Real x) { return std::assoc_laguerre(n, m, x); }

    // Beta and exponential integral functions
    static inline Real Beta(Real x, Real y) { return std::beta(x, y); }
    static inline Real Expint(Real x) { return std::expint(x); }

    // Alias for Bessel function of the second kind (same as CylNeumann)
    static inline Real CylBesselY(Real n, Real x) { return std::cyl_neumann(n, x); }

    // Note: Basic math functions (Sin, Cos, Exp, Log, etc.) now templated above.
    // They work with Real, Complex, float, long double, etc. - no separate Complex overloads needed.

		// Factorial functions
		static inline Real Factorial(int n) {
			Real fact = 1.0;
			for (int i = 2; i <= n; i++)
				fact *= i;
			return fact;
		}
		static inline long long FactorialInt(int n) {
			long long fact = 1;
			for (int i = 2; i <= n; i++)
				fact *= i;
			return fact;
		}
		static inline Real FactorialStirling(int n)
		{
			if (n < 0) return 0.0; // Factorial is not defined for negative integers
			if (n == 0 || n == 1) return 1.0;
			return sqrt(2 * Constants::PI * n) * std::pow(n / Constants::E, n);
		}
	}
}


///////////////////////////   mml/base/Geometry.h   ///////////////////////////



namespace MML
{
	class Point2Cartesian
	{
	private:
		Real _x, _y;

	public:
		Real  X() const { return _x; }
		Real& X()				{ return _x; }
		Real  Y() const { return _y; }
		Real& Y()				{ return _y; }

		Point2Cartesian() : _x(0), _y(0) {}
		Point2Cartesian(Real x, Real y) : _x(x), _y(y) {}

		Real Dist(const Point2Cartesian& b) const { return sqrt(POW2(b.X() - X()) + POW2(b.Y() - Y())); }

		bool	operator==(const Point2Cartesian& b) const { return (X() == b.X()) && (Y() == b.Y()); }
		bool	operator!=(const Point2Cartesian& b) const { return (X() != b.X()) || (Y() != b.Y()); }
		bool  IsEqual(const Point2Cartesian& b, Real eps = Defaults::Pnt2CartIsEqualTolerance) const { return Dist(b) < eps; }

		Point2Cartesian  operator+(const Point2Cartesian& b) const { return Point2Cartesian(X() + b.X(), Y() + b.Y()); }
		Point2Cartesian& operator+=(const Point2Cartesian& b)	{	_x += b.X(); _y += b.Y(); return *this;	}

		Point2Cartesian  operator-(const Point2Cartesian& b) const { return Point2Cartesian(X() - b.X(), Y() - b.Y()); }
		Point2Cartesian& operator-=(const Point2Cartesian& b) { _x -= b.X(); _y -= b.Y(); return *this; }

		Point2Cartesian  operator*(Real b) const { return Point2Cartesian(X() * b, Y() * b); }
		Point2Cartesian& operator*=(Real b) { _x *= b; _y *= b; return *this; }

		Point2Cartesian	 operator/(Real b) const { return Point2Cartesian(X() / b, Y() / b); }
		Point2Cartesian& operator/=(Real b) { _x /= b; _y /= b; return *this; }

		friend Point2Cartesian operator*(Real a, const Point2Cartesian& b) { return Point2Cartesian(a * b.X(), a * b.Y()); }
	};	

	class Point2Polar
	{
	private:
		Real _r, _phi;

	public:
		Real  R() const		{ return _r; }
		Real& R()					{ return _r; }
		Real  Phi() const { return _phi; }
		Real& Phi()				{ return _phi; }

		Point2Polar() : _r(0), _phi(0) {}
		Point2Polar(Real r, Real phi) : _r(r), _phi(phi) {}
		Point2Polar(const Point2Cartesian& pnt) 
		{ 
			_r = sqrt(POW2(pnt.X()) + POW2(pnt.Y()));
			_phi = atan2(pnt.Y(), pnt.X());
		}

		bool	operator==(const Point2Polar& b) const { return (R() == b.R()) && (Phi() == b.Phi()); }
		bool	operator!=(const Point2Polar& b) const { return (R() != b.R()) || (Phi() != b.Phi()); }
		bool  IsEqual(const Point2Polar& b, Real eps = Defaults::Pnt2PolarIsEqualTolerance) const { return Dist(b) < eps; }

		Point2Cartesian TransfToCart() const {  return Point2Cartesian(R() * cos(Phi()), R() * sin(Phi())); }

		Real Dist(const Point2Polar& b) const { return sqrt(R() * R() + b.R() * b.R() - 2 * R() * b.R() * cos(b.Phi() - Phi())); }
	};

	class Point3Cartesian
	{
	private:
		Real _x, _y, _z;

	public:
		Real  X() const { return _x; }
		Real& X()				{ return _x; }
		Real  Y() const { return _y; }
		Real& Y()				{ return _y; }
		Real  Z() const { return _z; }
		Real& Z()				{ return _z; }

		Point3Cartesian() : _x(0), _y(0), _z(0) {}
		Point3Cartesian(Real x, Real y, Real z) : _x(x), _y(y), _z(z) {}

		Real Dist(const Point3Cartesian& b) const
		{ 
			return sqrt(POW2(b.X() - X()) + POW2(b.Y() - Y()) + POW2(b.Z() - Z())); 
		}

		bool	operator==(const Point3Cartesian& b) const {return (X() == b.X()) && (Y() == b.Y()) && (Z() == b.Z()); }
		bool	operator!=(const Point3Cartesian& b) const {return (X() != b.X()) || (Y() != b.Y()) || (Z() != b.Z()); }
		bool  IsEqual(const Point3Cartesian& b, Real eps = Defaults::Pnt3CartIsEqualTolerance) const { return Dist(b) < eps; }

		Point3Cartesian operator+(const Point3Cartesian& b) const { return Point3Cartesian(X() + b.X(), Y() + b.Y(), Z() + b.Z()); }
		Point3Cartesian& operator+=(const Point3Cartesian& b) { _x += b.X(); _y += b.Y(); _z += b.Z(); return *this; }

		Point3Cartesian operator-(const Point3Cartesian& b) const { return Point3Cartesian(X() - b.X(), Y() - b.Y(), Z() - b.Z()); }
		Point3Cartesian& operator-=(const Point3Cartesian& b) { _x -= b.X(); _y -= b.Y(); _z -= b.Z(); return *this; }

		Point3Cartesian operator*(Real b) const { return Point3Cartesian(X() * b, Y() * b, Z() * b); }
		Point3Cartesian& operator*=(Real b) { _x *= b; _y *= b; _z *= b; return *this; }

		Point3Cartesian operator/(Real b) const { return Point3Cartesian(X() / b, Y() / b, Z() / b); }
		Point3Cartesian& operator/=(Real b) { _x /= b; _y /= b; _z /= b; return *this; }

		friend Point3Cartesian operator*(Real a, const Point3Cartesian& b) { return Point3Cartesian(a * b.X(), a * b.Y(), a * b.Z()); }
	};

	class Point3Spherical
	{
	private:
		Real _r, _theta, _phi;

	public:
		Real  R() const			{ return _r; }
		Real& R()						{ return _r; }
		Real  Theta() const { return _theta; }
		Real& Theta()				{ return _theta; }
		Real  Phi() const		{ return _phi; }
		Real& Phi()					{ return _phi; }

		Point3Spherical() : _r(0), _theta(0), _phi(0) {}
		Point3Spherical(Real r, Real theta, Real phi) : _r(r), _theta(theta), _phi(phi) {}
		Point3Spherical(const Point3Cartesian& pnt)
		{
			_r = sqrt(POW2(pnt.X()) + POW2(pnt.Y()) + POW2(pnt.Z()));
			_theta = atan2(sqrt(POW2(pnt.X()) + POW2(pnt.Y())), pnt.Z());
			_phi = atan2(pnt.Y(), pnt.X());
		}
		
		bool	operator==(const Point3Spherical& b) const { return (R() == b.R()) && (Theta() == b.Theta()) && (Phi() == b.Phi()); }
		bool	operator!=(const Point3Spherical& b) const { return (R() != b.R()) || (Theta() != b.Theta()) || (Phi() != b.Phi()); }
		bool  IsEqual(const Point3Spherical& b, Real eps = Defaults::Pnt3SphIsEqualTolerance) const { return Dist(b) < eps; }

		Point3Cartesian TransfToCart() const
		{
			return Point3Cartesian(R() * sin(Theta()) * cos(Phi()), R() * sin(Theta()) * sin(Phi()), R() * cos(Theta()));
		}
		
		Real Dist(const Point3Spherical& b) const
		{
			return sqrt(R() * R() + b.R() * b.R() - 2 * R() * b.R() * cos(b.Theta() - Theta()) * cos(b.Phi() - Phi()));
		}
	};

	class Point3Cylindrical
	{
	private:
		Real _r, _phi, _z;

	public:
		Real  R() const		{ return _r; }
		Real& R()					{ return _r; }
		Real  Phi() const { return _phi; }
		Real& Phi()				{ return _phi; }
		Real  Z() const		{ return _z; }
		Real& Z()					{ return _z; }

		Point3Cylindrical() : _r(0), _phi(0), _z(0) {}
		Point3Cylindrical(Real r, Real phi, Real z) : _r(r), _phi(phi), _z(z) {}
		Point3Cylindrical(const Point3Cartesian& pnt)
		{
			_r = sqrt(POW2(pnt.X()) + POW2(pnt.Y()));
			_phi = atan2(pnt.Y(), pnt.X());
			_z = pnt.Z();
		}
		
		bool	operator==(const Point3Cylindrical& b) const { return (R() == b.R()) && (Phi() == b.Phi()) && (Z() == b.Z()); }
		bool	operator!=(const Point3Cylindrical& b) const { return (R() != b.R()) || (Phi() != b.Phi()) || (Z() != b.Z()); }
		bool  IsEqual(const Point3Cylindrical& b, Real eps = Defaults::Pnt3CylIsEqualTolerance) const { return Dist(b) < eps; }

		Point3Cartesian TransfToCart() const
		{
			return Point3Cartesian(R() * cos(Phi()), R() * sin(Phi()), Z());
		}
		
		Real Dist(const Point3Cylindrical& b) const
		{
			return sqrt(R() * R() + b.R() * b.R() - 2 * R() * b.R() * cos(b.Phi() - Phi()) + POW2(b.Z() - Z()));
		}
	};

	class Triangle
	{
	private:
		Real _a, _b, _c;

	public:
		Real  A() const { return _a; }
		Real& A()				{ return _a; }
		Real  B() const { return _b; }
		Real& B()				{ return _b; }
		Real  C() const { return _c; }
		Real& C()				{ return _c; }

		Triangle() : _a(0.0), _b(0.0), _c(0.0){}
		Triangle(Real a, Real b, Real c) : _a(a), _b(b), _c(c) {}

		Real Area() const
		{
			Real s = (A() + B() + C()) / 2.0;
			return sqrt(s * (s - A()) * (s - B()) * (s - C()));
		}
		
		bool IsRight() const
		{
			return (hypot(A(), B()) == C() || hypot(A(), C()) == B() || hypot(B(), C()) == A());
		}
		bool IsIsosceles() const		// two sides are the same length
		{
			return (A() == B()) || (A() == C()) || (B() == C());
		}
		bool IsEquilateral() const	// all sides are the same length
		{
			return (A() == B()) && (A() == C());
		}
	};

	typedef Point2Cartesian		Pnt2Cart;
	typedef Point2Polar				Pnt2Pol;
	typedef Point3Cartesian		Pnt3Cart;
	typedef Point3Spherical		Pnt3Sph;
	typedef Point3Cylindrical Pnt3Cyl;
}

///////////////////////////   mml/base/Vector.h   ///////////////////////////



namespace MML
{
	template<class Type>
	class	Vector
	{
	private:
		std::vector<Type> _elems;

	public:
		typedef Type value_type;      // make T available externally

		/////////////////////                  Constructors                ////////////////////
		Vector() {}
		explicit Vector(int n) {
			if(n < 0)
				throw VectorInitializationError("Vector::Vector - negative size", n);

			// Initialize to zero for numeric types, default construct for others
			if constexpr (std::is_arithmetic_v<Type>) {
				_elems.resize(n, Type{ 0 });
			} else {
				_elems.resize(n);
			}
		}
		explicit Vector(int n, const Type &val) {
			if (n < 0)
				throw VectorInitializationError("Vector::Vector - negative size", n);

			_elems.resize(n, val);
		}
		explicit Vector(int n, Type* vals) 
		{
			if (n < 0)
				throw VectorInitializationError("Vector::Vector - negative size", n);

			_elems.resize(n);
			for (int i = 0; i < n; ++i)
				_elems[i] = vals[i];
		}
		explicit Vector(const std::vector<Type> &values) : _elems(values) {}
		explicit Vector(std::initializer_list<Type> list) : _elems(list) {}

		static Vector GetUnitVector(int dimVec, int indUnit)
		{
			static_assert(std::is_arithmetic_v<Type>, "GetUnitVector requires arithmetic type");
			
			if (indUnit < 0 || indUnit >= dimVec)
				throw VectorDimensionError("Vector::GetUnitVector - wrong unit index", dimVec, indUnit);

			Vector ret(dimVec);
			ret[indUnit] = Type{ 1.0 };
			return ret;
		}

		// not really needed, but let's be explicit
		Vector(const Vector& b) = default; 
		Vector(Vector&& b) noexcept = default;
		Vector& operator=(const Vector& b) = default; 
		Vector& operator=(Vector&& b) noexcept = default;

		////////////////            std::vector forwarding                 ////////////////////
		int  size()			const { return (int)_elems.size(); }
		bool isEmpty()	const { return _elems.empty(); }

		// front and back
		Type& front()							{ return _elems.front(); }
		const Type& front() const { return _elems.front(); }
		Type& back()							{ return _elems.back(); }
		const Type& back() const	{ return _elems.back(); }

    auto begin()	noexcept { return _elems.begin(); }
    auto end()		noexcept { return _elems.end(); }
    auto begin()	const noexcept { return _elems.begin(); }
    auto end()		const noexcept { return _elems.end(); }
    auto cbegin() const noexcept { return _elems.cbegin(); }
    auto cend()		const noexcept { return _elems.cend(); }

		void push_back(const Type& val) { _elems.push_back(val); }
		void push_back(Type&& val)			{ _elems.push_back(std::move(val)); }
		
		void insert(int pos, const Type& val) { _elems.insert(_elems.begin() + pos, val); }
		void insert(int pos, Type&& val) { _elems.insert(_elems.begin() + pos, std::move(val)); }
		
		void erase(int pos)							{ _elems.erase(_elems.begin() + pos); }
		void erase(int start, int end)	{ _elems.erase(_elems.begin() + start, _elems.begin() + end); }
		void erase(const Type& val)			{ _elems.erase(std::remove(_elems.begin(), _elems.end(), val), _elems.end()); }

		void Clear()	{ _elems.clear(); }
		void Resize(int newLen, bool preserveElements = false)	
		{ 
			if (preserveElements == true)
			{
				std::vector<Type> oldElems(_elems);

				_elems.resize(newLen); 

				for (int i = 0; i < oldElems.size() && i < newLen; i++)
					_elems[i] = oldElems[i];
			}
			else
				_elems.resize(newLen); 
		}

		/////////////////////            Accessing elements             ///////////////////////
		inline Type&       operator[](int n)       { return _elems[n]; }
		inline const Type& operator[](int n) const { return _elems[n]; }

		// checked access
		Type& at(int n)	{
			if(n < 0 || n >= size())
				throw VectorDimensionError("Vector::at - index out of bounds", size(), n);
			else
				return _elems[n];
		}
		Type  at(int n) const { 
			if(n < 0 || n >= size())
				throw VectorDimensionError("Vector::at - index out of bounds", size(), n);
			else
				return _elems[n];
		}

		///////////////////////          Arithmetic operators         ////////////////////////
		Vector  operator-() const         // unary minus
		{
			Vector ret(size());
			for (int i = 0; i < size(); i++)
				ret._elems[i] = Type{ -1 } * (*this)[i];
			return ret;
		}
		
		Vector  operator+(const Vector& b) const
		{
			if (size() != b.size())
				throw VectorDimensionError("Vector::operator+() - vectors must be equal size", size(), b.size());

			Vector ret(b.size());;
			for (int i = 0; i < b.size(); i++)
				ret._elems[i] = (*this)[i] + b._elems[i];
			return ret;
		}
		Vector& operator+=(const Vector& b)
		{
			if (size() != b.size())
				throw VectorDimensionError("Vector::operator+=() - vectors must be equal size", size(), b.size());
			
			for (int i = 0; i < b.size(); i++)
				_elems[i] += b._elems[i];
			return *this;
		}
		Vector  operator-(const Vector& b) const
		{
			if (size() != b.size())
				throw VectorDimensionError("Vector::operator-() - vectors must be equal size", size(), b.size());

			Vector ret(b.size());;
			for (int i = 0; i < b.size(); i++)
				ret._elems[i] = (*this)[i] - b._elems[i];
			return ret;
		}
		Vector& operator-=(const Vector& b)
		{
			if (size() != b.size())
				throw VectorDimensionError("Vector::operator-=() - vectors must be equal size", size(), b.size());
			
			for (int i = 0; i < b.size(); i++)
				_elems[i] -= b._elems[i];
			return *this;
		}

		Vector  operator*(Type b) const
		{
			Vector ret(size());;
			for (int i = 0; i < size(); i++)
				ret._elems[i] = b * _elems[i];
			return ret;
		}
		Vector& operator*=(Type b)
		{
			for (int i = 0; i < size(); i++)
				_elems[i] *= b;
			return *this;
		}
		Vector  operator/(Type b) const
		{
			Vector ret(size());
			for (int i = 0; i < size(); i++)
				ret._elems[i] = _elems[i] / b;
			return ret;
		}
		Vector& operator/=(Type b)
		{
			for (int i = 0; i < size(); i++)
				_elems[i] /= b;
			return *this;
		}
		
		friend Vector operator*(Type a, const Vector& b)
		{
			Vector ret(b.size());;
			for (int i = 0; i < b.size(); i++)
				ret._elems[i] = a * b._elems[i];
			return ret;
		}

		///////////////////////             Testing equality             ////////////////////////
		bool operator==(const Vector& b) const
		{
			if (size() != b.size())
				throw VectorDimensionError("Vector::operator==() - vectors must be equal size", size(), b.size());

			for (int i = 0; i < size(); i++)
				if ((*this)[i] != b[i])
					return false;

			return true;
		}
		bool operator!=(const Vector& b) const
		{
			return !(*this == b);
		}
		bool IsEqualTo(const Vector& b, Real eps = Defaults::VectorIsEqualTolerance) const
		{
			if (size() != b.size())
				throw VectorDimensionError("Vector::IsEqual - vectors must be equal size", size(), b.size());

			for (int i = 0; i < size(); i++)
			{
				if (Abs((*this)[i] - b[i]) > eps)
					return false;
			}
			return true;
		}	
		bool IsNullVec() const
		{
			for (int i = 0; i < size(); i++)
				if (Abs((*this)[i]) != 0.0 )
					return false;
			return true;
		}
		
		//////////////////////                 Operations                 ///////////////////////
		Real NormL1() const
		{
			Real norm{ 0.0 };
			for (int i = 0; i < size(); i++)
				norm += Abs((*this)[i]);
			return norm;
		}
		Real NormL2() const
		{
			Real norm{ 0.0 };
			for (int i = 0; i < size(); i++)
				norm += (*this)[i] * (*this)[i];
			return std::sqrt(norm);
		}
		Real NormLInf() const
		{
			Real norm{ 0.0 };
			for (int i = 0; i < size(); i++)
				norm = std::max(norm, Abs((*this)[i]));
			return norm;
		}

		///////////////////////////               I/O                 ///////////////////////////
		std::ostream& Print(std::ostream& stream, int width, int precision, Real zeroThreshold) const
		{
			stream << "[";
			bool first = true;
			for (const Type& x : _elems)
			{
				if (!first)
					stream << ", ";
				else
					first = false;

        if( Abs(x) > zeroThreshold )
				  stream << std::setw(width) << std::setprecision(precision) << x;
        else
          stream << std::setw(width) << std::setprecision(precision) << 0.0;
			}
			stream << "]";

			return stream;
		}
		std::ostream& Print(std::ostream& stream, int width, int precision) const
		{
			return Print(stream, width, precision, 0.0);
		}
    std::ostream& PrintLine(std::ostream& stream, const std::string &msg, int width, int precision) const
		{
			stream << msg;
			Print(stream, width, precision);
			stream << std::endl;

			return stream;
		}
		// print in column
		std::ostream& PrintCol(std::ostream& stream, int width, int precision) const
		{
			for (const Type& x : _elems)
				stream << std::setw(width) << std::setprecision(precision) << x << std::endl;
			return stream;
		}		

		std::string to_string(int width, int precision) const
		{
			std::stringstream str;

			Print(str, width, precision);

			return str.str();
		}    
		friend std::ostream& operator<<(std::ostream &stream, const Vector &a)
		{
			a.Print(stream, Defaults::VectorPrintWidth, Defaults::VectorPrintPrecision);

			return stream;
		}  
	};

	typedef Vector<int>     VectorInt;
	typedef Vector<float>   VectorFlt;
	typedef Vector<double>  VectorDbl;
	typedef Vector<Complex> VectorComplex;

	typedef Vector<int>     VecI;
	typedef Vector<float>   VecF;
	typedef Vector<double>  VecD;
	typedef Vector<Complex> VecC;

	// Verify noexcept move operations enable STL optimizations
	static_assert(std::is_nothrow_move_constructible_v<Vector<double>>,
	              "Vector<double> should be nothrow move constructible");
	static_assert(std::is_nothrow_move_assignable_v<Vector<double>>,
	              "Vector<double> should be nothrow move assignable");
}


///////////////////////////   mml/base/VectorN.h   ///////////////////////////



namespace MML
{
	template<class Type, int N>
	class VectorN
	{
	protected:
		Type  _val[N] = { 0 };

	public:
		typedef Type value_type;      // make T available externally

		///////////////////////          Constructors and destructor       //////////////////////
		VectorN() {}
		explicit VectorN(const Type& init_val) {
			for (int i = 0; i < N; ++i)
				_val[i] = init_val;
		}
		VectorN(std::initializer_list<Type> list)
		{
			int count = 0;
			for (auto element : list)
			{
				_val[count] = element;
				++count;

				if (count >= N)
					break;
			}
		}
		VectorN(std::vector<Type> list)
		{
			int count{ 0 };
			for (auto element : list)
			{
				_val[count] = element;
				++count;

				if (count >= N)
					break;
			}
		}
		explicit VectorN(Type* vals)
		{
			for (int i = 0; i < N; ++i)
				_val[i] = vals[i];
		}
		
		static VectorN GetUnitVector(int indUnit)
		{
			VectorN ret;
			ret[indUnit] = 1.0;
			return ret;
		}
		VectorN Normalized() const
		{
			VectorN ret;
			Real norm = NormL2();
			if (norm == 0.0)
				throw VectorDimensionError("VectorN::Normalized - cannot normalize zero vector", N, 0);
			for (int i = 0; i < N; ++i)
				ret._val[i] = _val[i] / norm;
			return ret;
		}
		////////////////////////            Standard stuff             ////////////////////////
		int  size() const { return N; }
		void clear() {
			for (int i = 0; i < N; ++i)
				_val[i] = Type{ 0 };
		}

		///////////////////////            Accessing elements             ///////////////////////
		inline Type& operator[](int n) { return _val[n]; }
		inline Type  operator[](int n) const { return _val[n]; }

		// checked access
		Type& at(int n) {
			if (n < 0 || n >= N)
				throw VectorDimensionError("VectorN::at - index out of bounds", N, n);
			else
				return _val[n];
		}
		Type  at(int n) const {
			if (n < 0 || n >= N)
				throw VectorDimensionError("VectorN::at - index out of bounds", N, n);
			else
				return _val[n];
		}

		///////////////////////            Testing equality                ///////////////////////
		bool operator==(const VectorN& b) const
		{
			for (int i = 0; i < size(); i++)
				if ((*this)[i] != b[i])
					return false;

			return true;
		}
		static bool AreEqual(const VectorN& a, const VectorN& b, Type eps = Defaults::VectorIsEqualTolerance)
		{
			return a.IsEqualTo(b, eps);
		}
		bool IsEqualTo(const VectorN& b, Type eps = Defaults::VectorIsEqualTolerance) const
		{
			for (int i = 0; i < N; i++)
			{
				if (Abs((*this)[i] - b[i]) > eps)
					return false;
			}
			return true;
		}
		bool operator!=(const VectorN& b) const
		{
			return !(*this == b);
		}

		bool IsNullVec() const
		{
			for (int i = 0; i < N; i++)
				if (_val[i] != 0.0)
					return false;

			return true;
		}
		
		/////////////////////             Arithmetic operators             ///////////////////////
		VectorN  operator-() const        // unary minus
		{
			VectorN ret;
			for (int i = 0; i < N; i++)
				ret._val[i] = Type{ -1 } *_val[i];
			return ret;
		}
		
		VectorN  operator+(const VectorN& b) const
		{
			VectorN ret;
			for (int i = 0; i < N; i++)
				ret._val[i] = _val[i] + b._val[i];
			return ret;
		}
		VectorN& operator+=(const VectorN& b)
		{
			for (int i = 0; i < N; i++)
				_val[i] += b._val[i];
			return *this;
		}
		VectorN  operator-(const VectorN& b) const
		{
			VectorN ret;
			for (int i = 0; i < N; i++)
				ret._val[i] = _val[i] - b._val[i];
			return ret;
		}
		VectorN& operator-=(const VectorN& b)
		{
			for (int i = 0; i < N; i++)
				_val[i] -= b._val[i];
			return *this;
		}

		VectorN  operator*(const Type &b) const
		{
			VectorN ret;
			for (int i = 0; i < N; i++)
				ret._val[i] = _val[i] * b;
			return ret;
		}
		VectorN& operator*=(const Type& b)
		{
			for (int i = 0; i < N; i++)
				_val[i] *= b;
			return *this;
		}
		VectorN  operator/(const Type &b) const
		{
			VectorN ret;
			for (int i = 0; i < N; i++)
				ret._val[i] = _val[i] / b;
			return ret;
		}		
		VectorN& operator/=(const Type& b)
		{
			for (int i = 0; i < N; i++)
				_val[i] /= b;
			return *this;
		}
		
		friend VectorN operator*(Type a, const VectorN<Type, N>& b)
		{
			VectorN ret;
			for (int i = 0; i < N; i++)
				ret._val[i] = a * b[i];
			return ret;
		}

		//////////////////////                 Operations                 ///////////////////////
		Real NormL1() const
		{
			Real norm{ 0.0 };
			for (int i = 0; i < N; i++)
				norm += Abs((*this)[i]);
			return norm;
		}
		Real NormL2() const
		{
			Real norm{ 0.0 };
			for (int i = 0; i < N; i++)
				norm += (*this)[i] * (*this)[i];
			return std::sqrt(norm);
		}
		Real NormLInf() const
		{
			Real norm{ 0.0 };
			for (int i = 0; i < N; i++)
				norm = std::max(norm, Abs((*this)[i]));
			return norm;
		}

		///////////////////////////               I/O                 ///////////////////////////
		std::ostream& Print(std::ostream& stream, int width, int precision) const
		{
			stream << "[";
			bool first = true;
			for (const Type& x : _val)
			{
				if (!first)
					stream << ", ";
				else
					first = false;

				stream << std::setw(width) << std::setprecision(precision) << x;
			}
			stream << "]";

			return stream;
		}
		std::ostream& Print(std::ostream& stream, int width, int precision, Real zeroThreshold) const
		{
			stream << "[";
			bool first = true;
			for (const Type& x : _val)
			{
				if (!first)
					stream << ", ";
				else
					first = false;

				if (Abs(x) > zeroThreshold)
					stream << std::setw(width) << std::setprecision(precision) << x;
				else
					stream << std::setw(width) << std::setprecision(precision) << 0.0;
			}
			stream << "]";

			return stream;
		}
		std::ostream& PrintLine(std::ostream& stream, std::string msg, int width, int precision) const
		{
			stream << msg;
			Print(stream, width, precision);
			stream << std::endl;

			return stream;
		}

		std::string to_string(int width, int precision) const
		{
			std::stringstream str;

			Print(str, width, precision);

			return str.str();
		}
		friend std::ostream& operator<<(std::ostream& stream, const VectorN<Type, N>& a)
		{
			a.Print(stream, Defaults::VectorNPrintWidth, Defaults::VectorNPrintPrecision);

			return stream;
		}
	};

	typedef VectorN<Real, 2> Vec2;
	typedef VectorN<Real, 3> Vec3;
	typedef VectorN<Real, 4> Vec4;

	typedef VectorN<float, 2> Vec2Flt;
	typedef VectorN<float, 3> Vec3Flt;
	typedef VectorN<float, 4> Vec4Flt;

	typedef VectorN<double, 2> Vec2Dbl;
	typedef VectorN<double, 3> Vec3Dbl;
	typedef VectorN<double, 4> Vec4Dbl;

	typedef VectorN<Complex, 2> Vec2Complex;
	typedef VectorN<Complex, 3> Vec3Complex;
	typedef VectorN<Complex, 4> Vec4Complex;

	typedef VectorN<float, 2> Vec2F;
	typedef VectorN<float, 3> Vec3F;
	typedef VectorN<float, 4> Vec4F;

	typedef VectorN<double, 2> Vec2D;
	typedef VectorN<double, 3> Vec3D;
	typedef VectorN<double, 4> Vec4D;

	typedef VectorN<Complex, 2> Vec2C;
	typedef VectorN<Complex, 3> Vec3C;
	typedef VectorN<Complex, 4> Vec4C;
}


///////////////////////////   mml/base/VectorTypes.h   ///////////////////////////



namespace MML
{
	class Vector2Cartesian : public VectorN<Real, 2>
	{
	public:
		Vector2Cartesian() {}
		Vector2Cartesian(Real x, Real y)
		{
			_val[0] = x;
			_val[1] = y;
		}
		Vector2Cartesian(const VectorN<Real, 2>& b) : VectorN<Real, 2>{ b[0], b[1] } {}
		Vector2Cartesian(const Point2Cartesian& a, const Point2Cartesian& b)
		{
			_val[0] = b.X() - a.X();
			_val[1] = b.Y() - a.Y();
		}
		Vector2Cartesian(std::initializer_list<Real> list) : VectorN<Real, 2>(list) {}

		Real  X() const { return _val[0]; }
		Real& X()				{ return _val[0]; }
		Real  Y() const { return _val[1]; }
		Real& Y()				{ return _val[1]; }
		
		// unary minus operator
		Vector2Cartesian operator-() const
		{
			Vector2Cartesian ret;
			for (int i = 0; i < 2; i++)
				ret._val[i] = -_val[i];
			return ret;
		}
		
		// arithmetic operations
		Vector2Cartesian operator+(const Vector2Cartesian& b) const
		{
			Vector2Cartesian ret;
			for (int i = 0; i < 2; i++)
				ret._val[i] = _val[i] + b[i];
			return ret;
		}
		Vector2Cartesian operator-(const Vector2Cartesian& b) const
		{
			Vector2Cartesian ret;
			for (int i = 0; i < 2; i++)
				ret._val[i] = _val[i] - b[i];
			return ret;
		}

		Vector2Cartesian operator*(Real b) const
		{
			Vector2Cartesian ret;
			for (int i = 0; i < 2; i++)
				ret._val[i] = _val[i] * b;
			return ret;
		}
		Vector2Cartesian operator/(Real b) const
		{
			Vector2Cartesian ret;
			for (int i = 0; i < 2; i++)
				ret._val[i] = _val[i] / b;
			return ret;
		}
		friend Vector2Cartesian operator*(Real a, const Vector2Cartesian& b)
		{
			Vector2Cartesian ret;
			for (int i = 0; i < 2; i++)
				ret._val[i] = a * b[i];
			return ret;
		}

		// equality operators
		bool operator==(const Vector2Cartesian& b) const
		{
			return (X() == b.X()) && (Y() == b.Y());
		}
		bool operator!=(const Vector2Cartesian& b) const
		{
			return (X() != b.X()) || (Y() != b.Y());
		}
		bool IsEqual(const Vector2Cartesian& b, Real absEps = Defaults::Vec2CartIsEqualTolerance) const
		{
			return (std::abs(X() - b.X()) < absEps) && (std::abs(Y() - b.Y()) < absEps);
		}

		Vector2Cartesian Normalized() const
		{
			Vector2Cartesian ret;
			Real norm = NormL2();
			if (norm > 0.0)
			{
				for (int i = 0; i < 2; i++)
					ret._val[i] = _val[i] / norm;
			}
			else
			{
				ret._val[0] = 0.0;
				ret._val[1] = 0.0;
			}
			return ret;
		}
		Vector2Cartesian GetAsUnitVector() const
		{
			VectorN<Real, 2> res = (*this) / NormL2();

			return Vector2Cartesian(res[0], res[1]);
		}
		Vector2Cartesian GetAsUnitVectorAtPos(const Vector2Cartesian& pos) const
		{
			return Vector2Cartesian{ (*this) / NormL2() };
		}
		
		// returns two vectors that are perpendicular to this vector
		void getPerpendicularVectors(Vector2Cartesian& v1, Vector2Cartesian& v2) const
		{
			v1 = Vector2Cartesian(-Y(), X());
			v2 = Vector2Cartesian(Y(), -X());
		}

		// For Cartesian vector, we will enable operator* to represent standard scalar product
		Real operator*(const Vector2Cartesian& b) const
		{
			return X() * b.X() + Y() * b.Y();
		}

		friend Real ScalarProduct(const Vector2Cartesian& a, const Vector2Cartesian& b)
		{
			return a * b;
		}

		friend Point2Cartesian operator+(const Point2Cartesian& a, const Vector2Cartesian& b) { return Point2Cartesian(a.X() + b[0], a.Y() + b[1]); }
		friend Point2Cartesian operator-(const Point2Cartesian& a, const Vector2Cartesian& b) { return Point2Cartesian(a.X() - b[0], a.Y() - b[1]); }
	};

	class Vector2Polar : public VectorN<Real, 2>
	{
	public:
		Real  R() const		{ return _val[0]; }
		Real& R()					{ return _val[0]; }
		Real  Phi() const { return _val[1]; }
		Real& Phi()				{ return _val[1]; }

		Vector2Polar() {}
		Vector2Polar(Real r, Real phi)
		{
			_val[0] = r;
			_val[1] = phi;
		}
		Vector2Polar(const VectorN<Real, 2>& b) : VectorN<Real, 2>{ b[0], b[1] } {}

		// unary minus operator
		Vector2Polar operator-() const
		{
			// Negating a polar vector means keeping the radius and adding pi to the angle
			return Vector2Polar(R(), Phi() + Constants::PI);
		}
		
		// arithmetic operations
		Vector2Polar operator+(const Vector2Polar& b) const
		{
			Real r1 = R();
			Real phi1 = Phi();
			Real r2 = b.R();
			Real phi2 = b.Phi();

			Real delta = phi2 - phi1;
			Real r	 = std::sqrt(r1 * r1 + r2 * r2 + 2 * r1 * r2 * std::cos(delta));
			Real phi = phi1 + std::atan2(r2 * std::sin(delta), r1 + r2 * std::cos(delta));

			return Vector2Polar(r, phi);
		}
		Vector2Polar operator-(const Vector2Polar& b) const
		{
			Real r1 = R();
			Real phi1 = Phi();
			Real r2 = b.R();
			Real phi2 = b.Phi();

			Real delta = phi2 - phi1;
			Real r	 = std::sqrt(r1 * r1 + r2 * r2 - 2 * r1 * r2 * std::cos(delta));
			Real phi = phi1 + std::atan2(-r2 * std::sin(delta), r1 - r2 * std::cos(delta));

			return Vector2Polar(r, phi);
		}
		Vector2Polar operator*(Real b) const
		{
			return Vector2Polar(R() * b, Phi());
		}
		Vector2Polar operator/(Real b) const
		{
			return Vector2Polar(R() / b, Phi());
		}

		friend Vector2Polar operator*(Real a, const Vector2Polar& b)
		{
			return Vector2Polar(b.R() * a, b.Phi());
		}

		Vector2Polar GetAsUnitVectorAtPos(const Vector2Polar& /*pos*/) const
		{
			// Returns a unit vector in the direction of this vector (ignores pos)
			return Vector2Polar(1.0, Phi());
		}
	};

	class Vector3Cartesian : public VectorN<Real, 3>
	{
	public:
		Real  X() const { return _val[0]; }
		Real& X()				{ return _val[0]; }
		Real  Y() const { return _val[1]; }
		Real& Y()				{ return _val[1]; }
		Real  Z() const { return _val[2]; }
		Real& Z()				{ return _val[2]; }

		Vector3Cartesian() : VectorN<Real, 3>{ 0.0, 0.0, 0.0 } {}
		Vector3Cartesian(const VectorN<Real, 3>& b) : VectorN<Real, 3>{ b } {}
		Vector3Cartesian(Real x, Real y, Real z) : VectorN<Real, 3>{ x, y, z } {}
		Vector3Cartesian(std::initializer_list<Real> list) : VectorN<Real, 3>(list) { }
		Vector3Cartesian(const Point3Cartesian& a, const Point3Cartesian& b)
		{
			_val[0] = b.X() - a.X();
			_val[1] = b.Y() - a.Y();
			_val[2] = b.Z() - a.Z();
		}
		// we'll provide a constructor that takes a Point3Cartesian, 
		// so it can be used to convert a Cartesian point to a vector
		Vector3Cartesian(const Point3Cartesian& a)
		{
			_val[0] = a.X();
			_val[1] = a.Y();
			_val[2] = a.Z();
		}

		Point3Cartesian getAsPoint()
		{
			return Point3Cartesian(_val[0], _val[1], _val[2]);
		}
		
		Vector3Cartesian Normalized() const
		{
			Vector3Cartesian ret;
			Real norm = NormL2();
			if (norm > 0.0)
			{
				for (int i = 0; i < 3; i++)
					ret._val[i] = _val[i] / norm;
			}
			else
			{
				ret._val[0] = 0.0;
				ret._val[1] = 0.0;
				ret._val[2] = 0.0;
			}
			return ret;
		}
		Vector3Cartesian GetAsUnitVector() const
		{
			if(NormL2() == 0.0)
			{
				return Vector3Cartesian{ REAL(0.0), REAL(0.0), REAL(0.0) };
			}
			return Vector3Cartesian{ (*this) / NormL2() };
		}
		Vector3Cartesian GetAsUnitVectorAtPos(const Vector3Cartesian& pos) const
		{
			return GetAsUnitVector();
		}

		// For Cartesian vector, we will enable operator* to represent standard scalar product
		Real operator*(const Vector3Cartesian& b) const
		{
			return X()*b.X() + Y()*b.Y() + Z()*b.Z();
		}

		// unary minus operator
		Vector3Cartesian operator-() const
		{
			Vector3Cartesian ret;
			for (int i = 0; i < 3; i++)
				ret._val[i] = -_val[i];
			return ret;
		}

		// arithmetic operations
		Vector3Cartesian operator+(const Vector3Cartesian& b) const
		{
			Vector3Cartesian ret;
			for (int i = 0; i < 3; i++)
				ret._val[i] = _val[i] + b[i];
			return ret;
		}
		Vector3Cartesian operator-(const Vector3Cartesian& b) const
		{
			Vector3Cartesian ret;
			for (int i = 0; i < 3; i++)
				ret._val[i] = _val[i] - b[i];
			return ret;
		}

		Vector3Cartesian operator*(Real b) const
		{
			Vector3Cartesian ret;
			for (int i = 0; i < 3; i++)
				ret._val[i] = _val[i] * b;
			return ret;
		}
		Vector3Cartesian operator/(Real b) const
		{
			Vector3Cartesian ret;
			for (int i = 0; i < 3; i++)
				ret._val[i] = _val[i] / b;
			return ret;
		}
		friend Vector3Cartesian operator*(Real a, const Vector3Cartesian& b)
		{
			Vector3Cartesian ret;
			for (int i = 0; i < 3; i++)
				ret._val[i] = a * b[i];
			return ret;
		}

		// equality operators
		bool operator==(const Vector3Cartesian& b) const
		{
			return (X() == b.X()) && (Y() == b.Y()) && (Z() == b.Z());
		}
		bool operator!=(const Vector3Cartesian& b) const
		{
			return (X() != b.X()) || (Y() != b.Y()) || (Z() != b.Z());
		}
		bool IsEqual(const Vector3Cartesian& b, Real absEps = Defaults::Vec3CartIsEqualTolerance) const
		{
			return (std::abs(X() - b.X()) < absEps) && (std::abs(Y() - b.Y()) < absEps) && (std::abs(Z() - b.Z()) < absEps);
		}

		friend Point3Cartesian operator+(const Point3Cartesian& a, const Vector3Cartesian& b) { return Point3Cartesian(a.X() + b[0], a.Y() + b[1], a.Z() + b[2]); }
		friend Point3Cartesian operator-(const Point3Cartesian& a, const Vector3Cartesian& b) { return Point3Cartesian(a.X() - b[0], a.Y() - b[1], a.Z() - b[2]); }

		bool IsParallelTo(const Vector3Cartesian& b, Real eps = Defaults::Vec3CartIsParallelTolerance) const
		{
			Real norm1 = NormL2();
			Real norm2 = b.NormL2();

			return std::abs(X() / norm1 - b.X() / norm2) < eps &&
				std::abs(Y() / norm1 - b.Y() / norm2) < eps &&
				std::abs(Z() / norm1 - b.Z() / norm2) < eps;
		}
		bool IsPerpendicularTo(const Vector3Cartesian& b, Real eps = 1e-15) const
		{
			if (std::abs(this->ScalarProduct(b)) < eps)
				return true;
			else
				return false;
		}
		bool GetPerpendicularVectors(Vector3Cartesian& v1, Vector3Cartesian& v2) const
		{
			if (IsNullVec())
				return false;
			
			// find a vector that is not parallel to this vector
			Vector3Cartesian not_parallel;
			if (std::abs(X()) <= std::abs(Y()) && std::abs(X()) <= std::abs(Z()))
				not_parallel = Vector3Cartesian(1.0, 0.0, 0.0);
			else if (std::abs(Y()) <= std::abs(X()) && std::abs(Y()) <= std::abs(Z()))
				not_parallel = Vector3Cartesian(0.0, 1.0, 0.0);
			else
				not_parallel = Vector3Cartesian(0.0, 0.0, 1.0);
			
			v1 = VectorProduct(*this, not_parallel).GetAsUnitVector();
			v2 = VectorProduct(*this, v1).GetAsUnitVector();
			
			return true;
		}

		Real AngleToVector(const Vector3Cartesian& b)
		{
			Real cos_phi = this->ScalarProduct(b) / (NormL2() * b.NormL2());

			return acos(cos_phi);
		}

		Real ScalarProduct(const Vector3Cartesian& b) const
		{
			return (*this) * b;
		}

		friend Real ScalarProduct(const Vector3Cartesian& a, const Vector3Cartesian& b)
		{
			return a * b;
		}

		friend Vector3Cartesian VectorProduct(const Vector3Cartesian& a, const Vector3Cartesian& b)
		{
			Vector3Cartesian ret;

			ret.X() = a.Y() * b.Z() - a.Z() * b.Y();
			ret.Y() = a.Z() * b.X() - a.X() * b.Z();
			ret.Z() = a.X() * b.Y() - a.Y() * b.X();

			return ret;
		}
	};

	class Vector3Spherical : public VectorN<Real, 3>
	{
	public:
		Real  R()     const { return _val[0]; }
		Real& R()						{ return _val[0]; }
		Real  Theta() const { return _val[1]; }
		Real& Theta()				{ return _val[1]; }
		Real  Phi()   const { return _val[2]; }
		Real& Phi()					{ return _val[2]; }

		Vector3Spherical() : VectorN<Real, 3>{ 0.0, 0.0, 0.0 } {}
		Vector3Spherical(const VectorN<Real, 3>& b) : VectorN<Real, 3>{ b[0], b[1], b[2] } {}
		Vector3Spherical(Real r, Real theta, Real phi) : VectorN<Real, 3>{ r, theta, phi } {}
		Vector3Spherical(std::initializer_list<Real> list) : VectorN<Real, 3>(list) { }

		// unary minus operator
		Vector3Spherical operator-() const
		{
			return Vector3Spherical(R(), Constants::PI - Theta(), Phi() + Constants::PI);
		}

		// arithmetic operations
		Vector3Spherical operator+(const Vector3Spherical& b) const
		{
			Real r1 = R();
			Real theta1 = Theta();
			Real phi1 = Phi();
			Real r2 = b.R();
			Real theta2 = b.Theta();
			Real phi2 = b.Phi();

			// Convert spherical to Cartesian coordinates
			Real x1 = r1 * std::sin(theta1) * std::cos(phi1);
			Real y1 = r1 * std::sin(theta1) * std::sin(phi1);
			Real z1 = r1 * std::cos(theta1);
			Real x2 = r2 * std::sin(theta2) * std::cos(phi2);
			Real y2 = r2 * std::sin(theta2) * std::sin(phi2);
			Real z2 = r2 * std::cos(theta2);
			
			// Add Cartesian coordinates
			Real x = x1 + x2;
			Real y = y1 + y2;
			Real z = z1 + z2;
			
			// Convert back to spherical coordinates
			Real r = std::sqrt(x * x + y * y + z * z);
			if (r == 0.0)
				return Vector3Spherical(0.0, 0.0, 0.0);
			Real theta = std::acos(z / r);
			Real phi = std::atan2(y, x);
			
			return Vector3Spherical(r, theta, phi);
		}
		Vector3Spherical operator-(const Vector3Spherical& b) const
		{
			Real r1 = R();
			Real theta1 = Theta();
			Real phi1 = Phi();
			Real r2 = b.R();
			Real theta2 = b.Theta();
			Real phi2 = b.Phi();
			// Convert spherical to Cartesian coordinates
			Real x1 = r1 * std::sin(theta1) * std::cos(phi1);
			Real y1 = r1 * std::sin(theta1) * std::sin(phi1);
			Real z1 = r1 * std::cos(theta1);
			Real x2 = r2 * std::sin(theta2) * std::cos(phi2);
			Real y2 = r2 * std::sin(theta2) * std::sin(phi2);
			Real z2 = r2 * std::cos(theta2);
			// Subtract Cartesian coordinates
			Real x = x1 - x2;
			Real y = y1 - y2;
			Real z = z1 - z2;
			// Convert back to spherical coordinates
			Real r = std::sqrt(x * x + y * y + z * z);
			if (r == 0.0)
				return Vector3Spherical(0.0, 0.0, 0.0);
			Real theta = std::acos(z / r);
			Real phi = std::atan2(y, x);
			return Vector3Spherical(r, theta, phi);
		}

		Vector3Spherical operator*(Real b) const
		{
			return Vector3Spherical(R() * b, Theta(), Phi());
		}
		Vector3Spherical operator/(Real b) const
		{
			if (b == 0.0)
				throw std::runtime_error("Division by zero in Vector3Spherical division.");
			return Vector3Spherical(R() / b, Theta(), Phi());
		}
		friend Vector3Spherical operator*(Real a, const Vector3Spherical& b)
		{
			return Vector3Spherical(b.R() * a, b.Theta(), b.Phi());
		}

		// equality operators
		bool operator==(const Vector3Spherical& b) const
		{
			return (R() == b.R()) && (Theta() == b.Theta()) && (Phi() == b.Phi());
		}
		bool operator!=(const Vector3Spherical& b) const
		{
			return (R() != b.R()) || (Theta() != b.Theta()) || (Phi() != b.Phi());
		}
		bool IsEqual(const Vector3Spherical& b, Real absEps = Defaults::Vec3SphIsEqualTolerance) const
		{
			return (std::abs(R() - b.R()) < absEps) && (std::abs(Theta() - b.Theta()) < absEps) && (std::abs(Phi() - b.Phi()) < absEps);
		}
		
		// for spherical vector with, with components defined in local spherical coordinate system
		// at given positon 'pos', returns the same vector but with unit length
		// and result is in spherical coordinates
		Vector3Spherical GetAsUnitVectorAtPosGlobalSpher(const Vector3Spherical& pos) const
		{
			// Convert this vector to Cartesian (as a displacement from the origin)
			Real r = R();
			Real theta = Theta();
			Real phi = Phi();

			// Spherical to Cartesian (displacement from origin)
			Real x = r * std::sin(theta) * std::cos(phi);
			Real y = r * std::sin(theta) * std::sin(phi);
			Real z = r * std::cos(theta);

			// Now, express this vector in the local spherical basis at 'pos'
			// The local basis at 'pos' consists of:
			//   e_r     = [sinÎ¸ cosÏ†, sinÎ¸ sinÏ†, cosÎ¸]
			//   e_theta = [cosÎ¸ cosÏ†, cosÎ¸ sinÏ†, -sinÎ¸]
			//   e_phi   = [-sinÏ†, cosÏ†, 0]
			// at the position (pos.Theta(), pos.Phi())

			Real st = std::sin(pos.Theta());
			Real ct = std::cos(pos.Theta());
			Real sp = std::sin(pos.Phi());
			Real cp = std::cos(pos.Phi());

			// Local basis vectors at pos (expressed in Cartesian coordinates)
			Real e_r[3] = { st * cp, st * sp, ct };
			Real e_theta[3] = { ct * cp, ct * sp, -st };
			Real e_phi[3] = { -sp,   cp,    0 };

			// Project (x, y, z) onto the local basis at pos
			Real v_r = x * e_r[0] + y * e_r[1] + z * e_r[2];
			Real v_theta = x * e_theta[0] + y * e_theta[1] + z * e_theta[2];
			Real v_phi = x * e_phi[0] + y * e_phi[1] + z * e_phi[2];

			// Normalize
			Real norm = std::sqrt(v_r * v_r + v_theta * v_theta + v_phi * v_phi);
			if (norm == 0.0)
				return Vector3Spherical(0.0, 0.0, 0.0);

			return Vector3Spherical(1.0, std::acos(v_r / norm), std::atan2(v_phi, v_theta));
		}
		// for spherical vector with, with components defined in local spherical coordinate system
		// at given positon 'pos', returns the same vector but with unit length
		// and result is in local spherical basis at 'pos'
		Vector3Spherical GetAsUnitVectorAtPos(const Vector3Spherical& pos) const
		{
			// Step 1: Convert *this to Cartesian (as a displacement from the origin)
			Real r = R();
			Real theta = Theta();
			Real phi = Phi();

			Real x = r * std::sin(theta) * std::cos(phi);
			Real y = r * std::sin(theta) * std::sin(phi);
			Real z = r * std::cos(theta);

			// Step 2: Compute local spherical basis at pos
			Real st = std::sin(pos.Theta());
			Real ct = std::cos(pos.Theta());
			Real sp = std::sin(pos.Phi());
			Real cp = std::cos(pos.Phi());

			// Local basis vectors at pos
			Real e_r[3] = { st * cp, st * sp, ct };
			Real e_theta[3] = { ct * cp, ct * sp, -st };
			Real e_phi[3] = { -sp,   cp,    0 };

			// Step 3: Project (x, y, z) onto the local basis at pos
			Real v_r = x * e_r[0] + y * e_r[1] + z * e_r[2];
			Real v_theta = x * e_theta[0] + y * e_theta[1] + z * e_theta[2];
			Real v_phi = x * e_phi[0] + y * e_phi[1] + z * e_phi[2];

			// Step 4: Normalize
			Real norm = std::sqrt(v_r * v_r + v_theta * v_theta + v_phi * v_phi);
			if (norm == 0.0)
				return Vector3Spherical(0.0, 0.0, 0.0);

			return Vector3Spherical(v_r / norm, v_theta / norm, v_phi / norm);
		}

		std::ostream& PrintDeg(std::ostream& stream, int width, int precision) const
		{
			stream << "[ ";
			stream << std::fixed << std::setw(width) << std::setprecision(precision);
			stream << R();
			stream << ", " << Theta() * 180.0 / Constants::PI;
			stream << ", " << Phi() * 180.0 / Constants::PI << " ]" << std::endl;

			return stream;
		}
	};

	class Vector3Cylindrical : public VectorN<Real, 3>
	{
	public:
		Real  R()   const { return _val[0]; }
		Real& R()					{ return _val[0]; }
		Real  Phi() const { return _val[1]; }
		Real& Phi()				{ return _val[1]; }
		Real  Z()   const { return _val[2]; }
		Real& Z()					{ return _val[2]; }

		Vector3Cylindrical() : VectorN<Real, 3>{ 0.0, 0.0, 0.0 } {}
		Vector3Cylindrical(const VectorN<Real, 3>& b) : VectorN<Real, 3>{ b[0], b[1], b[2] } {}
		Vector3Cylindrical(Real r, Real phi, Real z) : VectorN<Real, 3>{ r, phi, z } {}
		Vector3Cylindrical(std::initializer_list<Real> list) : VectorN<Real, 3>(list) { }

		// unary minus operator
		Vector3Cylindrical operator-() const
		{
			return Vector3Cylindrical(R(), Phi() + Constants::PI, Z());
		}

		// arithmetic operations
		Vector3Cylindrical operator+(const Vector3Cylindrical& b) const
		{
			Real r1 = R();
			Real phi1 = Phi();
			Real z1 = Z();
			Real r2 = b.R();
			Real phi2 = b.Phi();
			Real z2 = b.Z();
			// Convert cylindrical to Cartesian coordinates
			Real x1 = r1 * std::cos(phi1);
			Real y1 = r1 * std::sin(phi1);
			Real x2 = r2 * std::cos(phi2);
			Real y2 = r2 * std::sin(phi2);
			// Add Cartesian coordinates
			Real x = x1 + x2;
			Real y = y1 + y2;
			Real z = z1 + z2;
			// Convert back to cylindrical coordinates
			Real r = std::sqrt(x * x + y * y);
			if (r == 0.0)
				return Vector3Cylindrical(0.0, 0.0, z);
			Real phi = std::atan2(y, x);
			return Vector3Cylindrical(r, phi, z);
		}
		Vector3Cylindrical operator-(const Vector3Cylindrical& b) const
		{
			Real r1 = R();
			Real phi1 = Phi();
			Real z1 = Z();
			Real r2 = b.R();
			Real phi2 = b.Phi();
			Real z2 = b.Z();
			// Convert cylindrical to Cartesian coordinates
			Real x1 = r1 * std::cos(phi1);
			Real y1 = r1 * std::sin(phi1);
			Real x2 = r2 * std::cos(phi2);
			Real y2 = r2 * std::sin(phi2);
			// Subtract Cartesian coordinates
			Real x = x1 - x2;
			Real y = y1 - y2;
			Real z = z1 - z2;
			// Convert back to cylindrical coordinates
			Real r = std::sqrt(x * x + y * y);
			if (r == 0.0)
				return Vector3Cylindrical(0.0, 0.0, z);
			Real phi = std::atan2(y, x);
			return Vector3Cylindrical(r, phi, z);
		}

		Vector3Cylindrical operator*(Real b) const
		{
			return Vector3Cylindrical(R() * b, Phi(), Z() * b);
		}
		Vector3Cylindrical operator/(Real b) const
		{
			if (b == 0.0)
				throw std::runtime_error("Division by zero in Vector3Cylindrical division.");
			return Vector3Cylindrical(R() / b, Phi(), Z() / b);
		}
		friend Vector3Cylindrical operator*(Real a, const Vector3Cylindrical& b)
		{
			return Vector3Cylindrical(b.R() * a, b.Phi(), b.Z() * a);
		}

		Vector3Cylindrical GetAsUnitVectorAtPos(const Vector3Cylindrical& pos) const
		{
			return Vector3Cylindrical{ R(), Phi() / pos.R(), Z() };
		}
	};

	class Vector4Minkowski : public VectorN<Real, 4>
	{
	public:
		Real  T() const { return _val[0]; }
		Real& T()				{ return _val[0]; }
		Real  X() const { return _val[1]; }
		Real& X()				{ return _val[1]; }
		Real  Y() const { return _val[2]; }
		Real& Y()				{ return _val[2]; }
		Real  Z() const { return _val[3]; }
		Real& Z()				{ return _val[3]; }

		Vector4Minkowski() : VectorN<Real, 4>{ 0.0, 0.0, 0.0, 0.0 } {}
		Vector4Minkowski(std::initializer_list<Real> list) : VectorN<Real, 4>(list) { }

		friend Real ScalarProduct(const Vector4Minkowski& a, const Vector4Minkowski& b)
		{
			return a.T() * b.T() - a.X() * b.X() - a.Y() * b.Y() - a.Z() * b.Z();
		}

		Real Norm() const
		{
			if(T() == 0.0 && X() == 0.0 && Y() == 0.0 && Z() == 0.0)
				return 0.0;

			// Minkowski norm: sqrt(T^2 - X^2 - Y^2 - Z^2)
			if (isTimelike())
				return sqrt(T() * T() - X() * X() - Y() * Y() - Z() * Z());
			else if (isSpacelike())
				return -sqrt(X() * X() + Y() * Y() + Z() * Z() - T() * T());
			else 
				return 0.0; // Lightlike vectors have zero Minkowski norm
		}

		Real Distance(const Vector4Minkowski& b) const
		{
			return sqrt((T() - b.T()) * (T() - b.T()) - (X() - b.X()) * (X() - b.X()) -
									(Y() - b.Y()) * (Y() - b.Y()) - (Z() - b.Z()) * (Z() - b.Z()));
		}
		
		bool isTimelike() const
		{
			return (-T() * T() + X() * X() + Y() * Y() + Z() * Z()) < 0;
		}
		bool isSpacelike() const
		{
			return (-T() * T() + X() * X() + Y() * Y() + Z() * Z()) > 0;
		}
		bool isLightlike() const
		{
			return (T() * T() - X() * X() - Y() * Y() - Z() * Z()) == 0;
		}
	};

	typedef Vector2Cartesian    Vec2Cart;
	typedef Vector2Polar				Vec2Pol;
	typedef Vector3Cartesian    Vec3Cart;
	typedef Vector3Spherical    Vec3Sph;
	typedef Vector3Cylindrical  Vec3Cyl;
	typedef Vector4Minkowski    Vec4Mink;
}

///////////////////////////   mml/base/Matrix.h   ///////////////////////////



namespace MML
{
	// Forward declarations
	template<class Type> class Matrix;
	template<class Type> class MatrixViewNew;

	///////////////////////////////////////////////////////////////////////////////////////////
	///                               MatrixViewNew - Lightweight view                       ///
	///////////////////////////////////////////////////////////////////////////////////////////
	template<class Type>
	class MatrixViewNew {
		Type* _data;
		int _rows, _cols, _stride;
	public:
		MatrixViewNew(Type* data, int rows, int cols, int stride)
			: _data(data), _rows(rows), _cols(cols), _stride(stride) {}

		// Element access (row-major with stride)
		Type& operator()(int i, int j) { return _data[i * _stride + j]; }
		const Type& operator()(int i, int j) const { return _data[i * _stride + j]; }

		int RowNum() const { return _rows; }
		int ColNum() const { return _cols; }
	};

	///////////////////////////////////////////////////////////////////////////////////////////
	///                                      Matrix                                       ///
	///   Modern Matrix implementation using contiguous std::vector storage (row-major)      ///
	///                                                                                       ///
	///   Key improvements over legacy Matrix:                                               ///
	///   - std::vector for automatic memory management (RAII)                               ///
	///   - Exception-safe (no manual new/delete)                                            ///
	///   - Better cache locality (flat storage vs Type**)                                   ///
	///   - Move semantics automatic and efficient                                           ///
	///   - Compatible interface for drop-in replacement                                     ///
	///////////////////////////////////////////////////////////////////////////////////////////
	template<class Type>
	class Matrix
	{
	private:
		// Allocation safety limits
		static constexpr int MAX_DIMENSION = 100000;
		static constexpr size_t MAX_ELEMENTS = 100000000;  // ~800MB for doubles

		int _rows;
		int _cols;
		std::vector<Type> _data;  // Flat row-major storage

		// Index calculation (row-major)
		inline size_t idx(int i, int j) const { return static_cast<size_t>(i) * _cols + j; }

		// Validate dimensions for allocation
		void ValidateDimensions(int rows, int cols) const
		{
			if (rows < 0 || cols < 0)
				throw MatrixDimensionError("Matrix - dimensions cannot be negative", rows, cols, -1, -1);
			
			if (rows > MAX_DIMENSION || cols > MAX_DIMENSION)
				throw MatrixDimensionError("Matrix - dimensions exceed maximum limit", rows, cols, MAX_DIMENSION, MAX_DIMENSION);
			
			// Integer overflow protection
			size_t numElements = static_cast<size_t>(rows) * static_cast<size_t>(cols);
			if (cols > 0 && numElements / static_cast<size_t>(cols) != static_cast<size_t>(rows))
				throw std::overflow_error("Matrix - size calculation overflow");
			
			if (numElements > MAX_ELEMENTS)
				throw std::bad_alloc();
		}

		bool IsMatrixTypeComplex() const
		{
			return std::is_same_v<Type, std::complex<double>> ||
			       std::is_same_v<Type, std::complex<float>> ||
			       std::is_same_v<Type, std::complex<long double>>;
		}

	public:
		typedef Type value_type;

		///////////////////////          Constructors and destructor       //////////////////////
		
		// Default constructor - empty matrix
		Matrix() : _rows(0), _cols(0), _data() {}
		
		// Size constructor - zero-initialized for numeric types
		explicit Matrix(int rows, int cols) : _rows(rows), _cols(cols)
		{
			if (rows < 0 || cols < 0) {
				throw MatrixDimensionError("Matrix: negative dimensions not allowed");
			}
			if (rows == 0 || cols == 0) {
				_rows = 0;
				_cols = 0;
				return;
			}
			ValidateDimensions(rows, cols);
			
			if constexpr (is_MML_simple_numeric<Type>) {
				_data.resize(static_cast<size_t>(rows) * cols, Type{0});
			} else {
				_data.resize(static_cast<size_t>(rows) * cols);
			}
		}
		
		// Size + fill value constructor
		explicit Matrix(int rows, int cols, const Type& val) : _rows(rows), _cols(cols)
		{
			if (rows < 0 || cols < 0) {
				throw MatrixDimensionError("Matrix: negative dimensions not allowed");
			}
			if (rows == 0 || cols == 0) {
				_rows = 0;
				_cols = 0;
				return;
			}
			ValidateDimensions(rows, cols);
			_data.resize(static_cast<size_t>(rows) * cols, val);
		}
		
		// Constructor from std::vector<std::vector<Type>>
		explicit Matrix(const std::vector<std::vector<Type>>& values)
		{
			if (values.empty() || values[0].empty()) {
				_rows = 0;
				_cols = 0;
				return;
			}
			_rows = static_cast<int>(values.size());
			_cols = static_cast<int>(values[0].size());
			ValidateDimensions(_rows, _cols);
			
			_data.reserve(static_cast<size_t>(_rows) * _cols);
			for (int i = 0; i < _rows; ++i) {
				if (static_cast<int>(values[i].size()) != _cols)
					throw MatrixDimensionError("Matrix - inconsistent row sizes", _rows, _cols, i, static_cast<int>(values[i].size()));
				for (int j = 0; j < _cols; ++j)
					_data.push_back(values[i][j]);
			}
		}
		
		// Constructor from std::array<std::array<Type, Cols>, Rows>
		template <std::size_t Rows, std::size_t Cols>
		explicit Matrix(const std::array<std::array<Type, Cols>, Rows>& arr)
			: _rows(static_cast<int>(Rows)), _cols(static_cast<int>(Cols))
		{
			ValidateDimensions(_rows, _cols);
			_data.reserve(static_cast<size_t>(_rows) * _cols);
			for (size_t i = 0; i < Rows; ++i)
				for (size_t j = 0; j < Cols; ++j)
					_data.push_back(arr[i][j]);
		}
		
		// Constructor from pointer to continuous data
		explicit Matrix(int rows, int cols, Type* val, bool isRowWise = true)
			: _rows(rows), _cols(cols)
		{
			if (rows < 0 || cols < 0) {
				throw MatrixDimensionError("Matrix: negative dimensions not allowed");
			}
			if (rows == 0 || cols == 0) {
				_rows = 0;
				_cols = 0;
				return;
			}
			ValidateDimensions(rows, cols);
			_data.resize(static_cast<size_t>(rows) * cols);
			
			if (isRowWise) {
				std::copy(val, val + static_cast<size_t>(rows) * cols, _data.begin());
			} else {
				// Column-wise: need to transpose during copy
				for (int j = 0; j < cols; ++j)
					for (int i = 0; i < rows; ++i)
						_data[idx(i, j)] = *val++;
			}
		}
		
		// Constructor from initializer list (row-major)
		explicit Matrix(int rows, int cols, std::initializer_list<Type> values, bool strictMode = true)
			: _rows(rows), _cols(cols)
		{
			if (rows < 0 || cols < 0) {
				throw MatrixDimensionError("Matrix: negative dimensions not allowed");
			}
			if (rows == 0 || cols == 0) {
				_rows = 0;
				_cols = 0;
				return;
			}
			ValidateDimensions(rows, cols);
			
			size_t totalSize = static_cast<size_t>(rows) * cols;
			if (strictMode && values.size() != totalSize)
				throw MatrixDimensionError("Matrix - initializer list size mismatch", rows, cols, -1, -1);
			
			if constexpr (is_MML_simple_numeric<Type>) {
				_data.resize(totalSize, Type{0});
			} else {
				_data.resize(totalSize);
			}
			
			auto it = values.begin();
			for (size_t i = 0; i < totalSize && it != values.end(); ++i, ++it)
				_data[i] = *it;
		}
		
		// Copy constructor
		Matrix(const Matrix& m) = default;
		
		// Move constructor - explicitly reset source dimensions
		Matrix(Matrix&& m) noexcept 
			: _data(std::move(m._data)), _rows(m._rows), _cols(m._cols)
		{
			m._rows = 0;
			m._cols = 0;
		}
		
		// Submatrix constructor
		Matrix(const Matrix& m, int ind_row, int ind_col, int row_num, int col_num)
		{
			if (ind_row < 0 || ind_row >= m._rows || ind_col < 0 || ind_col >= m._cols)
				throw MatrixDimensionError("Matrix submatrix - invalid start indices", m._rows, m._cols, ind_row, ind_col);
			if (row_num <= 0 || col_num <= 0)
				throw MatrixDimensionError("Matrix submatrix - dimensions must be positive", row_num, col_num, -1, -1);
			if (ind_row + row_num > m._rows || ind_col + col_num > m._cols)
				throw MatrixDimensionError("Matrix submatrix - out of bounds", m._rows, m._cols, ind_row + row_num, ind_col + col_num);
			
			_rows = row_num;
			_cols = col_num;
			_data.reserve(static_cast<size_t>(row_num) * col_num);
			
			for (int i = 0; i < row_num; ++i)
				for (int j = 0; j < col_num; ++j)
					_data.push_back(m(ind_row + i, ind_col + j));
		}
		
		// Destructor - default is fine, std::vector handles cleanup
		~Matrix() = default;

		///////////////////////          Assignment operators              //////////////////////
		Matrix& operator=(const Matrix& m) = default;
		
		Matrix& operator=(Matrix&& m) noexcept
		{
			if (this != &m) {
				_data = std::move(m._data);
				_rows = m._rows;
				_cols = m._cols;
				m._rows = 0;
				m._cols = 0;
			}
			return *this;
		}

		///////////////////////              Resize operations             //////////////////////
		void Resize(int rows, int cols, bool preserveElements = false)
		{
			if (rows == _rows && cols == _cols)
				return;
			
			if (rows <= 0 || cols <= 0)
				throw MatrixDimensionError("Matrix::Resize - dimensions must be positive", rows, cols, -1, -1);
			
			ValidateDimensions(rows, cols);
			
			if (preserveElements) {
				std::vector<Type> newData(static_cast<size_t>(rows) * cols, Type{0});
				int minRows = std::min(_rows, rows);
				int minCols = std::min(_cols, cols);
				for (int i = 0; i < minRows; ++i)
					for (int j = 0; j < minCols; ++j)
						newData[static_cast<size_t>(i) * cols + j] = _data[idx(i, j)];
				_data = std::move(newData);
			} else {
				if constexpr (is_MML_simple_numeric<Type>) {
					_data.assign(static_cast<size_t>(rows) * cols, Type{0});
				} else {
					_data.resize(static_cast<size_t>(rows) * cols);
				}
			}
			_rows = rows;
			_cols = cols;
		}
		
		void MakeUnitMatrix()
		{
			if (_rows != _cols)
				throw MatrixDimensionError("Matrix::MakeUnitMatrix - must be square", _rows, _cols, -1, -1);
			
			std::fill(_data.begin(), _data.end(), Type{0});
			for (int i = 0; i < _rows; ++i)
				_data[idx(i, i)] = Type{1};
		}

		///////////////////////          Static factory methods            //////////////////////
		static Matrix GetUnitMatrix(int dim)
		{
			if (dim <= 0)
				throw MatrixDimensionError("Matrix::GetUnitMatrix - dimension must be positive", dim, dim, -1, -1);
			
			Matrix mat(dim, dim);
			mat.MakeUnitMatrix();
			return mat;
		}
		
		static Matrix GetDiagonalMatrix(const Vector<Type>& diagValues)
		{
			int n = diagValues.size();
			if (n <= 0)
				throw MatrixDimensionError("Matrix::GetDiagonalMatrix - vector size must be positive", n, n, -1, -1);
			
			Matrix mat(n, n);
			for (int i = 0; i < n; ++i)
				mat(i, i) = diagValues[i];
			return mat;
		}

		///////////////////////              Standard stuff                //////////////////////
		inline int RowNum() const { return _rows; }
		inline int ColNum() const { return _cols; }
		inline bool IsEmpty() const { return _rows == 0 || _cols == 0; }
		
		// Direct access to underlying data (for algorithms that need it)
		Type* data() { return _data.data(); }
		const Type* data() const { return _data.data(); }

		///////////////////////          Vector extraction                 //////////////////////
		Vector<Type> VectorFromRow(int rowInd) const
		{
			if (rowInd < 0 || rowInd >= _rows)
				throw MatrixAccessBoundsError("VectorFromRow - invalid row index", rowInd, 0, _rows, _cols);
			
			Vector<Type> ret(_cols);
			for (int j = 0; j < _cols; ++j)
				ret[j] = (*this)(rowInd, j);
			return ret;
		}
		
		Vector<Type> VectorFromColumn(int colInd) const
		{
			if (colInd < 0 || colInd >= _cols)
				throw MatrixAccessBoundsError("VectorFromColumn - invalid column index", 0, colInd, _rows, _cols);
			
			Vector<Type> ret(_rows);
			for (int i = 0; i < _rows; ++i)
				ret[i] = (*this)(i, colInd);
			return ret;
		}
		
		Vector<Type> VectorFromDiagonal() const
		{
			if (_rows != _cols)
				throw MatrixDimensionError("VectorFromDiagonal - must be square", _rows, _cols, -1, -1);
			
			Vector<Type> ret(_rows);
			for (int i = 0; i < _rows; ++i)
				ret[i] = (*this)(i, i);
			return ret;
		}
		
		Vector<Type> GetDiagonal() const { return VectorFromDiagonal(); }

		///////////////////////          Matrix extraction                 //////////////////////
		Matrix GetLower(bool includeDiagonal = true) const
		{
			if (_rows != _cols)
				throw MatrixDimensionError("Matrix::GetLower - must be square", _rows, _cols, -1, -1);
			
			Matrix ret(_rows, _cols);
			for (int i = 0; i < _rows; ++i) {
				int jEnd = includeDiagonal ? i + 1 : i;
				for (int j = 0; j < jEnd; ++j)
					ret(i, j) = (*this)(i, j);
			}
			return ret;
		}
		
		Matrix GetUpper(bool includeDiagonal = true) const
		{
			if (_rows != _cols)
				throw MatrixDimensionError("Matrix::GetUpper - must be square", _rows, _cols, -1, -1);
			
			Matrix ret(_rows, _cols);
			for (int i = 0; i < _rows; ++i) {
				int jStart = includeDiagonal ? i : i + 1;
				for (int j = jStart; j < _cols; ++j)
					ret(i, j) = (*this)(i, j);
			}
			return ret;
		}
		
		Matrix GetSubmatrix(int start_row, int start_col, int row_num, int col_num) const
		{
			return Matrix(*this, start_row, start_col, row_num, col_num);
		}

		///////////////////////          Row/column operations             //////////////////////
		void InitRowWithVector(int rowInd, const Vector<Type>& vec)
		{
			if (rowInd < 0 || rowInd >= _rows)
				throw MatrixAccessBoundsError("InitRowWithVector - invalid row index", rowInd, 0, _rows, _cols);
			if (vec.size() != _cols)
				throw MatrixDimensionError("InitRowWithVector - vector size must match columns", _rows, _cols, vec.size(), -1);
			
			for (int j = 0; j < _cols; ++j)
				_data[idx(rowInd, j)] = vec[j];
		}
		
		void InitColWithVector(int colInd, const Vector<Type>& vec)
		{
			if (colInd < 0 || colInd >= _cols)
				throw MatrixAccessBoundsError("InitColWithVector - invalid column index", 0, colInd, _rows, _cols);
			if (vec.size() != _rows)
				throw MatrixDimensionError("InitColWithVector - vector size must match rows", _rows, _cols, vec.size(), -1);
			
			for (int i = 0; i < _rows; ++i)
				_data[idx(i, colInd)] = vec[i];
		}
		
		void SwapRows(int k, int l)
		{
			if (k < 0 || k >= _rows || l < 0 || l >= _rows)
				throw MatrixDimensionError("Matrix::SwapRows - invalid row index", _rows, _cols, k, l);
			if (k == l) return;
			
			for (int j = 0; j < _cols; ++j)
				std::swap(_data[idx(k, j)], _data[idx(l, j)]);
		}
		
		void SwapCols(int k, int l)
		{
			if (k < 0 || k >= _cols || l < 0 || l >= _cols)
				throw MatrixDimensionError("Matrix::SwapCols - invalid column index", _rows, _cols, k, l);
			if (k == l) return;
			
			for (int i = 0; i < _rows; ++i)
				std::swap(_data[idx(i, k)], _data[idx(i, l)]);
		}

		///////////////////////              Creating views                //////////////////////
		MatrixViewNew<Type> block(int startRow, int startCol, int numRows, int numCols)
		{
			if (startRow < 0 || startCol < 0 || numRows <= 0 || numCols <= 0 ||
			    startRow + numRows > _rows || startCol + numCols > _cols)
				throw MatrixDimensionError("Matrix::block - invalid parameters", _rows, _cols, startRow, startCol);
			return MatrixViewNew<Type>(&_data[idx(startRow, startCol)], numRows, numCols, _cols);
		}
		
		const MatrixViewNew<Type> block(int startRow, int startCol, int numRows, int numCols) const
		{
			if (startRow < 0 || startCol < 0 || numRows <= 0 || numCols <= 0 ||
			    startRow + numRows > _rows || startCol + numCols > _cols)
				throw MatrixDimensionError("Matrix::block - invalid parameters", _rows, _cols, startRow, startCol);
			return MatrixViewNew<Type>(const_cast<Type*>(&_data[idx(startRow, startCol)]), numRows, numCols, _cols);
		}

		///////////////////////               Matrix properties            //////////////////////
		bool IsUnit(double eps = Defaults::IsMatrixUnitTolerance) const
		{
			if (_rows != _cols) return false;
			
			for (int i = 0; i < _rows; ++i) {
				for (int j = 0; j < _cols; ++j) {
					if (i == j) {
						if (Abs((*this)(i, j) - Type{1}) > eps) return false;
					} else {
						if (Abs((*this)(i, j)) > eps) return false;
					}
				}
			}
			return true;
		}
		
		bool IsDiagonal(double eps = Defaults::IsMatrixDiagonalTolerance) const
		{
			for (int i = 0; i < _rows; ++i)
				for (int j = 0; j < _cols; ++j)
					if (i != j && Abs((*this)(i, j)) > eps)
						return false;
			return true;
		}
		
		bool IsDiagDominant() const
		{
			for (int i = 0; i < _rows; ++i) {
				Type sum{0};
				for (int j = 0; j < _cols; ++j)
					if (i != j)
						sum += Abs((*this)(i, j));
				if (Abs((*this)(i, i)) < sum)
					return false;
			}
			return true;
		}
		
		bool IsSymmetric() const
		{
			if (_rows != _cols) return false;
			
			for (int i = 0; i < _rows; ++i)
				for (int j = i + 1; j < _cols; ++j)
					if ((*this)(i, j) != (*this)(j, i))
						return false;
			return true;
		}
		
		bool IsAntiSymmetric() const
		{
			if (_rows != _cols) return false;
			
			for (int i = 0; i < _rows; ++i) {
				for (int j = i + 1; j < _cols; ++j) {
					if (IsMatrixTypeComplex()) {
						if ((*this)(i, j) != -std::conj((*this)(j, i)))
							return false;
					} else {
						if ((*this)(i, j) != -(*this)(j, i))
							return false;
					}
				}
			}
			return true;
		}

		///////////////////////             Matrix norm calculations       //////////////////////
		Real NormL1() const
		{
			Real norm{0};
			for (const auto& elem : _data)
				norm += Abs(elem);
			return norm;
		}
		
		Real NormL2() const
		{
			Real norm{0};
			for (const auto& elem : _data)
				norm += elem * elem;
			return std::sqrt(norm);
		}
		
		Real NormLInf() const
		{
			Real norm{0};
			for (const auto& elem : _data)
				norm = std::max(norm, static_cast<Real>(Abs(elem)));
			return norm;
		}

		///////////////////////               Access operators             //////////////////////
		
		// Primary access: operator() - checked bounds in debug, unchecked in release
		inline Type  operator()(int i, int j) const { return _data[idx(i, j)]; }
		inline Type& operator()(int i, int j)       { return _data[idx(i, j)]; }
		
		// Legacy compatibility: operator[] returns pointer to row start
		// This maintains compatibility with code using mat[i][j] syntax
		inline Type* operator[](int i)             { return &_data[idx(i, 0)]; }
		inline const Type* operator[](int i) const { return &_data[idx(i, 0)]; }
		
		// Checked access
		Type at(int i, int j) const
		{
			if (i < 0 || i >= _rows || j < 0 || j >= _cols)
				throw MatrixAccessBoundsError("Matrix::at", i, j, _rows, _cols);
			return _data[idx(i, j)];
		}
		
		Type& at(int i, int j)
		{
			if (i < 0 || i >= _rows || j < 0 || j >= _cols)
				throw MatrixAccessBoundsError("Matrix::at", i, j, _rows, _cols);
			return _data[idx(i, j)];
		}

		///////////////////////             Iterator support               //////////////////////
		
		// Flat iterators - traverse all elements in row-major order
		auto begin()        { return _data.begin(); }
		auto end()          { return _data.end(); }
		auto begin() const  { return _data.begin(); }
		auto end() const    { return _data.end(); }
		auto cbegin() const { return _data.cbegin(); }
		auto cend() const   { return _data.cend(); }

		// Row iterator proxy
		class row_range {
			Type* _ptr;
			int _cols;
		public:
			row_range(Type* ptr, int cols) : _ptr(ptr), _cols(cols) {}
			Type* begin() { return _ptr; }
			Type* end()   { return _ptr + _cols; }
		};
		
		class const_row_range {
			const Type* _ptr;
			int _cols;
		public:
			const_row_range(const Type* ptr, int cols) : _ptr(ptr), _cols(cols) {}
			const Type* begin() const { return _ptr; }
			const Type* end() const   { return _ptr + _cols; }
		};
		
		row_range row(int i)
		{
			if (i < 0 || i >= _rows)
				throw MatrixAccessBoundsError("Matrix::row", i, 0, _rows, _cols);
			return row_range(&_data[idx(i, 0)], _cols);
		}
		
		const_row_range row(int i) const
		{
			if (i < 0 || i >= _rows)
				throw MatrixAccessBoundsError("Matrix::row", i, 0, _rows, _cols);
			return const_row_range(&_data[idx(i, 0)], _cols);
		}

		// Column iterator (strided)
		class col_iterator {
			Type* _ptr;
			int _stride;
		public:
			using iterator_category = std::forward_iterator_tag;
			using value_type = Type;
			using difference_type = std::ptrdiff_t;
			using pointer = Type*;
			using reference = Type&;

			col_iterator(Type* ptr, int stride) : _ptr(ptr), _stride(stride) {}
			col_iterator& operator++() { _ptr += _stride; return *this; }
			col_iterator operator++(int) { auto tmp = *this; _ptr += _stride; return tmp; }
			bool operator==(const col_iterator& other) const { return _ptr == other._ptr; }
			bool operator!=(const col_iterator& other) const { return _ptr != other._ptr; }
			Type& operator*() { return *_ptr; }
		};
		
		class col_range {
			Type* _ptr;
			int _rows, _stride;
		public:
			col_range(Type* ptr, int rows, int stride) : _ptr(ptr), _rows(rows), _stride(stride) {}
			col_iterator begin() { return col_iterator(_ptr, _stride); }
			col_iterator end()   { return col_iterator(_ptr + _rows * _stride, _stride); }
		};
		
		col_range col(int j)
		{
			if (j < 0 || j >= _cols)
				throw MatrixAccessBoundsError("Matrix::col", 0, j, _rows, _cols);
			return col_range(&_data[j], _rows, _cols);
		}

		///////////////////////              Equality operations           //////////////////////
		bool operator==(const Matrix& b) const
		{
			if (_rows != b._rows || _cols != b._cols)
				return false;
			return _data == b._data;
		}
		
		bool operator!=(const Matrix& b) const { return !(*this == b); }
		
		bool IsEqualTo(const Matrix& b, Type eps = Defaults::MatrixIsEqualTolerance) const
		{
			if (_rows != b._rows || _cols != b._cols)
				return false;
			
			for (size_t i = 0; i < _data.size(); ++i)
				if (Abs(_data[i] - b._data[i]) > eps)
					return false;
			return true;
		}
		
		static bool AreEqual(const Matrix& a, const Matrix& b, Type eps = Defaults::MatrixIsEqualTolerance)
		{
			return a.IsEqualTo(b, eps);
		}

		///////////////////////              Arithmetic operators          //////////////////////
		
		// Unary minus
		Matrix operator-() const
		{
			Matrix ret(_rows, _cols);
			for (size_t i = 0; i < _data.size(); ++i)
				ret._data[i] = -_data[i];
			return ret;
		}
		
		// Matrix + Matrix
		Matrix operator+(const Matrix& b) const
		{
			if (_rows != b._rows || _cols != b._cols)
				throw MatrixDimensionError("Matrix::operator+ - dimensions must match", _rows, _cols, b._rows, b._cols);
			
			Matrix ret(_rows, _cols);
			for (size_t i = 0; i < _data.size(); ++i)
				ret._data[i] = _data[i] + b._data[i];
			return ret;
		}
		
		Matrix& operator+=(const Matrix& b)
		{
			if (_rows != b._rows || _cols != b._cols)
				throw MatrixDimensionError("Matrix::operator+= - dimensions must match", _rows, _cols, b._rows, b._cols);
			
			for (size_t i = 0; i < _data.size(); ++i)
				_data[i] += b._data[i];
			return *this;
		}
		
		// Matrix - Matrix
		Matrix operator-(const Matrix& b) const
		{
			if (_rows != b._rows || _cols != b._cols)
				throw MatrixDimensionError("Matrix::operator- - dimensions must match", _rows, _cols, b._rows, b._cols);
			
			Matrix ret(_rows, _cols);
			for (size_t i = 0; i < _data.size(); ++i)
				ret._data[i] = _data[i] - b._data[i];
			return ret;
		}
		
		Matrix& operator-=(const Matrix& b)
		{
			if (_rows != b._rows || _cols != b._cols)
				throw MatrixDimensionError("Matrix::operator-= - dimensions must match", _rows, _cols, b._rows, b._cols);
			
			for (size_t i = 0; i < _data.size(); ++i)
				_data[i] -= b._data[i];
			return *this;
		}
		
		// Matrix * Matrix
		Matrix operator*(const Matrix& b) const
		{
			if (_cols != b._rows)
				throw MatrixDimensionError("Matrix::operator* - a.cols must equal b.rows", _rows, _cols, b._rows, b._cols);
			
			Matrix ret(_rows, b._cols);
			for (int i = 0; i < _rows; ++i) {
				for (int j = 0; j < b._cols; ++j) {
					Type sum{0};
					for (int k = 0; k < _cols; ++k)
						sum += (*this)(i, k) * b(k, j);
					ret(i, j) = sum;
				}
			}
			return ret;
		}
		
		// Matrix * scalar
		Matrix operator*(const Type& scalar) const
		{
			Matrix ret(_rows, _cols);
			for (size_t i = 0; i < _data.size(); ++i)
				ret._data[i] = _data[i] * scalar;
			return ret;
		}
		
		Matrix& operator*=(const Type& scalar)
		{
			for (auto& elem : _data)
				elem *= scalar;
			return *this;
		}
		
		// Matrix / scalar
		Matrix operator/(const Type& scalar) const
		{
			Matrix ret(_rows, _cols);
			for (size_t i = 0; i < _data.size(); ++i)
				ret._data[i] = _data[i] / scalar;
			return ret;
		}
		
		Matrix& operator/=(const Type& scalar)
		{
			for (auto& elem : _data)
				elem /= scalar;
			return *this;
		}
		
		// Matrix * Vector
		Vector<Type> operator*(const Vector<Type>& v) const
		{
			if (_cols != v.size())
				throw MatrixDimensionError("Matrix * Vector - cols must equal vector size", _rows, _cols, v.size(), -1);
			
			Vector<Type> ret(_rows);
			for (int i = 0; i < _rows; ++i) {
				Type sum{0};
				for (int j = 0; j < _cols; ++j)
					sum += (*this)(i, j) * v[j];
				ret[i] = sum;
			}
			return ret;
		}
		
		// Scalar * Matrix (friend)
		friend Matrix operator*(const Type& scalar, const Matrix& m)
		{
			return m * scalar;
		}
		
		// Vector * Matrix (friend)
		friend Vector<Type> operator*(const Vector<Type>& v, const Matrix& m)
		{
			if (v.size() != m._rows)
				throw MatrixDimensionError("Vector * Matrix - vector size must equal rows", v.size(), -1, m._rows, m._cols);
			
			Vector<Type> ret(m._cols);
			for (int j = 0; j < m._cols; ++j) {
				Type sum{0};
				for (int i = 0; i < m._rows; ++i)
					sum += v[i] * m(i, j);
				ret[j] = sum;
			}
			return ret;
		}

		///////////////////////            Trace, Inverse & Transpose      //////////////////////
		Type Trace() const
		{
			if (_rows != _cols)
				throw MatrixDimensionError("Matrix::Trace - must be square", _rows, _cols, -1, -1);
			
			Type sum{0};
			for (int i = 0; i < _rows; ++i)
				sum += (*this)(i, i);
			return sum;
		}
		
		void Invert()
		{
			if (_rows != _cols)
				throw MatrixDimensionError("Matrix::Invert - must be square", _rows, _cols, -1, -1);
			
			// Gauss-Jordan elimination with pivoting
			int n = _rows;
			Matrix& a = *this;
			std::vector<int> indxc(n), indxr(n), ipiv(n, 0);
			
			for (int i = 0; i < n; ++i) {
				Real big{0};
				int irow = 0, icol = 0;
				
				// Find pivot
				for (int j = 0; j < n; ++j) {
					if (ipiv[j] != 1) {
						for (int k = 0; k < n; ++k) {
							if (ipiv[k] == 0) {
								if (Abs(a(j, k)) >= big) {
									big = Abs(a(j, k));
									irow = j;
									icol = k;
								}
							}
						}
					}
				}
				++ipiv[icol];
				
				// Swap rows if needed
				if (irow != icol) {
					for (int l = 0; l < n; ++l)
						std::swap(a(irow, l), a(icol, l));
				}
				
				indxr[i] = irow;
				indxc[i] = icol;
				
				if (a(icol, icol) == Type{0})
					throw SingularMatrixError("Matrix::Invert - Singular Matrix");
				
				Type pivinv = Type{1} / a(icol, icol);
				a(icol, icol) = Type{1};
				for (int l = 0; l < n; ++l)
					a(icol, l) *= pivinv;
				
				for (int ll = 0; ll < n; ++ll) {
					if (ll != icol) {
						Type dum = a(ll, icol);
						a(ll, icol) = Type{0};
						for (int l = 0; l < n; ++l)
							a(ll, l) -= a(icol, l) * dum;
					}
				}
			}
			
			// Unscramble columns
			for (int l = n - 1; l >= 0; --l) {
				if (indxr[l] != indxc[l]) {
					for (int k = 0; k < n; ++k)
						std::swap(a(k, indxr[l]), a(k, indxc[l]));
				}
			}
		}
		
		Matrix GetInverse() const
		{
			Matrix ret(*this);
			ret.Invert();
			return ret;
		}
		
		void Transpose()
		{
			if (_rows != _cols)
				throw MatrixDimensionError("Matrix::Transpose - in-place requires square matrix", _rows, _cols, -1, -1);
			
			for (int i = 0; i < _rows; ++i)
				for (int j = i + 1; j < _cols; ++j)
					std::swap(_data[idx(i, j)], _data[idx(j, i)]);
		}
		
		Matrix GetTranspose() const
		{
			Matrix ret(_cols, _rows);
			for (int i = 0; i < _rows; ++i)
				for (int j = 0; j < _cols; ++j)
					ret(j, i) = (*this)(i, j);
			return ret;
		}

		///////////////////////                    I/O                    //////////////////////
		void Print(std::ostream& stream, const MatrixPrintFormat& fmt = MatrixPrintFormat::Default()) const
		{
			if (IsEmpty()) {
				if (fmt.showHeader)
					stream << "Rows: " << _rows << " Cols: " << _cols << " - Empty matrix" << std::endl;
				return;
			}

			if (fmt.showHeader)
				stream << "Rows: " << _rows << " Cols: " << _cols << std::endl;

			std::ios_base::fmtflags oldFlags = stream.flags();
			if (fmt.scientific)
				stream << std::scientific;
			else if (fmt.fixed)
				stream << std::fixed;

			for (int i = 0; i < _rows; ++i) {
				if (fmt.showBrackets) stream << "[ ";
				for (int j = 0; j < _cols; ++j) {
					stream << std::setw(fmt.width) << std::setprecision(fmt.precision) << (*this)(i, j);
					if (j < _cols - 1) stream << fmt.delimiter;
				}
				if (fmt.showBrackets) stream << " ]";
				if (i < _rows - 1) stream << std::endl;
			}
			
			stream.flags(oldFlags);
		}
		
		void Print(std::ostream& stream, int width, int precision) const
		{
			MatrixPrintFormat fmt = MatrixPrintFormat::Default();
			fmt.width = width;
			fmt.precision = precision;
			fmt.fixed = false;
			Print(stream, fmt);
		}
		
		// Print with zero threshold - values below threshold printed as 0
		void Print(std::ostream& stream, int width, int precision, Real threshold) const
		{
			// Create a temporary copy with thresholded values
			Matrix<Type> temp(*this);
			if constexpr (is_MML_simple_numeric<Type>) {
				for (int i = 0; i < _rows; ++i) {
					for (int j = 0; j < _cols; ++j) {
						if (std::abs(static_cast<Real>(temp(i, j))) < threshold) {
							temp(i, j) = Type{0};
						}
					}
				}
			}
			// Use the standard Print function for consistent formatting
			temp.Print(stream, width, precision);
		}
		
		friend std::ostream& operator<<(std::ostream& stream, const Matrix& a)
		{
			a.Print(stream, 10, 3);
			return stream;
		}
		
		std::string to_string(int width, int precision) const
		{
			std::stringstream str;
			Print(str, width, precision);
			return str.str();
		}

		///////////////////////              File I/O                      //////////////////////
		static bool LoadFromFile(const std::string& filename, Matrix& outMat)
		{
			std::ifstream file(filename);
			if (!file.is_open()) {
				std::cerr << "Error: could not open file " << filename << " for reading." << std::endl;
				return false;
			}
			
			int rows, cols;
			file >> rows >> cols;
			outMat.Resize(rows, cols);
			
			for (int i = 0; i < rows; ++i)
				for (int j = 0; j < cols; ++j)
					file >> outMat(i, j);
			
			file.close();
			return true;
		}
		
		static bool SaveToFile(const Matrix& mat, const std::string& filename)
		{
			std::ofstream file(filename);
			if (!file.is_open()) {
				std::cerr << "Error: could not create file " << filename << " for writing." << std::endl;
				return false;
			}
			
			file << mat._rows << " " << mat._cols << std::endl;
			for (int i = 0; i < mat._rows; ++i) {
				for (int j = 0; j < mat._cols; ++j)
					file << mat(i, j) << " ";
				file << std::endl;
			}
			
			file.close();
			return true;
		}
		
		static bool LoadFromCSV(const std::string& filename, Matrix& outMat)
		{
			std::ifstream file(filename);
			if (!file.is_open()) return false;
			
			std::vector<std::vector<Type>> data;
			std::string line;
			
			while (std::getline(file, line)) {
				std::vector<Type> row;
				std::stringstream ss(line);
				std::string cell;
				while (std::getline(ss, cell, ',')) {
					std::stringstream cellStream(cell);
					Type value;
					cellStream >> value;
					row.push_back(value);
				}
				if (!row.empty())
					data.push_back(row);
			}
			
			file.close();
			if (data.empty()) return false;
			
			outMat = Matrix(data);
			return true;
		}
		
		static bool SaveToCSV(const Matrix& mat, const std::string& filename)
		{
			std::ofstream file(filename);
			if (!file.is_open()) return false;
			
			for (int i = 0; i < mat._rows; ++i) {
				for (int j = 0; j < mat._cols; ++j) {
					file << mat(i, j);
					if (j < mat._cols - 1) file << ",";
				}
				file << "\n";
			}
			
			file.close();
			return true;
		}
	};

	//////////////////////               Default Matrix typedefs       //////////////////////
	typedef Matrix<int>     MatrixInt;
	typedef Matrix<float>   MatrixFlt;
	typedef Matrix<double>  MatrixDbl;
	typedef Matrix<Complex> MatrixComplex;

	// Legacy typedef aliases (for backward compatibility)
	typedef Matrix<int>     MatI;
	typedef Matrix<float>   MatF;
	typedef Matrix<double>  MatD;
	typedef Matrix<Complex> MatC;

	// Verify noexcept move operations
	static_assert(std::is_nothrow_move_constructible_v<Matrix<double>>,
	              "Matrix<double> should be nothrow move constructible");
	static_assert(std::is_nothrow_move_assignable_v<Matrix<double>>,
	              "Matrix<double> should be nothrow move assignable");
}


///////////////////////////   mml/base/Matrix3D.h   ///////////////////////////


namespace MML
{
	template <class Type>
	class Matrix3D {
	private:
		int _n;
		int _m;
		int _k;
		Type*** _v;

	public:
		Matrix3D() : _n(0), _m(0), _k(0), _v(nullptr) {}

		Matrix3D(int n, int m, int k) : _n(n), _m(m), _k(k), _v(new Type** [n])
		{
			int i, j;

			_v[0] = new Type * [n * m];
			_v[0][0] = new Type[n * m * k];

			for (j = 1; j < m; j++)
				_v[0][j] = _v[0][j - 1] + k;

			for (i = 1; i < n; i++) {
				_v[i] = _v[i - 1] + m;
				_v[i][0] = _v[i - 1][0] + m * k;

				for (j = 1; j < m; j++)
					_v[i][j] = _v[i][j - 1] + k;
			}
		}

		~Matrix3D()
		{
			if (_v != NULL) {
				delete[](_v[0][0]);
				delete[](_v[0]);
				delete[](_v);
			}
		}

		//subscripting: pointer to row i
		inline Type** operator[](const int i) { return _v[i]; }
		inline const Type* const* operator[](const int i) const { return _v[i]; }

		Type  operator()(int i, int j, int k) const { return _v[i][j][k]; }
		Type& operator()(int i, int j, int k) { return _v[i][j][k]; }

		inline int dim1() const { return _n; }
		inline int dim2() const { return _m; }
		inline int dim3() const { return _k; }
	};
}


///////////////////////////   mml/base/MatrixNM.h   ///////////////////////////



namespace MML
{
	template <class Type, int N, int M>
	class MatrixNM
	{
	public:
		Type _vals[N][M] = { {0} };

	public:
		typedef Type value_type;      // make T available externally

		//////////////////////////             Constructors           /////////////////////////
		MatrixNM() {}
		MatrixNM(std::initializer_list<Type> values)
		{
			auto val = values.begin();
			for (size_t i = 0; i < RowNum(); ++i)
				for (size_t j = 0; j < ColNum(); ++j)
					if (val != values.end())
						_vals[i][j] = *val++;
					else
						_vals[i][j] = 0.0;
		}
		// Constructor that takes an initializer_list of initializer_lists for row-wise initialization
		MatrixNM(std::initializer_list<std::initializer_list<Type>> rows)
		{
			size_t i = 0;
			for (auto rowIt = rows.begin(); rowIt != rows.end() && i < N; ++rowIt, ++i) {
				size_t j = 0;
				for (auto colIt = rowIt->begin(); colIt != rowIt->end() && j < M; ++colIt, ++j) {
					_vals[i][j] = *colIt;
				}
				// Fill remaining columns with zero if not enough elements
				for (; j < M; ++j) {
					_vals[i][j] = Type{ 0 };
				}
			}
			// Fill remaining rows with zero if not enough rows
			for (; i < N; ++i) {
				for (size_t j = 0; j < M; ++j) {
					_vals[i][j] = Type{ 0 };
				}
			}
		}
		// Constructor from flat array
		MatrixNM(const Type* arr, size_t len) {
			size_t idx = 0;
			for (size_t i = 0; i < RowNum(); ++i) {
				for (size_t j = 0; j < ColNum(); ++j) {
					if (idx < len)
						_vals[i][j] = arr[idx++];
					else
						_vals[i][j] = Type{ 0 };
				}
			}
		}
		MatrixNM(const MatrixNM& m)
		{
			for (size_t i = 0; i < RowNum(); ++i)
				for (size_t j = 0; j < ColNum(); ++j)
					_vals[i][j] = m._vals[i][j];
		}
		MatrixNM(const Type& m)        // initialize as diagonal matrix
		{
			for (int i = 0; i < N; i++)
				_vals[i][i] = Type{ m };
		}

		////////////////////////            Standard stuff             ////////////////////////
		int RowNum() const { return N; }
		int ColNum() const { return M; }

		static MatrixNM GetUnitMatrix()
		{
			MatrixNM unitMat;

			for (int i = 0; i < N; i++)
				unitMat._vals[i][i] = 1.0;

			return unitMat;
		}
		void   MakeUnitMatrix(void)
		{
			if (RowNum() == ColNum())
			{
				for (int i = 0; i < RowNum(); i++)
					for (int j = 0; j < ColNum(); j++)
						if (i == j)
							_vals[i][j] = 1;
						else
							_vals[i][j] = 0;
			}
			else
				throw MatrixDimensionError("MatrixNM::MakeUnitMatrix - must be square matrix", N, M, -1, -1);
		}

		MatrixNM GetLower(bool includeDiagonal = true) const
		{
			if (RowNum() != ColNum())
				throw MatrixDimensionError("Matrix::GetLower - must be square matrix", N, M, -1, -1);

			MatrixNM ret;
			for (int i = 0; i < RowNum(); i++)
			{
				if (includeDiagonal)
					for (int j = 0; j < i + 1; j++)
						ret[i][j] = _vals[i][j];
				else
					for (int j = 0; j < i; j++)
						ret[i][j] = _vals[i][j];
			}

			return ret;
		}
		MatrixNM GetUpper(bool includeDiagonal = true) const
		{
			if (RowNum() != ColNum())
				throw MatrixDimensionError("Matrix::GetUpper - must be square matrix", N, M, -1, -1);

			MatrixNM ret;
			for (int i = 0; i < RowNum(); i++)
			{
				if (includeDiagonal)
					for (int j = i; j < ColNum(); j++)
						ret[i][j] = _vals[i][j];
				else
					for (int j = i + 1; j < ColNum(); j++)
						ret[i][j] = _vals[i][j];
			}

			return ret;
		}

		/////////////////////          Vector-Matrix conversion           /////////////////////
		VectorN<Type, M> VectorFromRow(int rowInd)
		{
			VectorN<Type, M> ret;
			for (int j = 0; j < M; j++)
				ret[j] = _vals[rowInd][j];

			return ret;
		}
		VectorN<Type, N> VectorFromColumn(int colInd)
		{
			VectorN<Type, N> ret;
			for (int i = 0; i < N; i++)
				ret[i] = _vals[i][colInd];

			return ret;
		}
		VectorN<Type, N> VectorFromDiagonal()
		{
			VectorN<Type, N> ret;
			for (int i = 0; i < N; i++)
				ret[i] = _vals[i][i];

			return ret;
		}

		/////////////////////            Assignment operators             ////////////////////
		MatrixNM& operator=(const MatrixNM& m)
		{
			if (this == &m)
				return *this;

			for (size_t i = 0; i < RowNum(); ++i)
				for (size_t j = 0; j < ColNum(); ++j)
					_vals[i][j] = m._vals[i][j];

			return *this;
		}
		MatrixNM& operator=(const Type& m)
		{
			if (this == &m)
				return *this;

			for (size_t i = 0; i < RowNum(); ++i)
				for (size_t j = 0; j < ColNum(); ++j)
					_vals[i][j] = m;

			return *this;
		}

		////////////////////            Access operators             ///////////////////////
		inline const Type* operator[](int i)  const { return _vals[i]; }
		inline Type* operator[](int i) { return _vals[i]; }

		inline Type  operator()(int i, int j) const { return _vals[i][j]; }
		inline Type& operator()(int i, int j) { return _vals[i][j]; }

		// version with checking bounds
		Type  ElemAt(int i, int j) const
		{
			if (i < 0 || i >= RowNum() || j < 0 || j >= ColNum())
				throw MatrixAccessBoundsError("MatrixNM::ElemAt", i, j, RowNum(), ColNum());

			return _vals[i][j];
		}
		Type& ElemAt(int i, int j)
		{
			if (i < 0 || i >= RowNum() || j < 0 || j >= ColNum())
				throw MatrixAccessBoundsError("MatrixNM::ElemAt", i, j, RowNum(), ColNum());

			return _vals[i][j];
		}

		////////////////////            Arithmetic operators             ////////////////////
		MatrixNM operator-()            // unary minus
		{
			MatrixNM temp;
			for (size_t i = 0; i < RowNum(); i++)
				for (size_t j = 0; j < ColNum(); j++)
					temp._vals[i][j] = -_vals[i][j];
			return temp;
		}
		MatrixNM operator+(const MatrixNM& b) const
		{
			MatrixNM temp;
			for (size_t i = 0; i < RowNum(); i++)
				for (size_t j = 0; j < ColNum(); j++)
					temp._vals[i][j] = b._vals[i][j] + _vals[i][j];
			return temp;
		}
		MatrixNM operator-(const MatrixNM& b) const
		{
			MatrixNM temp;
			for (size_t i = 0; i < RowNum(); i++)
				for (size_t j = 0; j < ColNum(); j++)
					temp._vals[i][j] = _vals[i][j] - b._vals[i][j];
			return temp;
		}

		template<int K>
		MatrixNM<Type, N, K>  operator*(const MatrixNM<Type, M, K>& b) const
		{
			MatrixNM<Type, N, K>	ret;

			for (int i = 0; i < ret.RowNum(); i++)
				for (int j = 0; j < ret.ColNum(); j++)
				{
					ret._vals[i][j] = 0;
					for (int k = 0; k < ColNum(); k++)
						ret._vals[i][j] += _vals[i][k] * b._vals[k][j];
				}

			return	ret;
		}

		MatrixNM  operator*(const Type& b) const
		{
			int	i, j;
			MatrixNM	ret(*this);

			for (i = 0; i < RowNum(); i++)
				for (j = 0; j < ColNum(); j++)
					ret._vals[i][j] *= b;

			return ret;
		}
		MatrixNM& operator*=(const Type& b)
		{
			int	i, j;

			for (i = 0; i < RowNum(); i++)
				for (j = 0; j < ColNum(); j++)
					_vals[i][j] *= b;

			return *this;
		}
		MatrixNM  operator/(const Type& b) const
		{
			int	i, j;
			MatrixNM	ret(*this);

			for (i = 0; i < RowNum(); i++)
				for (j = 0; j < ColNum(); j++)
					ret._vals[i][j] /= b;

			return ret;
		}

		VectorN<Type, N> operator*(const VectorN<Type, M>& b) const
		{
			int	i, j;
			VectorN<Type, N>	ret;

			for (i = 0; i < N; i++)
			{
				ret[i] = 0;
				for (j = 0; j < M; j++)
					ret[i] += _vals[i][j] * b[j];
			}

			return ret;
		}

		friend MatrixNM operator*(Type a, const MatrixNM& b)
		{
			int	i, j;
			MatrixNM	ret;

			for (i = 0; i < b.RowNum(); i++)
				for (j = 0; j < b.ColNum(); j++)
					ret._vals[i][j] = a * b._vals[i][j];

			return ret;
		}
		friend VectorN<Type, M> operator*(const VectorN<Type, N>& a, const MatrixNM<Type, N, M>& b)
		{
			int	i, j;
			VectorN<Type, M>	ret;

			for (i = 0; i < M; i++)
			{
				ret[i] = 0;
				for (j = 0; j < N; j++)
					ret[i] += a[j] * b._vals[j][i];
			}

			return ret;
		}

		///////////////////////            Equality operations             //////////////////////
		bool operator==(const MatrixNM& b) const
		{
			for (int i = 0; i < N; i++)
				for (int j = 0; j < M; j++)
					if (_vals[i][j] != b._vals[i][j])
						return false;

			return true;
		}
		bool operator!=(const MatrixNM& b) const
		{
			return !(*this == b);
		}

		bool IsEqual(const MatrixNM& b, Type eps = Defaults::MatrixIsEqualTolerance) const
		{
			for (int i = 0; i < RowNum(); i++)
				for (int j = 0; j < ColNum(); j++)
					if (std::abs(_vals[i][j] - b._vals[i][j]) > eps)
						return false;

			return true;
		}
		bool AreEqual(const MatrixNM& a, const MatrixNM& b, Type eps = Defaults::MatrixIsEqualTolerance) const
		{
			return a.IsEqual(b, eps);
		}

		///////////////////            Trace, Inverse & Transpose             ///////////////////
		Type   Trace() const
		{
			if (RowNum() != ColNum())
				throw MatrixDimensionError("MatrixNM::Trace - must be square matrix", N, M, -1, -1);

			Type sum = 0;
			for (int i = 0; i < RowNum(); i++)
				sum += _vals[i][i];

			return sum;
		}

		void Invert()
		{
			if (RowNum() != ColNum())
				throw MatrixDimensionError("MatrixNM::Invert - must be square matrix", N, M, -1, -1);

			MatrixNM& a = *this;
			MatrixNM<Type, N, 1>  b;      // dummy rhs

			b(0, 0) = 1.0;

			int i, icol, irow, j, k, l, ll;
			Type big, dum, pivinv;

			int n = RowNum();
			int m = b.ColNum();
			std::vector<int> indxc(n), indxr(n), ipiv(n);
			for (j = 0; j < n; j++) ipiv[j] = 0;
			for (i = 0; i < n; i++) {
				big = 0.0;
				for (j = 0; j < n; j++)
					if (ipiv[j] != 1)
						for (k = 0; k < n; k++) {
							if (ipiv[k] == 0) {
								if (std::abs(a._vals[j][k]) >= big) {
									big = std::abs(a._vals[j][k]);
									irow = j;
									icol = k;
								}
							}
						}
				++(ipiv[icol]);
				if (irow != icol) {
					for (l = 0; l < n; l++) std::swap(a._vals[irow][l], a._vals[icol][l]);
					for (l = 0; l < m; l++) std::swap(b._vals[irow][l], b._vals[icol][l]);
				}
				indxr[i] = irow;
				indxc[i] = icol;

				if (a._vals[icol][icol] == 0.0)
					throw SingularMatrixError("MatrixNM::Invert, gaussj: Singular Matrix");

				pivinv = 1.0 / a._vals[icol][icol];
				a._vals[icol][icol] = 1.0;
				for (l = 0; l < n; l++) a._vals[icol][l] *= pivinv;
				for (l = 0; l < m; l++) b._vals[icol][l] *= pivinv;
				for (ll = 0; ll < n; ll++)
					if (ll != icol) {
						dum = a._vals[ll][icol];
						a._vals[ll][icol] = 0.0;
						for (l = 0; l < n; l++) a._vals[ll][l] -= a._vals[icol][l] * dum;
						for (l = 0; l < m; l++) b._vals[ll][l] -= b._vals[icol][l] * dum;
					}
			}
			for (l = n - 1; l >= 0; l--) {
				if (indxr[l] != indxc[l])
					for (k = 0; k < n; k++)
						std::swap(a._vals[k][indxr[l]], a._vals[k][indxc[l]]);
			}
		}
		MatrixNM GetInverse() const
		{
			if (RowNum() != ColNum())
				throw MatrixDimensionError("MatrixNM::GetInverse - must be square matrix", N, M, -1, -1);

			MatrixNM a(*this);              // making a copy, where inverse will be stored at the end

			a.Invert();

			return a;
		}

		void Transpose()
		{
			if (RowNum() != ColNum())
				throw MatrixDimensionError("MatrixNM::Transpose - inplace Transpose possible only for square  matrix", N, M, -1, -1);

			for (size_t i = 0; i < RowNum(); i++)
				for (size_t j = i + 1; j < ColNum(); j++)
					std::swap(_vals[i][j], _vals[j][i]);
		}
		MatrixNM<Type, M, N> GetTranspose() const
		{
			MatrixNM<Type, M, N> ret;

			for (size_t i = 0; i < ColNum(); i++)
				for (size_t j = 0; j < RowNum(); j++)
					ret._vals[i][j] = _vals[j][i];

			return ret;
		}

		///////////////////////////               I/O                 ///////////////////////////
		std::string to_string(int width, int precision) const
		{
			std::stringstream str;

			Print(str, width, precision);

			return str.str();
		}
		// New formatted print with MatrixPrintFormat
		void Print(std::ostream& stream, const MatrixPrintFormat& fmt = MatrixPrintFormat::Default()) const
		{
			// Show header if requested
			if (fmt.showHeader) {
				stream << "Rows: " << RowNum() << " Cols: " << ColNum() << std::endl;
			}

			// Set formatting flags
			std::ios_base::fmtflags oldFlags = stream.flags();
			if (fmt.scientific)
				stream << std::scientific;
			else if (fmt.fixed)
				stream << std::fixed;

			// Compact mode - print on one line for small matrices
			if (fmt.compactMode && RowNum() <= 3 && ColNum() <= 3) {
				if (fmt.showBrackets)
					stream << "[";
				for (int i = 0; i < RowNum(); i++) {
					if (i > 0) stream << "; ";
					for (int j = 0; j < ColNum(); j++) {
						if (j > 0) stream << fmt.delimiter;
						stream << std::setw(fmt.width) << std::setprecision(fmt.precision) << _vals[i][j];
					}
				}
				if (fmt.showBrackets)
					stream << "]";
				stream << std::endl;
			}
			else {
				// Normal multi-line mode
				for (int i = 0; i < RowNum(); i++)
				{
					if (fmt.showBrackets)
						stream << "[ ";
					for (int j = 0; j < ColNum(); j++)
					{
						stream << std::setw(fmt.width) << std::setprecision(fmt.precision) << _vals[i][j];
						if (j < ColNum() - 1)
							stream << fmt.delimiter;
					}
					if (fmt.showBrackets)
						stream << " ]";
					if (i < RowNum() - 1)
						stream << std::endl;
				}
			}

			// Restore original flags
			stream.flags(oldFlags);
		}

		// Legacy print method (backward compatibility)
		void Print(std::ostream& stream, int width, int precision) const
		{
			MatrixPrintFormat fmt = MatrixPrintFormat::Default();
			fmt.width = width;
			fmt.precision = precision;
			Print(stream, fmt);
		}
		void   Print(std::ostream& stream, int width, int precision, Real zeroThreshold) const
		{
			stream << "Rows: " << RowNum() << " Cols: " << ColNum();

			for (int i = 0; i < RowNum(); i++)
			{
				stream << "[ ";
				for (int j = 0; j < ColNum(); j++)
				{
					Type value{ 0 };
					if (Abs(_vals[i][j]) > zeroThreshold)
						value = _vals[i][j];

					if (j == ColNum() - 1)
						stream << std::setw(width) << std::setprecision(precision) << value;
					else
						stream << std::setw(width) << std::setprecision(precision) << value << ", ";
				}
				if (i == RowNum() - 1)
					stream << " ]";
				else
					stream << " ]" << std::endl;
			}
		}
		friend std::ostream& operator<<(std::ostream& stream, const MatrixNM& a)
		{
			a.Print(stream, 10, 3);

			return stream;
		}
	};

	///////////////////               Default MatrixNM typdefs                 ///////////////////
	typedef MatrixNM<float, 2, 2> Matrix22Flt;
	typedef MatrixNM<float, 3, 3> Matrix33Flt;
	typedef MatrixNM<float, 4, 4> Matrix44Flt;

	typedef MatrixNM<Real, 2, 2> Matrix22Dbl;
	typedef MatrixNM<Real, 3, 3> Matrix33Dbl;
	typedef MatrixNM<Real, 4, 4> Matrix44Dbl;

	typedef MatrixNM<Complex, 2, 2> Matrix22Complex;
	typedef MatrixNM<Complex, 3, 3> Matrix33Complex;
	typedef MatrixNM<Complex, 4, 4> Matrix44Complex;

	typedef MatrixNM<float, 2, 2> Mat22F;
	typedef MatrixNM<float, 3, 3> Mat33F;
	typedef MatrixNM<float, 4, 4> Mat44F;

	typedef MatrixNM<Real, 2, 2> Mat22D;
	typedef MatrixNM<Real, 3, 3> Mat33D;
	typedef MatrixNM<Real, 4, 4> Mat44D;

	typedef MatrixNM<Complex, 2, 2> Mat22C;
	typedef MatrixNM<Complex, 3, 3> Mat33C;
	typedef MatrixNM<Complex, 4, 4> Mat44C;
}


///////////////////////////   mml/base/MatrixSym.h   ///////////////////////////




namespace MML
{
    // Constants for symmetric matrix allocation limits
    struct MatrixSymLimits {
        static constexpr int MAX_DIMENSION = 10000;                 // Maximum dimension
        static constexpr size_t MAX_ELEMENTS = 50'000'000;          // Maximum storage elements
    };

    template<class Type>
    class MatrixSym
    {
    private:
        int _dim;
        std::vector<Type> _data;  // Contiguous storage for lower triangular elements

        //////////////////       Helper functions for linear indexing       //////////////////
        // Storage layout: row-wise lower triangular
        // [a00, a10, a11, a20, a21, a22, a30, a31, a32, a33, ...]
        // For element (i,j) where i >= j: index = i*(i+1)/2 + j
        
        static constexpr size_t numElements(int dim) noexcept {
            return static_cast<size_t>(dim) * (dim + 1) / 2;
        }
        
        static constexpr size_t linearIndex(int i, int j) noexcept {
            // Ensure i >= j for lower triangular access
            if (i < j) std::swap(i, j);
            return static_cast<size_t>(i) * (i + 1) / 2 + j;
        }

        void validateDimension(int dim) const {
            if (dim < 0)
                throw MatrixDimensionError("MatrixSym: dimension cannot be negative", dim, -1, -1, -1);
            if (dim > MatrixSymLimits::MAX_DIMENSION)
                throw MatrixDimensionError("MatrixSym: dimension exceeds maximum allowed", dim, MatrixSymLimits::MAX_DIMENSION, -1, -1);
            
            size_t requiredElements = numElements(dim);
            if (requiredElements > MatrixSymLimits::MAX_ELEMENTS)
                throw MatrixAllocationError("MatrixSym: allocation would exceed maximum elements", dim, -1);
        }

    public:
        typedef Type value_type;      // make Type available externally

        ///////////////////////          Constructors and destructor       //////////////////////
        
        // Default constructor - creates empty (0x0) matrix
        MatrixSym() noexcept : _dim(0), _data() {}
        
        // Dimension constructor - creates dim x dim matrix initialized to zero
        explicit MatrixSym(int dim) : _dim(0), _data() 
        {
            if (dim == 0) return;
            
            validateDimension(dim);
            _dim = dim;
            _data.resize(numElements(dim), Type{0});
        }
        
        // Dimension + value constructor - creates dim x dim matrix initialized to val
        MatrixSym(int dim, Type val) : _dim(0), _data()
        {
            if (dim == 0) return;
            
            validateDimension(dim);
            _dim = dim;
            _data.resize(numElements(dim), val);
        }
        
        // Initializer list constructor - takes lower triangular elements row-wise
        // Example for 3x3: {a00, a10, a11, a20, a21, a22}
        MatrixSym(int dim, std::initializer_list<Type> values) : _dim(0), _data()
        {
            if (dim == 0) {
                if (values.size() != 0)
                    throw MatrixDimensionError("MatrixSym: non-empty initializer for zero dimension", 0, -1, -1, -1);
                return;
            }
            
            validateDimension(dim);
            
            size_t expected = numElements(dim);
            if (values.size() != expected)
                throw MatrixDimensionError("MatrixSym: initializer list size mismatch - expected " + 
                    std::to_string(expected) + " but got " + std::to_string(values.size()), 
                    dim, -1, static_cast<int>(values.size()), -1);
            
            _dim = dim;
            _data.assign(values.begin(), values.end());
        }
        
        // Copy constructor
        MatrixSym(const MatrixSym& other) : _dim(other._dim), _data(other._data) {}
        
        // Move constructor
        MatrixSym(MatrixSym&& other) noexcept 
            : _dim(other._dim), _data(std::move(other._data))
        {
            other._dim = 0;
        }
        
        // Destructor - default is fine with std::vector
        ~MatrixSym() = default;

        ////////////////////////               Standard stuff             ////////////////////////
        
        int Dim() const noexcept { return _dim; }
        int RowNum() const noexcept { return _dim; }
        int ColNum() const noexcept { return _dim; }
        
        // Number of stored elements (lower triangular)
        size_t size() const noexcept { return _data.size(); }
        
        // Check if matrix is empty (0x0)
        bool empty() const noexcept { return _dim == 0; }
        
        // Raw data access (for interop with libraries)
        Type* data() noexcept { return _data.data(); }
        const Type* data() const noexcept { return _data.data(); }
        
        // Resize the matrix (destroys existing data)
        void Resize(int newDim)
        {
            if (newDim == _dim) return;
            
            if (newDim == 0) {
                _dim = 0;
                _data.clear();
                return;
            }
            
            validateDimension(newDim);
            _dim = newDim;
            _data.assign(numElements(newDim), Type{0});
        }
        
        // Resize with preservation of existing elements where possible
        void Resize(int newDim, bool preserveData)
        {
            if (!preserveData || _dim == 0) {
                Resize(newDim);
                return;
            }
            
            if (newDim == _dim) return;
            
            if (newDim == 0) {
                _dim = 0;
                _data.clear();
                return;
            }
            
            validateDimension(newDim);
            
            // Create new storage
            std::vector<Type> newData(numElements(newDim), Type{0});
            
            // Copy existing elements where dimensions overlap
            int minDim = std::min(_dim, newDim);
            for (int i = 0; i < minDim; ++i) {
                for (int j = 0; j <= i; ++j) {
                    size_t oldIdx = linearIndex(i, j);
                    size_t newIdx = static_cast<size_t>(i) * (i + 1) / 2 + j;
                    newData[newIdx] = _data[oldIdx];
                }
            }
            
            _dim = newDim;
            _data = std::move(newData);
        }
        
        // Set all elements to zero
        void SetToZero() noexcept
        {
            std::fill(_data.begin(), _data.end(), Type{0});
        }
        
        // Set all elements to a value
        void SetToValue(Type val) noexcept
        {
            std::fill(_data.begin(), _data.end(), val);
        }

        ///////////////////////          Comparison                   //////////////////////
        
        bool IsEqual(const MatrixSym& b, Type eps = Defaults::MatrixIsEqualTolerance) const
        {
            if (_dim != b._dim)
                return false;

            for (size_t i = 0; i < _data.size(); ++i) {
                if (Abs(_data[i] - b._data[i]) > eps)
                    return false;
            }
            return true;
        }
        
        static bool AreEqual(const MatrixSym& a, const MatrixSym& b, Type eps = Defaults::MatrixIsEqualTolerance)
        {
            return a.IsEqual(b, eps);
        }

        ///////////////////////          Conversion to Matrix         //////////////////////
        
        Matrix<Type> GetAsMatrix() const
        {
            if (_dim == 0) return Matrix<Type>();
            
            Matrix<Type> ret(_dim, _dim);
            for (int i = 0; i < _dim; ++i) {
                for (int j = 0; j < _dim; ++j) {
                    ret(i, j) = (*this)(i, j);
                }
            }
            return ret;
        }

        /////////////////////          Init from regular Matrix           /////////////////////
        
        // Create symmetric matrix from lower triangular part of a matrix
        static MatrixSym FromLower(const Matrix<Type>& m)
        {
            if (m.RowNum() != m.ColNum())
                throw MatrixDimensionError("MatrixSym::FromLower - must be square matrix", 
                    m.RowNum(), m.ColNum(), -1, -1);

            int dim = m.RowNum();
            if (dim == 0) return MatrixSym();
            
            MatrixSym ret(dim);
            for (int i = 0; i < dim; ++i) {
                for (int j = 0; j <= i; ++j) {
                    ret(i, j) = m(i, j);
                }
            }
            return ret;
        }
        
        // Create symmetric matrix from upper triangular part of a matrix
        static MatrixSym FromUpper(const Matrix<Type>& m)
        {
            if (m.RowNum() != m.ColNum())
                throw MatrixDimensionError("MatrixSym::FromUpper - must be square matrix", 
                    m.RowNum(), m.ColNum(), -1, -1);

            int dim = m.RowNum();
            if (dim == 0) return MatrixSym();
            
            MatrixSym ret(dim);
            for (int i = 0; i < dim; ++i) {
                for (int j = i; j < dim; ++j) {
                    // a(i,j) from upper = a(j,i) in storage = a(i,j) symmetric
                    ret(j, i) = m(i, j);  // Transpose to lower
                }
            }
            return ret;
        }
        
        // Create symmetric matrix as (M + M^T) / 2
        static MatrixSym FromFullMatrix(const Matrix<Type>& m)
        {
            if (m.RowNum() != m.ColNum())
                throw MatrixDimensionError("MatrixSym::FromFullMatrix - must be square matrix", 
                    m.RowNum(), m.ColNum(), -1, -1);

            int dim = m.RowNum();
            if (dim == 0) return MatrixSym();
            
            MatrixSym ret(dim);
            for (int i = 0; i < dim; ++i) {
                for (int j = 0; j <= i; ++j) {
                    ret(i, j) = (m(i, j) + m(j, i)) / Type{2};
                }
            }
            return ret;
        }
        
        // Legacy methods (deprecated - use static factory methods instead)
        [[deprecated("Use static MatrixSym::FromLower() instead")]]
        MatrixSym InitFromLower(const Matrix<Type>& b)
        {
            return FromLower(b);
        }
        
        [[deprecated("Use static MatrixSym::FromUpper() instead")]]
        MatrixSym InitFromUpper(const Matrix<Type>& b)
        {
            return FromUpper(b);
        }

        ///////////////////////          Static Factory Methods       //////////////////////
        
        // Create identity matrix of given dimension
        static MatrixSym GetUnitMatrix(int dim)
        {
            MatrixSym ret(dim);  // Initializes to zero
            for (int i = 0; i < dim; ++i) {
                ret(i, i) = Type{1};
            }
            return ret;
        }
        
        // Create diagonal matrix from vector
        static MatrixSym GetDiagonalMatrix(const Vector<Type>& diag)
        {
            int dim = static_cast<int>(diag.size());
            MatrixSym ret(dim);  // Initializes to zero
            for (int i = 0; i < dim; ++i) {
                ret(i, i) = diag[i];
            }
            return ret;
        }

        /////////////////////          Vector-Matrix conversion           /////////////////////
        
        Vector<Type> VectorFromRow(int rowInd) const
        {
            if (rowInd < 0 || rowInd >= _dim)
                throw MatrixAccessBoundsError("VectorFromRow - row index out of bounds", 
                    rowInd, 0, _dim, _dim);

            Vector<Type> ret(_dim);
            for (int j = 0; j < _dim; ++j) {
                ret[j] = (*this)(rowInd, j);
            }
            return ret;
        }
        
        Vector<Type> VectorFromColumn(int colInd) const
        {
            if (colInd < 0 || colInd >= _dim)
                throw MatrixAccessBoundsError("VectorFromColumn - column index out of bounds", 
                    0, colInd, _dim, _dim);

            Vector<Type> ret(_dim);
            for (int i = 0; i < _dim; ++i) {
                ret[i] = (*this)(i, colInd);
            }
            return ret;
        }
        
        Vector<Type> VectorFromDiagonal() const
        {
            Vector<Type> ret(_dim);
            for (int i = 0; i < _dim; ++i) {
                ret[i] = (*this)(i, i);
            }
            return ret;
        }

        ///////////////////////          Matrix Properties            //////////////////////
        
        // Compute trace (sum of diagonal elements)
        Type Trace() const noexcept
        {
            Type sum{0};
            for (int i = 0; i < _dim; ++i) {
                sum += (*this)(i, i);
            }
            return sum;
        }
        
        // Frobenius norm: sqrt(sum of squared elements)
        // Note: off-diagonal elements counted twice in full matrix
        Type NormFrobenius() const
        {
            Type sum{0};
            for (int i = 0; i < _dim; ++i) {
                // Diagonal element
                sum += (*this)(i, i) * (*this)(i, i);
                // Off-diagonal elements (counted twice in full matrix)
                for (int j = 0; j < i; ++j) {
                    sum += Type{2} * (*this)(i, j) * (*this)(i, j);
                }
            }
            return std::sqrt(sum);
        }
        
        // Infinity norm (max row sum of absolute values)
        Type NormInf() const
        {
            Type maxSum{0};
            for (int i = 0; i < _dim; ++i) {
                Type rowSum{0};
                for (int j = 0; j < _dim; ++j) {
                    rowSum += Abs((*this)(i, j));
                }
                if (rowSum > maxSum) maxSum = rowSum;
            }
            return maxSum;
        }
        
        // One norm (max column sum of absolute values)
        // For symmetric matrix, same as infinity norm
        Type Norm1() const
        {
            return NormInf();  // Symmetric property: row sum = column sum
        }

        ///////////////////////////            Operators             ///////////////////////////
        
        // Copy assignment
        MatrixSym& operator=(const MatrixSym& other)
        {
            if (this != &other) {
                _dim = other._dim;
                _data = other._data;
            }
            return *this;
        }
        
        // Move assignment
        MatrixSym& operator=(MatrixSym&& other) noexcept
        {
            if (this != &other) {
                _dim = other._dim;
                _data = std::move(other._data);
                other._dim = 0;
            }
            return *this;
        }

        ////////////////////////           Access operators             ///////////////////////
        
        // Element access without bounds checking - primary access method
        Type operator()(int i, int j) const {
            return _data[linearIndex(i, j)];
        }
        
        Type& operator()(int i, int j) {
            return _data[linearIndex(i, j)];
        }

        // Element access with bounds checking (like std::vector::at)
        Type at(int i, int j) const
        {
            if (i < 0 || i >= _dim || j < 0 || j >= _dim)
                throw MatrixAccessBoundsError("MatrixSym::at", i, j, _dim, _dim);
            return _data[linearIndex(i, j)];
        }
        
        Type& at(int i, int j)
        {
            if (i < 0 || i >= _dim || j < 0 || j >= _dim)
                throw MatrixAccessBoundsError("MatrixSym::at", i, j, _dim, _dim);
            return _data[linearIndex(i, j)];
        }

        // Legacy ElemAt (alias for at)
        Type ElemAt(int i, int j) const { return at(i, j); }
        Type& ElemAt(int i, int j) { return at(i, j); }

        ///////////////////////           Arithmetic operators             //////////////////////
        
        MatrixSym operator+(const MatrixSym& b) const
        {
            if (_dim != b._dim)
                throw MatrixDimensionError("MatrixSym::operator+ - dimensions must match", 
                    _dim, -1, b._dim, -1);

            MatrixSym ret(_dim);
            for (size_t i = 0; i < _data.size(); ++i) {
                ret._data[i] = _data[i] + b._data[i];
            }
            return ret;
        }
        
        MatrixSym& operator+=(const MatrixSym& b)
        {
            if (_dim != b._dim)
                throw MatrixDimensionError("MatrixSym::operator+= - dimensions must match", 
                    _dim, -1, b._dim, -1);

            for (size_t i = 0; i < _data.size(); ++i) {
                _data[i] += b._data[i];
            }
            return *this;
        }
        
        MatrixSym operator-() const
        {
            MatrixSym ret(_dim);
            for (size_t i = 0; i < _data.size(); ++i) {
                ret._data[i] = -_data[i];
            }
            return ret;
        }
        
        MatrixSym operator-(const MatrixSym& b) const
        {
            if (_dim != b._dim)
                throw MatrixDimensionError("MatrixSym::operator- - dimensions must match", 
                    _dim, -1, b._dim, -1);

            MatrixSym ret(_dim);
            for (size_t i = 0; i < _data.size(); ++i) {
                ret._data[i] = _data[i] - b._data[i];
            }
            return ret;
        }
        
        MatrixSym& operator-=(const MatrixSym& b)
        {
            if (_dim != b._dim)
                throw MatrixDimensionError("MatrixSym::operator-= - dimensions must match", 
                    _dim, -1, b._dim, -1);

            for (size_t i = 0; i < _data.size(); ++i) {
                _data[i] -= b._data[i];
            }
            return *this;
        }

        // Matrix-Matrix multiplication (result is NOT symmetric in general)
        Matrix<Type> operator*(const MatrixSym& b) const
        {
            if (_dim != b._dim)
                throw MatrixDimensionError("MatrixSym::operator*(MatrixSym) - dimensions must match", 
                    _dim, _dim, b._dim, b._dim);

            Matrix<Type> ret(_dim, _dim);
            for (int i = 0; i < _dim; ++i) {
                for (int j = 0; j < _dim; ++j) {
                    Type sum{0};
                    for (int k = 0; k < _dim; ++k) {
                        sum += (*this)(i, k) * b(k, j);
                    }
                    ret(i, j) = sum;
                }
            }
            return ret;
        }

        Matrix<Type> operator*(const Matrix<Type>& b) const
        {
            if (_dim != b.RowNum())
                throw MatrixDimensionError("MatrixSym::operator*(Matrix) - dimension mismatch", 
                    _dim, _dim, b.RowNum(), b.ColNum());

            Matrix<Type> ret(_dim, b.ColNum());
            for (int i = 0; i < _dim; ++i) {
                for (int j = 0; j < b.ColNum(); ++j) {
                    Type sum{0};
                    for (int k = 0; k < _dim; ++k) {
                        sum += (*this)(i, k) * b(k, j);
                    }
                    ret(i, j) = sum;
                }
            }
            return ret;
        }

        // Scalar multiplication
        friend MatrixSym operator*(const MatrixSym& a, Type scalar)
        {
            MatrixSym ret(a._dim);
            for (size_t i = 0; i < a._data.size(); ++i) {
                ret._data[i] = a._data[i] * scalar;
            }
            return ret;
        }
        
        friend MatrixSym operator*(Type scalar, const MatrixSym& a)
        {
            return a * scalar;
        }
        
        MatrixSym& operator*=(Type scalar)
        {
            for (auto& elem : _data) {
                elem *= scalar;
            }
            return *this;
        }
        
        // Scalar division
        friend MatrixSym operator/(const MatrixSym& a, Type scalar)
        {
            MatrixSym ret(a._dim);
            for (size_t i = 0; i < a._data.size(); ++i) {
                ret._data[i] = a._data[i] / scalar;
            }
            return ret;
        }
        
        MatrixSym& operator/=(Type scalar)
        {
            for (auto& elem : _data) {
                elem /= scalar;
            }
            return *this;
        }

        // Matrix-Vector multiplication
        friend Vector<Type> operator*(const MatrixSym& a, const Vector<Type>& v)
        {
            if (a._dim != static_cast<int>(v.size()))
                throw MatrixDimensionError("operator*(MatrixSym, Vector) - dimension mismatch", 
                    a._dim, a._dim, static_cast<int>(v.size()), -1);

            Vector<Type> ret(a._dim);
            for (int i = 0; i < a._dim; ++i) {
                Type sum{0};
                for (int j = 0; j < a._dim; ++j) {
                    sum += a(i, j) * v[j];
                }
                ret[i] = sum;
            }
            return ret;
        }
        
        friend Vector<Type> operator*(const Vector<Type>& v, const MatrixSym& a)
        {
            if (static_cast<int>(v.size()) != a._dim)
                throw MatrixDimensionError("operator*(Vector, MatrixSym) - dimension mismatch", 
                    static_cast<int>(v.size()), -1, a._dim, a._dim);

            Vector<Type> ret(a._dim);
            for (int j = 0; j < a._dim; ++j) {
                Type sum{0};
                for (int i = 0; i < a._dim; ++i) {
                    sum += v[i] * a(i, j);
                }
                ret[j] = sum;
            }
            return ret;
        }

        ////////////////////////            Inverse              ///////////////////////
        
        Matrix<Type> GetInverse() const
        {
            if (_dim == 0)
                throw MatrixDimensionError("MatrixSym::GetInverse - cannot invert empty matrix", 0, 0, -1, -1);

            Matrix<Type> a = GetAsMatrix();
            a.Invert();
            return a;
        }

        ///////////////////////////               I/O                 ///////////////////////////
        
        std::string to_string(int width = 10, int precision = 3) const
        {
            std::stringstream str;
            Print(str, width, precision);
            return str.str();
        }
        
        // Formatted print with MatrixPrintFormat
        void Print(std::ostream& stream, const MatrixPrintFormat& fmt = MatrixPrintFormat::Default()) const
        {
            if (fmt.showHeader) {
                stream << "Rows: " << _dim << " Cols: " << _dim << " (Symmetric)" << std::endl;
            }

            std::ios_base::fmtflags oldFlags = stream.flags();
            if (fmt.scientific)
                stream << std::scientific;
            else if (fmt.fixed)
                stream << std::fixed;

            // Compact mode for small matrices
            if (fmt.compactMode && _dim <= 3) {
                if (fmt.showBrackets)
                    stream << "[";
                for (int i = 0; i < _dim; ++i) {
                    if (i > 0) stream << "; ";
                    for (int j = 0; j < _dim; ++j) {
                        if (j > 0) stream << fmt.delimiter;
                        stream << std::setw(fmt.width) << std::setprecision(fmt.precision) << (*this)(i, j);
                    }
                }
                if (fmt.showBrackets)
                    stream << "]";
                stream << std::endl;
            }
            else {
                // Normal multi-line mode
                for (int i = 0; i < _dim; ++i) {
                    if (fmt.showBrackets)
                        stream << "[ ";
                    for (int j = 0; j < _dim; ++j) {
                        stream << std::setw(fmt.width) << std::setprecision(fmt.precision) << (*this)(i, j);
                        if (j < _dim - 1)
                            stream << fmt.delimiter;
                    }
                    if (fmt.showBrackets)
                        stream << " ]";
                    if (i < _dim - 1)
                        stream << std::endl;
                }
            }

            stream.flags(oldFlags);
        }

        // Legacy print method
        void Print(std::ostream& stream, int width, int precision) const
        {
            MatrixPrintFormat fmt = MatrixPrintFormat::Default();
            fmt.width = width;
            fmt.precision = precision;
            Print(stream, fmt);
        }
        
        friend std::ostream& operator<<(std::ostream& stream, const MatrixSym& a)
        {
            a.Print(stream, 10, 3);
            return stream;
        }
    };
}

///////////////////////////   mml/base/MatrixTriDiag.h   ///////////////////////////


namespace MML
{
	template<class Type>
	class TridiagonalMatrix
	{
	private:
		int _dim;
		Vector<Type> _belowDiag;
		Vector<Type> _diag;
		Vector<Type> _aboveDiag;

	public:
		TridiagonalMatrix(int dim, const Vector<Type>& a, const Vector<Type>& diag, const Vector<Type>& c) : _belowDiag(a), _diag(diag), _aboveDiag(c), _dim(dim)
		{
			if( dim < 3)
				throw("Error in TridiagonalMatrix constructor: dim < 3");

			if (a.size() != dim || diag.size() != dim || c.size() != dim)
				throw("Error in TridiagonalMatrix constructor: wrong dimensions");
		}

		TridiagonalMatrix(int dim, std::initializer_list<Type> values) : _dim(dim), _belowDiag(dim), _diag(dim), _aboveDiag(dim)
		{
			if (values.size() != dim * 3 - 2)
				throw("Error in TridiagonalMatrix constructor: wrong dimensions");

			auto val = values.begin();
			_belowDiag[0] = 0.0;
			_diag[0] = *val++;
			_aboveDiag[0] = *val++;
			for (int i = 1; i < dim - 1; ++i)
			{
				_belowDiag[i] = *val++;
				_diag[i] = *val++;
				_aboveDiag[i] = *val++;
			}
			_belowDiag[dim - 1] = *val++;
			_diag[dim - 1] = *val++;
			_aboveDiag[dim - 1] = 0.0;
		}

		int RowNum() const { return _dim; }
		int ColNum() const { return _dim; }

		Type  operator()(int i, int j) const {
			if (i == j)
				return _diag[i];
			else if (i == j - 1)
				return _aboveDiag[i];
			else if (i == j + 1 && j < _dim - 1)
				return _belowDiag[i];
			else
				return 0.0;
		}
		Type& operator()(int i, int j) {
			if (i == j)
				return _diag[i];
			else if (i == j - 1)
				return _aboveDiag[i];
			else if (i == j + 1 && j < _dim - 1)
				return _belowDiag[i];
			else
				throw MatrixAccessBoundsError("TridiagonalMatrix::operator()", i, j, _dim, _dim);
		}

		bool IsEqual(const TridiagonalMatrix& b, Type eps = Defaults::MatrixIsEqualTolerance) const
		{
			if (_dim != b._dim)
				return false;

			for (int i = 0; i < _dim; i++) {
				if (std::abs(_diag[i] - b._diag[i]) > eps)
					return false;
				if (std::abs(_belowDiag[i] - b._belowDiag[i]) > eps)
					return false;
				if (std::abs(_aboveDiag[i] - b._aboveDiag[i]) > eps)
					return false;
			}
			return true;
		}

		TridiagonalMatrix operator+(const TridiagonalMatrix& b) const
		{
			if (_dim != b._dim)
				throw MatrixDimensionError("TridiagonalMatrix::operator+() - must be same dim", _dim, _dim, b._dim, b._dim);

			TridiagonalMatrix temp(*this);
			for (int i = 0; i < _belowDiag.size(); i++)
				temp._belowDiag[i] += b._belowDiag[i];
			for (int i = 0; i < _diag.size(); i++)
				temp._diag[i] += b._diag[i];
			for (int i = 0; i < _aboveDiag.size(); i++)
				temp._aboveDiag[i] += b._aboveDiag[i];

			return temp;
		}
		TridiagonalMatrix operator-(const TridiagonalMatrix& b) const
		{
			if (_dim != b._dim)
				throw MatrixDimensionError("TridiagonalMatrix::operator+() - must be same dim", _dim, _dim, b._dim, b._dim);

			TridiagonalMatrix temp(*this);
			for (int i = 0; i < _belowDiag.size(); i++)
				temp._belowDiag[i] -= b._belowDiag[i];
			for (int i = 0; i < _diag.size(); i++)
				temp._diag[i] -= b._diag[i];
			for (int i = 0; i < _aboveDiag.size(); i++)
				temp._aboveDiag[i] -= b._aboveDiag[i];

			return temp;
		}

		friend TridiagonalMatrix operator*(const TridiagonalMatrix& a, Type b)
		{
			int	i, j;
			TridiagonalMatrix	ret(a);

			for (int i = 0; i < ret._belowDiag.size(); i++)
				ret._belowDiag[i] *= b;
			for (int i = 0; i < ret._diag.size(); i++)
				ret._diag[i] *= b;
			for (int i = 0; i < ret._aboveDiag.size(); i++)
				ret._aboveDiag[i] *= b;

			return ret;
		}
		friend TridiagonalMatrix operator*(Type a, const TridiagonalMatrix& b)
		{
			int	i, j;
			TridiagonalMatrix	ret(b);

			for (int i = 0; i < ret._belowDiag.size(); i++)
				ret._belowDiag[i] *= a;
			for (int i = 0; i < ret._diag.size(); i++)
				ret._diag[i] *= a;
			for (int i = 0; i < ret._aboveDiag.size(); i++)
				ret._aboveDiag[i] *= a;

			return ret;
		}
		friend TridiagonalMatrix operator/(const TridiagonalMatrix& a, Type b)
		{
			int	i, j;
			TridiagonalMatrix	ret(a);

			for (int i = 0; i < ret._belowDiag.size(); i++)
				ret._belowDiag[i] /= b;
			for (int i = 0; i < ret._diag.size(); i++)
				ret._diag[i] /= b;
			for (int i = 0; i < ret._aboveDiag.size(); i++)
				ret._aboveDiag[i] /= b;

			return ret;
		}

		TridiagonalMatrix GetTranspose() const
		{
			// For a tridiagonal matrix, transpose swaps and shifts the above and below diagonals
			// belowDiag_new[i] = aboveDiag_old[i-1] (with belowDiag_new[0] = 0)
			// aboveDiag_new[i] = belowDiag_old[i+1] (with aboveDiag_new[dim-1] = 0)
			Vector<Type> newBelowDiag(_dim);
			Vector<Type> newAboveDiag(_dim);

			newBelowDiag[0] = 0.0;
			for (int i = 1; i < _dim; i++)
				newBelowDiag[i] = _aboveDiag[i - 1];

			for (int i = 0; i < _dim - 1; i++)
				newAboveDiag[i] = _belowDiag[i + 1];
			newAboveDiag[_dim - 1] = 0.0;

			return TridiagonalMatrix(_dim, newBelowDiag, _diag, newAboveDiag);
		}

		TridiagonalMatrix GetInverse() const
		{
			// For tridiagonal matrices, computing the exact inverse is complex
			// and often results in a full matrix (not tridiagonal)
			// This would require returning a full Matrix<Type> instead
			throw std::runtime_error("TridiagonalMatrix::GetInverse() - "
				"inverse of tridiagonal matrix is generally not tridiagonal. "
				"Use Matrix<Type> conversion or solve linear systems directly with Solve()");
		}

		void Solve(const Vector<Type>& rhs, Vector<Type>& sol)
		{
			int j, n = _belowDiag.size();
			Real bet;
			Vector<Type> gam(n);

			if (_diag[0] == 0.0)
				throw("Error 1 in tridag");

			sol[0] = rhs[0] / (bet = _diag[0]);

			for (j = 1; j < n; j++) {
				gam[j] = _aboveDiag[j - 1] / bet;
				bet = _diag[j] - _belowDiag[j] * gam[j];

				if (bet == 0.0)
					throw("Error 2 in tridag");

				sol[j] = (rhs[j] - _belowDiag[j] * sol[j - 1]) / bet;
			}
			for (j = (n - 2); j >= 0; j--)
				sol[j] -= gam[j + 1] * sol[j + 1];
		}
		Vector<Type> Solve(const Vector<Type>& rhs)
		{
			Vector<Type> sol(rhs.size());
			Solve(rhs, sol);
			return sol;
		}

		// New formatted print with MatrixPrintFormat
		void Print(std::ostream& stream, const MatrixPrintFormat& fmt = MatrixPrintFormat::Default()) const
		{
			// Show header if requested
			if (fmt.showHeader) {
				stream << "Rows: " << _dim << " Cols: " << _dim << " (Tridiagonal)" << std::endl;
			}

			// Set formatting flags
			std::ios_base::fmtflags oldFlags = stream.flags();
			if (fmt.scientific)
				stream << std::scientific;
			else if (fmt.fixed)
				stream << std::fixed;

			// Compact mode - print on one line for small matrices
			if (fmt.compactMode && _dim <= 3) {
				if (fmt.showBrackets)
					stream << "[";
				for (int i = 0; i < _dim; i++) {
					if (i > 0) stream << "; ";
					for (int j = 0; j < _dim; j++) {
						if (j > 0) stream << fmt.delimiter;
						stream << std::setw(fmt.width) << std::setprecision(fmt.precision) << (*this)(i, j);
					}
				}
				if (fmt.showBrackets)
					stream << "]";
				stream << std::endl;
			}
			else {
				// Normal multi-line mode
				for (int i = 0; i < _dim; i++)
				{
					if (fmt.showBrackets)
						stream << "[ ";
					for (int j = 0; j < _dim; j++)
					{
						stream << std::setw(fmt.width) << std::setprecision(fmt.precision) << (*this)(i, j);
						if (j < _dim - 1)
							stream << fmt.delimiter;
					}
					if (fmt.showBrackets)
						stream << " ]";
					if (i < _dim - 1)
						stream << std::endl;
				}
			}

			// Restore original flags
			stream.flags(oldFlags);
		}

		// Legacy print method (backward compatibility)
		void   Print(std::ostream& stream, int width, int precision) const
		{
			MatrixPrintFormat fmt = MatrixPrintFormat::Default();
			fmt.width = width;
			fmt.precision = precision;
			Print(stream, fmt);
		}
	};
}


///////////////////////////   mml/base/MatrixBandDiag.h   ///////////////////////////



namespace MML
{
	class BandDiagonalMatrix
	{
		// The array a[0..n-1][0..m1+m2] stores A as follows: The diagonal elements are in a[0..n-1][m1].
		// Subdiagonal elements are in a[j..n-1][0..m1-1] with j > 0 appropriate to the number of
		// elements on each subdiagonal. Superdiagonal elements are in a[0..j][m1+1..m1+m2] with
		// j < n-1 appropriate to the number of elements on each superdiagonal.        
		int _dim;
		int _m1, _m2;
		Matrix<Real> _data;

	public:
		int RowNum() const { return _dim; }
		int ColNum() const { return _dim; }

		BandDiagonalMatrix(int dim, int m1, int m2, const Matrix<Real>& data) : _dim(dim), _m1(m1), _m2(m2), _data(data)
		{
			if (data.RowNum() != dim || data.ColNum() != m1 + m2 + 1)
				throw("Error in BandDiagonalMatrix constructor: wrong dimensions");
		}

		Real  operator()(int i, int j) const {
			if (i > j + _m1 || j > i + _m2)
				return 0.0;
			else
				return _data[i][j - i + _m1];
		}
		Real& operator()(int i, int j) {
			if (i > j + _m1 || j > i + _m2)
				throw MatrixAccessBoundsError("BandDiagonalMatrix::operator()", i, j, _dim, _dim);
			else
				return _data[i][j - i + _m1];
		}


	// Matrix-vector multiplication for band diagonal matrix
	// Optimized to only multiply non-zero elements
	Vector<Real> operator*(const Vector<Real>& x) const
	{
		if (x.size() != _dim)
			throw std::invalid_argument("BandDiagonalMatrix::operator* - Vector size mismatch");

		Vector<Real> result(_dim);
		for (int i = 0; i < _dim; i++)
		{
			Real sum = 0.0;
			// Only iterate over the band (non-zero elements)
			int j_start = std::max(0, i - _m1);
			int j_end = std::min(_dim - 1, i + _m2);
			
			for (int j = j_start; j <= j_end; j++)
			{
				sum += (*this)(i, j) * x[j];
			}
			result[i] = sum;
		}
		return result;
	}

	// Get full matrix representation (for debugging/testing)
	Matrix<Real> ToFullMatrix() const
	{
		Matrix<Real> full(_dim, _dim);
		for (int i = 0; i < _dim; i++)
		{
			for (int j = 0; j < _dim; j++)
			{
				full[i][j] = (*this)(i, j);
			}
		}
		return full;
	}

	// Get bandwidth information
	int GetLowerBandwidth() const { return _m1; }
	int GetUpperBandwidth() const { return _m2; }
	int GetDimension() const { return _dim; }

	// Check if element is within the band
	bool IsInBand(int i, int j) const
	{
		return !(i > j + _m1 || j > i + _m2);
	}

	///////////////////     ARITHMETIC OPERATIONS     ///////////////////

	// Scalar multiplication
	BandDiagonalMatrix operator*(Real scalar) const
	{
		Matrix<Real> new_data = _data * scalar;
		return BandDiagonalMatrix(_dim, _m1, _m2, new_data);
	}

	// Scalar division
	BandDiagonalMatrix operator/(Real scalar) const
	{
		if (std::abs(scalar) < PrecisionValues<Real>::MatrixElementZeroThreshold)
			throw std::invalid_argument("BandDiagonalMatrix::operator/ - Division by zero");
		Matrix<Real> new_data = _data / scalar;
		return BandDiagonalMatrix(_dim, _m1, _m2, new_data);
	}

	// Unary negation
	BandDiagonalMatrix operator-() const
	{
		Matrix<Real> new_data = -_data;
		return BandDiagonalMatrix(_dim, _m1, _m2, new_data);
	}

	// Matrix addition (requires compatible bandwidth)
	BandDiagonalMatrix operator+(const BandDiagonalMatrix& other) const
	{
		if (_dim != other._dim || _m1 != other._m1 || _m2 != other._m2)
			throw std::invalid_argument("BandDiagonalMatrix::operator+ - Incompatible dimensions or bandwidth");
		
		Matrix<Real> new_data = _data + other._data;
		return BandDiagonalMatrix(_dim, _m1, _m2, new_data);
	}

	// Matrix subtraction (requires compatible bandwidth)
	BandDiagonalMatrix operator-(const BandDiagonalMatrix& other) const
	{
		if (_dim != other._dim || _m1 != other._m1 || _m2 != other._m2)
			throw std::invalid_argument("BandDiagonalMatrix::operator- - Incompatible dimensions or bandwidth");
		
		Matrix<Real> new_data = _data - other._data;
		return BandDiagonalMatrix(_dim, _m1, _m2, new_data);
	}

	// In-place scalar multiplication
	BandDiagonalMatrix& operator*=(Real scalar)
	{
		_data *= scalar;
		return *this;
	}

	// In-place scalar division
	BandDiagonalMatrix& operator/=(Real scalar)
	{
		if (std::abs(scalar) < PrecisionValues<Real>::MatrixElementZeroThreshold)
			throw std::invalid_argument("BandDiagonalMatrix::operator/= - Division by zero");
		_data /= scalar;
		return *this;
	}

	// In-place addition
	BandDiagonalMatrix& operator+=(const BandDiagonalMatrix& other)
	{
		if (_dim != other._dim || _m1 != other._m1 || _m2 != other._m2)
			throw std::invalid_argument("BandDiagonalMatrix::operator+= - Incompatible dimensions or bandwidth");
		
		_data += other._data;
		return *this;
	}

	// In-place subtraction
	BandDiagonalMatrix& operator-=(const BandDiagonalMatrix& other)
	{
		if (_dim != other._dim || _m1 != other._m1 || _m2 != other._m2)
			throw std::invalid_argument("BandDiagonalMatrix::operator-= - Incompatible dimensions or bandwidth");
		
		_data -= other._data;
		return *this;
	}

	///////////////////     MATRIX PROPERTIES     ///////////////////

	// Trace (sum of diagonal elements)
	Real Trace() const
	{
		Real trace = 0.0;
		for (int i = 0; i < _dim; i++)
			trace += (*this)(i, i);
		return trace;
	}

	// Frobenius norm (sqrt of sum of squares of all elements)
	Real NormFrobenius() const
	{
		Real sum = 0.0;
		for (int i = 0; i < _dim; i++)
		{
			int j_start = std::max(0, i - _m1);
			int j_end = std::min(_dim - 1, i + _m2);
			for (int j = j_start; j <= j_end; j++)
			{
				Real val = (*this)(i, j);
				sum += val * val;
			}
		}
		return std::sqrt(sum);
	}

	// Maximum absolute value of elements
	Real NormInf() const
	{
		Real max_val = 0.0;
		for (int i = 0; i < _dim; i++)
		{
			Real row_sum = 0.0;
			int j_start = std::max(0, i - _m1);
			int j_end = std::min(_dim - 1, i + _m2);
			for (int j = j_start; j <= j_end; j++)
				row_sum += std::abs((*this)(i, j));
			max_val = std::max(max_val, row_sum);
		}
		return max_val;
	}

	// Transpose (swaps upper and lower bandwidth)
	BandDiagonalMatrix Transpose() const
	{
		// For transpose, m1 and m2 are swapped
		Matrix<Real> trans_data(_dim, _m1 + _m2 + 1);
		
		for (int i = 0; i < _dim; i++)
		{
			int j_start = std::max(0, i - _m1);
			int j_end = std::min(_dim - 1, i + _m2);
			for (int j = j_start; j <= j_end; j++)
			{
				// A^T[j][i] = A[i][j]
				// In band storage: trans_data[j][i - j + m2] = data[i][j - i + m1]
				trans_data[j][i - j + _m2] = _data[i][j - i + _m1];
			}
		}
		
		return BandDiagonalMatrix(_dim, _m2, _m1, trans_data);
	}

	// Check if matrix is symmetric
	bool IsSymmetric(Real tolerance = 1e-10) const
	{
		if (_m1 != _m2)
			return false;  // Symmetric requires equal bandwidths
		
		for (int i = 0; i < _dim; i++)
		{
			int j_start = std::max(0, i - _m1);
			int j_end = std::min(_dim - 1, i + _m2);
			for (int j = j_start; j <= j_end; j++)
			{
				if (std::abs((*this)(i, j) - (*this)(j, i)) > tolerance)
					return false;
			}
		}
		return true;
	}

	// Equality comparison
	bool IsEqual(const BandDiagonalMatrix& other, Real tolerance = 1e-10) const
	{
		if (_dim != other._dim || _m1 != other._m1 || _m2 != other._m2)
			return false;
		
		return _data.IsEqualTo(other._data, tolerance);
	}

	// Get diagonal as vector
	Vector<Real> GetDiagonal() const
	{
		Vector<Real> diag(_dim);
		for (int i = 0; i < _dim; i++)
			diag[i] = (*this)(i, i);
		return diag;
	}

	// Get subdiagonal k (k=0 is main diagonal, k>0 is below, k<0 is above)
	Vector<Real> GetDiagonal(int k) const
	{
		if (k > _m1 || k < -_m2)
			throw std::invalid_argument("BandDiagonalMatrix::GetDiagonal - Diagonal outside band");
		
		int diag_length;
		int start_row, start_col;
		
		if (k >= 0)
		{
			// Below or on main diagonal
			diag_length = _dim - k;
			start_row = k;
			start_col = 0;
		}
		else
		{
			// Above main diagonal
			diag_length = _dim + k;
			start_row = 0;
			start_col = -k;
		}
		
		Vector<Real> diag(diag_length);
		for (int i = 0; i < diag_length; i++)
			diag[i] = (*this)(start_row + i, start_col + i);
		
		return diag;
	}

		void   Print(std::ostream& stream, int width, int precision) const
		{
			stream << "Dim: " << _dim << std::endl;
			for (int i = 0; i < _dim; i++)
			{
				stream << "[ ";
				for (int j = 0; j < _dim; j++) {
					stream << std::setw(width) << std::setprecision(precision) << (*this)(i, j) << ", ";
				}
				stream << " ]" << std::endl;
			}
		}
	};

	// Friend function for scalar * matrix
	inline BandDiagonalMatrix operator*(Real scalar, const BandDiagonalMatrix& mat)
	{
		return mat * scalar;
	}
}


///////////////////////////   mml/base/Tensor.h   ///////////////////////////





namespace MML
{
	template <int N>
	class Tensor2 : public ITensor2<N>
	{
		MatrixNM<Real, N, N> _coeff;
	public:
		int _numContravar = 0;
		int _numCovar = 0;
		bool _isContravar[2];

		Tensor2(int nCovar, int nContraVar) : _numContravar(nContraVar), _numCovar(nCovar)
		{
			if ( _numContravar < 0 || _numCovar  < 0 || _numContravar + _numCovar != 2 )
				throw TensorCovarContravarNumError("Tensor2 ctor, wrong number of contravariant and covariant indices", nCovar, nContraVar);

			for (int i = 0; i < _numCovar; i++)
				_isContravar[i] = false;

			for (int i = _numCovar; i < _numCovar + _numContravar; i++)
				_isContravar[i] = true;
		}
		Tensor2(int nCovar, int nContraVar, std::initializer_list<Real> values) : _numContravar(nContraVar), _numCovar(nCovar)
		{
			if ( _numContravar < 0 || _numCovar  < 0 || _numContravar + _numCovar != 2 )
				throw TensorCovarContravarNumError("Tensor2 ctor, wrong number of covariant and contravariant indices", nCovar, nContraVar);

			for (int i = 0; i < _numCovar; i++)
				_isContravar[i] = false;

			for (int i = _numCovar; i < _numCovar + _numContravar; i++)
				_isContravar[i] = true;

			auto val = values.begin();
			for (size_t i = 0; i < N; ++i)
				for (size_t j = 0; j < N; ++j)
					if (val != values.end())
						_coeff[i][j] = *val++;
					else
						_coeff[i][j] = 0.0;
		}

		int  NumContravar() const override { return _numContravar; }
		int  NumCovar()     const override { return _numCovar; }

		MatrixNM<Real, N, N> GetMatrix() const {	return _coeff; }

		bool IsContravar(int i) const { return _isContravar[i]; }
		bool IsCovar(int i) const			{ return !_isContravar[i]; }

		Real  operator()(int i, int j) const override { 
			assert(i >= 0 && i < N && "Tensor2: index i out of bounds");
			assert(j >= 0 && j < N && "Tensor2: index j out of bounds");
			return _coeff[i][j]; 
		}
		Real& operator()(int i, int j) override { 
			assert(i >= 0 && i < N && "Tensor2: index i out of bounds");
			assert(j >= 0 && j < N && "Tensor2: index j out of bounds");
			return _coeff[i][j]; 
		}
		
		// Checked access with exceptions
		Real at(int i, int j) const {
			if (i < 0 || i >= N || j < 0 || j >= N)
				throw TensorIndexError("Tensor2::at - index out of bounds");
			return _coeff[i][j];
		}
		Real& at(int i, int j) {
			if (i < 0 || i >= N || j < 0 || j >= N)
				throw TensorIndexError("Tensor2::at - index out of bounds");
			return _coeff[i][j];
		}

		Tensor2 operator+(const Tensor2& other) const
		{
			if (_numContravar != other._numContravar || _numCovar != other._numCovar)
				throw TensorCovarContravarArithmeticError("Tensor2 operator+, wrong number of contravariant and covariant indices", _numContravar, _numCovar, other._numContravar, other._numCovar);

			Tensor2 result(_numContravar, _numCovar);

			result._coeff = _coeff + other._coeff;

			return result;
		}
		Tensor2 operator-(const Tensor2& other) const
		{
			if (_numContravar != other._numContravar || _numCovar != other._numCovar)
				throw TensorCovarContravarArithmeticError("Tensor2 operator-, wrong number of contravariant and covariant indices", _numContravar, _numCovar, other._numContravar, other._numCovar);

			Tensor2 result(_numContravar, _numCovar);

			result._coeff = _coeff - other._coeff;

			return result;
		}
		Tensor2 operator*(Real scalar) const
		{
			Tensor2 result(_numContravar, _numCovar);

			result._coeff = _coeff * scalar;

			return result;
		}
		Tensor2 operator/(Real scalar) const
		{
			Tensor2 result(_numContravar, _numCovar);

			result._coeff = _coeff / scalar;

			return result;
		}

		friend Tensor2 operator*(Real scalar, const Tensor2& b)
		{
			Tensor2 result(b.NumContravar(), b.NumCovar());

			result._coeff = b._coeff * scalar;

			return result;
		}

		Real Contract() const
		{
			if (_numContravar != 1 || _numCovar != 1)
				throw TensorCovarContravarNumError("Tensor2 Contract, wrong number of contravariant and covariant indices", _numContravar, _numCovar);

			Real result = 0.0;
			for (int i = 0; i < N; i++)
				result += _coeff[i][i];

			return result;
		}
		Real operator()(const VectorN<Real, N>& v1, const VectorN<Real, N>& v2) const
		{
			Real sum = 0.0;
			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					sum += _coeff[i][j] * v1[i] * v2[j];

			return sum;
		}

		void   Print(std::ostream& stream, int width, int precision) const
		{
			stream << std::fixed << "(N = " << N << ")" << std::endl;

			for (size_t i = 0; i < N; i++)
			{
				stream << "[ ";
				for (size_t j = 0; j < N; j++)
					stream << std::setw(width) << std::setprecision(precision) << _coeff[i][j] << ", ";
				stream << " ]" << std::endl;
			}
		}
		friend std::ostream& operator<<(std::ostream& stream, const Tensor2& a)
		{
			a.Print(stream, 15, 10);

			return stream;
		}
	};

	template <int N>
	class Tensor3 : public ITensor3<N>
	{
		Real _coeff[N][N][N] = { 0 };
	public:
		int _numContravar;
		int _numCovar;
		bool _isContravar[3];

		Tensor3(int nCovar, int nContraVar) : _numContravar(nContraVar), _numCovar(nCovar)
		{
			if (_numContravar + _numCovar != 3)
				throw TensorCovarContravarNumError("Tensor3 ctor, wrong number of contravariant and covariant indices", nCovar, nContraVar);

			for (int i = 0; i < _numCovar; i++)
				_isContravar[i] = false;

			for (int i = _numCovar; i < _numCovar + _numContravar; i++)
				_isContravar[i] = true;
		}
		Tensor3(int nCovar, int nContraVar, std::initializer_list<Real> values) : _numContravar(nContraVar), _numCovar(nCovar)
		{
			if (_numContravar + _numCovar != 3)
				throw TensorCovarContravarNumError("Tensor3 ctor, wrong number of contravariant and covariant indices", nCovar, nContraVar);
			
			for (int i = 0; i < _numCovar; i++)
				_isContravar[i] = false;
			
			for (int i = _numCovar; i < _numCovar + _numContravar; i++)
				_isContravar[i] = true;
			
			auto val = values.begin();
			for (size_t i = 0; i < N; ++i)
				for (size_t j = 0; j < N; ++j)
					for (size_t k = 0; k < N; ++k)
						if (val != values.end())
							_coeff[i][j][k] = *val++;
						else
							_coeff[i][j][k] = 0.0;
		}

		int   NumContravar() const override { return _numContravar; }
		int   NumCovar()     const override { return _numCovar; }

		Real  operator()(int i, int j, int k) const override { 
			assert(i >= 0 && i < N && "Tensor3: index i out of bounds");
			assert(j >= 0 && j < N && "Tensor3: index j out of bounds");
			assert(k >= 0 && k < N && "Tensor3: index k out of bounds");
			return _coeff[i][j][k]; 
		}
		Real& operator()(int i, int j, int k) override { 
			assert(i >= 0 && i < N && "Tensor3: index i out of bounds");
			assert(j >= 0 && j < N && "Tensor3: index j out of bounds");
			assert(k >= 0 && k < N && "Tensor3: index k out of bounds");
			return _coeff[i][j][k]; 
		}
		
		// Checked access with exceptions
		Real at(int i, int j, int k) const {
			if (i < 0 || i >= N || j < 0 || j >= N || k < 0 || k >= N)
				throw TensorIndexError("Tensor3::at - index out of bounds");
			return _coeff[i][j][k];
		}
		Real& at(int i, int j, int k) {
			if (i < 0 || i >= N || j < 0 || j >= N || k < 0 || k >= N)
				throw TensorIndexError("Tensor3::at - index out of bounds");
			return _coeff[i][j][k];
		}

		Real operator()(const VectorN<Real, N>& v1, const VectorN<Real, N>& v2, const VectorN<Real, N>& v3) const
		{
			Real sum = 0.0;
			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					for (int k = 0; k < N; k++)
						sum += _coeff[i][j][k] * v1[i] * v2[j] * v3[k];

			return sum;
		}

		VectorN<Real, N> Contract(int ind1, int ind2) const
		{
			VectorN<Real, N> result;

			if (ind1 < 0 || ind1 >= N || ind2 < 0 || ind2 >= N)
				throw TensorIndexError("Tensor3 Contract, wrong index");

			if (ind1 == ind2)
				throw TensorIndexError("Tensor3 Contract, indices are the same");

			if (ind1 == 0 && ind2 == 1)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						result[i] += _coeff[j][j][i];
			}
			else if (ind1 == 0 && ind2 == 2)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						result[i] += _coeff[j][i][j];
			}
			else if (ind1 == 1 && ind2 == 2)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						result[i] += _coeff[i][j][j];
			}
			else
				throw TensorIndexError("Tensor3 Contract, wrong indices");

			return result;
		}
	};

	template <int N>
	class Tensor4 : public ITensor4<N>
	{
		Real _coeff[N][N][N][N] = { 0 };
	public:
		int _numContravar;
		int _numCovar;
		bool _isContravar[4];

		Tensor4(int nCovar, int nContraVar) : _numContravar(nContraVar), _numCovar(nCovar) 
		{
			if (_numContravar + _numCovar != 4)
				throw TensorCovarContravarNumError("Tensor4 ctor, wrong number of contravariant and covariant indices", nCovar, nContraVar);

			for (int i = 0; i < _numCovar; i++)
				_isContravar[i] = false;

			for (int i = _numCovar; i < _numCovar + _numContravar; i++)
				_isContravar[i] = true;
		}

		int   NumContravar() const override { return _numContravar; }
		int   NumCovar()     const override { return _numCovar; }

		Real  operator()(int i, int j, int k, int l) const override { 
			assert(i >= 0 && i < N && "Tensor4: index i out of bounds");
			assert(j >= 0 && j < N && "Tensor4: index j out of bounds");
			assert(k >= 0 && k < N && "Tensor4: index k out of bounds");
			assert(l >= 0 && l < N && "Tensor4: index l out of bounds");
			return _coeff[i][j][k][l]; 
		}
		Real& operator()(int i, int j, int k, int l) override { 
			assert(i >= 0 && i < N && "Tensor4: index i out of bounds");
			assert(j >= 0 && j < N && "Tensor4: index j out of bounds");
			assert(k >= 0 && k < N && "Tensor4: index k out of bounds");
			assert(l >= 0 && l < N && "Tensor4: index l out of bounds");
			return _coeff[i][j][k][l]; 
		}
		
		// Checked access with exceptions
		Real at(int i, int j, int k, int l) const {
			if (i < 0 || i >= N || j < 0 || j >= N || k < 0 || k >= N || l < 0 || l >= N)
				throw TensorIndexError("Tensor4::at - index out of bounds");
			return _coeff[i][j][k][l];
		}
		Real& at(int i, int j, int k, int l) {
			if (i < 0 || i >= N || j < 0 || j >= N || k < 0 || k >= N || l < 0 || l >= N)
				throw TensorIndexError("Tensor4::at - index out of bounds");
			return _coeff[i][j][k][l];
		}

		Real operator()(const VectorN<Real, N>& v1, const VectorN<Real, N>& v2, const VectorN<Real, N>& v3, const VectorN<Real, N>& v4) const
		{
			Real sum = 0.0;
			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					for (int k = 0; k < N; k++)
						for (int l = 0; l < N; l++)
							sum += _coeff[i][j][k][l] * v1[i] * v2[j] * v3[k] * v4[l];

			return sum;
		}

		Tensor2<N> Contract(int ind1, int ind2) const
		{
			MatrixNM<Real, N, N> result;
			Tensor2<N> ret;

			// check covar contravar!!!!
			if (ind1 < 0 || ind1 >= N || ind2 < 0 || ind2 >= N)
				throw TensorIndexError("Tensor4 Contract, wrong index");

			if (ind1 == ind2)
				throw TensorIndexError("Tensor4 Contract, indices are the same");

			if (ind1 == 0 && ind2 == 1)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						for(int k = 0; k < N; k++)
							result[i][j] += _coeff[k][k][i][j];
			}
			else if (ind1 == 0 && ind2 == 2)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						for(int k = 0; k < N; k++)
							result[i][j] += _coeff[k][i][k][j];
			}
			else if (ind1 == 0 && ind2 == 3)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						for(int k = 0; k < N; k++)
							result[i][j] += _coeff[k][i][j][k];
			}
			else if (ind1 == 1 && ind2 == 2)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						for(int k = 0; k < N; k++)
							result[i][j] += _coeff[i][k][k][j];
			}
			else if (ind1 == 1 && ind2 == 3)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						for(int k = 0; k < N; k++)
							result[i][j] += _coeff[i][k][j][k];
			}
			else if (ind1 == 2 && ind2 == 3)
			{
				for (int i = 0; i < N; i++)
					for (int j = 0; j < N; j++)
						for(int k = 0; k < N; k++)
							result[i][j] += _coeff[i][j][k][k];
			}
			else
				throw TensorIndexError("Tensor4 Contract, wrong indices");

			ret._coeff = result;

			return ret;
		}
	};

	template <int N>
	class Tensor5 : public ITensor5<N>
	{
		Real _coeff[N][N][N][N][N];
	public:
		int _numContravar;
		int _numCovar;
		bool _isContravar[5];

		Tensor5(int nCovar, int nContraVar) : _numContravar(nContraVar), _numCovar(nCovar) 
		{
			if (_numContravar + _numCovar != 5)
				throw TensorCovarContravarNumError("Tensor5 ctor, wrong number of contravariant and covariant indices", nCovar, nContraVar);

			for (int i = 0; i < _numCovar; i++)
				_isContravar[i] = false;

			for (int i = _numCovar; i < _numCovar + _numContravar; i++)
				_isContravar[i] = true;

		}

		int   NumContravar() const override { return _numContravar; }
		int   NumCovar()     const override { return _numCovar; }

		Real  operator()(int i, int j, int k, int l, int m) const override { 
			assert(i >= 0 && i < N && "Tensor5: index i out of bounds");
			assert(j >= 0 && j < N && "Tensor5: index j out of bounds");
			assert(k >= 0 && k < N && "Tensor5: index k out of bounds");
			assert(l >= 0 && l < N && "Tensor5: index l out of bounds");
			assert(m >= 0 && m < N && "Tensor5: index m out of bounds");
			return _coeff[i][j][k][l][m]; 
		}
		Real& operator()(int i, int j, int k, int l, int m) override { 
			assert(i >= 0 && i < N && "Tensor5: index i out of bounds");
			assert(j >= 0 && j < N && "Tensor5: index j out of bounds");
			assert(k >= 0 && k < N && "Tensor5: index k out of bounds");
			assert(l >= 0 && l < N && "Tensor5: index l out of bounds");
			assert(m >= 0 && m < N && "Tensor5: index m out of bounds");
			return _coeff[i][j][k][l][m]; 
		}
		
		// Checked access with exceptions
		Real at(int i, int j, int k, int l, int m) const {
			if (i < 0 || i >= N || j < 0 || j >= N || k < 0 || k >= N || l < 0 || l >= N || m < 0 || m >= N)
				throw TensorIndexError("Tensor5::at - index out of bounds");
			return _coeff[i][j][k][l][m];
		}
		Real& at(int i, int j, int k, int l, int m) {
			if (i < 0 || i >= N || j < 0 || j >= N || k < 0 || k >= N || l < 0 || l >= N || m < 0 || m >= N)
				throw TensorIndexError("Tensor5::at - index out of bounds");
			return _coeff[i][j][k][l][m];
		}
	};
}

///////////////////////////   mml/interfaces/IFunction.h   ///////////////////////////



namespace MML
{
	//////////////////////////////////////////////////////////////////////
	template<typename _RetType, typename _ArgType>
	class IFunction
	{
	public:
		virtual _RetType operator()(_ArgType) const = 0;

		virtual ~IFunction() {}
	};

	//////////////////////////////////////////////////////////////////////
	class IRealFunction : public IFunction<Real, Real>
	{
	public:
		virtual Real operator()(Real) const = 0;
		
		void GetValues(Real x1, Real x2, int numPnt, Vector<Real>& outX, Vector<Real>& outY) const
		{
			outX.Resize(numPnt);
			outY.Resize(numPnt);

			for (int i = 0; i < numPnt; i++) {
				outX[i] = x1 + i * (x2 - x1) / (numPnt - 1);
				outY[i] = (*this)(outX[i]);
			}
		}

		virtual ~IRealFunction() {}
	};

	class IRealFunctionParametrized : public IRealFunction
	{
	public:
		virtual int		getNumParam() const = 0;
		virtual Real	getParam(int i) const = 0;
		virtual void	setParam(int i, Real val) = 0;

		virtual Vector<Real>	getParams() const = 0;
		virtual void					setParams(const Vector<Real>&) = 0;
	};

	//////////////////////////////////////////////////////////////////////
	template<int N>
	class IScalarFunction : public IFunction<Real, const VectorN<Real, N>&>
	{
	public:
		virtual Real operator()(const VectorN<Real, N>& x) const = 0;

		virtual ~IScalarFunction() {}
	};

	template<int N>
	class IScalarFunctionParametrized : public IScalarFunction<N>
	{
	public:
		virtual int		getNumParam() const = 0;
		virtual Real	getParam(int i) const = 0;
		virtual void	setParam(int i, Real val) = 0;

		virtual Vector<Real>	getParams() const = 0;
		virtual void					setParams(const Vector<Real>&) = 0;
	};

	//////////////////////////////////////////////////////////////////////
	template<int N>
	class IRealToVectorFunction : public IFunction<VectorN<Real, N>, Real>
	{
	public:
		virtual VectorN<Real, N> operator()(Real x) const = 0;

		virtual ~IRealToVectorFunction() {}
	};

	//////////////////////////////////////////////////////////////////////
	template<int N>
	class IVectorFunction : public IFunction<VectorN<Real, N>, const VectorN<Real, N>&>
	{
	public:
		virtual VectorN<Real, N> operator()(const VectorN<Real, N>& x) const = 0;

		virtual ~IVectorFunction() {}
	};

	template<int N>
	class IVectorFunctionParametrized : public IVectorFunction<N>
	{
	public:
		virtual int		getNumParam() const = 0;
		virtual Real	getParam(int i) const = 0;
		virtual void	setParam(int i, Real val) = 0;

		virtual Vector<Real>	getParams() const = 0;
		virtual void					setParams(const Vector<Real>&) = 0;
	};

	//////////////////////////////////////////////////////////////////////
	template<int N, int M>
	class IVectorFunctionNM : public IFunction<VectorN<Real, M>, const VectorN<Real, N>&>
	{
	public:
		virtual VectorN<Real, M> operator()(const VectorN<Real, N>& x) const = 0;
		
		virtual Real operator()(const VectorN<Real, N>& x, int component) const
		{
			VectorN<Real, M> val = (*this)(x);
			return val[component];
		}
		
		virtual ~IVectorFunctionNM() {}
	};

	//////////////////////////////////////////////////////////////////////
	template<int N>
	class IParametricCurve : public IRealToVectorFunction<N>
	{
	public:
		virtual Real getMinT() const = 0;
		virtual Real getMaxT() const = 0;

		std::vector<VectorN<Real, N>> GetTrace(double t1, double t2, int numPoints) const
		{
			std::vector<VectorN<Real, N>> ret;
                        Real deltaT = (t2 - t1) / (numPoints - 1);
		}

		virtual ~IParametricCurve() {}
	};

	template<int N>
	class IParametricCurveParametrized : public IParametricCurve<N>
	{
	public:
			virtual int		getNumParam() const = 0;
			virtual Real	getParam(int i) const = 0;
			virtual void	setParam(int i, Real val) = 0;

			virtual VectorN<Real, N> operator()(Real t, const Vector<Real> &params) = 0;
	};

	//////////////////////////////////////////////////////////////////////
	// complex surface, with fixed u limits, but variable w limits (dependent on u)
	template<int N>
	class IParametricSurface : public IVectorFunctionNM<2, N>
	{
	public:
		virtual VectorN<Real, N> operator()(Real u, Real w) const = 0;

		virtual Real getMinU() const = 0;
		virtual Real getMaxU() const = 0;
		virtual Real getMinW(Real u) const = 0;
		virtual Real getMaxW(Real u) const = 0;

		virtual VectorN<Real, N> operator()(const VectorN<Real, 2>& coord) const
		{
			return operator()(coord[0], coord[1]);
		}

		virtual ~IParametricSurface() {}
	};

	// simple regular surface, defined on rectangular coordinate patch
	template<int N>
	class IParametricSurfaceRect : public IVectorFunctionNM<2, N>
	{
	public:
		virtual VectorN<Real, N> operator()(Real u, Real w) const = 0;

		virtual Real getMinU() const = 0;
		virtual Real getMaxU() const = 0;
		virtual Real getMinW() const = 0;
		virtual Real getMaxW() const = 0;

		virtual VectorN<Real, N> operator()(const VectorN<Real, 2>& coord) const
		{
			return operator()(coord[0], coord[1]);
		}

		virtual ~IParametricSurfaceRect() {}
	};
}

///////////////////////////   mml/interfaces/IODESystem.h   ///////////////////////////



namespace MML
{
	class IODESystem
	{
	public:
		virtual ~IODESystem() = default;
		virtual int   getDim() const = 0;
		virtual void  derivs(const Real t, const Vector<Real> &x, Vector<Real> &dxdt) const = 0;

		// overridable function for providing variable names
		virtual std::string getVarName(int ind) const
		{
			if (ind < 0 || ind >= getDim())
				return "var" + std::to_string(ind);

			return "var" + std::to_string(ind + 1); // 1-based index 
		}
	};

	class IODESystemWithJacobian : public IODESystem
	{
	public:
		virtual void jacobian(const Real t, const Vector<Real>& x, Vector<Real>& dxdt, Matrix<Real>& dydx) const = 0;
	};

	class IODESystemParametrized : public IODESystem
	{
	public:
		virtual int		getNumParam() const = 0;
		virtual Real	getParam(int i) const = 0;
		virtual void	setParam(int i, Real val) = 0;

		virtual Vector<Real>	getParams() const = 0;
		virtual void					setParams(const Vector<Real>&) = 0;

	};

}

///////////////////////////   mml/interfaces/ICoordTransf.h   ///////////////////////////




namespace MML
{
	template<typename VectorFrom, typename VectorTo, int N>
	class ICoordTransf : public IVectorFunction<N>
	{
	public:
		virtual       VectorTo            transf(const VectorFrom& in) const = 0;
		virtual const IScalarFunction<N>& coordTransfFunc(int i) const = 0;

		virtual ~ICoordTransf() {}
	};

	template<typename VectorFrom, typename VectorTo, int N>
	class ICoordTransfWithInverse : public virtual ICoordTransf<VectorFrom, VectorTo, N>
	{
	public:
		virtual       VectorFrom          transfInverse(const VectorTo& in) const = 0;
		virtual const IScalarFunction<N>& inverseCoordTransfFunc(int i) const = 0;

		virtual ~ICoordTransfWithInverse() {}
	};
}

///////////////////////////   mml/interfaces/ITensorField.h   ///////////////////////////




namespace MML
{
	//////////////////////////////////////////////////////////////////////
	template<int N>
	class ITensorField2 : public IFunction<Tensor2<N>, const VectorN<Real, N>& >
	{
		int _numContravar;
		int _numCovar;
	public:
		ITensorField2(int numContra, int numCo) : _numContravar(numContra), _numCovar(numCo) {}

		int getNumContravar() const { return _numContravar; }
		int getNumCovar()			const { return _numCovar; }

		// concrete implementations need to provide this 
		virtual Real Component(int i, int j, const VectorN<Real, N>& pos) const = 0;

		virtual ~ITensorField2() {}
	};

	template<int N>
	class ITensorField3 : public IFunction<Tensor3<N>, const VectorN<Real, N>& >
	{
		int _numContravar;
		int _numCovar;
	public:
		int getNumContravar() const { return _numContravar; }
		int getNumCovar() const { return _numCovar; }

		virtual Real    Component(int i, int j, int k, const VectorN<Real, N>& pos) const = 0;

		virtual ~ITensorField3() {}
	};

	template<int N>
	class ITensorField4 : public IFunction<Tensor4<N>, const VectorN<Real, N>& >
	{
		int _numContravar;
		int _numCovar;
	public:
		int getNumContravar() const { return _numContravar; }
		int getNumCovar() const { return _numCovar; }

		virtual Real    Component(int i, int j, int k, int l, const VectorN<Real, N>& pos) const = 0;

		virtual ~ITensorField4() {}
	};

	template<int N>
	class ITensorField5 : public IFunction<Tensor5<N>, const VectorN<Real, N>& >
	{
		int _numContravar;
		int _numCovar;
	public:
		int getNumContravar() const { return _numContravar; }
		int getNumCovar() const { return _numCovar; }

		virtual Real    Component(int i, int j, int k, int l, int m, const VectorN<Real, N>& pos) const = 0;
		virtual ~ITensorField5() {}
	};
}

///////////////////////////   mml/interfaces/IODESystemStepCalculator.h   ///////////////////////////




namespace MML
{
	class IODESystemStepCalculator
	{
	public:
		virtual void calcStep(const IODESystem& odeSystem, 
													const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
													const Real h, Vector<Real>& xout, Vector<Real>& xerr) const = 0;
	};
}

///////////////////////////   mml/interfaces/IODESystemStepper.h   ///////////////////////////




namespace MML
{
	class IODESystemStepper	{
	public:
		virtual void doStep(const IODESystem& odeSystem, 
												const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
												const Real h, Vector<Real>& xout, Vector<Real>& xerr) = 0;
	};
}

///////////////////////////   mml/base/BaseUtils.h   ///////////////////////////



namespace MML
{
	namespace Utils
	{
		static int LeviCivita(int i, int j, int k)
		{
			if (i == j || j == k || i == k)
				return 0;

			if (i == 1 && j == 2 && k == 3)
				return 1;
			if (i == 2 && j == 3 && k == 1)
				return 1;
			if (i == 3 && j == 1 && k == 2)
				return 1;
			if (i == 3 && j == 2 && k == 1)
				return -1;
			if (i == 2 && j == 1 && k == 3)
				return -1;
			if (i == 1 && j == 3 && k == 2)
				return -1;

			return 0;
		}
	static int LeviCivita(int i, int j, int k, int l)
	{
		// Validate input: must be permutation of {1, 2, 3, 4}
		bool present[5] = { false, false, false, false, false }; // index 0 unused
		int indices[4] = { i, j, k, l };
		
		for (int idx = 0; idx < 4; idx++)
		{
			if (indices[idx] < 1 || indices[idx] > 4)
				return 0; // Invalid index
			if (present[indices[idx]])
				return 0; // Duplicate index
			present[indices[idx]] = true;
		}
		
		// All indices 1,2,3,4 present - compute sign from permutation
		int a[4] = { i, j, k, l };
		int ret = 1;

		for (int i = 0; i < 4; i++)
			for (int j = i + 1; j < 4; j++)
				if (a[i] > a[j])
				{
					int tmp = a[i];
					a[i] = a[j];
					a[j] = tmp;
					ret *= -1;
				}
		return ret;
	}		static Real DegToRad(Real angleDeg) { return angleDeg * Constants::PI / 180.0; }
		static Real RadToDeg(Real angleRad) { return angleRad * 180.0 / Constants::PI; }

		static void AngleDegToExplicit(Real angle, Real& deg, Real& min, Real& sec)
		{
			deg = floor(angle);
			min = floor((angle - deg) * 60.0);
			sec = (angle - deg - min / 60.0) * 3600.0;
		}
		static void AngleRadToExplicit(Real angleRad, Real& deg, Real& min, Real& sec) { AngleDegToExplicit(angleRad * 180.0 / Constants::PI, deg, min, sec); }
		static Real ExplicitToAngleDeg(Real deg, Real min, Real sec) { return deg + min / 60.0 + sec / 3600.0; }
		static Real ExplicitToAngleRad(Real deg, Real min, Real sec) { return ExplicitToAngleDeg(deg, min, sec) * Constants::PI / 180.0; }

		static Real AngleTo2PiRange(Real rad)
		{
			while (rad < 0)
				rad += 2 * Constants::PI;
			while (rad >= 2 * Constants::PI)
				rad -= 2 * Constants::PI;
			return rad;
		}
		static Real AngleToPiPiRange(Real rad)
		{
			while (rad < -Constants::PI)
				rad += 2 * Constants::PI;
			while (rad >= Constants::PI)
				rad -= 2 * Constants::PI;
			return rad;
		}
		///////////////////                     Complex helpers                   ///////////////////
		static bool AreEqual(const Complex& a, const Complex& b, double eps = Defaults::ComplexAreEqualTolerance)
		{
			if (std::abs(a.real() - b.real()) > eps || std::abs(a.imag() - b.imag()) > eps)
				return false;
			return true;
		}
		static bool AreEqualAbs(const Complex& a, const Complex& b, double eps = Defaults::ComplexAreEqualAbsTolerance)
		{
			if (Abs(a - b) > eps)
				return false;
			return true;
		}

		///////////////////                     Vector helpers                    ///////////////////
		static bool AreEqual(const Vector<Real> &a, const Vector<Real> &b, 
												 Real eps = Defaults::VectorIsEqualTolerance)
		{
			return a.IsEqualTo(b, eps);
		}
		static bool AreEqual(const Vector<Complex>& a, const Vector<Complex>& b, 
												 Real eps = Defaults::ComplexAreEqualTolerance)
		{
			if (a.size() != b.size())
				return false;

			for (int i = 0; i < a.size(); i++)
				if( !AreEqual(a[i], b[i], eps) )
					return false;

			return true;
		}
		static bool AreEqualAbs(const Vector<Complex>& a, const Vector<Complex>& b, 
														Real eps = Defaults::ComplexAreEqualAbsTolerance)
		{
			if (a.size() != b.size())
				return false;

			for (int i = 0; i < a.size(); i++)
				if ( !AreEqualAbs(a[i], b[i], eps) )
					return false;

			return true;
		}

		static Real		 ScalarProduct(const Vector<Real>& a, const Vector<Real>& b)
		{
			if (a.size() != b.size())
				throw VectorDimensionError("ScalarProduct - must be same dim", a.size(), b.size());

			Real ret = 0;
			for (int i = 0; i < a.size(); i++)
				ret += a[i] * b[i];

			return ret;
		}
		static Complex ScalarProduct(const Vector<Complex>& a, const Vector<Complex>& b)
		{
			if (a.size() != b.size())
				throw VectorDimensionError("ScalarProduct - must be same dim", a.size(), b.size());

			Complex ret = 0;
			for (int i = 0; i < a.size(); i++)
				ret += a[i] * std::conj(b[i]);

			return ret;
		}
		static Real		 VectorsAngle(const Vector<Real>& a, const Vector<Real>& b)
		{
			if (a.size() != b.size())
				throw VectorDimensionError("Vector::AngleToVector - vectors must be equal size", a.size(), b.size());

			Real cosAngle = ScalarProduct(a, b) / (a.NormL2() * b.NormL2());
			return std::acos(cosAngle);
		}

		static Vector<Real> VectorProjectionParallelTo(const Vector<Real>& orig, const Vector<Real>& b)
		{
			return ScalarProduct(orig, b) / b.NormL2() * b;
		}
		static Vector<Real> VectorProjectionPerpendicularTo(const Vector<Real>& orig, const Vector<Real>& b)
		{
			return orig - VectorProjectionParallelTo(orig, b);
		}

		template<int N>
		static Real		 ScalarProduct(const VectorN<Real, N> &a, const VectorN<Real, N> &b)
		{
			Real ret = 0;
			for (int i = 0; i < N; i++)
				ret += a[i] * b[i];
			return ret;
		}
		template<int N> 
		static Complex ScalarProduct(const VectorN<Complex, N>& a, const VectorN<Complex, N>& b)
		{
			Complex ret = 0;
			for (int i = 0; i < N; i++)
				ret += a[i] * std::conj(b[i]);
			return ret;
		}

		template<int N> 
		static Real		 VectorsAngle(const VectorN<Real, N> &a, const VectorN<Real, N> &b)
		{
			Real cosAngle = ScalarProduct(a, b) / (a.NormL2() * b.NormL2());
			return std::acos(cosAngle);
		}

		template<class Type> static Matrix<Type> OuterProduct(const Vector<Type>& a, const Vector<Type>& b)
		{
			Matrix<Type> ret(a.size(), b.size());

			for (int i = 0; i < a.size(); i++)
				for (int j = 0; j < b.size(); j++)
					ret[i][j] = a[i] * b[j];

			return ret;
		}

		///////////////////       Vector<Complex> - Vector<Real> operations       ///////////////////
		static Vector<Complex> AddVec(const Vector<Complex>& a, const Vector<Real>& b)
		{
			if (a.size() != b.size())
				throw VectorDimensionError("AddVec(Complex, Real) - must be same dim", a.size(), b.size());

			Vector<Complex> ret(b.size());;
			for (int i = 0; i < b.size(); i++)
				ret[i] = a[i] + b[i];
			return ret;
		}
		static Vector<Complex> AddVec(const Vector<Real>& a, const Vector<Complex>& b)
		{
			if (a.size() != b.size())
				throw VectorDimensionError("AddVec(Real, Complex) - must be same dim", a.size(), b.size());

			Vector<Complex> ret(b.size());;
			for (int i = 0; i < b.size(); i++)
				ret[i] = a[i] + b[i];
			return ret;
		}

		static Vector<Complex> SubVec(const Vector<Complex>& a, const Vector<Real>& b)
		{
			if (a.size() != b.size())
				throw VectorDimensionError("SubVec(Complex, Real) - must be same dim", a.size(), b.size());

			Vector<Complex> ret(b.size());;
			for (int i = 0; i < b.size(); i++)
				ret[i] = a[i] - b[i];
			return ret;
		}
		static Vector<Complex> SubVec(const Vector<Real>& a, const Vector<Complex>& b)
		{
			if (a.size() != b.size())
				throw VectorDimensionError("SubVec(Real, Complex) - must be same dim", a.size(), b.size());

			Vector<Complex> ret(b.size());;
			for (int i = 0; i < b.size(); i++)
				ret[i] = a[i] - b[i];
			return ret;
		}

		static Vector<Complex> MulVec(const Complex& a, const Vector<Real>& b)
		{
			Vector<Complex> ret(b.size());;
			for (int i = 0; i < b.size(); i++)
				ret[i] = a * b[i];
			return ret;
		}
		static Vector<Complex> MulVec(const Vector<Real>& a, const Complex& b)
		{
			Vector<Complex> ret(a.size());;
			for (int i = 0; i < a.size(); i++)
				ret[i] = b * a[i];
			return ret;
		}

		///////////////////             Predefined matrices                      ///////////////////
		const static inline MatrixNM<Complex, 2, 2> Pauli[] = {
				MatrixNM<Complex, 2, 2>{ 0, 1,
																 1, 0 },
				MatrixNM<Complex, 2, 2>{ 0,              Complex(0, -1),
																 Complex(0, 1),  0},
				MatrixNM<Complex, 2, 2>{ 1,  0,
																 0, -1 }
		};
		const static inline MatrixNM<Complex, 4, 4> DiracGamma[] = {
				MatrixNM<Complex, 4, 4>{ 1,  0,  0,  0,
																 0,  1,  0,  0,
																 0,  0, -1,  0,
																 0,  0,  0, -1 },
				MatrixNM<Complex, 4, 4>{ 0,  0,  0,  1,
																 0,  0,  1,  0,
																 0, -1,  0,  0,
																-1,  0,  0,  0 },
				MatrixNM<Complex, 4, 4>{              0,             0,             0, Complex(0, -1),
																              0,             0, Complex(0, 1),              0,
																              0, Complex(0, 1),             0,              0,
																 Complex(0, -1),             0,             0,              0 },
				MatrixNM<Complex, 4, 4>{ 0,  0,  1,  0,
																 0,  0,  0, -1,
																-1,  0,  0,  0,
																 0,  1,  0,  0 }
		};
		const static inline MatrixNM<Complex, 4, 4> DiracGamma5{ 0,  0,  1,  0,
																														 0,  0,  0,  1,
																														 1,  0,  0,  0,
																														 0,  1,  0,  0 };

		///////////////////             Creating Matrix from Vector              ///////////////////
		template<class Type> static Matrix<Type> RowMatrixFromVector(const Vector<Type>& b)
		{
			Matrix<Type> ret(1, (int)b.size());
			for (int i = 0; i < b.size(); i++)
				ret[0][i] = b[i];

			return ret;
		}
		template<class Type> static Matrix<Type> ColumnMatrixFromVector(const Vector<Type>& b)
		{
			Matrix<Type> ret((int)b.size(), 1);
			for (int i = 0; i < b.size(); i++)
				ret[i][0] = b[i];

			return ret;
		}
		template<class Type> static Matrix<Type> DiagonalMatrixFromVector(const Vector<Type>& b)
		{
			Matrix<Type> ret((int)b.size(), (int)b.size());
			for (int i = 0; i < b.size(); i++)
				ret[i][i] = b[i];

			return ret;
		}

		// create Row matrix from std::vector list of Vectors
		template<class Type> static Matrix<Type> MatrixFromVectorsInRows(const std::vector<Vector<Type>>& b)
		{
			Matrix<Type> ret((int)b.size(), (int)b[0].size());
			for (int i = 0; i < b.size(); i++)
				for (int j = 0; j < b[i].size(); j++)
					ret[i][j] = b[i][j];
			return ret;
		}
		template<class Type> static Matrix<Type> MatrixFromVectorsInColumns(const std::vector<Vector<Type>>& b)
		{
			Matrix<Type> ret((int)b[0].size(), (int)b.size());
			for (int i = 0; i < b.size(); i++)
				for (int j = 0; j < b[i].size(); j++)
					ret[j][i] = b[i][j];
			return ret;
		}

		template<class Type, int N> MatrixNM<Type, 1, N> RowMatrixFromVector(const VectorN<Type, N>& b)
		{
			MatrixNM<Type, 1, N>  ret;
			for (int j = 0; j < N; j++)
				ret._vals[0][j] = b[j];

			return ret;
		}
		template<class Type, int N> MatrixNM<Type, N, 1> ColumnMatrixFromVector(const VectorN<Type, N>& b)
		{
			MatrixNM<Type, N, 1>  ret;
			for (int i = 0; i < N; i++)
				ret._vals[i][0] = b[i];
			return ret;
		}
		template<class Type, int N> MatrixNM<Type, N, N> DiagonalMatrixFromVector(const VectorN<Type, N>& b)
		{
			MatrixNM<Type, N, N> ret;
			for (int i = 0; i < N; i++)
				ret[i][i] = b[i];
			return ret;
		}

		///////////////////                   Matrix helpers                     ///////////////////
		template<class Type> static Matrix<Type> Commutator(const Matrix<Type>& a, const Matrix<Type>& b)
		{
			return a * b - b * a;
		}
		template<class Type> static Matrix<Type> AntiCommutator(const Matrix<Type>& a, const Matrix<Type>& b)
		{
			return a * b + b * a;
		}

		template<class Type> 
		static void MatrixDecomposeToSymAntisym(const Matrix<Type>& orig, 
																						Matrix<Type>& outSym, 
																						Matrix<Type>& outAntiSym)
		{
			if (orig.RowNum() != orig.ColNum())
				throw MatrixDimensionError("MatrixDecompose - matrix must be square", orig.RowNum(), orig.ColNum(), -1, -1);

			auto transp = orig.GetTranspose();
			outSym = (orig + transp) * 0.5;
			outAntiSym = (orig - transp) * 0.5;
		}

		///////////////////                  Matrix functions                    ///////////////////
		template<class Type> static Matrix<Type> Exp(const Matrix<Type>& a, int n = 10)
		{
			Matrix<Type> ret(a.RowNum(), a.ColNum());
			Matrix<Type> a_pow_n(a);

			double fact = 1.0;
			ret.MakeUnitMatrix();

			for (int i = 1; i <= n; i++)
			{
				ret += a_pow_n / fact;

				a_pow_n = a_pow_n * a;
				fact *= (double)i;
			}

			return ret;
		}
		// Verify
		template<class Type> static Matrix<Type> Sin(const Matrix<Type>& a, int n = 10)
		{
			Matrix<Type> ret(a.RowNum(), a.ColNum());		// initialized to zero matrix!
			Matrix<Type> a_pow_n(a);
			
			double fact = 1.0;
			
			for (int i = 1; i <= n; i += 2)
			{
				ret += a_pow_n / fact;
				
				a_pow_n = (-1.0) * a_pow_n * a * a;
				fact *= (double)(i + 1) * (i + 2);
			}
			return ret;
		}
		// Verify
		template<class Type> static Matrix<Type> Cos(const Matrix<Type>& a, int n = 10)
		{
			Matrix<Type> ret(a.RowNum(), a.ColNum());
			Matrix<Type> a_pow_n;

			double fact = 1.0;
			ret.MakeUnitMatrix();
			a_pow_n.MakeUnitMatrix();

			for (int i = 1; i <= n; i+=2)
			{
				a_pow_n = (-1.0) * a_pow_n * a * a;
				fact *= (double)(i) * (i + 1);

				ret += a_pow_n / fact;
			}
			return ret;
		}

		///////////////////                Real matrix helpers                   ///////////////////
		static bool IsOrthogonal(const Matrix<Real>& mat, double eps = Defaults::IsMatrixOrthogonalTolerance)
		{
			if (mat.RowNum() != mat.ColNum())
				throw MatrixDimensionError("IsOrthogonal - matrix must be square", mat.RowNum(), mat.ColNum(), -1, -1);

			Matrix<Real> matProd = mat * mat.GetTranspose();

			return matProd.IsUnit(eps);
		}

		///////////////////               Complex matrix helpers                 ///////////////////
		static Matrix<Real> GetRealPart(const Matrix<Complex>& a)
		{
			Matrix<Real> ret(a.RowNum(), a.ColNum());

			for (int i = 0; i < ret.RowNum(); i++)
				for (int j = 0; j < ret.ColNum(); j++) {
					ret[i][j] = a[i][j].real();
				}

			return	ret;
		}
		static Matrix<Real> GetImagPart(const Matrix<Complex>& a)
		{
			Matrix<Real> ret(a.RowNum(), a.ColNum());

			for (int i = 0; i < ret.RowNum(); i++)
				for (int j = 0; j < ret.ColNum(); j++) {
					ret[i][j] = a[i][j].imag();
				}

			return	ret;
		}

		static Matrix<Complex> GetConjugateTranspose(const Matrix<Complex>& mat)
		{
			Matrix<Complex> ret(mat.ColNum(), mat.RowNum());

			for (int i = 0; i < mat.RowNum(); i++)
				for (int j = 0; j < mat.ColNum(); j++)
					ret[j][i] = std::conj(mat[i][j]);

			return ret;
		}
		static Matrix<Complex> CmplxMatFromRealMat(const Matrix<Real>& mat)
		{
			Matrix<Complex> mat_cmplx(mat.RowNum(), mat.ColNum());

			for (int i = 0; i < mat.RowNum(); i++)
				for (int j = 0; j < mat.ColNum(); j++)
					mat_cmplx[i][j] = Complex(mat(i, j), 0.0);

			return mat_cmplx;
		}

		static bool IsComplexMatReal(const Matrix<Complex>& mat)
		{
			for (int i = 0; i < mat.RowNum(); i++)
				for (int j = 0; j < mat.ColNum(); j++)
					if (mat[i][j].imag() != 0.0)
						return false;

			return true;
		}
		static bool IsHermitian(const Matrix<Complex>& mat)
		{
			if (mat.RowNum() != mat.ColNum())
				throw MatrixDimensionError("IsHermitian - matrix must be square", mat.RowNum(), mat.ColNum(), -1, -1);

			for (int i = 0; i < mat.RowNum(); i++)
				for (int j = i + 1; j < mat.ColNum(); j++)
					if (mat[i][j] != std::conj(mat[j][i]))
						return false;
			return true;
		}
		static bool IsUnitary(const Matrix<Complex>& mat)
		{
			// IsUnitary - complex square matrix U is unitary if its conjugate transpose U* is also its inverse
			if (mat.RowNum() != mat.ColNum())
				throw MatrixDimensionError("IsUnitary - matrix must be square", mat.RowNum(), mat.ColNum(), -1, -1);

			Matrix<Complex> matProd = mat * GetConjugateTranspose(mat);

			return matProd.IsUnit();
		}

		///////////////////       Matrix<Complex> - Matrix<Real>  operations     ///////////////////
		static Matrix<Complex> AddMat(const Matrix<Complex>& a, const Matrix<Real>& b)
		{
			if (a.RowNum() != b.RowNum() || a.ColNum() != b.ColNum())
				throw MatrixDimensionError("AddMat(Complex, Real) - must be same dim", a.RowNum(), a.ColNum(), b.RowNum(), b.ColNum());

			Matrix<Complex> ret(a);
			for (int i = 0; i < b.RowNum(); i++)
				for (int j = 0; j < b.ColNum(); j++)
					ret[i][j] += b[i][j];
			return ret;
		}
		static Matrix<Complex> AddMat(const Matrix<Real>& a, const Matrix<Complex>& b)
		{
			if (a.RowNum() != b.RowNum() || a.ColNum() != b.ColNum())
				throw MatrixDimensionError("AddMat(Real, Complex) - must be same dim", a.RowNum(), a.ColNum(), b.RowNum(), b.ColNum());

			Matrix<Complex> ret(b);
			for (int i = 0; i < a.RowNum(); i++)
				for (int j = 0; j < a.ColNum(); j++)
					ret[i][j] += a[i][j];
			return ret;
		}

		static Matrix<Complex> SubMat(const Matrix<Complex>& a, const Matrix<Real>& b)
		{
			if (a.RowNum() != b.RowNum() || a.ColNum() != b.ColNum())
				throw MatrixDimensionError("AddMat(Complex, Real) - must be same dim", a.RowNum(), a.ColNum(), b.RowNum(), b.ColNum());

			Matrix<Complex> ret(a);
			for (int i = 0; i < b.RowNum(); i++)
				for (int j = 0; j < b.ColNum(); j++)
					ret[i][j] -= b[i][j];
			return ret;
		}
		static Matrix<Complex> SubMat(const Matrix<Real>& a, const Matrix<Complex>& b)
		{
			if (a.RowNum() != b.RowNum() || a.ColNum() != b.ColNum())
				throw MatrixDimensionError("AddMat(Real, Complex) - must be same dim", a.RowNum(), a.ColNum(), b.RowNum(), b.ColNum());

			Matrix<Complex> ret(b);
			for (int i = 0; i < a.RowNum(); i++)
				for (int j = 0; j < a.ColNum(); j++)
					ret[i][j] = a[i][j] - b[i][j];
			return ret;
		}

		static Matrix<Complex> MulMat(const Complex& a, const Matrix<Real>& b)
		{
			Matrix<Complex>	ret(b.RowNum(), b.ColNum());

			for (int i = 0; i < ret.RowNum(); i++)
				for (int j = 0; j < ret.ColNum(); j++) {
					ret[i][j] = a * b[i][j];
				}

			return	ret;
		}
		static Matrix<Complex> MulMat(const Matrix<Real>& a, const Complex& b)
		{
			Matrix<Complex>	ret(a.RowNum(), a.ColNum());

			for (int i = 0; i < ret.RowNum(); i++)
				for (int j = 0; j < ret.ColNum(); j++) {
					ret[i][j] = b * a[i][j];
				}

			return	ret;
		}
		
		static Matrix<Complex> MulMat(const Matrix<Complex>& a, const Matrix<Real>& b)
		{
			if (a.ColNum() != b.RowNum())
				throw MatrixDimensionError("Matrix::operator*(Complex, Real)) - a.colNum must be equal to b.rowNum", a.RowNum(), a.ColNum(), b.RowNum(), b.ColNum());

			Matrix<Complex>	ret(a.RowNum(), b.ColNum());
			for (int i = 0; i < ret.RowNum(); i++)
				for (int j = 0; j < ret.ColNum(); j++) {
					ret[i][j] = 0.0;
					for (int k = 0; k < a.ColNum(); k++)
						ret[i][j] += a[i][k] * b[k][j];
				}

			return	ret;
		}
		static Matrix<Complex> MulMat(const Matrix<Real>& a, const Matrix<Complex>& b)
		{
			if (a.ColNum() != b.RowNum())
				throw MatrixDimensionError("Matrix::operator*(Real, Complex)) - a.colNum must be equal to b.rowNum", a.RowNum(), a.ColNum(), b.RowNum(), b.ColNum());

			Matrix<Complex>	ret(a.RowNum(), b.ColNum());
			for (int i = 0; i < ret.RowNum(); i++)
				for (int j = 0; j < ret.ColNum(); j++) {
					ret[i][j] = 0.0;
					for (int k = 0; k < a.ColNum(); k++)
						ret[i][j] += a[i][k] * b[k][j];
				}

			return	ret;
		}

		static Vector<Complex> MulMatVec(const Matrix<Real>& a, const Vector<Complex>& b)
		{
			if (a.ColNum() != b.size())
				throw MatrixDimensionError("operator*(Mat a, Vec b) - a.colNum must be equal to vector size", a.RowNum(), a.ColNum(), (int)b.size(), -1);

			Vector<Complex>	ret(a.RowNum());
			for (int i = 0; i < a.RowNum(); i++)
			{
				ret[i] = 0;
				for (int j = 0; j < a.ColNum(); j++)
					ret[i] += a[i][j] * b[j];
			}
			return ret;
		}
		static Vector<Complex> MulMatVec(const Matrix<Complex>& a, const Vector<Real>& b)
		{
			if (a.ColNum() != b.size())
				throw MatrixDimensionError("operator*(Mat a, Vec b) - a.colNum must be equal to vector size", a.RowNum(), a.ColNum(), (int)b.size(), -1);

			Vector<Complex>	ret(a.RowNum());
			for (int i = 0; i < a.RowNum(); i++)
			{
				ret[i] = 0;
				for (int j = 0; j < a.ColNum(); j++)
					ret[i] += a[i][j] * b[j];
			}
			return ret;
		}

		static Vector<Complex> MulVecMat(const Vector<Complex>& a, const Matrix<Real>& b)
		{
			if (a.size() != b.RowNum())
				throw MatrixDimensionError("operator*(Vec a, Mat b) - vector size must be equal to b.rowNum", (int)a.size(), -1, b.RowNum(), b.ColNum());

			Vector<Complex>	ret(b.ColNum());
			for (int i = 0; i < b.ColNum(); i++)
			{
				ret[i] = 0;
				for (int j = 0; j < b.RowNum(); j++)
					ret[i] += a[j] * b[j][i];
			}
			return ret;
		}
		static Vector<Complex> MulVecMat(const Vector<Real>& a, const Matrix<Complex>& b)
		{
			if (a.size() != b.RowNum())
				throw MatrixDimensionError("operator*(Vec a, Mat b) - vector size must be equal to b.rowNum", (int)a.size(), -1, b.RowNum(), b.ColNum());

			Vector<Complex>	ret(b.ColNum());
			for (int i = 0; i < b.ColNum(); i++)
			{
				ret[i] = 0;
				for (int j = 0; j < b.RowNum(); j++)
					ret[i] += a[j] * b[j][i];
			}
			return ret;
		}
	}
}

///////////////////////////   mml/base/Random.h   ///////////////////////////



namespace MML
{
	class Random
	{
	private:
		// Thread-local static RNG for performance and thread-safety
		// Creating RNG once per thread instead of on every call provides 100-1000x speedup
		inline static thread_local std::mt19937 gen{std::random_device{}()};

	public:
		static Real UniformReal(Real min, Real max)
		{
			std::uniform_real_distribution<Real> dis(min, max);
			return dis(gen);
		}
		static int UniformInt(int min, int max)
		{
			std::uniform_int_distribution<int> dis(min, max);
			return dis(gen);
		}
		static Real UniformVecDirection2(Real& vx, Real& vy, Real abs)
		{
			// Generate a random angle in the range [0, 2*PI)
			Real angle = UniformReal(0, 2 * Constants::PI);
			vx = abs * std::cos(angle);
			vy = abs * std::sin(angle);
			return abs;
		}
		static Real UniformVecDirection3(Real& vx, Real& vy, Real& vz, Real abs)
		{
			// Generate a random direction on the sphere with radus 'abs'
			Real theta = UniformReal(0, 2 * Constants::PI); // azimuthal angle
			Real phi = UniformReal(0, Constants::PI); // polar angle
			vx = abs * std::sin(phi) * std::cos(theta);
			vy = abs * std::sin(phi) * std::sin(theta);
			vz = abs * std::cos(phi);
			return abs;
		}
	};
}


///////////////////////////   mml/base/GeometrySpherical.h   ///////////////////////////






namespace MML
{
	class SphericalGeometryCalculator
	{
		public:
		static Real RadiusFromCartesian(const Pnt3Cart& pnt)
		{
			return hypot(pnt.X(), hypot(pnt.Y(), pnt.Z()));
		}
		static Pnt3Cart CartesianFromSpherical(const Pnt3Sph& pnt)
		{
			// Standard spherical coordinates: (r, theta, phi)
			// theta = polar angle from z-axis [0, PI]
			// phi = azimuthal angle in xy-plane [0, 2*PI]
			return Pnt3Cart(pnt.R() * sin(pnt.Theta()) * cos(pnt.Phi()),
											pnt.R() * sin(pnt.Theta()) * sin(pnt.Phi()),
											pnt.R() * cos(pnt.Theta()));
		}

		// given latitude and longitude in degrees, return spherical point
		// latitude: -90 (South) to +90 (North), longitude: -180 to +180
		static Pnt3Sph SphericalFromLatLong(Real latitudeDeg, Real longitudeDeg)
		{
			Real latitudeRad = Utils::DegToRad(latitudeDeg);
			Real longitudeRad = Utils::DegToRad(longitudeDeg);
			// Convert latitude to theta (polar angle from z-axis)
			// latitude 90Â° (North) -> theta = 0, latitude -90Â° (South) -> theta = PI
			Real theta = Constants::PI / 2.0 - latitudeRad;
			return Pnt3Sph(1.0, theta, longitudeRad);
		}

		// given two points on sphere, with latitude and longitude in degrees,
		// return distance between them in radians
		static Real DistanceBetweenLatLong(Real lat1Deg, Real long1Deg, Real lat2Deg, Real long2Deg)
		{
			Pnt3Sph pnt1 = SphericalFromLatLong(lat1Deg, long1Deg);
			Pnt3Sph pnt2 = SphericalFromLatLong(lat2Deg, long2Deg);

			// using spherical law of cosines
			Real cosAngle = cos(pnt1.Theta()) * cos(pnt2.Theta()) +
											sin(pnt1.Theta()) * sin(pnt2.Theta()) *
											cos(pnt1.Phi() - pnt2.Phi());
			// Clamp to [-1, 1] to handle numerical precision issues
			cosAngle = std::max(Real(-1.0), std::min(Real(1.0), cosAngle));
			return acos(cosAngle);
		}
		// given two points on sphere of radius R in meters, with latitude and longitude in degrees,
		// return distance between them in meters
		static Real DistanceBetweenLatLong(Real radius, Real lat1Deg, Real long1Deg, Real lat2Deg, Real long2Deg)
		{
      Real angleRad = DistanceBetweenLatLong(lat1Deg, long1Deg, lat2Deg, long2Deg);
      return radius * angleRad;
    }    
	};
}


///////////////////////////   mml/base/Quaternions.h   ///////////////////////////


namespace MML
{
	/*****************************************************************************
	 * QUATERNION CONVENTIONS AND MATHEMATICAL BACKGROUND
	 * ====================================================
	 * 
	 * REPRESENTATION:
	 * A quaternion is represented as: q = w + xi + yj + zk
	 * where:
	 *   - w is the scalar (real) part
	 *   - (x, y, z) is the vector (imaginary) part
	 *   - i, j, k are the imaginary units satisfying:
	 *     iÂ² = jÂ² = kÂ² = ijk = -1
	 *     ij = k,  jk = i,  ki = j
	 *     ji = -k, kj = -i, ik = -j
	 * 
	 * STORAGE ORDER:
	 * We store quaternions as [w, x, y, z] where:
	 *   _data[0] = w  (scalar/real part)
	 *   _data[1] = x  (i component)
	 *   _data[2] = y  (j component)
	 *   _data[3] = z  (k component)
	 * 
	 * MULTIPLICATION CONVENTION (Hamilton convention):
	 * For quaternions p = (w1, x1, y1, z1) and q = (w2, x2, y2, z2):
	 * 
	 * p * q = (w1*w2 - x1*x2 - y1*y2 - z1*z2,
	 *          w1*x2 + x1*w2 + y1*z2 - z1*y2,
	 *          w1*y2 - x1*z2 + y1*w2 + z1*x2,
	 *          w1*z2 + x1*y2 - y1*x2 + z1*w2)
	 * 
	 * ROTATION CONVENTION:
	 * To rotate a vector v by angle Î¸ around unit axis u:
	 *   1. Create rotation quaternion: q = [cos(Î¸/2), sin(Î¸/2)*u]
	 *   2. Extend vector to quaternion: v_quat = [0, v]
	 *   3. Apply rotation: v' = q * v_quat * q^(-1)
	 * 
	 * This follows RIGHT-HANDED rotation (counter-clockwise when looking
	 * along the axis toward the origin).
	 * 
	 * NORMALIZATION:
	 * Unit quaternions (||q|| = 1) represent rotations. We provide:
	 *   - IsUnit(): Check if quaternion is normalized
	 *   - Normalize(): Normalize to unit length
	 *   - Normalized(): Return normalized copy
	 * 
	 * AXIS-ANGLE CONVENTION:
	 * When constructing from axis-angle:
	 *   - Axis must be a UNIT vector
	 *   - Angle is in RADIANS
	 *   - Positive angle = right-hand rule rotation
	 * 
	 * EULER ANGLES CONVENTION:
	 * We support multiple Euler angle conventions:
	 *   - ZYX (Yaw-Pitch-Roll): Common in aerospace
	 *   - XYZ: Alternative rotation order
	 *   - Angles are in RADIANS
	 *   - Applied in INTRINSIC order (each rotation in rotating frame)
	 * 
	 * INTERPOLATION:
	 * - Slerp (Spherical Linear Interpolation): Shortest path on 4D unit sphere
	 *   Used for smooth rotation interpolation between orientations
	 * - Lerp (Linear Interpolation): Faster but not constant angular velocity
	 *   Must be followed by normalization for rotations
	 * 
	 *****************************************************************************/

	class Quaternion
	{
	private:
		Real _data[4];  // [w, x, y, z] storage

	public:
		/********************************************************************
		 * CONSTRUCTORS
		 ********************************************************************/

		// Default: Identity quaternion [1, 0, 0, 0] (no rotation)
		Quaternion() : _data{1, 0, 0, 0} {}

		// From components: q = w + xi + yj + zk
		Quaternion(Real w, Real x, Real y, Real z) : _data{w, x, y, z} {}

		// From scalar and vector parts: q = w + v
		Quaternion(Real w, const Vec3Cart& vec) 
			: _data{w, vec[0], vec[1], vec[2]} {}

		// Pure imaginary quaternion from vector: q = 0 + v
		explicit Quaternion(const Vec3Cart& vec)
			: _data{0, vec[0], vec[1], vec[2]} {}

		// Copy constructor
		Quaternion(const Quaternion& q) 
			: _data{q._data[0], q._data[1], q._data[2], q._data[3]} {}

		/********************************************************************
		 * STATIC FACTORY METHODS FOR ROTATIONS
		 ********************************************************************/

		// Create identity quaternion (no rotation)
		static Quaternion Identity()
		{
			return Quaternion(1, 0, 0, 0);
		}

		// Create rotation quaternion from axis-angle
		// axis: UNIT vector defining rotation axis
		// angle: rotation angle in RADIANS (right-hand rule)
		static Quaternion FromAxisAngle(const Vec3Cart& axis, Real angle)
		{
			Real halfAngle = angle / 2.0;
			Real sinHalf = std::sin(halfAngle);
			Real cosHalf = std::cos(halfAngle);
			
			return Quaternion(cosHalf, 
											 axis[0] * sinHalf,
											 axis[1] * sinHalf,
											 axis[2] * sinHalf);
		}

		// Create rotation quaternion from Euler angles (ZYX convention - Yaw, Pitch, Roll)
		// yaw: rotation around Z-axis (radians)
		// pitch: rotation around Y-axis (radians)
		// roll: rotation around X-axis (radians)
		// Applied as: R = Rz(yaw) * Ry(pitch) * Rx(roll)
		static Quaternion FromEulerZYX(Real yaw, Real pitch, Real roll)
		{
			Real cy = std::cos(yaw * 0.5);
			Real sy = std::sin(yaw * 0.5);
			Real cp = std::cos(pitch * 0.5);
			Real sp = std::sin(pitch * 0.5);
			Real cr = std::cos(roll * 0.5);
			Real sr = std::sin(roll * 0.5);

			return Quaternion(
				cr * cp * cy + sr * sp * sy,
				sr * cp * cy - cr * sp * sy,
				cr * sp * cy + sr * cp * sy,
				cr * cp * sy - sr * sp * cy
			);
		}

		// Create rotation quaternion from Euler angles (XYZ convention)
		// roll: rotation around X-axis (radians)
		// pitch: rotation around Y-axis (radians)
		// yaw: rotation around Z-axis (radians)
		// Applied as: R = Rx(roll) * Ry(pitch) * Rz(yaw)
		static Quaternion FromEulerXYZ(Real roll, Real pitch, Real yaw)
		{
			Real cr = std::cos(roll * 0.5);
			Real sr = std::sin(roll * 0.5);
			Real cp = std::cos(pitch * 0.5);
			Real sp = std::sin(pitch * 0.5);
			Real cy = std::cos(yaw * 0.5);
			Real sy = std::sin(yaw * 0.5);

			return Quaternion(
				cr * cp * cy + sr * sp * sy,
				sr * cp * cy - cr * sp * sy,
				cr * sp * cy + sr * cp * sy,
				cr * cp * sy - sr * sp * cy
			);
		}

		/********************************************************************
		 * ACCESSORS
		 ********************************************************************/

		Real w() const { return _data[0]; }
		Real x() const { return _data[1]; }
		Real y() const { return _data[2]; }
		Real z() const { return _data[3]; }

		Real& w() { return _data[0]; }
		Real& x() { return _data[1]; }
		Real& y() { return _data[2]; }
		Real& z() { return _data[3]; }

		// Access by index: [0]=w, [1]=x, [2]=y, [3]=z
		Real operator[](int i) const { return _data[i]; }
		Real& operator[](int i) { return _data[i]; }

		// Get scalar part
		Real Scalar() const { return _data[0]; }

		// Get vector part as Vec3Cart
		Vec3Cart Vector() const 
		{ 
			return Vec3Cart(_data[1], _data[2], _data[3]); 
		}

		/********************************************************************
		 * BASIC OPERATIONS
		 ********************************************************************/

		// Addition
		Quaternion operator+(const Quaternion& q) const
		{
			return Quaternion(_data[0] + q._data[0],
											 _data[1] + q._data[1],
											 _data[2] + q._data[2],
											 _data[3] + q._data[3]);
		}

		// Subtraction
		Quaternion operator-(const Quaternion& q) const
		{
			return Quaternion(_data[0] - q._data[0],
											 _data[1] - q._data[1],
											 _data[2] - q._data[2],
											 _data[3] - q._data[3]);
		}

		// Negation
		Quaternion operator-() const
		{
			return Quaternion(-_data[0], -_data[1], -_data[2], -_data[3]);
		}

		// Scalar multiplication
		Quaternion operator*(Real scalar) const
		{
			return Quaternion(_data[0] * scalar,
											 _data[1] * scalar,
											 _data[2] * scalar,
											 _data[3] * scalar);
		}

		// Scalar division
		Quaternion operator/(Real scalar) const
		{
			Real inv = 1.0 / scalar;
			return (*this) * inv;
		}

		// Quaternion multiplication (Hamilton product)
		// NOTE: Non-commutative! p*q != q*p in general
		Quaternion operator*(const Quaternion& q) const
		{
			return Quaternion(
				_data[0] * q._data[0] - _data[1] * q._data[1] - _data[2] * q._data[2] - _data[3] * q._data[3],
				_data[0] * q._data[1] + _data[1] * q._data[0] + _data[2] * q._data[3] - _data[3] * q._data[2],
				_data[0] * q._data[2] - _data[1] * q._data[3] + _data[2] * q._data[0] + _data[3] * q._data[1],
				_data[0] * q._data[3] + _data[1] * q._data[2] - _data[2] * q._data[1] + _data[3] * q._data[0]
			);
		}

		// In-place operations
		Quaternion& operator+=(const Quaternion& q)
		{
			_data[0] += q._data[0];
			_data[1] += q._data[1];
			_data[2] += q._data[2];
			_data[3] += q._data[3];
			return *this;
		}

		Quaternion& operator-=(const Quaternion& q)
		{
			_data[0] -= q._data[0];
			_data[1] -= q._data[1];
			_data[2] -= q._data[2];
			_data[3] -= q._data[3];
			return *this;
		}

		Quaternion& operator*=(Real scalar)
		{
			_data[0] *= scalar;
			_data[1] *= scalar;
			_data[2] *= scalar;
			_data[3] *= scalar;
			return *this;
		}

		Quaternion& operator*=(const Quaternion& q)
		{
			*this = (*this) * q;
			return *this;
		}

		/********************************************************************
		 * QUATERNION-SPECIFIC OPERATIONS
		 ********************************************************************/

		// Conjugate: q* = w - xi - yj - zk
		// For unit quaternions: q* = q^(-1)
		Quaternion Conjugate() const
		{
			return Quaternion(_data[0], -_data[1], -_data[2], -_data[3]);
		}

		// Squared norm: ||q||Â² = wÂ² + xÂ² + yÂ² + zÂ²
		Real NormSquared() const
		{
			return _data[0] * _data[0] + 
						 _data[1] * _data[1] + 
						 _data[2] * _data[2] + 
						 _data[3] * _data[3];
		}

		// Norm (magnitude): ||q|| = sqrt(wÂ² + xÂ² + yÂ² + zÂ²)
		Real Norm() const
		{
			return std::sqrt(NormSquared());
		}

		// Inverse: q^(-1) = q* / ||q||Â²
		// For unit quaternions: q^(-1) = q*
		Quaternion Inverse() const
		{
			Real normSq = NormSquared();
			if (normSq < PrecisionValues<Real>::QuaternionZeroThreshold)
				throw QuaternionError("Cannot invert zero quaternion");
			
			Real invNormSq = 1.0 / normSq;
			return Quaternion(_data[0] * invNormSq,
											 -_data[1] * invNormSq,
											 -_data[2] * invNormSq,
											 -_data[3] * invNormSq);
		}

		// Normalize quaternion to unit length
		void Normalize()
		{
			Real norm = Norm();
			if (norm < PrecisionValues<Real>::QuaternionZeroThreshold)
				throw QuaternionError("Cannot normalize zero quaternion");
			
			Real invNorm = 1.0 / norm;
			_data[0] *= invNorm;
			_data[1] *= invNorm;
			_data[2] *= invNorm;
			_data[3] *= invNorm;
		}

		// Return normalized copy
		Quaternion Normalized() const
		{
			Quaternion result(*this);
			result.Normalize();
			return result;
		}

		// Check if quaternion is unit (within tolerance)
		bool IsUnit(Real tolerance = PrecisionValues<Real>::DefaultTolerance) const
		{
			return std::abs(NormSquared() - 1.0) < tolerance;
		}

		// Check if quaternion is identity
		bool IsIdentity(Real tolerance = PrecisionValues<Real>::DefaultTolerance) const
		{
			return std::abs(_data[0] - 1.0) < tolerance &&
						 std::abs(_data[1]) < tolerance &&
						 std::abs(_data[2]) < tolerance &&
						 std::abs(_data[3]) < tolerance;
		}

		// Dot product: q1 Â· q2 = w1*w2 + x1*x2 + y1*y2 + z1*z2
		Real Dot(const Quaternion& q) const
		{
			return _data[0] * q._data[0] + 
						 _data[1] * q._data[1] + 
						 _data[2] * q._data[2] + 
						 _data[3] * q._data[3];
		}

		/********************************************************************
		 * ROTATION OPERATIONS
		 ********************************************************************/

		// Rotate a 3D vector using this quaternion
		// Assumes this quaternion is a unit rotation quaternion
		// Formula: v' = q * [0, v] * q^(-1)
		Vec3Cart Rotate(const Vec3Cart& v) const
		{
			// Optimized version avoiding quaternion construction
			// v' = v + 2w(u Ã— v) + 2u Ã— (u Ã— v)
			// where q = [w, u]
			
			Vec3Cart u(_data[1], _data[2], _data[3]);
			Real w = _data[0];
			
			Vec3Cart uCrossV = VectorProduct(u, v);
			Vec3Cart uCrossUCrossV = VectorProduct(u, uCrossV);
			
			return v + uCrossV * (2.0 * w) + uCrossUCrossV * 2.0;
		}

		// Get rotation axis (for non-identity rotation quaternions)
		// Returns unit vector along rotation axis
		Vec3Cart GetRotationAxis() const
		{
			if (IsIdentity())
				return Vec3Cart(0, 0, 1);  // Arbitrary axis for zero rotation
			
			Vec3Cart axis(_data[1], _data[2], _data[3]);
			Real vecNorm = axis.NormL2();
			
			if (vecNorm < PrecisionValues<Real>::QuaternionZeroThreshold)
				return Vec3Cart(0, 0, 1);  // Arbitrary axis
			
			return axis / vecNorm;
		}

		// Get rotation angle (in radians)
		Real GetRotationAngle() const
		{
			// For unit quaternion q = [cos(Î¸/2), sin(Î¸/2)*axis]
			// angle Î¸ = 2 * acos(w)
			Real w = _data[0];
			
			// Clamp to [-1, 1] for numerical stability
			if (w > 1.0) w = 1.0;
			if (w < -1.0) w = -1.0;
			
			return 2.0 * std::acos(w);
		}

		// Get axis-angle representation
		void ToAxisAngle(Vec3Cart& axis, Real& angle) const
		{
			angle = GetRotationAngle();
			axis = GetRotationAxis();
		}

		// Convert to Euler angles (ZYX convention: Yaw, Pitch, Roll)
		// Returns [yaw, pitch, roll] in radians
		Vec3Cart ToEulerZYX() const
		{
			Real w = _data[0], x = _data[1], y = _data[2], z = _data[3];
			
			// Roll (x-axis rotation)
			Real sinr_cosp = 2.0 * (w * x + y * z);
			Real cosr_cosp = 1.0 - 2.0 * (x * x + y * y);
			Real roll = std::atan2(sinr_cosp, cosr_cosp);
			
			// Pitch (y-axis rotation)
			Real sinp = 2.0 * (w * y - z * x);
			Real pitch;
			if (std::abs(sinp) >= 1.0)
				pitch = std::copysign(Constants::PI / 2.0, sinp); // Gimbal lock
			else
				pitch = std::asin(sinp);
			
			// Yaw (z-axis rotation)
			Real siny_cosp = 2.0 * (w * z + x * y);
			Real cosy_cosp = 1.0 - 2.0 * (y * y + z * z);
			Real yaw = std::atan2(siny_cosp, cosy_cosp);
			
			return Vec3Cart(yaw, pitch, roll);
		}

		// Convert to 3Ã—3 rotation matrix
		// Returns orthogonal matrix R such that R*v rotates vector v
		// Compatible with CoordTransf3D transformation matrices
		MatrixNM<Real, 3, 3> ToRotationMatrix() const
		{
			Real w = _data[0], x = _data[1], y = _data[2], z = _data[3];
			
			MatrixNM<Real, 3, 3> mat;
			
			// First row
			mat[0][0] = 1.0 - 2.0 * (y*y + z*z);
			mat[0][1] = 2.0 * (x*y - w*z);
			mat[0][2] = 2.0 * (x*z + w*y);
			
			// Second row
			mat[1][0] = 2.0 * (x*y + w*z);
			mat[1][1] = 1.0 - 2.0 * (x*x + z*z);
			mat[1][2] = 2.0 * (y*z - w*x);
			
			// Third row
			mat[2][0] = 2.0 * (x*z - w*y);
			mat[2][1] = 2.0 * (y*z + w*x);
			mat[2][2] = 1.0 - 2.0 * (x*x + y*y);
			
			return mat;
		}

		// Create quaternion from 3Ã—3 rotation matrix
		// Matrix must be orthogonal (rotation matrix)
		// Uses Shepperd's method for numerical stability
		static Quaternion FromRotationMatrix(const MatrixNM<Real, 3, 3>& mat)
		{
			Real trace = mat[0][0] + mat[1][1] + mat[2][2];
			
			if (trace > 0.0)
			{
				// w is the largest component
				Real s = std::sqrt(trace + 1.0) * 2.0;  // s = 4*w
				Real w = 0.25 * s;
				Real x = (mat[2][1] - mat[1][2]) / s;
				Real y = (mat[0][2] - mat[2][0]) / s;
				Real z = (mat[1][0] - mat[0][1]) / s;
				return Quaternion(w, x, y, z);
			}
			else if (mat[0][0] > mat[1][1] && mat[0][0] > mat[2][2])
			{
				// x is the largest component
				Real s = std::sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;  // s = 4*x
				Real w = (mat[2][1] - mat[1][2]) / s;
				Real x = 0.25 * s;
				Real y = (mat[0][1] + mat[1][0]) / s;
				Real z = (mat[0][2] + mat[2][0]) / s;
				return Quaternion(w, x, y, z);
			}
			else if (mat[1][1] > mat[2][2])
			{
				// y is the largest component
				Real s = std::sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;  // s = 4*y
				Real w = (mat[0][2] - mat[2][0]) / s;
				Real x = (mat[0][1] + mat[1][0]) / s;
				Real y = 0.25 * s;
				Real z = (mat[1][2] + mat[2][1]) / s;
				return Quaternion(w, x, y, z);
			}
			else
			{
				// z is the largest component
				Real s = std::sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;  // s = 4*z
				Real w = (mat[1][0] - mat[0][1]) / s;
				Real x = (mat[0][2] + mat[2][0]) / s;
				Real y = (mat[1][2] + mat[2][1]) / s;
				Real z = 0.25 * s;
				return Quaternion(w, x, y, z);
			}
		}

		/********************************************************************
		 * INTERPOLATION
		 ********************************************************************/

		// Linear interpolation (faster but not constant angular velocity)
		// t âˆˆ [0, 1]: 0 returns this, 1 returns q
		// Result should be normalized for rotations
		static Quaternion Lerp(const Quaternion& q1, const Quaternion& q2, Real t)
		{
			return q1 * (1.0 - t) + q2 * t;
		}

		// Spherical linear interpolation (constant angular velocity)
		// t âˆˆ [0, 1]: 0 returns this, 1 returns q
		// Interpolates along shortest arc on 4D unit sphere
		static Quaternion Slerp(const Quaternion& q1, const Quaternion& q2, Real t)
		{
			Quaternion q2_adjusted = q2;
			
			// Compute dot product
			Real dot = q1.Dot(q2);
			
			// If dot < 0, negate q2 to take shortest path
			if (dot < 0.0)
			{
				q2_adjusted = -q2_adjusted;
				dot = -dot;
			}
			
			// If quaternions are very close, use linear interpolation
			if (dot > 0.9995)
			{
				return Lerp(q1, q2_adjusted, t).Normalized();
			}
			
			// Perform slerp
			Real theta = std::acos(dot);
			Real sinTheta = std::sin(theta);
			
			Real w1 = std::sin((1.0 - t) * theta) / sinTheta;
			Real w2 = std::sin(t * theta) / sinTheta;
			
			return q1 * w1 + q2_adjusted * w2;
		}

		/********************************************************************
		 * COMPARISON
		 ********************************************************************/

		bool operator==(const Quaternion& q) const
		{
			return _data[0] == q._data[0] &&
						 _data[1] == q._data[1] &&
						 _data[2] == q._data[2] &&
						 _data[3] == q._data[3];
		}

		bool operator!=(const Quaternion& q) const
		{
			return !(*this == q);
		}

		// Check approximate equality
		bool IsApprox(const Quaternion& q, Real tolerance = PrecisionValues<Real>::DefaultTolerance) const
		{
			return std::abs(_data[0] - q._data[0]) < tolerance &&
						 std::abs(_data[1] - q._data[1]) < tolerance &&
						 std::abs(_data[2] - q._data[2]) < tolerance &&
						 std::abs(_data[3] - q._data[3]) < tolerance;
		}

		/********************************************************************
		 * OUTPUT
		 ********************************************************************/

		friend std::ostream& operator<<(std::ostream& os, const Quaternion& q)
		{
			os << "[" << q._data[0] << ", " 
				 << q._data[1] << "i, " 
				 << q._data[2] << "j, " 
				 << q._data[3] << "k]";
			return os;
		}

		void Print(std::ostream& os = std::cout) const
		{
			os << *this;
		}
	};

	// Scalar * Quaternion
	inline Quaternion operator*(Real scalar, const Quaternion& q)
	{
		return q * scalar;
	}

} // namespace MML


///////////////////////////   mml/base/Polynom.h   ///////////////////////////




namespace MML
{
	template <typename CoefT, typename FieldT = CoefT>
	class Polynom
	{
	protected:
		// polynom coefficients - with _vecCoef[0] being the constant term
		std::vector<CoefT> _vecCoef;
	public:
		Polynom() {}
		Polynom(int n) { _vecCoef.resize(n + 1); }
		Polynom(const std::vector<CoefT>& vecCoef) : _vecCoef(vecCoef) {}
		Polynom(std::initializer_list<CoefT> list) : _vecCoef(list) {}
		Polynom(const Polynom& Copy) = default;

		Polynom(Polynom&&) noexcept = default;
		Polynom& operator=(Polynom&&) noexcept = default;

		// Static constructors for common polynomials
		// Returns the zero polynomial (all coefficients zero)
		static Polynom Zero() {
			return Polynom(std::initializer_list<CoefT>{CoefT(0)});
		}

		// Returns the monomial x^degree (coefficient 1 at degree, 0 elsewhere)
		static Polynom Monomial(int degree) {
			std::vector<CoefT> coef(degree + 1, CoefT(0));
			if (degree >= 0) coef[degree] = CoefT(1);
			return Polynom(coef);
		}

		// Returns the constant polynomial (all coefficients zero except constant term)
		static Polynom Constant(const CoefT& value) {
			return Polynom(std::initializer_list<CoefT>{value});
		}

    // Given arrays x[0..n-1] and y[0..n-1] containing a tabulated function y[i] = f(x[i]), 
    // this routine returns a polynomial such that y[i] = P(x[i]) for all i.
    // Uses Lagrange interpolation via Newton's divided differences method.
    static Polynom FromValues(const std::vector<FieldT>& x, const std::vector<FieldT>& y)
    {
      int n = (int)x.size();
      if (n != (int)y.size())
        throw std::invalid_argument("FromValues: x and y arrays must have the same size");
      if (n == 0)
        throw std::invalid_argument("FromValues: arrays cannot be empty");

      std::vector<FieldT> cof(n, FieldT(0));
      std::vector<FieldT> s(n);
      
      // Initialize
      for (int i = 0; i < n; i++)
        s[i] = FieldT(0);
      
      s[n-1] = -x[0];
      
      // Build the polynomial basis
      for (int i = 1; i < n; i++) {
        for (int j = n-1-i; j < n-1; j++)
          s[j] -= x[i] * s[j+1];
        s[n-1] -= x[i];
      }
      
      // Compute coefficients using the basis
      for (int j = 0; j < n; j++) {
        FieldT phi = FieldT(n);
        for (int k = n-1; k > 0; k--)
          phi = FieldT(k) * s[k] + x[j] * phi;
      
        FieldT ff = y[j] / phi;
        FieldT b = FieldT(1);
        
        for (int k = n-1; k >= 0; k--) {
          cof[k] += b * ff;
          b = s[k] + x[j] * b;
        }
      }
      
      return Polynom(cof);
    }    

		// Returns the linear polynomial a*x + b
		static Polynom Linear(const CoefT& a, const CoefT& b) {
			return Polynom(std::initializer_list<CoefT>{b, a});
		}

		int  GetDegree() const { return (int)_vecCoef.size() - 1; }
		void SetDegree(int newDeg) { _vecCoef.resize(newDeg + 1); }
		bool IsNullPolynom() const { return _vecCoef.size() == 0; }
		void Reduce() { while (!_vecCoef.empty() && _vecCoef.back() == CoefT(0)) _vecCoef.pop_back(); }

		CoefT leadingTerm() const { return _vecCoef.empty() ? CoefT(0) : _vecCoef.back(); }
		CoefT constantTerm() const { return _vecCoef.empty() ? CoefT(0) : _vecCoef[0]; }

		const CoefT& operator[] (int i) const { return _vecCoef[i]; }
		CoefT& operator[] (int i) { return _vecCoef[i]; }

		///////////////////////////            Iterators              ///////////////////////////

		using iterator = typename std::vector<CoefT>::iterator;
		using const_iterator = typename std::vector<CoefT>::const_iterator;

		iterator begin() { return _vecCoef.begin(); }
		iterator end() { return _vecCoef.end(); }
		const_iterator begin() const { return _vecCoef.begin(); }
		const_iterator end() const { return _vecCoef.end(); }
		const_iterator cbegin() const { return _vecCoef.cbegin(); }
		const_iterator cend() const { return _vecCoef.cend(); }

		///////////////////////////            Operators              ///////////////////////////
		Polynom& operator=(const Polynom& Copy) { _vecCoef = Copy._vecCoef; return *this; }

		FieldT operator() (const FieldT& x) const {
			int j = GetDegree();
			FieldT p = _vecCoef[j] * FieldT(1);

			while (j > 0)
				p = p * x + _vecCoef[--j];
			return p;
		}

		bool IsEqual(const Polynom& b) const
		{
			// Compare polynomials by effective degree (ignoring trailing zeros)
			int maxSize = (int)std::max(_vecCoef.size(), b._vecCoef.size());
			
			for (int i = 0; i < maxSize; i++)
			{
				CoefT a_coef = (i < (int)_vecCoef.size()) ? _vecCoef[i] : CoefT(0);
				CoefT b_coef = (i < (int)b._vecCoef.size()) ? b._vecCoef[i] : CoefT(0);
				
				if (a_coef != b_coef)
					return false;
			}
			return true;
		}

		bool operator==(const Polynom& b) const
		{
			return IsEqual(b);
		}

		bool operator!=(const Polynom& b) const
		{
			return !IsEqual(b);
		}

		Polynom operator+(const Polynom& b) const
		{
			Polynom result;
			int n = (int)std::max(_vecCoef.size(), b._vecCoef.size());
			result._vecCoef.resize(n);
			for (int i = 0; i < n; i++)
			{
				if (i < _vecCoef.size())
					result._vecCoef[i] += _vecCoef[i];
				if (i < b._vecCoef.size())
					result._vecCoef[i] += b._vecCoef[i];
			}
			return result;
		}

		Polynom operator-(const Polynom& b) const
		{
			Polynom result;
			int n = (int)std::max(_vecCoef.size(), b._vecCoef.size());
			result._vecCoef.resize(n);
			for (int i = 0; i < n; i++)
			{
				if (i < _vecCoef.size())
					result._vecCoef[i] += _vecCoef[i];
				if (i < b._vecCoef.size())
					result._vecCoef[i] -= b._vecCoef[i];
			}
			return result;
		}

		Polynom operator*(const Polynom& b) const
		{
			Polynom result;

			int n = (int)(_vecCoef.size() + b._vecCoef.size() - 1);
			result._vecCoef.resize(n);
			for (int i = 0; i < _vecCoef.size(); i++)
				for (int j = 0; j < b._vecCoef.size(); j++)
					result._vecCoef[i + j] += _vecCoef[i] * b._vecCoef[j];
			return result;
		}

		// Addition by scalar (adds scalar to the constant term)
		Polynom operator+(const CoefT& scalar) const {
			Polynom result = *this;
			if (result._vecCoef.empty())
				result._vecCoef.resize(1, CoefT(0));
			result._vecCoef[0] += scalar;
			return result;
		}
		friend Polynom operator+(const CoefT& scalar, const Polynom& poly) {
			return poly + scalar;
		}

		// Subtraction by scalar (subtracts scalar from the constant term)
		Polynom operator-(const CoefT& scalar) const {
			Polynom result = *this;
			if (result._vecCoef.empty())
				result._vecCoef.resize(1, CoefT(0));
			result._vecCoef[0] -= scalar;
			return result;
		}
		friend Polynom operator-(const CoefT& scalar, const Polynom& poly) {
			Polynom result = -poly;
			if (result._vecCoef.empty())
				result._vecCoef.resize(1, CoefT(0));
			result._vecCoef[0] += scalar;
			return result;
		}

		// Multiplication by scalar
		Polynom operator*(const CoefT& scalar) const {
			Polynom result = *this;
			for (auto& coef : result._vecCoef)
				coef *= scalar;
			return result;
		}
		friend Polynom operator*(const CoefT& scalar, const Polynom& poly) {
			return poly * scalar;
		}

		// Division by scalar
		Polynom operator/(const CoefT& scalar) const {
			Polynom result = *this;
			for (auto& coef : result._vecCoef)
				coef /= scalar;
			return result;
		}

		static void poldiv(const Polynom& u, const Polynom& v, Polynom& qout, Polynom& rout)
		{
			int k, j, n = u.GetDegree(), nv = v.GetDegree();

			// find real degree of v
			while (nv >= 0 && v._vecCoef[nv] == CoefT(0))
				nv--;

			if (nv < 0)
				throw std::domain_error("poldiv divide by zero polynomial");

			Polynom r = u;
			Polynom q(u.GetDegree());
			for (k = n - nv; k >= 0; k--)
			{
				q[k] = r[nv + k] / v[nv];

				for (j = nv + k - 1; j >= k; j--)
					r[j] -= q[k] * v[j - k];
			}
			for (j = nv; j <= n; j++)
				r[j] = CoefT(0);


			int nq = q.GetDegree();
			while (nq >= 0 && q[nq] == CoefT(0))
				nq--;

			// setting exact size for quotient
			qout.SetDegree(nq);
			for (j = 0; j <= nq; j++)
				qout[j] = q[j];

			// setting exact size for remainder
			rout.SetDegree(nv - 1);
			for (j = 0; j < nv; j++)
				rout[j] = r[j];
		}

		///////////////////////////           Operations              ///////////////////////////
		// Given the coefficients of a polynomial of degree nc as an array c[0..nc] of size nc+1 (with
		// c[0] being the constant term), and given a value x, this routine fills an output array pd of size
		// nd+1 with the value of the polynomial evaluated at x in pd[0], and the first nd derivatives at
		// x in pd[1..nd].
		void Derive(const Real x, Vector<Real>& pd)
		{
			int  nnd, j, i;
			int  nc = GetDegree();
			int  nd = pd.size() - 1;
			Real cnst = 1.0;

			pd[0] = (*this)[nc];
			for (j = 1; j < nd + 1; j++)
				pd[j] = 0.0;

			for (i = nc - 1; i >= 0; i--)
			{
				nnd = (nd < (nc - i) ? nd : nc - i);
				for (j = nnd; j > 0; j--)
					pd[j] = pd[j] * x + pd[j - 1];

				pd[0] = pd[0] * x + (*this)[i];
			}
			for (i = 2; i < nd + 1; i++) {
				cnst *= i;
				pd[i] *= cnst;
			}
		}

		// Returns the first derivative of the polynomial as a new Polynom
		Polynom Derive() const {
			Polynom result;
			int deg = GetDegree();
			if (deg <= 0) {
				result._vecCoef.clear();
				return result;
			}
			result._vecCoef.resize(deg);
			for (int i = 1; i <= deg; ++i) {
				result._vecCoef[i - 1] = _vecCoef[i] * CoefT(i);
			}
			return result;
		}

		// Returns the indefinite integral of the polynomial as a new Polynom.
		// The constant of integration is set to zero.
		Polynom Integrate() const {
			Polynom result;
			int deg = GetDegree();
			result._vecCoef.resize(deg + 2, CoefT(0));
			for (int i = 0; i <= deg; ++i) {
				result._vecCoef[i + 1] = _vecCoef[i] / CoefT(i + 1);
			}
			return result;
		}

		///////////////////////////               I/O                 ///////////////////////////
		std::string to_string(int width, int precision) const
		{
			std::stringstream str;

			Print(str, width, precision);

			return str.str();
		}

		std::ostream& Print(std::ostream& stream) const
		{
			return Print(stream, 10, 6); // Default width and precision
		}

		std::ostream& Print(std::ostream& stream, int width, int precision) const
		{
			using std::abs;
			using std::to_string;

			std::ios_base::fmtflags f(stream.flags());
			stream << std::fixed << std::setw(width) << std::setprecision(precision);

			bool first = true;
			for (int i = (int)_vecCoef.size() - 1; i >= 0; --i)
			{
				// Skip zero coefficients
				bool is_zero = false;
				if constexpr (std::is_floating_point_v<CoefT>) {
					is_zero = (std::abs(_vecCoef[i]) < PrecisionValues<Real>::PolynomialCoeffZeroThreshold);
				}
				else if constexpr (std::is_same_v<CoefT, std::complex<double>> || std::is_same_v<CoefT, std::complex<float>>) {
					is_zero = (std::abs(_vecCoef[i]) < PrecisionValues<Real>::PolynomialCoeffZeroThreshold);
				}
				else {
					is_zero = (_vecCoef[i] == CoefT(0));
				}
				if (is_zero) continue;

				// Print sign and separator
				if (!first) {
					if constexpr (std::is_arithmetic_v<CoefT>) {
						stream << (_vecCoef[i] >= CoefT(0) ? " + " : " - ");
					}
					else {
						stream << " + "; // Always use '+' for non-ordered types
					}
				}
				else {
					if constexpr (std::is_arithmetic_v<CoefT>) {
						if (_vecCoef[i] < CoefT(0)) stream << "-";
					}
					first = false;
				}

				// Print coefficient (absolute value for arithmetic types, as-is for others)
				if constexpr (std::is_arithmetic_v<CoefT>) {
					CoefT abs_coef = _vecCoef[i] < CoefT(0) ? -_vecCoef[i] : _vecCoef[i];
					bool print_coef = (i == 0) || (abs_coef != CoefT(1));
					if (print_coef) stream << abs_coef;
				}
				else {
					stream << _vecCoef[i];
				}

				// Variable and exponent
				if (i > 0) {
					stream << "x";
					if (i > 1) stream << "^" << i;
				}
			}

			if (first) stream << CoefT(0);

			stream.flags(f);
			return stream;
		}

		friend std::ostream& operator<<(std::ostream& stream, const Polynom& poly)
		{
			return poly.Print(stream);
		}
	};

	class PolynomRealFunc : public Polynom<Real>, public IRealFunction
	{
	public:
		PolynomRealFunc() {}
		PolynomRealFunc(int n) { _vecCoef.resize(n + 1); }
		PolynomRealFunc(const std::vector<Real>& vecCoef) : Polynom(vecCoef) {}
		PolynomRealFunc(std::initializer_list<Real> list) : Polynom(list) {}
		PolynomRealFunc(const Polynom& Copy) : Polynom(Copy) {}
		~PolynomRealFunc() {}

		Real operator()(Real x) const { return Polynom::operator()(x); }
	};

	typedef Polynom<Real>      PolynomReal;
	typedef Polynom<Complex>   PolynomComplex;
	
	typedef Polynom<Real, Complex>   PolynomComplexRealCoef;

	typedef Polynom<Real, MatrixNM<Real, 2, 2>>       Matrix2Polynom;
	typedef Polynom<Real, MatrixNM<Real, 3, 3>>       Matrix3Polynom;
	typedef Polynom<Real, MatrixNM<Real, 4, 4>>       Matrix4Polynom;
}


///////////////////////////   mml/base/Geometry2D.h   ///////////////////////////



namespace MML
{
	// Geometry epsilon for floating-point comparisons
	namespace {
		constexpr Real GEOMETRY_EPSILON = 1e-10;
		
		inline bool AreEqual(Real a, Real b, Real eps = GEOMETRY_EPSILON) {
			return std::abs(a - b) < eps;
		}
	}
	class Line2D
	{
	private:
		Point2Cartesian _point;
		Vector2Cartesian _direction;					// unit vector in line direction

	public:
		// Constructors
		Line2D(const Point2Cartesian& pnt, const Vector2Cartesian& dir)
		{
			_point = pnt;
			_direction = dir.GetAsUnitVector();
		}

		Line2D(const Point2Cartesian& a, const Point2Cartesian& b)
		{
			Vector2Cartesian dir(a, b);
			_point = a;
			_direction = dir.GetAsUnitVector();
		}

		// Accessors
		Point2Cartesian   StartPoint() const { return _point; }
		Point2Cartesian&  StartPoint() { return _point; }

		Vector2Cartesian  Direction() const { return _direction; }
		Vector2Cartesian& Direction() { return _direction; }

		// Point on line at parameter t
		Point2Cartesian operator()(Real t) const
		{
			Vector2Cartesian dist = t * _direction;
			Point2Cartesian ret = _point + dist;
			return ret;
		}

		// Distance from point to line
		Real DistanceToPoint(const Point2Cartesian& p) const
		{
			Vector2Cartesian v(_point, p);
			// Distance = |v Ã— direction| (2D cross product magnitude)
			Real cross = v.X() * _direction.Y() - v.Y() * _direction.X();
			return std::abs(cross);
		}

		// Closest point on line to given point
		Point2Cartesian ClosestPoint(const Point2Cartesian& p) const
		{
			Vector2Cartesian v(_point, p);
			// Project v onto direction
			Real t = v.X() * _direction.X() + v.Y() * _direction.Y();
			return (*this)(t);
		}

		// Create perpendicular line through given point
		Line2D Perpendicular(const Point2Cartesian& throughPoint) const
		{
			// Perpendicular direction in 2D: rotate 90 degrees
			Vector2Cartesian perpDir(-_direction.Y(), _direction.X());
			return Line2D(throughPoint, perpDir);
		}

		// Check if point lies on line (within epsilon tolerance)
		bool Contains(const Point2Cartesian& p, Real epsilon = GEOMETRY_EPSILON) const
		{
			return DistanceToPoint(p) < epsilon;
		}

		// Intersection with another line (returns false if parallel)
		bool Intersects(const Line2D& other, Point2Cartesian* intersection = nullptr) const
		{
			// Lines: P1 + t*D1 and P2 + s*D2
			// Solve: P1 + t*D1 = P2 + s*D2
			Real det = _direction.X() * other._direction.Y() - _direction.Y() * other._direction.X();
			
			if (std::abs(det) < GEOMETRY_EPSILON)
				return false; // Parallel or coincident
			
			if (intersection) {
				Vector2Cartesian dp(other._point, _point);
				Real t = (dp.X() * other._direction.Y() - dp.Y() * other._direction.X()) / det;
				*intersection = (*this)(t);
			}
			
			return true;
		}
	};

	class SegmentLine2D
	{
	private:
		Point2Cartesian _point1;
		Point2Cartesian _point2;

	public:
		// Constructors
		SegmentLine2D(const Point2Cartesian& pnt1, const Point2Cartesian& pnt2) : _point1(pnt1), _point2(pnt2)
		{ }

		SegmentLine2D(const Point2Cartesian& pnt1, const Vector2Cartesian& direction, Real t) : _point1(pnt1)
		{
			_point2 = pnt1 + direction * t;
		}

		// Accessors
		Point2Cartesian  StartPoint() const { return _point1; }
		Point2Cartesian& StartPoint() { return _point1; }

		Point2Cartesian  EndPoint()  const { return _point2; }
		Point2Cartesian& EndPoint() { return _point2; }

		// Point on segment at parameter t âˆˆ [0,1]
		Point2Cartesian PointOnSegment(Real t) const
		{
			if (t < 0.0 || t > 1.0)
				throw GeometryError("SegmentLine2D::PointOnSegment t must be in [0,1]");

			Vector2Cartesian dist = t * Direction();
			Point2Cartesian ret = _point1 + dist;
			return ret;
		}

		// Basic properties
		Real                Length()    const { return _point1.Dist(_point2); }
		Vector2Cartesian    Direction() const { return Vector2Cartesian(_point1, _point2); }
		
		// Midpoint of segment
		Point2Cartesian Midpoint() const
		{
			return Point2Cartesian((_point1.X() + _point2.X()) / 2.0,
			                      (_point1.Y() + _point2.Y()) / 2.0);
		}

		// Distance from point to segment
		Real DistanceToPoint(const Point2Cartesian& p) const
		{
			Vector2Cartesian v(_point1, _point2);
			Vector2Cartesian w(_point1, p);
			
			Real lenSq = v.NormL2() * v.NormL2();
			if (lenSq < GEOMETRY_EPSILON)
				return _point1.Dist(p); // Degenerate segment
			
			// Project w onto v
			Real t = (w.X() * v.X() + w.Y() * v.Y()) / lenSq;
			t = std::clamp(t, REAL(0.0), REAL(1.0)); // Clamp to segment
			
			Point2Cartesian projection = _point1 + v * t;
			return p.Dist(projection);
		}

		// Closest point on segment to given point
		Point2Cartesian ClosestPoint(const Point2Cartesian& p) const
		{
			Vector2Cartesian v(_point1, _point2);
			Vector2Cartesian w(_point1, p);
			
			Real lenSq = v.NormL2() * v.NormL2();
			if (lenSq < GEOMETRY_EPSILON)
				return _point1; // Degenerate segment
			
			Real t = (w.X() * v.X() + w.Y() * v.Y()) / lenSq;
			t = std::clamp(t, REAL(0.0), REAL(1.0));
			
			return _point1 + v * t;
		}

		// Segment-segment intersection test
		bool Intersects(const SegmentLine2D& other, Point2Cartesian* intersection = nullptr) const
		{
			Vector2Cartesian r = Direction();
			Vector2Cartesian s = other.Direction();
			Vector2Cartesian pq(_point1, other._point1);
			
			Real rxs = r.X() * s.Y() - r.Y() * s.X();
			Real pqxr = pq.X() * r.Y() - pq.Y() * r.X();
			
			// Check if parallel
			if (std::abs(rxs) < GEOMETRY_EPSILON) {
				return false; // Parallel or collinear (collinear overlap not handled)
			}
			
			// Compute parameters
			Real t = (pq.X() * s.Y() - pq.Y() * s.X()) / rxs;
			Real u = pqxr / rxs;
			
			// Check if intersection is within both segments
			if (t >= 0.0 && t <= 1.0 && u >= 0.0 && u <= 1.0) {
				if (intersection) {
					*intersection = _point1 + r * t;
				}
				return true;
			}
			
			return false;
		}
	};

	// Triangle2D - Professional 2D triangle class with cached side lengths
	class Triangle2D
	{
	private:
		Point2Cartesian _pnt1, _pnt2, _pnt3;
		mutable Real _a, _b, _c; // Cached side lengths
		mutable bool _sidesComputed;

		void ComputeSides() const
		{
			if (!_sidesComputed) {
				_a = _pnt1.Dist(_pnt2);
				_b = _pnt2.Dist(_pnt3);
				_c = _pnt3.Dist(_pnt1);
				_sidesComputed = true;
			}
		}

	public:
		// Constructor
		Triangle2D(const Point2Cartesian& pnt1, const Point2Cartesian& pnt2, const Point2Cartesian& pnt3) 
			: _pnt1(pnt1), _pnt2(pnt2), _pnt3(pnt3), _a(0), _b(0), _c(0), _sidesComputed(false)
		{ }

		// Vertex accessors
		Point2Cartesian  Pnt1() const { return _pnt1; }
		Point2Cartesian& Pnt1() { _sidesComputed = false; return _pnt1; }
		Point2Cartesian  Pnt2() const { return _pnt2; }
		Point2Cartesian& Pnt2() { _sidesComputed = false; return _pnt2; }
		Point2Cartesian  Pnt3() const { return _pnt3; }
		Point2Cartesian& Pnt3() { _sidesComputed = false; return _pnt3; }

		// Side lengths (cached for efficiency)
		Real A() const { ComputeSides(); return _a; }
		Real B() const { ComputeSides(); return _b; }
		Real C() const { ComputeSides(); return _c; }

		// Perimeter
		Real Perimeter() const { return A() + B() + C(); }

		// Area using Heron's formula
		Real Area() const
		{
			Real a = A(), b = B(), c = C();
			Real s = (a + b + c) / 2.0;
			return std::sqrt(s * (s - a) * (s - b) * (s - c));
		}

		// Signed area (positive = CCW, negative = CW)
		Real SignedArea() const
		{
			Real area = (_pnt2.X() - _pnt1.X()) * (_pnt3.Y() - _pnt1.Y()) -
			           (_pnt3.X() - _pnt1.X()) * (_pnt2.Y() - _pnt1.Y());
			return area / 2.0;
		}

		// Centroid (geometric center)
		Point2Cartesian Centroid() const
		{
			return Point2Cartesian((_pnt1.X() + _pnt2.X() + _pnt3.X()) / 3.0,
			                      (_pnt1.Y() + _pnt2.Y() + _pnt3.Y()) / 3.0);
		}

		// Circumcenter (center of circumscribed circle)
		Point2Cartesian Circumcenter() const
		{
			Real D = 2.0 * (_pnt1.X() * (_pnt2.Y() - _pnt3.Y()) +
			               _pnt2.X() * (_pnt3.Y() - _pnt1.Y()) +
			               _pnt3.X() * (_pnt1.Y() - _pnt2.Y()));
			
			if (std::abs(D) < GEOMETRY_EPSILON)
				throw GeometryError("Triangle2D::Circumcenter - degenerate triangle");
			
			Real p1Sq = _pnt1.X() * _pnt1.X() + _pnt1.Y() * _pnt1.Y();
			Real p2Sq = _pnt2.X() * _pnt2.X() + _pnt2.Y() * _pnt2.Y();
			Real p3Sq = _pnt3.X() * _pnt3.X() + _pnt3.Y() * _pnt3.Y();
			
			Real ux = (p1Sq * (_pnt2.Y() - _pnt3.Y()) +
			          p2Sq * (_pnt3.Y() - _pnt1.Y()) +
			          p3Sq * (_pnt1.Y() - _pnt2.Y())) / D;
			
			Real uy = (p1Sq * (_pnt3.X() - _pnt2.X()) +
			          p2Sq * (_pnt1.X() - _pnt3.X()) +
			          p3Sq * (_pnt2.X() - _pnt1.X())) / D;
			
			return Point2Cartesian(ux, uy);
		}

		// Circumradius (radius of circumscribed circle)
		Real CircumRadius() const
		{
			Real a = A(), b = B(), c = C();
			Real area = Area();
			
			if (area < GEOMETRY_EPSILON)
				throw GeometryError("Triangle2D::CircumRadius - degenerate triangle");
			
			return (a * b * c) / (4.0 * area);
		}

		// Incenter (center of inscribed circle)
		Point2Cartesian Incenter() const
		{
			Real a = A(), b = B(), c = C();
			Real perimeter = a + b + c;
			
			if (perimeter < GEOMETRY_EPSILON)
				throw GeometryError("Triangle2D::Incenter - degenerate triangle");
			
			Real x = (a * _pnt3.X() + b * _pnt1.X() + c * _pnt2.X()) / perimeter;
			Real y = (a * _pnt3.Y() + b * _pnt1.Y() + c * _pnt2.Y()) / perimeter;
			
			return Point2Cartesian(x, y);
		}

		// Inradius (radius of inscribed circle)
		Real InRadius() const
		{
			Real area = Area();
			Real s = Perimeter() / 2.0;
			
			if (s < GEOMETRY_EPSILON)
				throw GeometryError("Triangle2D::InRadius - degenerate triangle");
			
			return area / s;
		}

		// Angles in radians
		Real AngleA() const // Angle at vertex 3 (pnt3) - opposite to side a
		{
			Real a = A(), b = B(), c = C();
			// Law of cosines: aÂ² = bÂ² + cÂ² - 2bcÂ·cos(A)
			Real cosA = (b * b + c * c - a * a) / (2.0 * b * c);
			return std::acos(std::clamp(cosA, REAL(-1.0), REAL(1.0)));
		}

		Real AngleB() const // Angle at vertex 1 (pnt1) - opposite to side b
		{
			Real a = A(), b = B(), c = C();
			Real cosB = (a * a + c * c - b * b) / (2.0 * a * c);
			return std::acos(std::clamp(cosB, REAL(-1.0), REAL(1.0)));
		}

		Real AngleC() const // Angle at vertex 2 (pnt2) - opposite to side c
		{
			Real a = A(), b = B(), c = C();
			Real cosC = (a * a + b * b - c * c) / (2.0 * a * b);
			return std::acos(std::clamp(cosC, REAL(-1.0), REAL(1.0)));
		}

		// Point containment using barycentric coordinates
		bool Contains(const Point2Cartesian& p, Real epsilon = GEOMETRY_EPSILON) const
		{
			// Compute barycentric coordinates
			Real denom = (_pnt2.Y() - _pnt3.Y()) * (_pnt1.X() - _pnt3.X()) +
			            (_pnt3.X() - _pnt2.X()) * (_pnt1.Y() - _pnt3.Y());
			
			if (std::abs(denom) < epsilon)
				return false; // Degenerate triangle
			
			Real a = ((_pnt2.Y() - _pnt3.Y()) * (p.X() - _pnt3.X()) +
			         (_pnt3.X() - _pnt2.X()) * (p.Y() - _pnt3.Y())) / denom;
			
			Real b = ((_pnt3.Y() - _pnt1.Y()) * (p.X() - _pnt3.X()) +
			         (_pnt1.X() - _pnt3.X()) * (p.Y() - _pnt3.Y())) / denom;
			
			Real c = 1.0 - a - b;
			
			// Point is inside if all barycentric coordinates are non-negative
			return (a >= -epsilon) && (b >= -epsilon) && (c >= -epsilon);
		}

		// Triangle classification with epsilon tolerance
		bool IsRight(Real epsilon = GEOMETRY_EPSILON) const
		{
			Real a = A(), b = B(), c = C();
			Real aSq = a * a, bSq = b * b, cSq = c * c;
			
			return AreEqual(aSq + bSq, cSq, epsilon) ||
			       AreEqual(aSq + cSq, bSq, epsilon) ||
			       AreEqual(bSq + cSq, aSq, epsilon);
		}

		bool IsIsosceles(Real epsilon = GEOMETRY_EPSILON) const
		{
			Real a = A(), b = B(), c = C();
			return AreEqual(a, b, epsilon) || AreEqual(a, c, epsilon) || AreEqual(b, c, epsilon);
		}

		bool IsEquilateral(Real epsilon = GEOMETRY_EPSILON) const
		{
			Real a = A(), b = B(), c = C();
			return AreEqual(a, b, epsilon) && AreEqual(a, c, epsilon);
		}

		// Orientation
		bool IsCounterClockwise() const
		{
			return SignedArea() > 0.0;
		}

		bool IsClockwise() const
		{
			return SignedArea() < 0.0;
		}
	};

	// Polygon2D - Professional computational geometry polygon class
	// Represents a 2D polygon as an ordered sequence of vertices
	class Polygon2D
	{
	private:
		std::vector<Point2Cartesian> _vertices;

		// Helper: Check if two line segments intersect (proper intersection, not endpoint touching)
		static bool SegmentsIntersect(const Point2Cartesian& p1, const Point2Cartesian& p2,
		                              const Point2Cartesian& p3, const Point2Cartesian& p4)
		{
			auto sign = [](Real val) { return (val > 0) - (val < 0); };
			
			// Compute cross products for orientation tests
			Real d1 = (p3.X() - p1.X()) * (p2.Y() - p1.Y()) - (p3.Y() - p1.Y()) * (p2.X() - p1.X());
			Real d2 = (p4.X() - p1.X()) * (p2.Y() - p1.Y()) - (p4.Y() - p1.Y()) * (p2.X() - p1.X());
			Real d3 = (p1.X() - p3.X()) * (p4.Y() - p3.Y()) - (p1.Y() - p3.Y()) * (p4.X() - p3.X());
			Real d4 = (p2.X() - p3.X()) * (p4.Y() - p3.Y()) - (p2.Y() - p3.Y()) * (p4.X() - p3.X());
			
			// Check if segments straddle each other
			if (sign(d1) * sign(d2) < 0 && sign(d3) * sign(d4) < 0)
				return true;
			
			return false;
		}

	public:
		// Constructors
		Polygon2D() {}
		
		Polygon2D(const std::vector<Point2Cartesian>& vertices) : _vertices(vertices) {}
		
		Polygon2D(std::initializer_list<Point2Cartesian> list) : _vertices(list) {}

		// Vertex access
		int NumVertices() const { return static_cast<int>(_vertices.size()); }
		
		const std::vector<Point2Cartesian>& Vertices() const { return _vertices; }
		std::vector<Point2Cartesian>& Vertices() { return _vertices; }
		
		const Point2Cartesian& operator[](int i) const { return _vertices[i]; }
		Point2Cartesian& operator[](int i) { return _vertices[i]; }
		
		const Point2Cartesian& Vertex(int i) const { 
			if (i < 0 || i >= NumVertices())
				throw VectorAccessBoundsError("Polygon2D::Vertex - index out of range", i, NumVertices());
			return _vertices[i]; 
		}
		
		void AddVertex(const Point2Cartesian& p) { _vertices.push_back(p); }
		
		void Clear() { _vertices.clear(); }

		// Edge access - returns directed edge as segment
		SegmentLine2D Edge(int i) const {
			if (i < 0 || i >= NumVertices())
				throw VectorAccessBoundsError("Polygon2D::Edge - index out of range", i, NumVertices());
			return SegmentLine2D(_vertices[i], _vertices[(i + 1) % NumVertices()]);
		}

		// Basic properties
		Real Perimeter() const {
			if (NumVertices() < 2) return 0.0;
			
			Real perimeter = 0.0;
			int n = NumVertices();
			for (int i = 0; i < n; i++) {
				perimeter += _vertices[i].Dist(_vertices[(i + 1) % n]);
			}
			return perimeter;
		}

		// Signed area using shoelace formula (positive = counterclockwise, negative = clockwise)
		Real SignedArea() const {
			if (NumVertices() < 3) return 0.0;
			
			Real area = 0.0;
			int n = NumVertices();
			for (int i = 0; i < n; i++) {
				area += _vertices[i].X() * _vertices[(i + 1) % n].Y();
				area -= _vertices[i].Y() * _vertices[(i + 1) % n].X();
			}
			return area / 2.0;
		}

		// Unsigned area
		Real Area() const {
			return std::abs(SignedArea());
		}

		// Centroid (geometric center)
		Point2Cartesian Centroid() const {
			if (NumVertices() == 0)
				throw GeometryError("Polygon2D::Centroid - empty polygon");
			
			if (NumVertices() == 1)
				return _vertices[0];
			
			if (NumVertices() == 2)
				return Point2Cartesian((_vertices[0].X() + _vertices[1].X()) / 2.0,
				                      (_vertices[0].Y() + _vertices[1].Y()) / 2.0);
			
			// For polygons with 3+ vertices, use area-weighted formula
			Real cx = 0.0, cy = 0.0;
			Real signedArea = 0.0;
			int n = NumVertices();
			
			for (int i = 0; i < n; i++) {
				int j = (i + 1) % n;
				Real cross = _vertices[i].X() * _vertices[j].Y() - _vertices[j].X() * _vertices[i].Y();
				signedArea += cross;
				cx += (_vertices[i].X() + _vertices[j].X()) * cross;
				cy += (_vertices[i].Y() + _vertices[j].Y()) * cross;
			}
			
			signedArea /= 2.0;
			if (std::abs(signedArea) < GEOMETRY_EPSILON)
				throw GeometryError("Polygon2D::Centroid - degenerate polygon (zero area)");
			
			cx /= (6.0 * signedArea);
			cy /= (6.0 * signedArea);
			
			return Point2Cartesian(cx, cy);
		}

		// Bounding box
		struct BoundingBox {
			Real minX, maxX, minY, maxY;
			
			Real Width() const { return maxX - minX; }
			Real Height() const { return maxY - minY; }
			Point2Cartesian Center() const { return Point2Cartesian((minX + maxX) / 2.0, (minY + maxY) / 2.0); }
		};
		
		BoundingBox GetBoundingBox() const {
			if (NumVertices() == 0)
				throw GeometryError("Polygon2D::GetBoundingBox - empty polygon");
			
			BoundingBox box;
			box.minX = box.maxX = _vertices[0].X();
			box.minY = box.maxY = _vertices[0].Y();
			
			for (int i = 1; i < NumVertices(); i++) {
				box.minX = std::min(box.minX, _vertices[i].X());
				box.maxX = std::max(box.maxX, _vertices[i].X());
				box.minY = std::min(box.minY, _vertices[i].Y());
				box.maxY = std::max(box.maxY, _vertices[i].Y());
			}
			
			return box;
		}

		// Orientation: counterclockwise (CCW) or clockwise (CW)
		bool IsCounterClockwise() const {
			return SignedArea() > 0.0;
		}
		
		bool IsClockwise() const {
			return SignedArea() < 0.0;
		}

		// Reverse vertex order
		void Reverse() {
			std::reverse(_vertices.begin(), _vertices.end());
		}

		// Simple polygon check - no self-intersections (excluding consecutive edges)
		bool IsSimple() const {
			int n = NumVertices();
			if (n < 3) return false;
			
			// Check all non-adjacent edge pairs for intersections
			for (int i = 0; i < n; i++) {
				Point2Cartesian p1 = _vertices[i];
				Point2Cartesian p2 = _vertices[(i + 1) % n];
				
				// Check against non-adjacent edges
				for (int j = i + 2; j < n; j++) {
					// Skip if edges are adjacent (share a vertex)
					if (j == (i + n - 1) % n) continue;
					
					Point2Cartesian p3 = _vertices[j];
					Point2Cartesian p4 = _vertices[(j + 1) % n];
					
					if (SegmentsIntersect(p1, p2, p3, p4))
						return false;
				}
			}
			
			return true;
		}

		// Convex polygon check
		bool IsConvex() const {
			int n = NumVertices();
			if (n < 3) return false;
			
			bool hasPositive = false;
			bool hasNegative = false;
			
			for (int i = 0; i < n; i++) {
				Point2Cartesian p0 = _vertices[i];
				Point2Cartesian p1 = _vertices[(i + 1) % n];
				Point2Cartesian p2 = _vertices[(i + 2) % n];
				
				// Compute cross product of edges (p0->p1) and (p1->p2)
				Vector2Cartesian v1(p0, p1);
				Vector2Cartesian v2(p1, p2);
				Real cross = v1.X() * v2.Y() - v1.Y() * v2.X();
				
				if (cross > GEOMETRY_EPSILON) hasPositive = true;
				if (cross < -GEOMETRY_EPSILON) hasNegative = true;
				
				// If we have both signs, polygon is not convex
				if (hasPositive && hasNegative)
					return false;
			}
			
			return true;
		}

		// Point-in-polygon test using ray-casting algorithm
		// Works for simple polygons (both convex and non-convex)
		bool Contains(const Point2Cartesian& point) const {
			int n = NumVertices();
			if (n < 3) return false;
			
			// Ray casting: count intersections of horizontal ray from point to the right
			int intersections = 0;
			
			for (int i = 0; i < n; i++) {
				Point2Cartesian p1 = _vertices[i];
				Point2Cartesian p2 = _vertices[(i + 1) % n];
				
				// Check if ray intersects edge
				if ((p1.Y() > point.Y()) != (p2.Y() > point.Y())) {
					// Compute x-coordinate of intersection
					Real xIntersect = p1.X() + (point.Y() - p1.Y()) * (p2.X() - p1.X()) / (p2.Y() - p1.Y());
					
					if (point.X() < xIntersect)
						intersections++;
				}
			}
			
			// Odd number of intersections = inside
			return (intersections % 2) == 1;
		}

		// Winding number algorithm for point-in-polygon (more robust than ray-casting)
		int WindingNumber(const Point2Cartesian& point) const {
			int n = NumVertices();
			if (n < 3) return 0;
			
			int wn = 0; // winding number counter
			
			for (int i = 0; i < n; i++) {
				Point2Cartesian p1 = _vertices[i];
				Point2Cartesian p2 = _vertices[(i + 1) % n];
				
				if (p1.Y() <= point.Y()) {
					if (p2.Y() > point.Y()) {
						// Upward crossing
						Real cross = (p2.X() - p1.X()) * (point.Y() - p1.Y()) - (point.X() - p1.X()) * (p2.Y() - p1.Y());
						if (cross > 0) {
							wn++; // Point is left of edge
						}
					}
				} else {
					if (p2.Y() <= point.Y()) {
						// Downward crossing
						Real cross = (p2.X() - p1.X()) * (point.Y() - p1.Y()) - (point.X() - p1.X()) * (p2.Y() - p1.Y());
						if (cross < 0) {
							wn--; // Point is right of edge
						}
					}
				}
			}
			
			return wn;
		}

		// Legacy compatibility
		std::vector<Point2Cartesian> Points() const { return _vertices; }
		std::vector<Point2Cartesian>& Points() { return _vertices; }
		bool IsInside(const Point2Cartesian& pnt) const { return Contains(pnt); }

		// Triangularization (ear clipping algorithm for simple polygons)
		// Note: This is a basic implementation - for production use, consider more robust algorithms
		std::vector<Triangle2D> Triangularization() const {
			std::vector<Triangle2D> triangles;
			int n = NumVertices();
			
			if (n < 3) return triangles;
			if (n == 3) {
				triangles.push_back(Triangle2D(_vertices[0], _vertices[1], _vertices[2]));
				return triangles;
			}
			
			// Simple fan triangulation from first vertex (works for convex polygons)
			// For non-convex, this is a placeholder - full ear clipping would be more complex
			for (int i = 1; i < n - 1; i++) {
				triangles.push_back(Triangle2D(_vertices[0], _vertices[i], _vertices[i + 1]));
			}
			
			return triangles;
		}
	};
}

///////////////////////////   mml/base/Geometry3D.h   ///////////////////////////




using namespace MML::Utils;

namespace MML
{


	// ============================================================================
	// 3D Geometric Primitives
	// ============================================================================

	class Line3D
	{
	private:
		Pnt3Cart  _point;
		Vec3Cart _direction;

	public:
		Line3D() {}
		// by default, direction vector is normalized to unit vector (but, it need not be such!)
		Line3D(const Pnt3Cart& pnt, const Vec3Cart dir)
		{
			// check for null vector as direction
			if (dir.X() == 0.0 && dir.Y() == 0.0 && dir.Z() == 0.0)
				throw GeometryError("Line3D ctor - null vector as direction");

			_point = pnt;
			_direction = dir.GetAsUnitVector();
		}
		Line3D(const Pnt3Cart& a, const Pnt3Cart& b)
		{
			// check for same points
			if (a == b)
				throw GeometryError("Line3D ctor - same points");

			Vec3Cart dir(a, b);
			_point = a;
			_direction = dir.GetAsUnitVector();
		}

		Pnt3Cart   StartPoint() const { return _point; }
		Pnt3Cart& StartPoint() { return _point; }

		Vec3Cart  Direction() const { return _direction; }
		Vec3Cart& Direction() { return _direction; }

		Pnt3Cart operator()(Real t) const { return _point + t * _direction; }

		bool AreEqual(const Line3D& b, Real eps = Defaults::Line3DAreEqualTolerance) const
		{
			return IsPointOnLine(b.StartPoint()) && b.IsPointOnLine(StartPoint()) && Direction().IsEqual(b.Direction(), eps);
		}
		bool operator==(const Line3D& b) const
		{
			return AreEqual(b, Defaults::Line3DAreEqualTolerance);
		}

		bool IsPerpendicular(const Line3D& b, Real eps = Defaults::Line3DIsPerpendicularTolerance) const
		{
			return ScalarProduct(Direction(), b.Direction()) < eps;
		}
		bool IsParallel(const Line3D& b, Real eps = Defaults::Line3DIsParallelTolerance) const
		{
			return Direction().IsEqual(b.Direction(), eps);
		}

		bool IsPointOnLine(const Pnt3Cart& pnt, Real eps = Defaults::Line3DIsPointOnLineTolerance) const
		{
			if (pnt == StartPoint())
				return true;	// point is start point of line

		// check if point is on line by checking if the vector from start point to point is parallel OR anti-parallel to direction vector
		// A line extends infinitely in both directions, so we use cross product which is zero for both parallel and anti-parallel vectors
		Vec3Cart vecFromStartToPnt(_point, pnt);
		Vec3Cart crossProd = VectorProduct(vecFromStartToPnt, _direction);
		return crossProd.NormL2() < eps;
	}

	// distance between point and line
	Real Dist(const Pnt3Cart& pnt) const
	{
		// Bronshtein 3.394
		const Real a = pnt.X();
		const Real b = pnt.Y();
		const Real c = pnt.Z();

		const Real x1 = StartPoint().X();
		const Real y1 = StartPoint().Y();
		const Real z1 = StartPoint().Z();

		const Real l = Direction().X();
		const Real m = Direction().Y();
		const Real n = Direction().Z();

		Real numer = POW2((a - x1) * m - (b - y1) * l) + POW2((b - y1) * n - (c - z1) * m) + POW2((c - z1) * l - (a - x1) * n);
		Real denom = l * l + m * m + n * n;

		return sqrt(numer / denom);
	}
	// nearest point on line to given point
		Pnt3Cart NearestPointOnLine(const Pnt3Cart& pnt) const
		{
			// https://math.stackexchange.com/questions/1521128/given-a-line-and-a-point-in-3d-how-to-find-the-closest-point-on-the-line         
			Vec3Cart line_dir = this->Direction();
			Vec3Cart rad_vec_AP(StartPoint(), pnt);

			Real t = rad_vec_AP * line_dir / POW2(line_dir.NormL2());

			return StartPoint() + t * line_dir;
		}

		// distance between two lines
		Real Dist(const Line3D& line) const
		{
			// https://math.stackexchange.com/questions/2213165/distance-between-two-lines-in-3d-space
			// https://en.wikipedia.org/wiki/Skew_lines#Nearest_points
			Pnt3Cart  p1 = StartPoint();
			Vec3Cart d1 = Direction();
			Pnt3Cart  p2 = line.StartPoint();
			Vec3Cart d2 = line.Direction();

			Vec3Cart n = VectorProduct(d1, d2);

			if (n.IsNullVec())
			{
				// parallel lines
				return Vec3Cart(p1, p2) * d1 / d2.NormL2();
			}
			else
			{
				// skew lines
				return Abs(n * Vec3Cart(p1, p2)) / n.NormL2();
			}
		}
		// distance between two lines, while also returning nearest points on both lines
		// if lines are parallel, returns false
		bool Dist(const Line3D& line, Real& out_dist, Pnt3Cart& out_line1_pnt, Pnt3Cart& out_line2_pnt) const
		{
			// https://math.stackexchange.com/questions/2213165/distance-between-two-lines-in-3d-space
			// https://en.wikipedia.org/wiki/Skew_lines#Nearest_points
			Pnt3Cart  p1 = StartPoint();
			Vec3Cart d1 = Direction();
			Pnt3Cart  p2 = line.StartPoint();
			Vec3Cart d2 = line.Direction();
			out_dist = 0.0;

			Vec3Cart n = VectorProduct(d1, d2);

			if (n.IsNullVec())				// check for parallel lines
			{
				out_dist = Vec3Cart(p1, p2) * d1 / d2.NormL2();
				return false;
			}
			else
			{
				// skew lines
				out_dist = Abs(n * Vec3Cart(p1, p2)) / n.NormL2();

				Real t1 = (VectorProduct(d2, n) * Vec3Cart(p1, p2)) / POW2(n.NormL2());
				Real t2 = (VectorProduct(d1, n) * Vec3Cart(p1, p2)) / POW2(n.NormL2());

				out_line1_pnt = p1 + t1 * d1;
				out_line2_pnt = p2 + t2 * d2;
			}

			return true;
		}
		// intersection of two lines
		bool Intersection(const Line3D& line, Pnt3Cart& out_inter_pnt) const
		{
			// https://en.wikipedia.org/wiki/Skew_lines#Nearest_points
			// https://math.stackexchange.com/questions/2213165/distance-between-two-lines-in-3d-space
			Pnt3Cart  p1 = StartPoint();
			Vec3Cart d1 = Direction();
			Pnt3Cart  p2 = line.StartPoint();
			Vec3Cart d2 = line.Direction();
			Real dist = 0.0;

			Vec3Cart n = VectorProduct(d1, d2);

			if (n.IsNullVec())				// check for parallel lines
			{
				if (*this == line)
				{
					// lines are equal, return any point on the line
					out_inter_pnt = p1;
					return true;
				}
				else
					return false;
			}
			else				// skew lines
			{
				dist = Abs(n * Vec3Cart(p1, p2)) / n.NormL2();

				if (dist > Defaults::Line3DIntersectionTolerance)
					return false;	// lines are skew, no intersection

				Real t1 = (VectorProduct(d2, n) * Vec3Cart(p1, p2)) / POW2(n.NormL2());

				out_inter_pnt = p1 + t1 * d1;
			}

			return true;
		}

		// perpendicular line that goes through givenpoint
		// direction is from given pnt to point on line that is closest to given point
		Line3D PerpendicularLineThroughPoint(const Pnt3Cart& pnt) const
		{
			if (IsPointOnLine(pnt))
				throw GeometryError("Line3D::PerpendicularLineThroughPoint - point is on the line");

			return Line3D(pnt, Vec3Cart(pnt, NearestPointOnLine(pnt)).GetAsUnitVector());
		}
	};

	class SegmentLine3D
	{
	private:
		Pnt3Cart _point1;
		Pnt3Cart _point2;

	public:
		SegmentLine3D(Pnt3Cart pnt1, Pnt3Cart pnt2) : _point1(pnt1), _point2(pnt2)
		{
		}
		SegmentLine3D(Pnt3Cart pnt1, Vec3Cart direction, Real t)
		{
			_point1 = pnt1;
			_point2 = pnt1 + t * direction;
		}

		Pnt3Cart   StartPoint() const { return _point1; }
		Pnt3Cart& StartPoint() { return _point1; }

		Pnt3Cart   EndPoint() const { return _point2; }
		Pnt3Cart& EndPoint() { return _point2; }

		Pnt3Cart		operator()(Real t) const
		{
			if (t < 0.0 || t > 1.0)
				throw GeometryError("SegmentLine3D::PointOnSegment - t not in [0,1]");

			return _point1 + t * Direction();
		}

		Real              Length()    const { return _point1.Dist(_point2); }
		Vec3Cart  Direction() const { return Vec3Cart(_point1, _point2); }

	// Distance from point to line segment
	Real Dist(const Pnt3Cart& pnt) const
	{
		Vec3Cart segDir = Direction();
		Real segLength = Length();
		
		if (segLength == 0.0)
			return _point1.Dist(pnt);  // degenerate segment
		
		// Project point onto line containing segment
		Vec3Cart vecToPnt(_point1, pnt);
		Real t = (vecToPnt * segDir) / (segLength * segLength);
		
		// Clamp t to [0, 1] to stay on segment
		if (t < 0.0)
			return _point1.Dist(pnt);  // closest to start point
		else if (t > 1.0)
			return _point2.Dist(pnt);  // closest to end point
		else
		{
			// Closest point is on the segment
			Pnt3Cart closestPoint = _point1 + t * segDir;
			return closestPoint.Dist(pnt);
		}
	}
	};

	class Plane3D
	{
	private:
		Real _A, _B, _C, _D;

	public:
		Plane3D(const Pnt3Cart& a, const Vec3Cart& normal)
		{
			if (normal.IsNullVec())
				throw GeometryError("Plane3D ctor - normal is null vector");

			Vec3Cart unitNormal = normal.GetAsUnitVector();

			_A = unitNormal.X();
			_B = unitNormal.Y();
			_C = unitNormal.Z();
			_D = -(a.X() * unitNormal.X() + a.Y() * unitNormal.Y() + a.Z() * unitNormal.Z());
		}
		Plane3D(const Pnt3Cart& a, const Pnt3Cart& b, const Pnt3Cart& c)
			: Plane3D(a, VectorProduct(Vec3Cart(a, b), Vec3Cart(a, c)))
		{
		}
		// Hesse normal form
		Plane3D(Real alpha, Real beta, Real gamma, Real d)
		{
			_A = cos(alpha);
			_B = cos(beta);
			_C = cos(gamma);
			_D = -d;
		}
		// segments on coordinate axes
		Plane3D(Real seg_x, Real seg_y, Real seg_z)
		{
			if (seg_x == 0 || seg_y == 0 || seg_z == 0)
				throw GeometryError("Plane3D ctor - zero segment");

			_A = 1 / seg_x;
			_B = 1 / seg_y;
			_C = 1 / seg_z;
			_D = -1;
		}

		static Plane3D GetXYPlane() { return Plane3D(Pnt3Cart(0, 0, 0), Vec3Cart(0, 0, 1)); }
		static Plane3D GetXZPlane() { return Plane3D(Pnt3Cart(0, 0, 0), Vec3Cart(0, 1, 0)); }
		static Plane3D GetYZPlane() { return Plane3D(Pnt3Cart(0, 0, 0), Vec3Cart(1, 0, 0)); }

		Real  A() const { return _A; }
		Real& A() { return _A; }
		Real  B() const { return _B; }
		Real& B() { return _B; }
		Real  C() const { return _C; }
		Real& C() { return _C; }
		Real  D() const { return _D; }
		Real& D() { return _D; }

		Vec3Cart	Normal() const { return Vec3Cart(_A, _B, _C); }
		Pnt3Cart	GetPointOnPlane() const {
			if (_A != 0.0)
				return Pnt3Cart(-_D / _A, 0, 0);
			else  if (_B != 0.0)
				return Pnt3Cart(0, -_D / _B, 0);
			else
				return Pnt3Cart(0, 0, -_D / _C);
		}

		void GetCoordAxisSegments(Real& outseg_x, Real& outseg_y, Real& outseg_z) const
		{
			if (_A != 0.0)
				outseg_x = -_D / _A;
			else
				outseg_x = Constants::PosInf;

			if (_B != 0.0)
				outseg_y = -_D / _B;
			else
				outseg_y = Constants::PosInf;

			if (_C != 0.0)
				outseg_z = -_D / _C;
			else
				outseg_z = Constants::PosInf;
		}

		// point to plane operations
		bool IsPointOnPlane(const Pnt3Cart& pnt, Real defEps = Defaults::Plane3DIsPointOnPlaneTolerance) const
		{
			return std::abs(_A * pnt.X() + _B * pnt.Y() + _C * pnt.Z() + _D) < defEps;
		}
		Real DistToPoint(const Pnt3Cart& pnt) const
		{
			Real a = _A * pnt.X() + _B * pnt.Y() + _C * pnt.Z() + _D;
			Real b = sqrt(_A * _A + _B * _B + _C * _C);

			return std::abs(a / b);
		}

		Pnt3Cart ProjectionToPlane(const Pnt3Cart& pnt) const
		{
			// Plane: nï¿½x + D = 0
			// Projection: p_proj = pnt - n * (nï¿½pnt + D) / |n|^2
			Vec3Cart n = Normal();
			
			Real n_norm2 = n.NormL2() * n.NormL2();
			if (n_norm2 == 0.0)
				throw GeometryError("ProjectionToPlane: plane normal is zero vector");

			Real dist = (n * pnt + D()) / n_norm2;
			
			return pnt - n * dist;
		}

		// line to plane operations
		bool IsLineOnPlane(const Line3D& line) const
		{
			// get two points
			const Pnt3Cart pnt1 = line.StartPoint();
			const Pnt3Cart pnt2 = line(1.0);

			if (IsPointOnPlane(pnt1) && IsPointOnPlane(pnt2))
				return true;
			else
				return false;
		}
		Real AngleToLine(const Line3D& line) const
		{
			// angle between line and normal to plane
			return Constants::PI / 2.0 - line.Direction().AngleToVector(this->Normal());
		}
		bool IntersectionWithLine(const Line3D& line, Pnt3Cart& out_inter_pnt) const
		{
			Vec3Cart line_dir = line.Direction();
			Vec3Cart plane_normal = Normal();

			// Check if the line is parallel to the plane
			if (ScalarProduct(line_dir, plane_normal) == 0) {
				return false;
			}

			// Calculate the distance between the point on the line and the plane
			double t = -(plane_normal * line.StartPoint() + D()) / ScalarProduct(line_dir, plane_normal);
			Pnt3Cart inter_pnt = line.StartPoint() + line_dir * t;
			out_inter_pnt = inter_pnt;
			
			return true;
		}

		// plane to plane operations
		bool IsParallelToPlane(const Plane3D& plane) const
		{
			Vec3Cart norm1(_A, _B, _C);
			Vec3Cart norm2(plane._A, plane._B, plane._C);

			return norm1.IsParallelTo(norm2);
		}
		bool IsPerpendicularToPlane(const Plane3D& plane) const
		{
			Vec3Cart norm1(_A, _B, _C);
			Vec3Cart norm2(plane._A, plane._B, plane._C);

			return norm1.IsPerpendicularTo(norm2);
		}
		Real AngleToPlane(const Plane3D& plane) const
		{
			// angle between normals of two planes
			return this->Normal().AngleToVector(plane.Normal());
		}
		Real DistToPlane(const Plane3D& plane) const
		{
			if (IsParallelToPlane(plane))
			{
				// distance between two parallel planes is the distance between any point on one plane and the other plane
				return DistToPoint(plane.GetPointOnPlane());
			}
			else
				return 0.0;
		}

		bool IntersectionWithPlane(const Plane3D& plane, Line3D& out_inter_line) const
		{
			Vec3Cart n1 = Normal();
			Vec3Cart n2 = plane.Normal();
			Vec3Cart dir = VectorProduct(n1, n2);

			if (dir.NormL2() == 0.0) {
				// Planes are parallel
				return false;
			}

			// Solve for a point on the intersection line:
			// x = ( (d2 n1 - d1 n2) x (n1 x n2) ) / |n1 x n2|^2
			double d1 = -D();
			double d2 = -plane.D();

			Vec3Cart n1xn2 = dir;
			Vec3Cart p = VectorProduct((d2 * n1 - d1 * n2), n1xn2) / POW2(n1xn2.NormL2());

			out_inter_line = Line3D(Pnt3Cart(p.X(), p.Y(), p.Z()), dir.GetAsUnitVector());
			return true;
		}
	};

	class Triangle3D
	{
	protected:
		Pnt3Cart _pnt1, _pnt2, _pnt3;
	public:
		Triangle3D() {}
		Triangle3D(Pnt3Cart pnt1, Pnt3Cart pnt2, Pnt3Cart pnt3)
			: _pnt1(pnt1), _pnt2(pnt2), _pnt3(pnt3)
		{
		}

		Real A() const { return _pnt1.Dist(_pnt2); }
		Real B() const { return _pnt2.Dist(_pnt3); }
		Real C() const { return _pnt3.Dist(_pnt1); }

		Pnt3Cart	Pnt1() const { return _pnt1; }
		Pnt3Cart& Pnt1()			 { return _pnt1; }
		Pnt3Cart	Pnt2() const { return _pnt2; }
		Pnt3Cart& Pnt2()			 { return _pnt2; }
		Pnt3Cart	Pnt3() const { return _pnt3; }
		Pnt3Cart& Pnt3()			 { return _pnt3; }

		Real Area() const
		{
			Real s = (A() + B() + C()) / 2.0;
			return sqrt(s * (s - A()) * (s - B()) * (s - C()));
		}

    bool IsRight(Real eps = Defaults::Triangle3DIsRightTolerance) const
    {
      // Check if a^2 + b^2 = c^2 (Pythagorean theorem) with tolerance
      Real a = A(), b = B(), c = C();
      return (std::abs(a*a + b*b - c*c) < eps) || 
            (std::abs(a*a + c*c - b*b) < eps) || 
            (std::abs(b*b + c*c - a*a) < eps);
    }
    bool IsIsosceles(Real eps = Defaults::Triangle3DIsIsoscelesTolerance) const		// two sides are the same length
    {
      Real a = A(), b = B(), c = C();
      return (std::abs(a - b) < eps) || (std::abs(a - c) < eps) || (std::abs(b - c) < eps);
    }
    bool IsEquilateral(Real eps = Defaults::Triangle3DIsEquilateralTolerance) const	// all sides are the same length
    {
      Real a = A(), b = B(), c = C();
      return (std::abs(a - b) < eps) && (std::abs(a - c) < eps);
    }

    Pnt3Cart Centroid() const
    {
      return (_pnt1 + _pnt2 + _pnt3) / 3.0;
    }

    Plane3D getDefinedPlane() const
    {
			return Plane3D(_pnt1, _pnt2, _pnt3);
		}

		// check if point is inside triangle
		bool IsPointInside(const Pnt3Cart& pnt, Real eps = Defaults::Triangle3DIsPointInsideTolerance) const
		{
			// check if point is inside triangle using barycentric coordinates
			Vec3Cart v0 = Vec3Cart(_pnt1, _pnt2);
			Vec3Cart v1 = Vec3Cart(_pnt1, _pnt3);
			Vec3Cart v2 = Vec3Cart(_pnt1, pnt);
			
			Real d00 = ScalarProduct(v0, v0);
			Real d01 = ScalarProduct(v0, v1);
			Real d11 = ScalarProduct(v1, v1);
			Real d20 = ScalarProduct(v2, v0);
			Real d21 = ScalarProduct(v2, v1);
			Real denom = d00 * d11 - d01 * d01;
			
			if (denom == 0.0)
				return false; // degenerate triangle
			
			Real v = (d11 * d20 - d01 * d21) / denom;
			
			if (v < 0.0 || v > 1.0)
				return false;
			
			Real w = (d00 * d21 - d01 * d20) / denom;
			
			if (w < 0.0 || w > 1.0)
				return false;
			
			return (v + w <= 1.0 + eps); // allow for small numerical errors
		}
	};

	// Represents triangular surface in 3D and defines all needed mappings 
	// to represent Triangle3D as IParametricSurface
	class TriangleSurface3D : public Triangle3D, IParametricSurface<3>
	{
	public:
		Real _minX, _maxX, _minY, _maxY;
		Pnt3Cart _origin;
		Pnt3Cart _center;
		Vec3Cart _localX, _localY;
		Vec3Cart _normal;
		Real _pnt3XCoord;

		// pnt1-pnt2 should be hypothenuse of the triangle!!!
		// but we will handle it, if it is not
		TriangleSurface3D(Pnt3Cart pnt1, Pnt3Cart pnt2, Pnt3Cart pnt3)
		{
			// CHECK THAT 1-2 side is THE LONGEST ONE!!!
			Real a = pnt1.Dist(pnt2);
			Real b = pnt2.Dist(pnt3);
			Real c = pnt3.Dist(pnt1);

			if (a >= b && a >= c)
			{
				; // nice, we are all good
			}
			else if (b >= a && b >= c)
			{
				// rotate points one place, so that 'b' side (pnt2-pnt3) is at the beginning
				Pnt3Cart tmp = pnt1;
				pnt1 = pnt2;
				pnt2 = pnt3;
				pnt3 = tmp;
			}
			else
			{
				// rotate points two places (c is longest, so pnt3-pnt1 becomes new pnt1-pnt2)
				Pnt3Cart tmp = pnt1;
				pnt1 = pnt3;
				pnt3 = pnt2;
				pnt2 = tmp;
			}

			_pnt1 = pnt1;		// initializing points in base Triangle3D class
			_pnt2 = pnt2;
			_pnt3 = pnt3;

			// calculate min and max
			// calculate center
			_center = (pnt1 + pnt2 + pnt3) / 3.0;

			// calculate local coordinate system
			// we will take x-axis to be from pnt1 to pnt2
			_localX = Vec3Cart(pnt1, pnt2).GetAsUnitVector();

			// we will calculate y-axis as following
			// calculate perpendicular vector to x-axis, that goes through pnt3
			Line3D	 lineX(pnt1, pnt2);
			Pnt3Cart pntOnLine = lineX.NearestPointOnLine(pnt3);

			_localY = Vec3Cart(pntOnLine, pnt3).GetAsUnitVector();

			_minX = 0.0;
			_maxX = pnt1.Dist(pnt2);
			_minY = 0.0;
			_maxY = pntOnLine.Dist(pnt3);
			_pnt3XCoord = pntOnLine.Dist(pnt1);

			_normal = VectorProduct(_localX, _localY).GetAsUnitVector();
		}

		virtual Real getMinU() const { return _minX; }
		virtual Real getMaxU() const { return _maxX; }
		virtual Real getMinW(Real u) const { return _minY; }
		virtual Real getMaxW(Real u) const
		{
			// this depends on value of u (which is localX)
			if (u < _pnt3XCoord)
				return _minY + (u / _pnt3XCoord) * (_maxY - _minY);
			else
				return _minY + ((_maxX - u) / (_maxX - _pnt3XCoord)) * (_maxY - _minY);
		}

		// for a given (u,w), which is basically (x,y) in local coordinate system
		// return point in global coordinate system
		VectorN<Real, 3> operator()(Real u, Real w) const
		{
			Pnt3Cart ret = _origin + u * _localX + w * _localY;
			return VectorN<Real, 3>({ ret.X(), ret.Y(), ret.Z() });
		}
	};

	// represents rectangular surface in 3D
	class RectSurface3D : public IParametricSurfaceRect<3>
	{
	public:
		// all constructors are expected to set properly these values
		Pnt3Cart _pnt1, _pnt2, _pnt3, _pnt4;
		Real _minX, _maxX, _minY, _maxY;
		Pnt3Cart _center;
		Vec3Cart _localX, _localY;

		RectSurface3D() {}
		// MUST SET NORMAL, FOR ORIENTATION! (uzeti right-hand ... defined by order of points?)
		// zadati i centralnom tockom, vektorom normale, uz dodatni a i b!
		RectSurface3D(Pnt3Cart pnt1, Pnt3Cart pnt2, Pnt3Cart pnt3, Pnt3Cart pnt4)
			: _pnt1(pnt1), _pnt2(pnt2), _pnt3(pnt3), _pnt4(pnt4)
		{
			// Validate coplanarity: all 4 points must lie in the same plane
			Plane3D plane(pnt1, pnt2, pnt3);
			if (!plane.IsPointOnPlane(pnt4))
				throw GeometryError("RectSurface3D ctor - points are not coplanar");

			// podesiti min i max
			Real lenX = _pnt1.Dist(_pnt2);
			Real lenY = _pnt1.Dist(_pnt4);
			_minX = -lenX / 2;
			_maxX = lenX / 2;
			_minY = -lenY / 2;
			_maxY = lenY / 2;

			// calculate center
			_center = (_pnt1 + _pnt2 + _pnt3 + _pnt4) / 4.0;

			// calculate local coordinate system
			_localX = Vec3Cart(_pnt1, _pnt2).GetAsUnitVector();
			_localY = Vec3Cart(_pnt1, _pnt4).GetAsUnitVector();
		}

		virtual Real getMinU() const { return _minX; }
		virtual Real getMaxU() const { return _maxX; }
		virtual Real getMinW() const { return _minY; }
		virtual Real getMaxW() const { return _maxY; }

		Vec3Cart getNormal() const {
			return VectorProduct(Vec3Cart(_pnt1, _pnt2), Vec3Cart(_pnt1, _pnt4)).GetAsUnitVector();
		}
		Pnt3Cart getCenter() const { return _center; }

		Real getArea() const {
			return VectorProduct(Vec3Cart(_pnt1, _pnt2), Vec3Cart(_pnt1, _pnt4)).NormL2();
		}

		// vraca dva Triangle3D - i orijentacija je parametar! (kako ce odabrati tocke)
		
		VectorN<Real, 3> operator()(Real u, Real w) const {
			Pnt3Cart ret = _center + u * _localX + w * _localY;
			return VectorN<Real, 3>({ ret.X(), ret.Y(), ret.Z() });
		}
	};

}



///////////////////////////   mml/base/Geometry3DBodies.h   ///////////////////////////






using namespace MML::Utils;

namespace MML
{
	// ============================================================================
	// Bounding Volumes for Spatial Queries and Collision Detection
	// ============================================================================

	/// <summary>
	/// Axis-Aligned Bounding Box (AABB) for fast spatial queries and collision broad-phase.
	/// Defined by minimum and maximum corner points.
	/// </summary>
	class BoundingBox3D
	{
	private:
		Pnt3Cart _min;
		Pnt3Cart _max;

	public:
		// Constructors
		BoundingBox3D() : _min(0, 0, 0), _max(0, 0, 0) {}
		
		BoundingBox3D(const Pnt3Cart& min, const Pnt3Cart& max) 
			: _min(min), _max(max)
		{
			// Validate that min is actually less than max in all dimensions
			if (min.X() > max.X() || min.Y() > max.Y() || min.Z() > max.Z())
				throw std::invalid_argument("BoundingBox3D: min point must be <= max point in all dimensions");
		}

		// Accessors
		Pnt3Cart Min() const { return _min; }
		Pnt3Cart Max() const { return _max; }

		// Dimensions
		Real Width() const { return _max.X() - _min.X(); }
		Real Height() const { return _max.Y() - _min.Y(); }
		Real Depth() const { return _max.Z() - _min.Z(); }
		Real Volume() const { return Width() * Height() * Depth(); }

		// Center point
		Pnt3Cart Center() const 
		{ 
			return Pnt3Cart(
				(_min.X() + _max.X()) / 2.0,
				(_min.Y() + _max.Y()) / 2.0,
				(_min.Z() + _max.Z()) / 2.0
			);
		}

		// Point containment test
		bool Contains(const Pnt3Cart& pnt) const 
		{
			return pnt.X() >= _min.X() && pnt.X() <= _max.X() &&
			       pnt.Y() >= _min.Y() && pnt.Y() <= _max.Y() &&
			       pnt.Z() >= _min.Z() && pnt.Z() <= _max.Z();
		}

		// Box-box intersection test
		bool Intersects(const BoundingBox3D& other) const 
		{
			// Boxes don't intersect if separated along any axis
			return !(_max.X() < other._min.X() || _min.X() > other._max.X() ||
			         _max.Y() < other._min.Y() || _min.Y() > other._max.Y() ||
			         _max.Z() < other._min.Z() || _min.Z() > other._max.Z());
		}

		// Expand to include a point
		void ExpandToInclude(const Pnt3Cart& pnt)
		{
			if (pnt.X() < _min.X()) _min.X() = pnt.X();
			if (pnt.Y() < _min.Y()) _min.Y() = pnt.Y();
			if (pnt.Z() < _min.Z()) _min.Z() = pnt.Z();
			if (pnt.X() > _max.X()) _max.X() = pnt.X();
			if (pnt.Y() > _max.Y()) _max.Y() = pnt.Y();
			if (pnt.Z() > _max.Z()) _max.Z() = pnt.Z();
		}

		// Expand to include another box
		void ExpandToInclude(const BoundingBox3D& box)
		{
			ExpandToInclude(box._min);
			ExpandToInclude(box._max);
		}

		// String representation
		std::string ToString() const
		{
			std::ostringstream oss;
			oss << "BoundingBox3D[Min=(" << _min.X() << "," << _min.Y() << "," << _min.Z() << ")"
			    << ", Max=(" << _max.X() << "," << _max.Y() << "," << _max.Z() << ")"
			    << ", Size=(" << Width() << "Ã—" << Height() << "Ã—" << Depth() << ")]";
			return oss.str();
		}
	};

	/// <summary>
	/// Bounding Sphere for fast spatial queries and collision detection.
	/// Often faster than AABB for intersection tests but less tight fitting.
	/// </summary>
	class BoundingSphere3D
	{
	private:
		Pnt3Cart _center;
		Real _radius;

	public:
		// Constructors
		BoundingSphere3D() : _center(0, 0, 0), _radius(0) {}
		
		BoundingSphere3D(const Pnt3Cart& center, Real radius) 
			: _center(center), _radius(radius)
		{
			if (radius < 0.0)
				throw std::invalid_argument("BoundingSphere3D: radius must be non-negative");
		}

		// Accessors
		Pnt3Cart Center() const { return _center; }
		Real Radius() const { return _radius; }

		// Volume (4/3 * Ï€ * rÂ³)
		Real Volume() const 
		{ 
			return (4.0 / 3.0) * Constants::PI * _radius * _radius * _radius; 
		}

		// Point containment test
		bool Contains(const Pnt3Cart& pnt) const 
		{
			return _center.Dist(pnt) <= _radius;
		}

		// Sphere-sphere intersection test
		bool Intersects(const BoundingSphere3D& other) const 
		{
			Real centerDist = _center.Dist(other._center);
			return centerDist <= (_radius + other._radius);
		}

		// Expand to include a point
		void ExpandToInclude(const Pnt3Cart& pnt)
		{
			Real dist = _center.Dist(pnt);
			if (dist > _radius)
				_radius = dist;
		}

		// String representation
		std::string ToString() const
		{
			std::ostringstream oss;
			oss << "BoundingSphere3D[Center=(" << _center.X() << "," << _center.Y() << "," << _center.Z() << ")"
			    << ", Radius=" << _radius << "]";
			return oss.str();
		}
	};

	class IBody
	{
	public:
		// Essential geometric properties
		virtual Real Volume() const = 0;
		virtual Real SurfaceArea() const = 0;
		virtual Pnt3Cart GetCenter() const = 0;
		
		// Bounding volumes
		virtual BoundingBox3D GetBoundingBox() const = 0;
		virtual BoundingSphere3D GetBoundingSphere() const = 0;
		
		// Spatial queries
		virtual bool IsInside(const Pnt3Cart& pnt) const = 0;
		
		// String representation
		virtual std::string ToString() const = 0;
		
		// Virtual destructor for proper cleanup
		virtual ~IBody() = default;
	};

	class ISolidBodyWithBoundary : public IBody
	{
	public:
		Real _x1, _x2;

		Real(*_y1)(Real);
		Real(*_y2)(Real);

		Real(*_z1)(Real, Real);
		Real(*_z2)(Real, Real);

	public:
		ISolidBodyWithBoundary(Real x1, Real x2,
			Real(*y1)(Real), Real(*y2)(Real),
			Real(*z1)(Real, Real), Real(*z2)(Real, Real))
			: _x1(x1), _x2(x2), _y1(y1), _y2(y2), _z1(z1), _z2(z2)
		{	}

		virtual Real getDensity(const VectorN<Real, 3>& x) const = 0;

		virtual bool IsInside(const Pnt3Cart& pnt) const override
		{
			const Real x = pnt.X();
			const Real y = pnt.Y();
			const Real z = pnt.Z();

			if (_x1 < x && x < _x2)
			{
				// check y bounds
				if (_y1(x) < y && y < _y2(x))
				{
					// check z bounds
					if (_z1(x, y) < z && z < _z2(x, y))
					{
						return true;	// point is inside the solid body
					}
				}
			}
			return false;
		}

		// IBody interface - provide default implementations
		// These are primarily used for physics calculations, not geometric queries
		virtual Real Volume() const override 
		{ 
			// Volume would require integration - not implemented for general case
			throw std::logic_error("Volume() requires integration - use ContinuousMassMomentOfInertiaTensorCalculator for mass properties"); 
		}
		
		virtual Real SurfaceArea() const override 
		{ 
			// Surface area would require integration - not implemented for general case
			throw std::logic_error("SurfaceArea() requires integration - not implemented for general ISolidBodyWithBoundary"); 
		}
		
		virtual Pnt3Cart GetCenter() const override 
		{ 
			// Return geometric center of the bounding box as approximation
			Real cx = (_x1 + _x2) / 2.0;
			Real cy = (_y1(cx) + _y2(cx)) / 2.0;
			Real cz = (_z1(cx, cy) + _z2(cx, cy)) / 2.0;
			return Pnt3Cart(cx, cy, cz);
		}
		
		virtual BoundingBox3D GetBoundingBox() const override 
		{ 
			// For general case, we need to find min/max across the entire domain
			// This is an approximation - assumes boundaries are monotonic
			Real minY = std::min(_y1(_x1), _y1(_x2));
			Real maxY = std::max(_y2(_x1), _y2(_x2));
			
			Real midX = (_x1 + _x2) / 2.0;
			Real midY = (_y1(midX) + _y2(midX)) / 2.0;
			Real minZ = std::min(_z1(_x1, midY), std::min(_z1(_x2, midY), _z1(midX, minY)));
			Real maxZ = std::max(_z2(_x1, midY), std::max(_z2(_x2, midY), _z2(midX, maxY)));
			
			return BoundingBox3D(Pnt3Cart(_x1, minY, minZ), Pnt3Cart(_x2, maxY, maxZ));
		}
		
		virtual BoundingSphere3D GetBoundingSphere() const override 
		{ 
			Pnt3Cart center = GetCenter();
			BoundingBox3D box = GetBoundingBox();
			
			// Use half the diagonal of bounding box as radius
			Real dx = box.Max().X() - box.Min().X();
			Real dy = box.Max().Y() - box.Min().Y();
			Real dz = box.Max().Z() - box.Min().Z();
			Real radius = 0.5 * std::sqrt(dx*dx + dy*dy + dz*dz);
			
			return BoundingSphere3D(center, radius);
		}
		
		virtual std::string ToString() const override 
		{ 
			std::ostringstream oss;
			oss << "ISolidBodyWithBoundary[xâˆˆ[" << _x1 << "," << _x2 << "]]";
			return oss.str();
		}

	};

	class SolidBodyWithBoundary : public ISolidBodyWithBoundary
	{
		Real(*_density)(const VectorN<Real, 3>& x);
	public:
		SolidBodyWithBoundary(Real x1, Real x2, Real(*y1)(Real), Real(*y2)(Real),
			Real(*z1)(Real, Real), Real(*z2)(Real, Real),
			Real(*density)(const VectorN<Real, 3>& x))
			: ISolidBodyWithBoundary(x1, x2, y1, y2, z1, z2), _density(density)
		{	}

		virtual Real getDensity(const VectorN<Real, 3>& x) const
		{
			return _density(x);
		}
	};

	class SolidBodyWithBoundaryConstDensity : public ISolidBodyWithBoundary
	{
		Real _density;
	public:
		SolidBodyWithBoundaryConstDensity(Real x1, Real x2, Real(*y1)(Real), Real(*y2)(Real),
			Real(*z1)(Real, Real), Real(*z2)(Real, Real),
			Real density)
			: ISolidBodyWithBoundary(x1, x2, y1, y2, z1, z2), _density(density)
		{	}

		virtual Real getDensity(const VectorN<Real, 3>& x) const
		{
			return _density;
		}
	};

	// solid body in 3D defined by triangular surfaces
	class BodyWithTriangleSurfaces : public IBody
	{
	protected:
		std::vector<Triangle3D> _surfaces;
	public:
		int GetSurfaceCount() const
		{
			return _surfaces.size();
		}
		const Triangle3D& GetSurface(int index) const
		{
			if (index < 0 || index >= GetSurfaceCount())
				throw std::out_of_range("BodyWithTriangleSurfaces::GetSurface - index out of range");
			return _surfaces[index];
		}
		
		// IBody interface - to be implemented by derived classes
		Real Volume() const override { throw std::logic_error("Volume() not implemented"); }
		Real SurfaceArea() const override { throw std::logic_error("SurfaceArea() not implemented"); }
		Pnt3Cart GetCenter() const override { throw std::logic_error("GetCenter() not implemented"); }
		BoundingBox3D GetBoundingBox() const override { throw std::logic_error("GetBoundingBox() not implemented"); }
		BoundingSphere3D GetBoundingSphere() const override { throw std::logic_error("GetBoundingSphere() not implemented"); }
		bool IsInside(const Pnt3Cart& pnt) const override { throw std::logic_error("IsInside() not implemented"); }
		std::string ToString() const override { throw std::logic_error("ToString() not implemented"); }
	};

	// solid body in 3D defined by rectangular surfaces
	class BodyWithRectSurfaces : public IBody
	{
	protected:
		std::vector<RectSurface3D> _surfaces;

	public:
		int GetSurfaceCount() const
		{
			return static_cast<int>(_surfaces.size());
		}
		const RectSurface3D& GetSurface(int index) const
		{
			if (index < 0 || index >= GetSurfaceCount())
				throw std::out_of_range("BodyWithRectSurfaces::GetSurface - index out of range");
			return _surfaces[index];
		}

		// IBody interface - to be implemented by derived classes
		Real Volume() const override { throw std::logic_error("Volume() not implemented"); }
		Real SurfaceArea() const override { throw std::logic_error("SurfaceArea() not implemented"); }
		Pnt3Cart GetCenter() const override { throw std::logic_error("GetCenter() not implemented"); }
		BoundingBox3D GetBoundingBox() const override { throw std::logic_error("GetBoundingBox() not implemented"); }
		BoundingSphere3D GetBoundingSphere() const override { throw std::logic_error("GetBoundingSphere() not implemented"); }
		bool IsInside(const Pnt3Cart& pnt) const override { throw std::logic_error("IsInside() not implemented"); }
		std::string ToString() const override { throw std::logic_error("ToString() not implemented"); }
		
		// isClosed() - iz centra mase (?) odasilje zrake u svim smje
		// rovima i gleda da li je pogodio iti jednu povrsinu
		// vraca listu povrsina, koje bi TREBALE omedjivati tijelo!

		// i po tome se moze obaviti surface integracija!!!
	};

	// represents solid that is composed of other solids
	// dobar nacin za provjeriti je li composed solid "tight" je izracunati fluks kroz sve povrsine
	class ComposedSolidSurfaces3D
	{
	private:
		std::vector<IBody*> _solids;

	public:
		ComposedSolidSurfaces3D() = default;
		ComposedSolidSurfaces3D(const std::vector<IBody*>& solids) : _solids(solids) {}

		void AddSolid(IBody* solid) { _solids.push_back(solid); }
		size_t GetSolidCount() const { return _solids.size(); }
		IBody* GetSolid(size_t index) { return _solids[index]; }
		const IBody* GetSolid(size_t index) const { return _solids[index]; }

		bool IsInside(const Pnt3Cart& pnt) const
		{
			// For a composed solid, point is inside if it's inside ANY of the component solids
			for (const auto* solid : _solids)
			{
				if (solid && solid->IsInside(pnt))
					return true;
			}
			return false;
		}
	};

	class Cube3D : public BodyWithRectSurfaces
	{
		// kocka
		Real _a;
		Pnt3Cart _center;
	public:
		Cube3D(Real a) : _a(a), _center(0, 0, 0)
		{
			Pnt3Cart pnt1( a / 2, -a / 2, -a / 2);
			Pnt3Cart pnt2( a / 2,  a / 2, -a / 2);
			Pnt3Cart pnt3(-a / 2,  a / 2, -a / 2);
			Pnt3Cart pnt4(-a / 2, -a / 2, -a / 2);
			Pnt3Cart pnt5( a / 2, -a / 2,  a / 2);
			Pnt3Cart pnt6( a / 2,  a / 2,  a / 2);
			Pnt3Cart pnt7(-a / 2,  a / 2,  a / 2);
			Pnt3Cart pnt8(-a / 2, -a / 2,  a / 2);

			// dodati svih 6 stranica u popis povrsina
			_surfaces.push_back(RectSurface3D(pnt1, pnt4, pnt3, pnt2));     // lower side in xy plane
			_surfaces.push_back(RectSurface3D(pnt5, pnt6, pnt7, pnt8));     // upper side in xy plane
			_surfaces.push_back(RectSurface3D(pnt1, pnt2, pnt6, pnt5));     // front side in yz plane
			_surfaces.push_back(RectSurface3D(pnt4, pnt8, pnt7, pnt3));     // back side in yz plane
			_surfaces.push_back(RectSurface3D(pnt1, pnt5, pnt8, pnt4));     // left side in xz plane
			_surfaces.push_back(RectSurface3D(pnt2, pnt3, pnt7, pnt6));     // right side in xz plane
		}
		Cube3D(Real a, const Pnt3Cart& center) : _a(a), _center(center)
		{
			// create 8 points for corners of the cube, centered at the given center point
			Pnt3Cart pnt1(center.X() + a / 2, center.Y() - a / 2, center.Z() - a / 2);
			Pnt3Cart pnt2(center.X() + a / 2, center.Y() + a / 2, center.Z() - a / 2);
			Pnt3Cart pnt3(center.X() - a / 2, center.Y() + a / 2, center.Z() - a / 2);
			Pnt3Cart pnt4(center.X() - a / 2, center.Y() - a / 2, center.Z() - a / 2);
			Pnt3Cart pnt5(center.X() + a / 2, center.Y() - a / 2, center.Z() + a / 2);
			Pnt3Cart pnt6(center.X() + a / 2, center.Y() + a / 2, center.Z() + a / 2);
			Pnt3Cart pnt7(center.X() - a / 2, center.Y() + a / 2, center.Z() + a / 2);
			Pnt3Cart pnt8(center.X() - a / 2, center.Y() - a / 2, center.Z() + a / 2);

			// add all 6 faces of the cube
			_surfaces.push_back(RectSurface3D(pnt1, pnt4, pnt3, pnt2));     // lower side in xy plane
			_surfaces.push_back(RectSurface3D(pnt5, pnt6, pnt7, pnt8));     // upper side in xy plane
			_surfaces.push_back(RectSurface3D(pnt1, pnt2, pnt6, pnt5));     // front side in yz plane
			_surfaces.push_back(RectSurface3D(pnt4, pnt8, pnt7, pnt3));     // back side in yz plane
			_surfaces.push_back(RectSurface3D(pnt1, pnt5, pnt8, pnt4));     // left side in xz plane
			_surfaces.push_back(RectSurface3D(pnt2, pnt3, pnt7, pnt6));     // right side in xz plane
		}

		bool IsInside(const Pnt3Cart& pnt) const override
		{
			// Check if point is inside the cube
			Real half_a = _a / 2.0;
			return (pnt.X() >= _center.X() - half_a && pnt.X() <= _center.X() + half_a &&
							pnt.Y() >= _center.Y() - half_a && pnt.Y() <= _center.Y() + half_a &&
							pnt.Z() >= _center.Z() - half_a && pnt.Z() <= _center.Z() + half_a);
		}

		// IBody interface implementation
		Real Volume() const override
		{
			// Volume = aÂ³
			return _a * _a * _a;
		}

		Real SurfaceArea() const override
		{
			// Surface area = 6aÂ²
			return 6.0 * _a * _a;
		}

		Pnt3Cart GetCenter() const override
		{
			return _center;
		}

		BoundingBox3D GetBoundingBox() const override
		{
			// AABB with min/max at center Â± half-side in all dimensions
			Real half_a = _a / 2.0;
			Pnt3Cart min(_center.X() - half_a, _center.Y() - half_a, _center.Z() - half_a);
			Pnt3Cart max(_center.X() + half_a, _center.Y() + half_a, _center.Z() + half_a);
			return BoundingBox3D(min, max);
		}

		BoundingSphere3D GetBoundingSphere() const override
		{
			// Bounding sphere has radius = half the space diagonal = (aâˆš3)/2
			Real radius = _a * std::sqrt(3.0) / 2.0;
			return BoundingSphere3D(_center, radius);
		}

		std::string ToString() const override
		{
			std::ostringstream oss;
			oss << "Cube3D{Center=(" << _center.X() << ", " << _center.Y() << ", " << _center.Z()
				<< "), Side=" << _a << ", Volume=" << Volume() << ", SurfaceArea=" << SurfaceArea() << "}";
			return oss.str();
		}

		// Getters
		Real GetSide() const { return _a; }
	};

	class CubeWithTriangles3D : public BodyWithTriangleSurfaces
	{
		Real _a;
		Pnt3Cart _center;
	public:
		// Cube centered at origin
		CubeWithTriangles3D(Real a) : _a(a), _center(0, 0, 0)
		{
			Real h = a / 2.0;
			// 8 vertices of the cube
			Pnt3Cart p1(h, -h, -h);
			Pnt3Cart p2(h, h, -h);
			Pnt3Cart p3(-h, h, -h);
			Pnt3Cart p4(-h, -h, -h);
			Pnt3Cart p5(h, -h, h);
			Pnt3Cart p6(h, h, h);
			Pnt3Cart p7(-h, h, h);
			Pnt3Cart p8(-h, -h, h);

			// Each face: two triangles (CCW order for outward normals)
			// Bottom face (z = -h)
			_surfaces.emplace_back(p1, p4, p3);
			_surfaces.emplace_back(p1, p3, p2);

			// Top face (z = +h)
			_surfaces.emplace_back(p5, p6, p7);
			_surfaces.emplace_back(p5, p7, p8);

			// Front face (y = +h)
			_surfaces.emplace_back(p2, p3, p7);
			_surfaces.emplace_back(p2, p7, p6);

			// Back face (y = -h)
			_surfaces.emplace_back(p1, p5, p8);
			_surfaces.emplace_back(p1, p8, p4);

			// Left face (x = -h)
			_surfaces.emplace_back(p4, p8, p7);
			_surfaces.emplace_back(p4, p7, p3);

			// Right face (x = +h)
			_surfaces.emplace_back(p1, p2, p6);
			_surfaces.emplace_back(p1, p6, p5);
		}

		// Cube centered at arbitrary point
		CubeWithTriangles3D(Real a, const Pnt3Cart& center) : _a(a), _center(center)
		{
			Real h = a / 2.0;
			// 8 vertices of the cube, centered at _center
			Pnt3Cart p1(center.X() + h, center.Y() - h, center.Z() - h);
			Pnt3Cart p2(center.X() + h, center.Y() + h, center.Z() - h);
			Pnt3Cart p3(center.X() - h, center.Y() + h, center.Z() - h);
			Pnt3Cart p4(center.X() - h, center.Y() - h, center.Z() - h);
			Pnt3Cart p5(center.X() + h, center.Y() - h, center.Z() + h);
			Pnt3Cart p6(center.X() + h, center.Y() + h, center.Z() + h);
			Pnt3Cart p7(center.X() - h, center.Y() + h, center.Z() + h);
			Pnt3Cart p8(center.X() - h, center.Y() - h, center.Z() + h);

			// Each face: two triangles (CCW order for outward normals)
			// Bottom face (z = -h)
			_surfaces.emplace_back(p1, p4, p3);
			_surfaces.emplace_back(p1, p3, p2);

			// Top face (z = +h)
			_surfaces.emplace_back(p5, p6, p7);
			_surfaces.emplace_back(p5, p7, p8);

			// Front face (y = +h)
			_surfaces.emplace_back(p2, p3, p7);
			_surfaces.emplace_back(p2, p7, p6);

			// Back face (y = -h)
			_surfaces.emplace_back(p1, p5, p8);
			_surfaces.emplace_back(p1, p8, p4);

			// Left face (x = -h)
			_surfaces.emplace_back(p4, p8, p7);
			_surfaces.emplace_back(p4, p7, p3);

			// Right face (x = +h)
			_surfaces.emplace_back(p1, p2, p6);
			_surfaces.emplace_back(p1, p6, p5);
		}

		bool IsInside(const Pnt3Cart& pnt) const override
		{
			Real h = _a / 2.0;
			return (pnt.X() >= _center.X() - h && pnt.X() <= _center.X() + h &&
				pnt.Y() >= _center.Y() - h && pnt.Y() <= _center.Y() + h &&
				pnt.Z() >= _center.Z() - h && pnt.Z() <= _center.Z() + h);
		}

		// IBody interface implementation
		Real Volume() const override { return _a * _a * _a; }
		
		Real SurfaceArea() const override { return 6.0 * _a * _a; }
		
		Pnt3Cart GetCenter() const override { return _center; }
		
		BoundingBox3D GetBoundingBox() const override
		{
			Real h = _a / 2.0;
			Pnt3Cart min(_center.X() - h, _center.Y() - h, _center.Z() - h);
			Pnt3Cart max(_center.X() + h, _center.Y() + h, _center.Z() + h);
			return BoundingBox3D(min, max);
		}
		
		BoundingSphere3D GetBoundingSphere() const override
		{
			// Sphere centered at cube center with radius to corner
			// Distance to corner = (a/2)*sqrt(3)
			Real radius = (_a / 2.0) * std::sqrt(3.0);
			return BoundingSphere3D(_center, radius);
		}
		
		std::string ToString() const override
		{
			std::ostringstream oss;
			oss << "CubeWithTriangles3D: Center=(" << _center.X() << ", " << _center.Y() << ", " << _center.Z() << ")"
				<< ", Side=" << _a
				<< ", Volume=" << Volume()
				<< ", SurfaceArea=" << SurfaceArea()
				<< ", Triangles=" << _surfaces.size();
			return oss.str();
		}

		Real GetSide() const { return _a; }
	};

	class Torus3D : public BodyWithRectSurfaces
	{
		Real _R;  // Major radius (distance from center to tube center)
		Real _r;  // Minor radius (tube radius)
		Pnt3Cart _center;
		int _numU;  // Number of divisions around major circle
		int _numV;  // Number of divisions around tube
	public:
		// Torus centered at origin with specified major and minor radii
		Torus3D(Real R, Real r, int numU = 20, int numV = 12)
			: _R(R), _r(r), _center(0, 0, 0), _numU(numU), _numV(numV)
		{
			constructSurfaces();
		}

		// Torus centered at specified point
		Torus3D(Real R, Real r, const Pnt3Cart& center, int numU = 20, int numV = 12)
			: _R(R), _r(r), _center(center), _numU(numU), _numV(numV)
		{
			constructSurfaces();
		}

		void constructSurfaces()
		{
			_surfaces.clear();
			Real du = 2.0 * Constants::PI / _numU;
			Real dv = 2.0 * Constants::PI / _numV;

			// Generate rectangular patches for the torus surface
			for (int i = 0; i < _numU; ++i)
			{
				for (int j = 0; j < _numV; ++j)
				{
					Real u1 = i * du;
					Real u2 = (i + 1) * du;
					Real v1 = j * dv;
					Real v2 = (j + 1) * dv;

					// Calculate the four corners of this patch
					// Torus parametrization: x = (R + r*cos(v))*cos(u), y = (R + r*cos(v))*sin(u), z = r*sin(v)
					Pnt3Cart p1 = torusPoint(u1, v1);
					Pnt3Cart p2 = torusPoint(u2, v1);
					Pnt3Cart p3 = torusPoint(u2, v2);
					Pnt3Cart p4 = torusPoint(u1, v2);

					_surfaces.push_back(RectSurface3D(p1, p2, p3, p4));
				}
			}
		}

		Pnt3Cart torusPoint(Real u, Real v) const
		{
			Real x = (_R + _r * std::cos(v)) * std::cos(u);
			Real y = (_R + _r * std::cos(v)) * std::sin(u);
			Real z = _r * std::sin(v);
			return Pnt3Cart(_center.X() + x, _center.Y() + y, _center.Z() + z);
		}

		bool IsInside(const Pnt3Cart& pnt) const override
		{
			// Translate point to torus-centered coordinates
			Real x = pnt.X() - _center.X();
			Real y = pnt.Y() - _center.Y();
			Real z = pnt.Z() - _center.Z();

			// Distance from point to Z-axis
			Real d = std::sqrt(x * x + y * y);

			// Distance from point to the tube center circle
			Real dist = std::sqrt((d - _R) * (d - _R) + z * z);

			return dist <= _r;
		}

		// IBody interface implementation
		Real Volume() const override
		{
			// Volume = 2Ï€Â²RrÂ²
			return 2.0 * Constants::PI * Constants::PI * _R * _r * _r;
		}

		Real SurfaceArea() const override
		{
			// Surface area = 4Ï€Â²Rr
			return 4.0 * Constants::PI * Constants::PI * _R * _r;
		}

		Pnt3Cart GetCenter() const override
		{
			return _center;
		}

		BoundingBox3D GetBoundingBox() const override
		{
			// AABB with extent based on major and minor radii
			Real outerRadius = _R + _r;  // Outer radius of torus
			Pnt3Cart min(_center.X() - outerRadius, _center.Y() - outerRadius, _center.Z() - _r);
			Pnt3Cart max(_center.X() + outerRadius, _center.Y() + outerRadius, _center.Z() + _r);
			return BoundingBox3D(min, max);
		}

		BoundingSphere3D GetBoundingSphere() const override
		{
			// Bounding sphere with radius = R + r (outer radius)
			Real radius = _R + _r;
			return BoundingSphere3D(_center, radius);
		}

		std::string ToString() const override
		{
			std::ostringstream oss;
			oss << "Torus3D{Center=(" << _center.X() << ", " << _center.Y() << ", " << _center.Z()
				<< "), MajorRadius=" << _R << ", MinorRadius=" << _r 
				<< ", Volume=" << Volume() << ", SurfaceArea=" << SurfaceArea() << "}";
			return oss.str();
		}

		// Getters
		Real GetMajorRadius() const { return _R; }
		Real GetMinorRadius() const { return _r; }
		int GetNumU() const { return _numU; }
		int GetNumV() const { return _numV; }
	};

	class Cylinder3D : public BodyWithTriangleSurfaces
	{
		Real _R;      // Radius
		Real _H;      // Height
		Pnt3Cart _center;
		int _numSegments;  // Number of segments around the circumference
	public:
		// Cylinder centered at origin with radius R and height H
		Cylinder3D(Real R, Real H, int numSegments = 20)
			: _R(R), _H(H), _center(0, 0, -H/2), _numSegments(numSegments)
		{
			constructSurfaces();
		}

		// Cylinder centered at specified point (center is at bottom)
		Cylinder3D(Real R, Real H, const Pnt3Cart& center, int numSegments = 20)
			: _R(R), _H(H), _center(center), _numSegments(numSegments)
		{
			constructSurfaces();
		}

		void constructSurfaces()
		{
			_surfaces.clear();
			Real angleStep = 2.0 * Constants::PI / _numSegments;

			// Bottom and top centers
			Pnt3Cart bottomCenter(_center.X(), _center.Y(), _center.Z());
			Pnt3Cart topCenter(_center.X(), _center.Y(), _center.Z() + _H);

			// Generate triangles for the cylinder
			for (int i = 0; i < _numSegments; ++i)
			{
				Real angle1 = i * angleStep;
				Real angle2 = (i + 1) * angleStep;

				// Points on bottom circle
				Pnt3Cart b1(_center.X() + _R * std::cos(angle1),
										_center.Y() + _R * std::sin(angle1),
										_center.Z());
				Pnt3Cart b2(_center.X() + _R * std::cos(angle2),
										_center.Y() + _R * std::sin(angle2),
										_center.Z());

				// Points on top circle
				Pnt3Cart t1(_center.X() + _R * std::cos(angle1),
										_center.Y() + _R * std::sin(angle1),
										_center.Z() + _H);
				Pnt3Cart t2(_center.X() + _R * std::cos(angle2),
										_center.Y() + _R * std::sin(angle2),
										_center.Z() + _H);

				// Bottom cap triangle (looking down from above, CCW)
				_surfaces.emplace_back(bottomCenter, b2, b1);

				// Top cap triangle (looking up from below, CCW)
				_surfaces.emplace_back(topCenter, t1, t2);

				// Side surface: two triangles forming a rectangle
				_surfaces.emplace_back(b1, b2, t2);
				_surfaces.emplace_back(b1, t2, t1);
			}
		}

		bool IsInside(const Pnt3Cart& pnt) const override
		{
			// Translate to cylinder-centered coordinates
			Real x = pnt.X() - _center.X();
			Real y = pnt.Y() - _center.Y();
			Real z = pnt.Z() - _center.Z();

			// Check if point is within height range
			if (z < 0.0 || z > _H)
				return false;

			// Check if point is within circular cross-section
			Real distSq = x * x + y * y;
			return distSq <= _R * _R;
		}

		// IBody interface implementation
		Real Volume() const override
		{
			// Volume = Ï€ * RÂ² * H
			return Constants::PI * _R * _R * _H;
		}

		Real SurfaceArea() const override
		{
			// Surface area = 2Ï€RÂ² (caps) + 2Ï€RH (lateral surface)
			return 2.0 * Constants::PI * _R * _R + 2.0 * Constants::PI * _R * _H;
		}

		Pnt3Cart GetCenter() const override
		{
			// Return geometric center (middle of cylinder)
			return Pnt3Cart(_center.X(), _center.Y(), _center.Z() + _H / 2.0);
		}

		BoundingBox3D GetBoundingBox() const override
		{
			// AABB with min/max based on radius and height
			Pnt3Cart min(_center.X() - _R, _center.Y() - _R, _center.Z());
			Pnt3Cart max(_center.X() + _R, _center.Y() + _R, _center.Z() + _H);
			return BoundingBox3D(min, max);
		}

		BoundingSphere3D GetBoundingSphere() const override
		{
			// Bounding sphere centered at geometric center
			// Radius is distance from center to corner of bounding cylinder
			Pnt3Cart geomCenter = GetCenter();
			Real halfH = _H / 2.0;
			Real radius = std::sqrt(_R * _R + halfH * halfH);
			return BoundingSphere3D(geomCenter, radius);
		}

		std::string ToString() const override
		{
			std::ostringstream oss;
			Pnt3Cart geomCenter = GetCenter();
			oss << "Cylinder3D{Center=(" << geomCenter.X() << ", " << geomCenter.Y() << ", " << geomCenter.Z()
				<< "), Radius=" << _R << ", Height=" << _H 
				<< ", Volume=" << Volume() << ", SurfaceArea=" << SurfaceArea() << "}";
			return oss.str();
		}

		// Getters
		Real GetRadius() const { return _R; }
		Real GetHeight() const { return _H; }
		Pnt3Cart GetBaseCenter() const { return _center; }
		int GetNumSegments() const { return _numSegments; }
	};

	class Sphere3D : public BodyWithTriangleSurfaces
	{
		Real _R;      // Radius
		Pnt3Cart _center;
		int _numLatitude;   // Number of latitude divisions
		int _numLongitude;  // Number of longitude divisions
	public:
		// Sphere centered at origin with radius R
		Sphere3D(Real R, int numLatitude = 16, int numLongitude = 20)
			: _R(R), _center(0, 0, 0), _numLatitude(numLatitude), _numLongitude(numLongitude)
		{
			constructSurfaces();
		}

		// Sphere centered at specified point
		Sphere3D(Real R, const Pnt3Cart& center, int numLatitude = 16, int numLongitude = 20)
			: _R(R), _center(center), _numLatitude(numLatitude), _numLongitude(numLongitude)
		{
			constructSurfaces();
		}

		void constructSurfaces()
		{
			_surfaces.clear();
			Real dTheta = Constants::PI / _numLatitude;        // Latitude step (0 to Ï€)
			Real dPhi = 2.0 * Constants::PI / _numLongitude;   // Longitude step (0 to 2Ï€)

			// Generate triangles for the sphere surface
			for (int i = 0; i < _numLatitude; ++i)
			{
				Real theta1 = i * dTheta;
				Real theta2 = (i + 1) * dTheta;

				for (int j = 0; j < _numLongitude; ++j)
				{
					Real phi1 = j * dPhi;
					Real phi2 = (j + 1) * dPhi;

					// Four corners of the current patch
					Pnt3Cart p1 = spherePoint(theta1, phi1);
					Pnt3Cart p2 = spherePoint(theta1, phi2);
					Pnt3Cart p3 = spherePoint(theta2, phi2);
					Pnt3Cart p4 = spherePoint(theta2, phi1);

					// Special handling for poles (avoid degenerate triangles)
					if (i == 0)
					{
						// Top pole: only one triangle
						_surfaces.emplace_back(p1, p4, p3);
					}
					else if (i == _numLatitude - 1)
					{
						// Bottom pole: only one triangle
						_surfaces.emplace_back(p1, p2, p3);
					}
					else
					{
						// Regular patch: two triangles
						_surfaces.emplace_back(p1, p2, p3);
						_surfaces.emplace_back(p1, p3, p4);
					}
				}
			}
		}

		Pnt3Cart spherePoint(Real theta, Real phi) const
		{
			// Spherical coordinates: theta (latitude, 0 to Ï€), phi (longitude, 0 to 2Ï€)
			Real x = _R * std::sin(theta) * std::cos(phi);
			Real y = _R * std::sin(theta) * std::sin(phi);
			Real z = _R * std::cos(theta);
			return Pnt3Cart(_center.X() + x, _center.Y() + y, _center.Z() + z);
		}

		bool IsInside(const Pnt3Cart& pnt) const override
		{
			// Check if point is within spherical radius
			Real dx = pnt.X() - _center.X();
			Real dy = pnt.Y() - _center.Y();
			Real dz = pnt.Z() - _center.Z();
			Real distSq = dx * dx + dy * dy + dz * dz;
			return distSq <= _R * _R;
		}

	// IBody interface implementation
	Real Volume() const override
	{
		// Volume = (4/3) * Ï€ * RÂ³
		return (4.0 / 3.0) * Constants::PI * _R * _R * _R;
	}

	Real SurfaceArea() const override
	{
		// Surface area = 4 * Ï€ * RÂ²
		return 4.0 * Constants::PI * _R * _R;
	}

	Pnt3Cart GetCenter() const override
	{
		return _center;
	}

	BoundingBox3D GetBoundingBox() const override
	{
		// AABB with min/max at center Â± radius in all dimensions
		Pnt3Cart min(_center.X() - _R, _center.Y() - _R, _center.Z() - _R);
		Pnt3Cart max(_center.X() + _R, _center.Y() + _R, _center.Z() + _R);
		return BoundingBox3D(min, max);
	}

	BoundingSphere3D GetBoundingSphere() const override
	{
		// Trivial - the sphere itself is the bounding sphere
		return BoundingSphere3D(_center, _R);
	}

	std::string ToString() const override
	{
		std::ostringstream oss;
		oss << "Sphere3D{Center=(" << _center.X() << ", " << _center.Y() << ", " << _center.Z() 
			<< "), Radius=" << _R << ", Volume=" << Volume() << ", SurfaceArea=" << SurfaceArea() << "}";
		return oss.str();
	}

	// Getters
	Real GetRadius() const { return _R; }
	int GetNumLatitude() const { return _numLatitude; }
	int GetNumLongitude() const { return _numLongitude; }
	};

	class Pyramid3D : public BodyWithTriangleSurfaces
	{
		Real _a;			// base side length
		Real _h;			// pyramid height
		Vec3Cart _center;
	public:
		Pyramid3D(Real a, Real h) : _a(a), _h(h), _center(0, 0, 0)
		{
			Pnt3Cart pnt1( a / 2, -a / 2, -a / 2);
			Pnt3Cart pnt2( a / 2,  a / 2, -a / 2);
			Pnt3Cart pnt3(-a / 2,  a / 2, -a / 2);
			Pnt3Cart pnt4(-a / 2, -a / 2, -a / 2);
			Pnt3Cart pnt5(     0,      0,      h);	// apex of the pyramid
			
			_surfaces.push_back(TriangleSurface3D(pnt1, pnt4, pnt3));     // lower side in xy plane
			_surfaces.push_back(TriangleSurface3D(pnt5, pnt1, pnt2));     // front side in yz plane
			_surfaces.push_back(TriangleSurface3D(pnt5, pnt2, pnt3));     // right side in yz plane
			_surfaces.push_back(TriangleSurface3D(pnt5, pnt3, pnt4));     // back side in yz plane
			_surfaces.push_back(TriangleSurface3D(pnt5, pnt4, pnt1));     // left side in xz plane
		}
		Pyramid3D(Real a, Real h, const Vec3Cart& center) : Pyramid3D(a, h)
		{
			_center = center;
		}

		bool IsInside(const Pnt3Cart& pnt) const override
		{
			// Check if point is inside the pyramid
			// Pyramid has square base [-a/2, a/2] x [-a/2, a/2] at z=0 and apex at (0, 0, h)
			
			// Translate point relative to center
			Real x = pnt.X() - _center.X();
			Real y = pnt.Y() - _center.Y();
			Real z = pnt.Z() - _center.Z();
			
			// Check if point is below base or above apex
			if (z < 0.0 || z > _h)
				return false;
			
			// For a pyramid, at height z, the cross-section is a square
			// The side length decreases linearly from _a at z=0 to 0 at z=_h
			// At height z, half-side = (_a / 2) * (1 - z / _h)
			Real half_side = (_a / 2.0) * (1.0 - z / _h);
			
			// Check if point is within the square cross-section at height z
			return (std::abs(x) <= half_side && std::abs(y) <= half_side);
		}

		// IBody interface implementation
		Real Volume() const override
		{
			// Volume = (1/3) * base_area * height = (1/3) * aÂ² * h
			return (_a * _a * _h) / 3.0;
		}

		Real SurfaceArea() const override
		{
			// Surface area = base + 4 triangular faces
			// Base area = aÂ²
			// Each triangular face: slant height s = sqrt(hÂ² + (a/2)Â²)
			// Area of one face = (1/2) * a * s
			// Total = aÂ² + 4 * (1/2) * a * s = aÂ² + 2as
			Real slant_height = std::sqrt(_h * _h + (_a / 2.0) * (_a / 2.0));
			return _a * _a + 2.0 * _a * slant_height;
		}

		Pnt3Cart GetCenter() const override
		{
			// Geometric center (centroid) is at 1/4 of height from base
			return Pnt3Cart(_center.X(), _center.Y(), _center.Z() + _h / 4.0);
		}

		BoundingBox3D GetBoundingBox() const override
		{
			// AABB from base corners to apex
			Real half_a = _a / 2.0;
			Pnt3Cart min(_center.X() - half_a, _center.Y() - half_a, _center.Z());
			Pnt3Cart max(_center.X() + half_a, _center.Y() + half_a, _center.Z() + _h);
			return BoundingBox3D(min, max);
		}

		BoundingSphere3D GetBoundingSphere() const override
		{
			// Bounding sphere centered at geometric center
			// Need to ensure it contains both base corners and apex
			Pnt3Cart geomCenter = GetCenter();
			Real half_a = _a / 2.0;
			
			// Distance from centroid (at h/4 from base) to base corner at (Â±a/2, Â±a/2, 0)
			Real distToBaseCorner = std::sqrt(half_a * half_a + half_a * half_a + (_h / 4.0) * (_h / 4.0));
			
			// Distance from centroid (at h/4 from base) to apex at (0, 0, h)
			// dz = h - h/4 = 3h/4
			Real distToApex = (3.0 * _h) / 4.0;
			
			// Use the maximum distance as radius
			Real radius = std::max(distToBaseCorner, distToApex);
			return BoundingSphere3D(geomCenter, radius);
		}

		std::string ToString() const override
		{
			std::ostringstream oss;
			Pnt3Cart geomCenter = GetCenter();
			oss << "Pyramid3D{Center=(" << geomCenter.X() << ", " << geomCenter.Y() << ", " << geomCenter.Z()
				<< "), BaseSize=" << _a << ", Height=" << _h 
				<< ", Volume=" << Volume() << ", SurfaceArea=" << SurfaceArea() << "}";
			return oss.str();
		}

		// Getters
		Real GetBaseSize() const { return _a; }
		Real GetHeight() const { return _h; }
		Vec3Cart GetBaseCenter() const { return _center; }
	};

	class PyramidEquilateral3D : public Pyramid3D
	{
	public:
		PyramidEquilateral3D(Real a) : Pyramid3D(a, a / sqrt(3))
		{ }

		PyramidEquilateral3D(Real a, const Vec3Cart& center) : Pyramid3D(a, a / sqrt(3), center)
		{ }

		std::string ToString() const override
		{
			std::ostringstream oss;
			Vec3Cart baseCenter = GetBaseCenter();
			oss << "PyramidEquilateral3D (Equilateral triangular base): Center=(" 
				<< baseCenter.X() << ", " << baseCenter.Y() << ", " << baseCenter.Z() << ")"
				<< ", BaseSize=" << GetBaseSize()
				<< ", Height=" << GetHeight()
				<< ", Volume=" << Volume()
				<< ", SurfaceArea=" << SurfaceArea();
			return oss.str();
		}
	};
}


///////////////////////////   mml/base/Function.h   ///////////////////////////





namespace MML
{
	///////////////////////////     REAL FUNCTION      ////////////////////////////////////
	class RealFunction : public IRealFunction
	{
		Real(*_func)(const Real);
	public:
		RealFunction(Real(*inFunc)(const Real)) : _func(inFunc) {}

		Real operator()(const Real x) const { return _func(x); }
	};
	class RealFunctionFromStdFunc : public IRealFunction
	{
		std::function<Real(const Real)> _func;
	public:
		RealFunctionFromStdFunc(const std::function<Real(const Real)> &inFunc) : _func(inFunc) {}

		Real operator()(const Real x) const { return _func(x); }
	};

	///////////////////////////     SCALAR FUNCTION       //////////////////////////////////
	template<int N>
	class ScalarFunction : public IScalarFunction<N>
	{
		Real(*_func)(const VectorN<Real, N>&);
	public:
		ScalarFunction(Real(*inFunc)(const VectorN<Real, N>&)) : _func(inFunc) {}

		Real operator()(const VectorN<Real, N>& x) const { return _func(x); }
	};

	template<int N>
	class ScalarFunctionFromStdFunc : public IScalarFunction<N>
	{
		std::function<Real(const VectorN<Real, N>&)> _func;
	public:
		ScalarFunctionFromStdFunc(const std::function<Real(const VectorN<Real, N>&)> inFunc) : _func(inFunc) {}

		Real operator()(const VectorN<Real, N>& x) const { return _func(x); }
	};

	/////////////////////////    VECTOR FUNCTION N -> N      ///////////////////////////////////
	template<int N>
	class VectorFunction : public IVectorFunction<N>
	{
		VectorN<Real, N>(*_func)(const VectorN<Real, N>&);
	public:
		VectorFunction(VectorN<Real, N>(*inFunc)(const VectorN<Real, N>&)) : _func(inFunc) {}

		VectorN<Real, N>     operator()(const VectorN<Real, N>& x) const { return _func(x); }
	};

	template<int N>
	class VectorFunctionFromStdFunc : public IVectorFunction<N>
	{
		std::function<VectorN<Real, N>(const VectorN<Real, N>&)> _func;
	public:
		VectorFunctionFromStdFunc(const std::function<VectorN<Real, N>(const VectorN<Real, N>&)>& inFunc) 
			: _func(inFunc) {}

		VectorN<Real, N>     operator()(const VectorN<Real, N>& x) const { return _func(x); }
	};

	/////////////////////////    VECTOR FUNCTION N -> M      ///////////////////////////////////
	template<int N, int M>
	class VectorFunctionNM : public IVectorFunctionNM<N, M>
	{
		VectorN<Real, M>(*_func)(const VectorN<Real, N>&);
	public:
		VectorFunctionNM(VectorN<Real, M>(*inFunc)(const VectorN<Real, N>&)) : _func(inFunc) {}

		VectorN<Real, M>     operator()(const VectorN<Real, N>& x) const { return _func(x); }
	};

	template<int N, int M>
	class VectorFunctionNMFromStdFunc : public IVectorFunctionNM<N, M>
	{
		std::function<VectorN<Real, M>(const VectorN<Real, N>&)> _func;
	public:
		VectorFunctionNMFromStdFunc(const std::function<VectorN<Real, M>(const VectorN<Real, N>&)>& inFunc) : _func(inFunc) {}

		VectorN<Real, M>     operator()(const VectorN<Real, N>& x) const { return _func(x); }
	};

	//////////////////////     PARAMETRIC CURVE             ///////////////////////////////////
	template<int N>
	class   ParametricCurve : public IParametricCurve<N>
	{
		Real _minT;
		Real _maxT;
		VectorN<Real, N>(*_func)(Real);
	public:
		ParametricCurve(VectorN<Real, N>(*inFunc)(Real)) 
			: _func(inFunc), _minT(Constants::NegInf), _maxT(Constants::PosInf) {}
		ParametricCurve(Real minT, Real maxT, VectorN<Real, N>(*inFunc)(Real)) 
			: _func(inFunc), _minT(minT), _maxT(maxT) {}

		Real getMinT() const { return _minT; }
		Real getMaxT() const { return _maxT; }

		virtual VectorN<Real, N> operator()(Real x) const { return _func(x); }
	};

	template<int N>
	class ParametricCurveFromStdFunc : public IParametricCurve<N>
	{
		Real _minT;
		Real _maxT;
		std::function<VectorN<Real, N>(Real)> _func;
	public:
		ParametricCurveFromStdFunc(const std::function<VectorN<Real, N>(Real)>& inFunc) 
			: _func(inFunc), _minT(Constants::NegInf), _maxT(Constants::PosInf) {}
		ParametricCurveFromStdFunc(Real minT, Real maxT, const std::function<VectorN<Real, N>(Real)>& inFunc) 
			: _func(inFunc), _minT(minT), _maxT(maxT) {}

		Real getMinT() const { return _minT; }
		Real getMaxT() const { return _maxT; }

		VectorN<Real, N> operator()(Real x) const { return _func(x); }
	};

	/////////////////////       PARAMETRIC SURFACE         //////////////////////////////////
	template<int N>
	class ParametricSurface : public IParametricSurface<N>
	{
		static_assert(N >= 3, "ParametricSurface requires N >= 3");

		Real _minX, _maxX;
		Real(*_y1)(Real);			// lower y boundary as function of x
		Real(*_y2)(Real);			// upper y boundary as function of x
		VectorN<Real, N>(*_func)(Real x, Real y);

	public:
		ParametricSurface(VectorN<Real, N>(*inFunc)(Real x, Real y),
											Real minX, Real maxX,
											Real(*y1)(Real), Real(*y2)(Real))
			: _func(inFunc), _minX(minX), _maxX(maxX), _y1(y1), _y2(y2)
		{	}

		VectorN<Real, N> operator()(Real x, Real y) const override
		{
			if (x < _minX || x > _maxX)
				throw std::domain_error("ParametricSurface: x out of domain");
			Real y_min = _y1(x), y_max = _y2(x);
			if (y < y_min || y > y_max)
				throw std::domain_error("ParametricSurface: y out of domain for given x");
			return _func(x, y);
		}

		virtual Real getMinU() const override { return _minX; }
		virtual Real getMaxU() const override { return _maxX; }
		virtual Real getMinW(Real x) const override { return _y1(x); }
		virtual Real getMaxW(Real x) const override { return _y2(x); }
	};
	
	template<int N>
	class ParametricSurfaceRect : public IParametricSurfaceRect<N>
	{
		static_assert(N >= 3, "ParametricSurfaceRect requires N >= 3");

		Real _minX;
		Real _maxX;
		Real _minY;
		Real _maxY;
		VectorN<Real, N>(*_func)(Real u, Real w);

	public:
		ParametricSurfaceRect(VectorN<Real, N>(*inFunc)(Real u, Real w)) 
				: _func(inFunc), _minX(Constants::NegInf), _maxX(Constants::PosInf), 
					_minY(Constants::NegInf), _maxY(Constants::PosInf) {}
		ParametricSurfaceRect(VectorN<Real, N>(*inFunc)(Real u, Real w), 
													Real minX, Real maxX, Real minY, Real maxY) 
				: _func(inFunc), _minX(minX), _maxX(maxX), _minY(minY), _maxY(maxY) {}

		VectorN<Real, N> operator()(Real u, Real w) const override { return _func(u, w); }

		virtual Real getMinU() const override { return _minX; }
		virtual Real getMaxU() const override { return _maxX; }
		virtual Real getMinW() const override { return _minY; }
		virtual Real getMaxW() const override { return _maxY; }
	};

	// imati cemo i surface Discrete, kreiran od triangles?

	template<int N>
	class ParametricSurfaceFromStdFunc : public IParametricSurfaceRect<N>
	{
		static_assert(N >= 3, "ParametricSurfaceFromStdFunc requires N >= 3");

		Real _minX;
		Real _maxX;
		Real _minY;
		Real _maxY;
		std::function<VectorN<Real, N>(Real u, Real w)> _func;
	public:
		ParametricSurfaceFromStdFunc(std::function<VectorN<Real, N>(Real u, Real w)>& inFunc) : _func(inFunc), _minX(Constants::NegInf), _maxX(Constants::PosInf), _minY(Constants::NegInf), _maxY(Constants::PosInf) {}
		ParametricSurfaceFromStdFunc(std::function<VectorN<Real, N>(Real u, Real w)>& inFunc, Real minX, Real maxX, Real minY, Real maxY) : _func(inFunc), _minX(minX), _maxX(maxX), _minY(minY), _maxY(maxY) {}

		VectorN<Real, N> operator()(Real u, Real w) const { return _func(u, w); }

		virtual Real getMinU() const { return _minX; }
		virtual Real getMaxU() const { return _maxX; }
		virtual Real getMinW() const { return _minY; }
		virtual Real getMaxW() const { return _maxY; }
	};
} // end namespace


///////////////////////////   mml/base/InterpolatedFunction.h   ///////////////////////////





namespace MML
{
	class RealFunctionInterpolated : public IRealFunction
	{
	private:
		int		_numPoints, _usedPoints;
		Vector<Real> _x, _y;						// we are storing copies of given values!

	public:
		RealFunctionInterpolated(const Vector<Real> &x, const Vector<Real> &y, 
														 int usedPointsInInterpolation)
							:  _x(x), _y(y), _numPoints(x.size()), _usedPoints(usedPointsInInterpolation)
		{
			// throw if not enough points
			if (_numPoints < 2 || _usedPoints < 2 || _usedPoints > _numPoints)
				throw RealFuncInterpInitError("RealFunctionInterpolated size error");
		}

		virtual ~RealFunctionInterpolated() {}

		Real virtual calcInterpValue(int startInd, Real x) const = 0;

		inline Real MinX() const { return X(0); }
		inline Real MaxX() const { return X(_numPoints-1); }

		inline Real X(int i) const { return _x[i]; }
		inline Real Y(int i) const { return _y[i]; }

		inline int	getNumPoints() const { return _numPoints; }
		inline int  getInterpOrder() const { return _usedPoints; }

		Real operator()(Real x) const
		{
			int startInd = locate(x);
			return calcInterpValue(startInd, x);
		}

		// Given a value x, return a value j such that x is (insofar as possible) centered in the subrange
		// xx[j..j+mm-1], where xx is the stored pointer. The values in xx must be monotonic, either
		// increasing or decreasing. The returned value is not less than 0, nor greater than _numPoints-1.
		int locate(const Real x) const
		{
			int  indUpper, indMid, indLower;
			bool isAscending = (_x[_numPoints - 1] >= _x[0]);

			indLower = 0;
			indUpper = _numPoints - 1;

			while (indUpper - indLower > 1) {
				indMid = (indUpper + indLower) / 2;
				if ((x >= _x[indMid]) == isAscending)
					indLower = indMid;
				else
					indUpper = indMid;
			}
			return std::max(0, std::min(_numPoints - _usedPoints, indLower - ((_usedPoints - 2) / 2)));
		}
	};

	////////////////////////             LINEAR INTERPOLATION						  ///////////////////////
	class LinearInterpRealFunc : public RealFunctionInterpolated
	{
		bool _extrapolateOutsideOfRange;
	public:
		LinearInterpRealFunc(const Vector<Real>& xv, const Vector<Real>& yv, bool extrapolateOutsideOfRange = false) 
						: RealFunctionInterpolated(xv, yv, 2), _extrapolateOutsideOfRange(extrapolateOutsideOfRange) {}

		Real calcInterpValue(int j, Real x) const override {
			if(_extrapolateOutsideOfRange == false && (x < MinX() || x > MaxX()) )
				return 0.0;

			if (X(j) == X(j + 1)) 
				return Y(j);
			else 
				return Y(j) + ((x - X(j)) / (X(j + 1) - X(j)) * (Y(j + 1) - Y(j)));
		}
	};

	////////////////////////           POLYNOMIAL INTERPOLATION						///////////////////////
	// Polynomial interpolation object.Construct with x and y vectors, and the number M of points
	// to be used locally(polynomial order plus one), then call interp for interpolated values.
	class PolynomInterpRealFunc : public RealFunctionInterpolated
	{
	private:
		mutable Real _errorEst;
	public:
		PolynomInterpRealFunc(const Vector<Real>& xv, const Vector<Real>& yv, int m)
						: RealFunctionInterpolated(xv, yv, m), _errorEst(0.) { }

		Real getLastErrorEst() const { return _errorEst; }	

		// Given a value x, and using pointers to data xx and yy, this routine returns an interpolated
		// value y, and stores an error estimate _errorEst.The returned value is obtained by mm-point polynomial
		// interpolation on the subrange xx[startInd..startInd + mm - 1].
		Real calcInterpValue(int startInd, Real x) const override
		{
			int i, m, ns = 0;
			Real y, den, dif, dift, ho, hp, w, dy;
			Vector<Real> c(getInterpOrder()), d(getInterpOrder());

			dif = std::abs(x - X(startInd));

			// First we find the index ns of the closest table entry
			for (i = 0; i < getInterpOrder(); i++) {
				if ((dift = std::abs(x - X(startInd + i))) < dif) {
					ns = i;
					dif = dift;
				}
				c[i] = Y(startInd + i);
				d[i] = Y(startInd + i);
			}
			y = Y(startInd + ns--);				// This is the initial approximation to y
			
			for (m = 1; m < getInterpOrder(); m++)  	// For each column of the tableau
			{
				for (i = 0; i < getInterpOrder() - m; i++) 
				{
					// we loop over the current c's and d's and update
					ho = X(startInd + i) - x;
					hp = X(startInd + i + m) - x;
					w = c[i + 1] - d[i];
					
					if ((den = ho - hp) == 0.0) 
						throw("Poly_interp error");
					
					den = w / den;
					d[i] = hp * den;
					c[i] = ho * den;
				}
				dy = (2 * (ns + 1) < (getInterpOrder() - m) ? c[ns + 1] : d[ns--]);

				y += dy;
			}
			_errorEst = dy;
			return y;
		}
	};

	///////////////////////           CUBIC SPLINE INTERPOLATION						//////////////////////
	// Construct with x and y vectors, and (optionally) values of
	// the first derivative at the endpoints, then call interp for interpolated values.
	//
	// Natural spline: yp1 = ypn = 1e99 (default) - zero second derivative at endpoints
	// Clamped spline: specify yp1 and/or ypn as first derivatives at endpoints
	class SplineInterpRealFunc : public RealFunctionInterpolated
	{
	private:
		Vector<Real> _secDerY;

	public:

		SplineInterpRealFunc(const Vector<Real>& xv, const Vector<Real>& yv, Real yp1 = 1.e99, Real ypn = 1.e99)
			: RealFunctionInterpolated(xv, yv, 2), _secDerY(xv.size())
		{
			initSecDerivs(&xv[0], &yv[0], yp1, ypn);
		}

		// This routine stores an array _secDerY[0..numPoints-1] with second derivatives of the interpolating function
		// at the tabulated points pointed to by xv, using function values pointed to by yv. If yp1 and/or
		// ypn are equal to 10e99 or larger, the routine is signaled to set the corresponding boundary
		// condition for a natural spline, with zero second derivative on that boundary; otherwise, they are
		// the values of the first derivatives at the endpoints.
		void initSecDerivs(const Real* xv, const Real* yv, Real yp1, Real ypn)
		{
			int		i, k;
			Real	p, qn, sig, un;

			int numPoints = (int)_secDerY.size();
			Vector<Real> u(numPoints - 1);

			if (yp1 > 0.99e99)
				_secDerY[0] = u[0] = 0.0;
			else 
			{
				_secDerY[0] = -0.5;
				u[0] = (3.0 / (xv[1] - xv[0])) * ((yv[1] - yv[0]) / (xv[1] - xv[0]) - yp1);
			}
			for (i = 1; i < numPoints - 1; i++) 
			{
				sig = (xv[i] - xv[i - 1]) / (xv[i + 1] - xv[i - 1]);
				p = sig * _secDerY[i - 1] + 2.0;

				_secDerY[i] = (sig - 1.0) / p;

				u[i] = (yv[i + 1] - yv[i]) / (xv[i + 1] - xv[i]) - (yv[i] - yv[i - 1]) / (xv[i] - xv[i - 1]);
				u[i] = (6.0 * u[i] / (xv[i + 1] - xv[i - 1]) - sig * u[i - 1]) / p;
			}
			if (ypn > 0.99e99)
				qn = un = 0.0;
			else 
			{
				qn = 0.5;
				un = (3.0 / (xv[numPoints - 1] - xv[numPoints - 2])) * (ypn - (yv[numPoints - 1] - yv[numPoints - 2]) / (xv[numPoints - 1] - xv[numPoints - 2]));
			}

			_secDerY[numPoints - 1] = (un - qn * u[numPoints - 2]) / (qn * _secDerY[numPoints - 2] + 1.0);

			for (k = numPoints - 2; k >= 0; k--)
				_secDerY[k] = _secDerY[k] * _secDerY[k + 1] + u[k];
		}

		// Given a value x, and using pointers to data xx and yy, and the stored vector of second derivatives
		// _secDerY, this routine returns the cubic spline interpolated value y.        
		Real calcInterpValue(int startInd, Real x) const override
		{
			int indLow = startInd, indUpp = startInd + 1;
			Real y, h, b, a;
			h = X(indUpp) - X(indLow);
			
			if (h == 0.0) 
				throw("Bad input to routine splint");
			
			a = (X(indUpp) - x) / h;
			b = (x - X(indLow)) / h;

			y = a * Y(indLow) + b * Y(indUpp) + 
				  ((POW3(a) - a) * _secDerY[indLow] + (POW3(b) - b) * _secDerY[indUpp]) * (h * h) / 6.0;
			
			return y;
		}

		// Evaluate the first derivative of the cubic spline at point x
		// Returns dy/dx at the given point
		Real Derivative(Real x) const
		{
			int startInd = locate(x);
			int indLow = startInd, indUpp = startInd + 1;
			Real h, b, a;
			h = X(indUpp) - X(indLow);
			
			if (h == 0.0) 
				throw("Bad input to routine splint derivative");
			
			a = (X(indUpp) - x) / h;
			b = (x - X(indLow)) / h;

			// Derivative of cubic spline:
			// dy/dx = (y[hi] - y[lo])/h - (3aÂ² - 1)/6 * h * y2[lo] + (3bÂ² - 1)/6 * h * y2[hi]
			Real dydx = (Y(indUpp) - Y(indLow)) / h
				- (3.0 * a * a - 1.0) / 6.0 * h * _secDerY[indLow]
				+ (3.0 * b * b - 1.0) / 6.0 * h * _secDerY[indUpp];
			
			return dydx;
		}

		// Evaluate the second derivative of the cubic spline at point x
		// Returns dÂ²y/dxÂ² at the given point (linearly interpolated between knots)
		Real SecondDerivative(Real x) const
		{
			int startInd = locate(x);
			int indLow = startInd, indUpp = startInd + 1;
			Real h, b, a;
			h = X(indUpp) - X(indLow);
			
			if (h == 0.0) 
				throw("Bad input to routine splint second derivative");
			
			a = (X(indUpp) - x) / h;
			b = (x - X(indLow)) / h;

			// Second derivative is linear interpolation of stored second derivatives
			return a * _secDerY[indLow] + b * _secDerY[indUpp];
		}

		// Compute definite integral of spline from a to b
		// Uses exact integration of cubic polynomials in each segment
		Real Integrate(Real a, Real b) const
		{
			if (a > b) return -Integrate(b, a);
			if (a < MinX() || b > MaxX())
				throw("Integration bounds outside spline domain");

			Real integral = 0.0;
			int iLow = locate(a);
			int iHigh = locate(b);

			// Helper lambda to integrate one segment from x0 to x1 within [X(i), X(i+1)]
			auto integrateSegment = [this](int i, Real x0, Real x1) -> Real {
				Real h = X(i + 1) - X(i);
				if (h == 0.0) return 0.0;

				// Compute a and b at both endpoints
				Real a0 = (X(i + 1) - x0) / h;
				Real b0 = (x0 - X(i)) / h;
				Real a1 = (X(i + 1) - x1) / h;
				Real b1 = (x1 - X(i)) / h;

				// Integral of spline segment: âˆ«[a*y_lo + b*y_hi + ((aÂ³-a)*y2_lo + (bÂ³-b)*y2_hi)*hÂ²/6] dx
				// Using substitution and exact integration
				Real y_lo = Y(i), y_hi = Y(i + 1);
				Real y2_lo = _secDerY[i], y2_hi = _secDerY[i + 1];

				// Antiderivative evaluated at x1 minus at x0
				// For term a*y_lo: integral is -h/2 * aÂ² * y_lo
				// For term b*y_hi: integral is h/2 * bÂ² * y_hi
				// For (aÂ³-a)*hÂ²/6*y2_lo: integral is -h/6 * (aâ´/4 - aÂ²/2) * h * y2_lo = -hÂ³/6 * (aâ´/4 - aÂ²/2) * y2_lo
				// For (bÂ³-b)*hÂ²/6*y2_hi: integral is h/6 * (bâ´/4 - bÂ²/2) * h * y2_hi = hÂ³/6 * (bâ´/4 - bÂ²/2) * y2_hi

				Real term1 = h * y_lo * 0.5 * (a0*a0 - a1*a1);
				Real term2 = h * y_hi * 0.5 * (b1*b1 - b0*b0);
				Real term3 = h*h*h / 6.0 * y2_lo * ((a0*a0*a0*a0/4.0 - a0*a0/2.0) - (a1*a1*a1*a1/4.0 - a1*a1/2.0));
				Real term4 = h*h*h / 6.0 * y2_hi * ((b1*b1*b1*b1/4.0 - b1*b1/2.0) - (b0*b0*b0*b0/4.0 - b0*b0/2.0));

				return term1 + term2 + term3 + term4;
			};

			if (iLow == iHigh) {
				// Both endpoints in same segment
				integral = integrateSegment(iLow, a, b);
			}
			else {
				// Multiple segments
				integral += integrateSegment(iLow, a, X(iLow + 1));
				for (int i = iLow + 1; i < iHigh; i++) {
					integral += integrateSegment(i, X(i), X(i + 1));
				}
				integral += integrateSegment(iHigh, X(iHigh), b);
			}

			return integral;
		}

		// Access second derivative at node i
		Real GetSecondDerivative(int i) const {
			if (i < 0 || i >= getNumPoints())
				throw std::out_of_range("Index out of range in GetSecondDerivative");
			return _secDerY[i];
		}
	};


	///////////////////////           RATIONAL INTERPOLATION                      //////////////////////
	// Rational function interpolation using diagonal rational function through mm points.
	// Better than polynomial interpolation when data has poles or asymptotic behavior.
	// Uses Bulirsch-Stoer algorithm (continued fraction representation).
	class RationalInterpRealFunc : public RealFunctionInterpolated
	{
	private:
		mutable Real _errorEst;
		static constexpr Real TINY = 1.0e-99;  // Small number to prevent division by zero
	
	public:
		RationalInterpRealFunc(const Vector<Real>& xv, const Vector<Real>& yv, int m)
			: RealFunctionInterpolated(xv, yv, m), _errorEst(0.) { }

		Real getLastErrorEst() const { return _errorEst; }

		// Rational function interpolation using Bulirsch-Stoer algorithm.
		// Returns interpolated value and stores error estimate in _errorEst.
		Real calcInterpValue(int startInd, Real x) const override
		{
			int m, i, ns = 0;
			Real y, w, t, hh, h, dd;
			int mm = getInterpOrder();
			Vector<Real> c(mm), d(mm);

			hh = std::abs(x - X(startInd));
			for (i = 0; i < mm; i++) {
				h = std::abs(x - X(startInd + i));
				if (h == 0.0) {
					_errorEst = 0.0;
					return Y(startInd + i);  // Exact hit on a data point
				}
				else if (h < hh) {
					ns = i;
					hh = h;
				}
				c[i] = Y(startInd + i);
				d[i] = Y(startInd + i) + TINY;  // TINY prevents rare zero-over-zero condition
			}
			y = Y(startInd + ns--);

			for (m = 1; m < mm; m++) {
				for (i = 0; i < mm - m; i++) {
					w = c[i + 1] - d[i];
					h = X(startInd + i + m) - x;
					t = (X(startInd + i) - x) * d[i] / h;
					dd = t - c[i + 1];
					if (dd == 0.0)
						throw RealFuncInterpRuntimeError("Error in RationalInterpRealFunc: pole detected");
					dd = w / dd;
					d[i] = c[i + 1] * dd;
					c[i] = t * dd;
				}
				_errorEst = (2 * (ns + 1) < (mm - m) ? c[ns + 1] : d[ns--]);
				y += _errorEst;
			}
			return y;
		}
	};


	///////////////////////        BARYCENTRIC RATIONAL INTERPOLATION             //////////////////////
	// Barycentric rational interpolation with no poles on the real line.
	// Floater-Hormann algorithm - provides smooth interpolation without the
	// oscillations of high-degree polynomial interpolation (Runge phenomenon).
	// Parameter d controls the "degree" - higher d gives smoother interpolation
	// but may be less accurate for rapidly varying functions.
	class BarycentricRationalInterp : public IRealFunction
	{
	private:
		int _n;             // Number of data points
		int _d;             // Blending parameter (0 to n-1)
		Vector<Real> _x;    // Abscissas
		Vector<Real> _y;    // Ordinates
		Vector<Real> _w;    // Barycentric weights

		void computeWeights() {
			for (int k = 0; k < _n; k++) {
				int imin = std::max(k - _d, 0);
				int imax = k >= _n - _d ? _n - _d - 1 : k;
				Real temp = (imin & 1) ? -1.0 : 1.0;  // Sign alternates
				Real sum = 0.0;
				
				for (int i = imin; i <= imax; i++) {
					int jmax = std::min(i + _d, _n - 1);
					Real term = 1.0;
					for (int j = i; j <= jmax; j++) {
						if (j == k) continue;
						term *= (_x[k] - _x[j]);
					}
					term = temp / term;
					temp = -temp;
					sum += term;
				}
				_w[k] = sum;
			}
		}

	public:
		// Construct with data points and blending parameter d.
		// d = 0 gives piecewise constant, d = 1 gives piecewise linear,
		// d = n-1 gives polynomial interpolation (equivalent to Lagrange).
		// Recommended: d = 3 to 5 for most applications.
		BarycentricRationalInterp(const Vector<Real>& xv, const Vector<Real>& yv, int d = 3)
			: _n(xv.size()), _d(d), _x(xv), _y(yv), _w(_n)
		{
			if (_n <= _d)
				throw RealFuncInterpInitError("BarycentricRationalInterp: d too large for number of points");
			if (_d < 0)
				throw RealFuncInterpInitError("BarycentricRationalInterp: d must be non-negative");
			computeWeights();
		}

		Real MinX() const { return _x[0]; }
		Real MaxX() const { return _x[_n - 1]; }
		int  getNumPoints() const { return _n; }
		int  getBlendingParameter() const { return _d; }

		Real operator()(Real x) const override
		{
			Real num = 0.0, den = 0.0;
			for (int i = 0; i < _n; i++) {
				Real h = x - _x[i];
				if (h == 0.0) {
					return _y[i];  // Exact hit on a data point
				}
				Real temp = _w[i] / h;
				num += temp * _y[i];
				den += temp;
			}
			return num / den;
		}

		// Get barycentric weight at index i
		Real getWeight(int i) const {
			if (i < 0 || i >= _n)
				throw std::out_of_range("Index out of range in getWeight");
			return _w[i];
		}
	};


	///////////////////////            2D INTERPOLATION CLASSES                   //////////////////////

	///////////////////////             BILINEAR INTERPOLATION                    //////////////////////
	// Bilinear interpolation on a regular 2D grid.
	// Given data z[i][j] at grid points (x1[i], x2[j]), interpolates to any point (x1, x2).
	class BilinearInterp2D
	{
	private:
		int _m, _n;                    // Grid dimensions
		Vector<Real> _x1, _x2;         // Grid coordinates
		const Matrix<Real>& _z;        // Reference to data matrix z[m][n]

		// Binary search to find interval containing x
		int locate(const Vector<Real>& arr, Real x) const {
			int n = arr.size();
			int lo = 0, hi = n - 1;
			bool ascending = (arr[n - 1] >= arr[0]);

			while (hi - lo > 1) {
				int mid = (hi + lo) / 2;
				if ((x >= arr[mid]) == ascending)
					lo = mid;
				else
					hi = mid;
			}
			return std::max(0, std::min(n - 2, lo));
		}

	public:
		BilinearInterp2D(const Vector<Real>& x1v, const Vector<Real>& x2v, const Matrix<Real>& zm)
			: _m(x1v.size()), _n(x2v.size()), _x1(x1v), _x2(x2v), _z(zm)
		{
			if (zm.RowNum() != _m || zm.ColNum() != _n)
				throw RealFuncInterpInitError("BilinearInterp2D: matrix dimensions don't match grid");
		}

		Real operator()(Real x1, Real x2) const
		{
			int i = locate(_x1, x1);
			int j = locate(_x2, x2);

			// Compute normalized coordinates t, u in [0, 1]
			Real t = (_x1[i + 1] - _x1[i] != 0.0) ? 
					 (x1 - _x1[i]) / (_x1[i + 1] - _x1[i]) : 0.0;
			Real u = (_x2[j + 1] - _x2[j] != 0.0) ? 
					 (x2 - _x2[j]) / (_x2[j + 1] - _x2[j]) : 0.0;

			// Bilinear interpolation formula
			return (1.0 - t) * (1.0 - u) * _z(i, j) 
				 + t * (1.0 - u) * _z(i + 1, j)
				 + (1.0 - t) * u * _z(i, j + 1) 
				 + t * u * _z(i + 1, j + 1);
		}

		// Evaluate with partial derivatives
		void interpWithDerivatives(Real x1, Real x2, Real& z, Real& dz_dx1, Real& dz_dx2) const
		{
			int i = locate(_x1, x1);
			int j = locate(_x2, x2);

			Real dx1 = _x1[i + 1] - _x1[i];
			Real dx2 = _x2[j + 1] - _x2[j];

			Real t = (dx1 != 0.0) ? (x1 - _x1[i]) / dx1 : 0.0;
			Real u = (dx2 != 0.0) ? (x2 - _x2[j]) / dx2 : 0.0;

			// Function value
			z = (1.0 - t) * (1.0 - u) * _z(i, j) 
			  + t * (1.0 - u) * _z(i + 1, j)
			  + (1.0 - t) * u * _z(i, j + 1) 
			  + t * u * _z(i + 1, j + 1);

			// Partial derivatives
			if (dx1 != 0.0) {
				dz_dx1 = ((1.0 - u) * (_z(i + 1, j) - _z(i, j)) 
						+ u * (_z(i + 1, j + 1) - _z(i, j + 1))) / dx1;
			} else {
				dz_dx1 = 0.0;
			}

			if (dx2 != 0.0) {
				dz_dx2 = ((1.0 - t) * (_z(i, j + 1) - _z(i, j)) 
						+ t * (_z(i + 1, j + 1) - _z(i + 1, j))) / dx2;
			} else {
				dz_dx2 = 0.0;
			}
		}

		int getGridDim1() const { return _m; }
		int getGridDim2() const { return _n; }
	};


	///////////////////////           BICUBIC SPLINE INTERPOLATION                //////////////////////
	// 2D spline interpolation on a regular grid using cubic splines in both directions.
	// More accurate than bilinear for smooth data, with continuous first derivatives.
	class BicubicSplineInterp2D
	{
	private:
		int _m, _n;
		Vector<Real> _x1, _x2;
		Matrix<Real> _z;               // Local copy of data
		std::vector<SplineInterpRealFunc*> _rowSplines;  // Splines along x2 for each x1[i]

	public:
		BicubicSplineInterp2D(const Vector<Real>& x1v, const Vector<Real>& x2v, const Matrix<Real>& zm)
			: _m(x1v.size()), _n(x2v.size()), _x1(x1v), _x2(x2v), _z(zm), _rowSplines(_m)
		{
			if (zm.RowNum() != _m || zm.ColNum() != _n)
				throw RealFuncInterpInitError("BicubicSplineInterp2D: matrix dimensions don't match grid");

			// Create a spline along x2 for each row (fixed x1[i])
			for (int i = 0; i < _m; i++) {
				Vector<Real> row(_n);
				for (int j = 0; j < _n; j++)
					row[j] = _z(i, j);
				_rowSplines[i] = new SplineInterpRealFunc(_x2, row);
			}
		}

		~BicubicSplineInterp2D() {
			for (int i = 0; i < _m; i++)
				delete _rowSplines[i];
		}

		// Disable copy to avoid double-free
		BicubicSplineInterp2D(const BicubicSplineInterp2D&) = delete;
		BicubicSplineInterp2D& operator=(const BicubicSplineInterp2D&) = delete;

		Real operator()(Real x1, Real x2) const
		{
			// First interpolate along x2 for each x1[i] to get values at fixed x2
			Vector<Real> yv(_m);
			for (int i = 0; i < _m; i++)
				yv[i] = (*_rowSplines[i])(x2);

			// Then interpolate along x1
			SplineInterpRealFunc colSpline(_x1, yv);
			return colSpline(x1);
		}

		// Evaluate with partial derivatives
		void interpWithDerivatives(Real x1, Real x2, Real& z, Real& dz_dx1, Real& dz_dx2) const
		{
			// Get values and x2-derivatives along rows
			Vector<Real> yv(_m), dyv_dx2(_m);
			for (int i = 0; i < _m; i++) {
				yv[i] = (*_rowSplines[i])(x2);
				dyv_dx2[i] = _rowSplines[i]->Derivative(x2);
			}

			// Interpolate values along x1
			SplineInterpRealFunc colSpline(_x1, yv);
			z = colSpline(x1);
			dz_dx1 = colSpline.Derivative(x1);

			// Interpolate x2-derivatives along x1
			SplineInterpRealFunc dSpline(_x1, dyv_dx2);
			dz_dx2 = dSpline(x1);
		}

		int getGridDim1() const { return _m; }
		int getGridDim2() const { return _n; }
	};


	//////////////////          PARAMETRIC CURVE LINEAR INTERPOLATION						/////////////////
	// Object for interpolating a curve specified by _numPoints points in N dimensions.
	template<int N>
	class LinInterpParametricCurve : public IParametricCurve<N>
	{
		int _numPoints;
		Matrix<Real> _curvePoints;
		Vector<Real> _arcLen; // normalized arc length parameter [0,1] for each point
		bool _isCurveClosed;

	public:
		LinInterpParametricCurve(const Matrix<Real>& ptsin, bool close = false)
			: _numPoints(ptsin.RowNum()), _curvePoints(ptsin), _arcLen(_numPoints), _isCurveClosed(close)
		{
			// Compute normalized arc length parameterization
			_arcLen[0] = 0.0;
			Real totalLen = 0.0;
			for (int i = 1; i < _numPoints; ++i) {
				Real segLen = 0.0;
				for (int j = 0; j < N; ++j)
					segLen += std::pow(_curvePoints[i][j] - _curvePoints[i - 1][j], 2);
				totalLen += std::sqrt(segLen);
				_arcLen[i] = totalLen;
			}
			// Normalize to [0,1]
			for (int i = 0; i < _numPoints; ++i)
				_arcLen[i] /= totalLen > 0 ? totalLen : 1.0;
		}

		Real getMinT() const override { return 0.0; }
		Real getMaxT() const override { return 1.0; }

		VectorN<Real, N> operator()(Real t) const override
		{
			// Clamp or wrap t
			if (_isCurveClosed) {
				t = t - std::floor(t);
			}
			else {
				if (t <= 0.0) t = 0.0;
				if (t >= 1.0) t = 1.0;
			}

			// Find segment
			int i = 0;
			while (i < _numPoints - 2 && t > _arcLen[i + 1])
				++i;

			// Linear interpolation
			Real t0 = _arcLen[i], t1 = _arcLen[i + 1];
			Real alpha = (t1 - t0 > 0) ? (t - t0) / (t1 - t0) : 0.0;

			VectorN<Real, N> result;
			for (int j = 0; j < N; ++j)
				result[j] = (1 - alpha) * _curvePoints[i][j] + alpha * _curvePoints[i + 1][j];
			return result;
		}
	};

	//////////////////          PARAMETRIC CURVE SPLINE INTERPOLATION						/////////////////
	// Object for interpolating a curve specified by _numPoints points in N dimensions.
	template<int N>
	class SplineInterpParametricCurve : public IParametricCurve<N>
	{
		Real _minT, _maxT;
		int  _dim, _numPoints, _bemba;
		bool _isCurveClosed;

		Matrix<Real> _curvePoints;
		Vector<Real> s;
		Vector<Real> ans;

		std::vector<SplineInterpRealFunc*> srp;
	
	public:
		// Constructor. The _numPoints _dim matrix ptsin inputs the data points. Input close as 0 for
		// an open curve, 1 for a closed curve. (For a closed curve, the last data point should not
		// duplicate the first - the algorithm will connect them.)
		SplineInterpParametricCurve(Real minT, Real maxT, const Matrix<Real>& ptsin, bool close = 0)
			: _numPoints(ptsin.RowNum()), _dim(ptsin.ColNum()), _bemba(close ? 2 * _numPoints : _numPoints),
			_isCurveClosed(close), _curvePoints(_dim, _bemba), s(_bemba), ans(_dim), srp(_dim),
			_minT(minT), _maxT(maxT)
		{
			// check N == dim
			if (N != _dim)
				throw("SplineInterpParametricCurve: N != dim");

			int i, ii, im, j, ofs;
			Real ss, soff, db, de;

			ofs = close ? _numPoints / 2 : 0;
			s[0] = 0.;
			for (i = 0; i < _bemba; i++) 
			{
				ii = (i - ofs + _numPoints) % _numPoints;
				im = (ii - 1 + _numPoints) % _numPoints;

				for (j = 0; j < _dim; j++) 
					_curvePoints[j][i] = ptsin[ii][j];
				
				if (i > 0) 
				{
					s[i] = s[i - 1] + rad(&ptsin[ii][0], &ptsin[im][0]);
					
					if (s[i] == s[i - 1]) 
						throw("error in Curve_interp");
					// Consecutive points may not be identical. For a closed curve, the last data
					// point should not duplicate the first.                    
				}
			}
			ss = close ? s[ofs + _numPoints] - s[ofs] : s[_numPoints - 1] - s[0];
			soff = s[ofs];
			
			for (i = 0; i < _bemba; i++) 
				s[i] = (s[i] - soff) / ss;
			
			for (j = 0; j < _dim; j++) 
			{
				db = _bemba < 4 ? 1.e99 : fprime(&s[0], &_curvePoints[j][0], 1);
				de = _bemba < 4 ? 1.e99 : fprime(&s[_bemba - 1], &_curvePoints[j][_bemba - 1], -1);

				Vector<Real> vec = _curvePoints.VectorFromRow(j);

				srp[j] = new SplineInterpRealFunc(s, vec, db, de);
			}
		}

		SplineInterpParametricCurve(const Matrix<Real>& ptsin, bool close = 0)
			: SplineInterpParametricCurve(0.0, 1.0, ptsin, close) {	}

		~SplineInterpParametricCurve() {
			for (int j = 0; j < _dim; j++) 
				delete srp[j];
		}
		
		Real getMinT() const { return _minT; }
		Real getMaxT() const { return _maxT; }

		// Interpolate a point on the stored curve. The point is parameterized by t, in the range [0,1].
		// For open curves, values of t outside this range will return extrapolations (dangerous!). For
		// closed curves, t is periodic with period 1
		VectorN<Real, N> operator()(Real t) const
		{
			if (_isCurveClosed == true && (t < _minT || t > _maxT))
				throw("SplineInterpParametricCurve: t outside interval");

			VectorN<Real, N> ans;

			if (_isCurveClosed)
				t = t - floor(t);

			// we have to map t from [minT, maxT] to [0, 1]
			t = (t - _minT) / (_maxT - _minT);
			for (int j = 0; j < _dim; j++)
				ans[j] = (*srp[j])(t);

			return ans;
		}

		// Utility for estimating the derivatives at the endpoints. x and y point to the abscissa and
		// ordinate of the endpoint. If pm is C1, points to the right will be used (left endpoint); if it
		// is -1, points to the left will be used (right endpoint). 
		Real fprime(Real* x, Real* y, int pm) {
			Real s1 = x[0] - x[pm * 1], s2 = x[0] - x[pm * 2], s3 = x[0] - x[pm * 3],
				s12 = s1 - s2, s13 = s1 - s3, s23 = s2 - s3;
			return -(s1 * s2 / (s13 * s23 * s3)) * y[pm * 3] + (s1 * s3 / (s12 * s2 * s23)) * y[pm * 2]
				- (s2 * s3 / (s1 * s12 * s13)) * y[pm * 1] + (1. / s1 + 1. / s2 + 1. / s3) * y[0];
		}

		Real rad(const Real* p1, const Real* p2) {
			Real sum = 0.;
			for (int i = 0; i < _dim; i++)
				sum += POW2(p1[i] - p2[i]);
			return sqrt(sum);
		}
	};


	template<int N>
	class InterpolatedSurface : public IParametricSurfaceRect<N>
	{
	public:
		InterpolatedSurface() {}

		VectorN<Real, N> operator()(const VectorN<Real, 2>& x) const { return VectorN<Real, N>{}; }
	};
}


///////////////////////////   mml/base/DiracDeltaFunction.h   ///////////////////////////



namespace MML
{
	class DiracFunction : public IRealFunction
	{
	protected:
		int _N;
	public:
		DiracFunction(int N) : _N(N) {}
	};

	class DiracStep : public DiracFunction
	{
	public:
		DiracStep(int N) : DiracFunction(N) {}

		Real operator()(const Real x) const
		{
			if (x < -1.0 / (2 * _N) || x > 1.0 / (2 * _N))
				return 0.0;
			else
				return _N;
		}
	};
	class DiracExp : public DiracFunction
	{
	public:
		DiracExp(int N) : DiracFunction(N) {}

		Real operator()(const Real x) const { return _N / sqrt(2 * Constants::PI) * exp(-x * x * _N * _N); }
	};
	class DiracSqr : public DiracFunction
	{
	public:
		DiracSqr(int N) : DiracFunction(N) {}

		Real operator()(const Real x) const { return _N / Constants::PI / (1 + _N * _N * x * x); }
	};
	class DiracSin : public DiracFunction
	{
	public:
		DiracSin(int N) : DiracFunction(N) {}

		Real operator()(const Real x) const { return sin(_N * x) / (Constants::PI * x); }
	};
}


///////////////////////////   mml/base/ODESystem.h   ///////////////////////////





namespace MML
{
	class ODESystem : public IODESystem
	{
	protected:
		int _dim;
		void (*_func)(Real, const Vector<Real>&, Vector<Real>&);

	public:
		ODESystem() 
				: _dim(0), _func(nullptr) { }
		ODESystem(int n, void (*inFunc)(Real, const Vector<Real>&, Vector<Real>&)) 
				: _dim(n), _func(inFunc) { }
		virtual ~ODESystem() = default;

		int		getDim() const { return _dim; }
		void	derivs(const Real t, const Vector<Real> &x, Vector<Real> &dxdt) const
		{
			_func(t, x, dxdt);
		}

		void  operator()(const Real t, const Vector<Real>& x, Vector<Real>& dxdt) const
		{
			derivs(t, x, dxdt);
		}
	};

	class ODESystemWithJacobian : public ODESystem
	{
	private:
		void (*_funcJac)(const Real, const Vector<Real>&, Vector<Real>&, Matrix<Real>&);

	public:
		ODESystemWithJacobian() : _funcJac(nullptr) { }
		ODESystemWithJacobian(int n,
			void (*inFunc)(Real, const Vector<Real>&, Vector<Real>&),
			void (*inFuncJac)(const Real t, const Vector<Real>& x, Vector<Real>& dxdt, Matrix<Real>& dydx)
		) : ODESystem(n, inFunc), _funcJac(inFuncJac) { }

		void jacobian(const Real t, const Vector<Real>& x, Vector<Real>& dxdt, Matrix<Real>& dydx) const
		{
			if (_funcJac != nullptr)
				_funcJac(t, x, dxdt, dydx);
		}
	};

}

///////////////////////////   mml/base/ODESystemSolution.h   ///////////////////////////


//#include "base/ODESystem.h"


namespace MML
{
	/// @brief Solution container for ODE system integration
	/// @details Stores time points and state vectors from ODE integration.
	///          Automatically grows storage as needed using exponential growth strategy.
	///          Provides interpolation methods for querying solution between saved points.
	class ODESystemSolution
	{
		int  _numStepsOK, _numStepsBad;

		int  _sysDim;
		int  _totalSavedSteps;
	
		Real _t1, _t2;
		Vector<Real> _tval;
		Matrix<Real> _xval;
	
		/// @brief Extend storage capacity using exponential growth (1.5x)
		void ExtendSavedSteps()
		{
			_totalSavedSteps = static_cast<int>(_totalSavedSteps * 1.5) + 1;
			
			// resizing the storage while preserving old values
			_tval.Resize(_totalSavedSteps, true);
			_xval.Resize(_sysDim, _totalSavedSteps, true);
		}

	public:
		/// @brief Construct solution container with specified capacity
		/// @param x1 Initial time
		/// @param x2 Final time
		/// @param dim System dimension (number of equations)
		/// @param maxSteps Initial storage capacity
		ODESystemSolution(Real x1, Real x2, int dim, int maxSteps)
			: _t1(x1), _t2(x2), _sysDim(dim),
				_numStepsOK(0), _numStepsBad(0), _totalSavedSteps(maxSteps + 1)
		{
			_tval.Resize(_totalSavedSteps);
			_xval.Resize(dim, _totalSavedSteps);
		}
		
		/// @brief Construct solution container with default capacity (1000 steps)
		ODESystemSolution(Real x1, Real x2, int dim) : ODESystemSolution(x1, x2, dim, 1000)	{ }

		/// @brief Increment count of successful integration steps
		void incrementSuccessfulSteps()	{ _numStepsOK++; }
		/// @brief Increment count of rejected integration steps
		void incrementRejectedSteps() { _numStepsBad++; }

		/// @brief Get system dimension (number of equations)
		int getSysDim() const { return _sysDim; }
		
		/// @brief Get initial time
		Real getT1() const { return _t1; }
		/// @brief Get final time
		Real getT2() const { return _t2; }

		/// @brief Get count of successful integration steps
		int getNumStepsOK() const { return _numStepsOK; }
		/// @brief Get count of rejected integration steps
		int getNumStepsBad() const { return _numStepsBad; }
		/// @brief Get total integration steps attempted (OK + rejected)
		int getTotalNumSteps() const { return _numStepsOK + _numStepsBad; }
		/// @brief Get current storage capacity
		int getTotalSavedSteps() const { return _totalSavedSteps; }
		/// @brief Get number of saved solution intervals
		int getNumSteps() const { return _totalSavedSteps - 1; }  // Number of intervals
		
		/// @brief Check if solution is empty (no points saved)
		bool isEmpty() const { return _totalSavedSteps == 0; }
		/// @brief Get number of saved solution points
		int size() const { return _totalSavedSteps; }
		/// @brief Get current storage capacity
		int capacity() const { return _totalSavedSteps; }
		
		/// @brief Pre-allocate storage for specified number of points
		/// @param n Number of points to reserve space for
		void reserve(int n) {
			if (n > _totalSavedSteps) {
				_totalSavedSteps = n;
				_tval.Resize(_totalSavedSteps, true);
				_xval.Resize(_sysDim, _totalSavedSteps, true);
			}
		}

		/// @brief Get all time points as vector
		Vector<Real> getTValues() const { return _tval; }
		/// @brief Get all state vectors as matrix (dim x numPoints)
		Matrix<Real> getXValues() const { return _xval; }
		
		/// @brief Get t-value at a specific saved point
		/// @param ind Index of saved point
		/// @throws std::out_of_range if index is invalid
		Real getTValue(int ind) const { 
			if (ind < 0 || ind >= _totalSavedSteps)
				throw std::out_of_range("Index out of range in ODESystemSolution::getTValue");
			return _tval[ind]; 
		}
		
		/// @brief Get x-value for a component at a specific saved point
		/// @param ind Index of saved point
		/// @param component Component index (0 to dim-1)
		/// @throws std::out_of_range if indices are invalid
		Real getXValue(int ind, int component) const { 
			if (ind < 0 || ind >= _totalSavedSteps)
				throw std::out_of_range("Index out of range in ODESystemSolution::getXValue(ind)");
			if (component < 0 || component >= _sysDim)
				throw std::out_of_range("Component out of range in ODESystemSolution::getXValue(component)");
			return _xval[component][ind]; 
		}
		
		/// @brief Get all values for a specific component as vector
		/// @param component Component index (0 to dim-1)
		/// @throws std::out_of_range if component index is invalid
		Vector<Real> getXValues(int component) const 
		{ 
			if (component < 0 || component >= _sysDim)
				throw std::out_of_range("Component out of range in ODESystemSolution::getXValues(component)");
			
			return _xval.VectorFromRow(component); 
		}

		/// @brief Get state vector at final saved point
		/// @return Vector of all components at last time point
		Vector<Real> getXValuesAtEnd() const
		{
			Vector<Real> res(_sysDim);
			for (int i = 0; i < _sysDim; i++)
				res[i] = _xval[i][_totalSavedSteps - 1];
			return res;
		}

		/// @brief Set time value at specified index
		/// @param ind Index where to store time value
		/// @param x Time value to store
		/// @throws std::out_of_range if index is negative
		void setTVal(int ind, Real x)
		{
			if (ind < 0 )
				throw std::out_of_range("Index must be non-negative in ODESystemSolution::setTVal");
			
			if (ind >= _totalSavedSteps)
				ExtendSavedSteps();

			_tval[ind] = x;
		}
		/// @brief Set state value for specific component at specified index
		/// @param ind Index where to store value
		/// @param component Component index (0 to dim-1)
		/// @param x Value to store
		/// @throws std::out_of_range if indices are invalid
		void setXVal(int ind, int component, Real x)
		{
			if (ind < 0)
				throw std::out_of_range("Index must be non-negative in ODESystemSolution::setXVal(ind)");

			if (component < 0 || component >= _sysDim)
				throw std::out_of_range("Component index out of range in ODESystemSolution::setXVal(component)");

			if (ind >= _totalSavedSteps)
				ExtendSavedSteps();

			_xval[component][ind] = x;
		}

		/// @brief Store time and state vector at specified index
		/// @param ind Index where to store values
		/// @param x Time value
		/// @param y State vector (must match system dimension)
		/// @throws std::out_of_range if index is negative
		/// @throws std::invalid_argument if vector size doesn't match system dimension
		void fillValues(int ind, Real x, const Vector<Real>& y)
		{
			if (ind < 0 )
				throw std::out_of_range("Index must be non-negative in ODESystemSolution::fillValues");

			if( y.size() != _sysDim )
				throw std::invalid_argument("Vector size mismatch in ODESystemSolution::fillValues");

			if(ind >= _totalSavedSteps)
				ExtendSavedSteps();

			_tval[ind] = x;
			for (int i = 0; i < _sysDim; i++)
				_xval[i][ind] = y[i];
		}
		/// @brief Trim storage to actual number of saved steps
		/// @param numDoneSteps Number of steps actually completed
		/// @note Call this after integration completes to free unused memory
		void setFinalSize(int numDoneSteps)
		{
			_totalSavedSteps = numDoneSteps + 1;

			_tval.Resize(_totalSavedSteps, true);
			_xval.Resize(_sysDim, _totalSavedSteps, true);
		}

		/// @brief Create linear interpolator for specified component
		/// @param component Component index (0 to dim-1)
		/// @return Linear interpolation function
		LinearInterpRealFunc  getSolAsLinInterp(int component) const
		{
			Vector<Real> xsave = _tval;
			Vector<Real> ysave = _xval.VectorFromRow(component);

			return LinearInterpRealFunc(xsave, ysave);
		}
		
		/// @brief Create polynomial interpolator for specified component
		/// @param component Component index (0 to dim-1)
		/// @param polyOrder Polynomial order for interpolation
		/// @return Polynomial interpolation function
		PolynomInterpRealFunc getSolAsPolyInterp(int component, int polyOrder) const
		{
			Vector<Real> xsave = _tval;
			Vector<Real> ysave = _xval.VectorFromRow(component);
			return PolynomInterpRealFunc(xsave, ysave, polyOrder + 1);
		}
		
		/// @brief Create cubic spline interpolator for specified component
		/// @param component Component index (0 to dim-1)
		/// @return Cubic spline interpolation function
		SplineInterpRealFunc  getSolAsSplineInterp(int component) const
		{
			Vector<Real> xsave = _tval;
			Vector<Real> ysave = _xval.VectorFromRow(component);
			return SplineInterpRealFunc(xsave, ysave);
		}

		/// @brief Create 2D parametric curve from two components
		/// @param ind1 First component index (x-coordinate)
		/// @param ind2 Second component index (y-coordinate)
		/// @return Spline-interpolated parametric curve in 2D
		SplineInterpParametricCurve<2> getSolAsParamCurve2D(int ind1, int ind2) const
		{
			Matrix<Real> curve_points(_totalSavedSteps, 2);
			for (int i = 0; i < _totalSavedSteps; i++)
			{
				curve_points(i, 0) = _xval[ind1][i];
				curve_points(i, 1) = _xval[ind2][i];
			}
			return SplineInterpParametricCurve<2>(_t1, _t2, curve_points);
		}

		/// @brief Create 3D parametric curve from three components
		/// @param ind1 First component index (x-coordinate)
		/// @param ind2 Second component index (y-coordinate)
		/// @param ind3 Third component index (z-coordinate)
		/// @return Spline-interpolated parametric curve in 3D
		SplineInterpParametricCurve<3> getSolAsParamCurve3D(int ind1, int ind2, int ind3) const
		{
			Matrix<Real> curve_points(_totalSavedSteps, 3);
			for (int i = 0; i < _totalSavedSteps; i++)
			{
				curve_points(i, 0) = _xval[ind1][i];
				curve_points(i, 1) = _xval[ind2][i];
				curve_points(i, 2) = _xval[ind3][i];
			}
			return SplineInterpParametricCurve<3>(_t1, _t2, curve_points);
		}
	};
}


///////////////////////////   mml/core/LinAlgEqSolvers.h   ///////////////////////////



namespace MML
{
	///////////////////////   GAUSS-JORDAN SOLVER    /////////////////////////////
	template<class Type>
	class GaussJordanSolver
	{
	public:
		// Solving with Matrix RHS (i.e. solving simultaneously for multiple RHS)
		// Throws SingularMatrixError or MatrixNumericalError on failure
		static void SolveInPlace(Matrix<Type>& a, Matrix<Type>& b)
		{
			int i, icol, irow, j, k, l, ll;
			Real big;
			Type dum, pivinv;

			int n = a.RowNum();
			int m = b.ColNum();
			std::vector<int> indxc(n), indxr(n), ipiv(n);
			for (j = 0; j < n; j++) ipiv[j] = 0;
			for (i = 0; i < n; i++) {
				big = 0.0;
				for (j = 0; j < n; j++)
					if (ipiv[j] != 1)
						for (k = 0; k < n; k++) {
							if (ipiv[k] == 0) {
								if (Abs(a[j][k]) >= big) {
									big = Abs(a[j][k]);
									irow = j;
									icol = k;
								}
							}
						}
				++(ipiv[icol]);
				if (irow != icol) {
					for (l = 0; l < n; l++) std::swap(a[irow][l], a[icol][l]);
					for (l = 0; l < m; l++) std::swap(b[irow][l], b[icol][l]);
				}
				indxr[i] = irow;
				indxc[i] = icol;

				if (a[icol][icol] == Real{ 0.0 })
					throw SingularMatrixError("GaussJordanSolver::SolveInPlace - Singular Matrix");

				pivinv = Real{ 1.0 } / a[icol][icol];
				
				// Check for non-finite pivot inverse (overflow from small pivot, Real types only)
				if constexpr (std::is_same_v<Type, Real>) {
					if (std::isnan(pivinv) || std::isinf(pivinv))
						throw MatrixNumericalError("Non-finite pivot inverse in Gauss-Jordan elimination");
				}
				
				a[icol][icol] = 1.0;
				for (l = 0; l < n; l++) a[icol][l] *= pivinv;
				for (l = 0; l < m; l++) b[icol][l] *= pivinv;
				for (ll = 0; ll < n; ll++)
					if (ll != icol) {
						dum = a[ll][icol];
						a[ll][icol] = 0.0;
						for (l = 0; l < n; l++) a[ll][l] -= a[icol][l] * dum;
						for (l = 0; l < m; l++) b[ll][l] -= b[icol][l] * dum;
					}
			}
			for (l = n - 1; l >= 0; l--) {
				if (indxr[l] != indxc[l])
					for (k = 0; k < n; k++)
						std::swap(a[k][indxr[l]], a[k][indxc[l]]);
			}
		}
		
		// Solving for a given RHS vector
		// Throws SingularMatrixError or MatrixNumericalError on failure
		static void SolveInPlace(Matrix<Type>& a, Vector<Type>& b)
		{
			auto bmat = Utils::ColumnMatrixFromVector(b);
			SolveInPlace(a, bmat);
			b = bmat.VectorFromColumn(0);
		}

		// Solving for a given RHS vector, returns result
		// Throws SingularMatrixError or MatrixNumericalError on failure
		static Vector<Type> Solve(Matrix<Type>& a, const Vector<Type>& b)
		{
			Matrix<Type> bmat = Utils::ColumnMatrixFromVector(b);
			SolveInPlace(a, bmat);
			return bmat.VectorFromColumn(0);
		}

		// solving for a given RHS vector, but with return value
		// both matrix and vector are const and are not changed
		// (in case of singular matrix 'a', exception is thrown)
		static Vector<Type> SolveConst(const Matrix<Type>& a, const Vector<Type>& b)
		{
			if (a.RowNum() != a.ColNum())
				throw MatrixDimensionError("GaussJordanSolver::SolveConst - matrix must be square", a.RowNum(), a.ColNum(), -1, -1);
			if (a.RowNum() != b.size())
				throw MatrixDimensionError("GaussJordanSolver::SolveConst - matrix and vector must have same size", a.RowNum(), a.ColNum(), b.size(), -1);
			if (b.size() == 0)
				throw MatrixDimensionError("GaussJordanSolver::SolveConst - vector must be non-empty", a.RowNum(), a.ColNum(), b.size(), -1);
			if (a.RowNum() == 0 || a.ColNum() == 0 )
				throw MatrixDimensionError("GaussJordanSolver::SolveConst - matrix must be non-empty", a.RowNum(), a.ColNum(), -1, -1);

			Matrix<Real> mat(a);
			Matrix<Type> bmat = Utils::ColumnMatrixFromVector(b);
			SolveInPlace(mat, bmat);
			return bmat.VectorFromColumn(0);
		}
	};

	//////////////////////   LU DECOMPOSITION SOLVER    ///////////////////////////
	template<class Type>
	class LUSolver
	{
	private:
		int _n;
		// Note: _refOrig removed - was unused and created dangling reference risk
		// The LU decomposition is stored in _lu (copy of input matrix)

		Matrix<Type> _lu;
		std::vector<int> _indx;
		Real _d;

	public:
		// constructor - performs the LU decomposition
		// The input matrix is copied, so temporaries are safe to pass
		// Algorithm uses partial pivoting with row interchanges
		LUSolver(const Matrix<Type>& inMatRef) 
			: _n(inMatRef.RowNum()), _lu(inMatRef), _indx(_n)
		{
			int i, imax, j, k;
			Real big, temp;
			Type temp2;
			Vector<Type> vv(_n);
			
			_d = 1.0;
			// finding biggest element in each row, and saving its invers in vv[]
			for (i = 0; i < _n; i++) 
			{
				big = 0.0;
				for (j = 0; j < _n; j++)
					if ((temp = Abs(_lu[i][j])) > big) 
						big = temp;
				
				// Check for non-finite values in matrix (Real types only)
				if constexpr (std::is_same_v<Type, Real>) {
					if (std::isnan(big) || std::isinf(big))
						throw MatrixNumericalError("Non-finite values detected in LUSolver input matrix");
				}
				
				if (big == 0.0)
					throw SingularMatrixError("LUSolver::ctor - Singular Matrix");

				vv[i] = 1.0 / big;
			}

			// main loop
			for (k = 0; k < _n; k++) 
			{
				big = 0.0;
				imax = k;
				for (i = k; i < _n; i++) 
				{
					temp = Abs(vv[i] * _lu[i][k]);
					if (temp > big) {
						big = temp;
						imax = i;
					}
				}

				if (k != imax) 
				{
					for (j = 0; j < _n; j++) 
					{
						temp2 = _lu[imax][j];
						_lu[imax][j] = _lu[k][j];
						_lu[k][j] = temp2;
					}
					_d = -_d;
					vv[imax] = vv[k];
				}

				_indx[k] = imax;
				if (_lu[k][k] == Real{ 0.0 }) 
					throw SingularMatrixError("LUSolver::ctor - Singular Matrix");
				
				for (i = k + 1; i < _n; i++) 
				{
					temp2 = _lu[i][k] /= _lu[k][k];
					
					// Check for non-finite multiplier (can happen from overflow/underflow, Real types only)
					if constexpr (std::is_same_v<Type, Real>) {
						if (std::isnan(temp2) || std::isinf(temp2))
							throw MatrixNumericalError("Non-finite multiplier in LU decomposition");
					}
					
					for (j = k + 1; j < _n; j++)
						_lu[i][j] -= temp2 * _lu[k][j];
				}
			}
		}

		// solving with Matrix RHS (ie. solving simultaneously for multiple RHS)
		// while using the LU decomposition already performed in the constructor
		void Solve(Matrix<Type>& matRHS, Matrix<Type> &outSol)
		{
			int i, j;

			int n = matRHS.RowNum();
			int m = matRHS.ColNum();

			if (matRHS.RowNum() != _n )
				throw("LUSolver::solve bad sizes");

			Vector<Type> xx(n);

			for (j = 0; j < m; j++) 
			{
				for (i = 0; i < n; i++)
					xx[i] = matRHS[i][j];

				Solve(xx, xx);

				for (i = 0; i < n; i++)
					outSol[i][j] = xx[i];
			}
		}

		// solving for a given RHS vector
		// while using the LU decomposition already performed in the constructor
		bool Solve(const Vector<Type>& b, Vector<Type>& x)
		{
			// _lu, _n, and _indx are not modified by this routine
			// and can be left in place for successive calls with different right-hand sides b. This routine takes
			// into account the possibility that b will begin with many zero elements, so it is efficient for use
			// in Matrix<Real> inversion
			int i, ii = 0, ip, j;
			Type sum;

			if (b.size() != _n || x.size() != _n)
				return false;

			for (i = 0; i < _n; i++)
				x[i] = b[i];

			for (i = 0; i < _n; i++) {
				ip = _indx[i];
				sum = x[ip];
				x[ip] = x[i];
				if (ii != 0)
					for (j = ii - 1; j < i; j++) 
						sum -= _lu[i][j] * x[j];
				else if (sum != Real{ 0.0 })
					ii = i + 1;
				x[i] = sum;
			}

			for (i = _n - 1; i >= 0; i--) {
				sum = x[i];
				for (j = i + 1; j < _n; j++) 
					sum -= _lu[i][j] * x[j];
				x[i] = sum / _lu[i][i];
			}
			return true;
		}

		Vector<Type> Solve(const Vector<Type>& b)
		{
			Vector<Type> x(b.size());
			if (Solve(b, x) == true)
				return x;
			else
				throw VectorDimensionError("LUDecompositionSolver::Solve - bad sizes", b.size(), _n);
		}

		// Using the stored LU decomposition, return in ainv the matrix inverse 
		void inverse(Matrix<Type>& ainv)
		{
			int i, j;
			ainv.Resize(_n, _n);
			for (i = 0; i < _n; i++) {
				for (j = 0; j < _n; j++) ainv[i][j] = 0.;
				ainv[i][i] = 1.;
			}
			Solve(ainv, ainv);
		}

		Type det()
		{
			Type dd = _d;
			for (int i = 0; i < _n; i++)
				dd = dd * _lu[i][i];
			return dd;
		}
	};


	template<class Type>
	class LUSolverInPlace
	{
	private:
		int _n;
		Matrix<Type> &_lu;
		std::vector<int> _indx;
		Real _d;

	public:
		// constructor - performs the LU decomposition
		// Algorithm uses partial pivoting with row interchanges
		LUSolverInPlace(Matrix<Type>& inMatRef)
			: _n(inMatRef.RowNum()), _lu(inMatRef), _indx(_n)
		{
			const Real TINY = 1.0e-40;
			int i, imax, j, k;
			Real big, temp;
			Type temp2;
			Vector<Type> vv(_n);
			_d = 1.0;
			for (i = 0; i < _n; i++) {
				big = 0.0;
				for (j = 0; j < _n; j++)
					if ((temp = Abs(_lu[i][j])) > big) big = temp;
				if (big == 0.0)
					throw SingularMatrixError("LUDecompositionSolver::ctor - Singular Matrix");

				vv[i] = 1.0 / big;
			}
			for (k = 0; k < _n; k++) {
				big = 0.0;
				imax = k;
				for (i = k; i < _n; i++) {
					temp = Abs(vv[i] * _lu[i][k]);
					if (temp > big) {
						big = temp;
						imax = i;
					}
				}
				if (k != imax) {
					for (j = 0; j < _n; j++) {
						temp2 = _lu[imax][j];
						_lu[imax][j] = _lu[k][j];
						_lu[k][j] = temp2;
					}
					_d = -_d;
					vv[imax] = vv[k];
				}
				_indx[k] = imax;
				if (_lu[k][k] == Real{ 0.0 })
					_lu[k][k] = TINY;

				for (i = k + 1; i < _n; i++) {
					temp2 = _lu[i][k] /= _lu[k][k];
					for (j = k + 1; j < _n; j++)
						_lu[i][j] -= temp2 * _lu[k][j];
				}
			}
		}
		// solving with Matrix RHS (ie. solving simultaneously for multiple RHS)
		// while using the LU decomposition already performed in the constructor

		Matrix<Type> Solve(Matrix<Type>& matRHS)
		{
			int i, j;

			int n = matRHS.RowNum();
			int m = matRHS.ColNum();

			if (matRHS.RowNum() != n)
				throw("LUSolver::solve bad sizes");

			Matrix<Type> outSol(n, m);
			Vector<Type> xx(n);

			for (j = 0; j < m; j++)
			{
				for (i = 0; i < n; i++)
					xx[i] = matRHS[i][j];

				Solve(xx, xx);

				for (i = 0; i < n; i++)
					outSol[i][j] = xx[i];
			}

			return outSol;
		}

		// solving for a given RHS vector
		// while using the LU decomposition already performed in the constructor
		bool Solve(const Vector<Type>& b, Vector<Type>& x)
		{
			// _lu, _n, and _indx are not modified by this routine
			// and can be left in place for successive calls with different right-hand sides b. This routine takes
			// into account the possibility that b will begin with many zero elements, so it is efficient for use
			// in Matrix<Real> inversion
			int i, ii = 0, ip, j;
			Type sum;

			if (b.size() != _n || x.size() != _n)
				return false;

			for (i = 0; i < _n; i++)
				x[i] = b[i];

			for (i = 0; i < _n; i++) {
				ip = _indx[i];
				sum = x[ip];
				x[ip] = x[i];
				if (ii != 0)
					for (j = ii - 1; j < i; j++)
						sum -= _lu[i][j] * x[j];
				else if (sum != Real{ 0.0 })
					ii = i + 1;
				x[i] = sum;
			}

			for (i = _n - 1; i >= 0; i--) {
				sum = x[i];
				for (j = i + 1; j < _n; j++)
					sum -= _lu[i][j] * x[j];
				x[i] = sum / _lu[i][i];
			}
			return true;
		}

		Vector<Type> Solve(const Vector<Type>& b)
		{
			Vector<Type> x(b.size());
			if (Solve(b, x) == true)
				return x;
			else
				throw VectorDimensionError("LUDecompositionSolver::Solve - bad sizes", b.size(), _n);
		}
	};


	///////////////////////   BAND DIAGONAL SOLVER    /////////////////////////////
	/**
	 * @brief Solver for band diagonal linear systems using LU decomposition
	 * 
	 * This solver is optimized for band diagonal matrices, exploiting their
	 * sparse structure for O(n*m^2) complexity instead of O(n^3) for general matrices,
	 * where n is the matrix dimension and m is the bandwidth.
	 * 
	 * Based on the algorithm from Numerical Recipes (bandec/banbks).
	 * 
	 * Usage:
	 * @code
	 *   BandDiagonalMatrix A(n, m1, m2, data);  // nÃ—n with lower bandwidth m1, upper bandwidth m2
	 *   Vector<Real> b = ...;                    // Right-hand side
	 *   BandDiagonalSolver solver(A);           // Performs LU decomposition
	 *   Vector<Real> x = solver.Solve(b);       // Solve Ax = b
	 * @endcode
	 */
	class BandDiagonalSolver
	{
	private:
		int _n;           // Matrix dimension
		int _m1;          // Lower bandwidth (number of subdiagonals)
		int _m2;          // Upper bandwidth (number of superdiagonals)
		Matrix<Real> _au; // Upper triangular factor with fill-in
		Matrix<Real> _al; // Lower triangular factor (stores multipliers)
		std::vector<int> _indx;  // Row permutation indices
		Real _d;          // +1 or -1 depending on row exchanges

	public:
		/**
		 * @brief Constructor - performs LU decomposition of band diagonal matrix
		 * @param a Band diagonal matrix to decompose
		 * @throws SingularMatrixError if matrix is singular
		 * 
		 * The decomposition stores L and U factors for subsequent solve operations.
		 * The algorithm uses partial pivoting within the band structure.
		 */
		BandDiagonalSolver(const BandDiagonalMatrix& a)
			: _n(a.GetDimension()), 
			  _m1(a.GetLowerBandwidth()), 
			  _m2(a.GetUpperBandwidth()),
			  _au(_n, _m1 + _m2 + 1),
			  _al(_n, _m1),
			  _indx(_n)
		{
			const Real TINY = 1.0e-40;
			int mm = _m1 + _m2 + 1;
			
			// Copy band diagonal matrix to working storage
			// _au stores the upper triangle with potential fill-in from pivoting
			for (int i = 0; i < _n; i++)
			{
				for (int j = 0; j < mm; j++)
				{
					int col = j - _m1 + i;
					if (col >= 0 && col < _n)
						_au[i][j] = a(i, col);
					else
						_au[i][j] = 0.0;
				}
			}
			
			_d = 1.0;
			int l = _m1;
			
			// Rearrange the storage for the initial rows
			for (int i = 0; i < _m1; i++)
			{
				for (int j = _m1 - i; j < mm; j++)
					_au[i][j - l] = _au[i][j];
				l--;
				for (int j = mm - l - 1; j < mm; j++)
					_au[i][j] = 0.0;
			}
			
			l = _m1;
			
			// LU decomposition with partial pivoting
			for (int k = 0; k < _n; k++)
			{
				Real dum = _au[k][0];
				int i = k;
				
				// Find pivot
				if (l < _n) l++;
				for (int j = k + 1; j < l; j++)
				{
					if (Abs(_au[j][0]) > Abs(dum))
					{
						dum = _au[j][0];
						i = j;
					}
				}
				
				_indx[k] = i + 1;  // Store 1-based index for compatibility
				
				if (dum == 0.0)
					_au[k][0] = TINY;  // Matrix is singular but proceed with tiny pivot
				
				// Interchange rows if necessary
				if (i != k)
				{
					_d = -_d;
					for (int j = 0; j < mm; j++)
						std::swap(_au[k][j], _au[i][j]);
				}
				
				// Compute multipliers and eliminate
				for (int i2 = k + 1; i2 < l; i2++)
				{
					dum = _au[i2][0] / _au[k][0];
					_al[k][i2 - k - 1] = dum;
					for (int j = 1; j < mm; j++)
						_au[i2][j - 1] = _au[i2][j] - dum * _au[k][j];
					_au[i2][mm - 1] = 0.0;
				}
			}
		}

		/**
		 * @brief Solve the system Ax = b using the stored LU decomposition
		 * @param b Right-hand side vector
		 * @param x Solution vector (output)
		 * @return true if solve succeeded, false if dimension mismatch
		 */
		bool Solve(const Vector<Real>& b, Vector<Real>& x) const
		{
			if (b.size() != static_cast<size_t>(_n) || x.size() != static_cast<size_t>(_n))
				return false;

			int mm = _m1 + _m2 + 1;
			int l = _m1;
			
			// Copy b to x
			for (int i = 0; i < _n; i++)
				x[i] = b[i];
			
			// Forward substitution
			for (int k = 0; k < _n; k++)
			{
				int j = _indx[k] - 1;  // Convert back to 0-based
				if (j != k)
					std::swap(x[k], x[j]);
				
				if (l < _n) l++;
				for (int j2 = k + 1; j2 < l; j2++)
					x[j2] -= _al[k][j2 - k - 1] * x[k];
			}
			
			l = 1;
			
			// Back substitution
			for (int i = _n - 1; i >= 0; i--)
			{
				Real dum = x[i];
				for (int k = 1; k < l; k++)
					dum -= _au[i][k] * x[k + i];
				x[i] = dum / _au[i][0];
				if (l < mm) l++;
			}
			
			return true;
		}

		/**
		 * @brief Solve the system Ax = b, returning the solution
		 * @param b Right-hand side vector
		 * @return Solution vector x
		 * @throws VectorDimensionError if dimension mismatch
		 */
		Vector<Real> Solve(const Vector<Real>& b) const
		{
			Vector<Real> x(_n);
			if (Solve(b, x))
				return x;
			else
				throw VectorDimensionError("BandDiagonalSolver::Solve - dimension mismatch", b.size(), _n);
		}

		/**
		 * @brief Solve multiple right-hand sides simultaneously
		 * @param B Matrix where each column is a right-hand side
		 * @return Solution matrix where each column is the corresponding solution
		 */
		Matrix<Real> Solve(const Matrix<Real>& B) const
		{
			if (B.RowNum() != _n)
				throw MatrixDimensionError("BandDiagonalSolver::Solve - row count mismatch", 
				                          B.RowNum(), B.ColNum(), _n, -1);
			
			Matrix<Real> X(_n, B.ColNum());
			Vector<Real> b(_n), x(_n);
			
			for (int j = 0; j < B.ColNum(); j++)
			{
				for (int i = 0; i < _n; i++)
					b[i] = B[i][j];
				
				Solve(b, x);
				
				for (int i = 0; i < _n; i++)
					X[i][j] = x[i];
			}
			
			return X;
		}

		/**
		 * @brief Get the determinant of the matrix
		 * @return Determinant value
		 */
		Real Det() const
		{
			Real dd = _d;
			for (int i = 0; i < _n; i++)
				dd *= _au[i][0];
			return dd;
		}

		/**
		 * @brief Get matrix dimension
		 */
		int GetDimension() const { return _n; }

		/**
		 * @brief Get lower bandwidth
		 */
		int GetLowerBandwidth() const { return _m1; }

		/**
		 * @brief Get upper bandwidth
		 */
		int GetUpperBandwidth() const { return _m2; }
	};


	///////////////////////   CHOLESKY DECOMPOSITION    /////////////////////////////
	template<class Type>
	class CholeskySolver
	{
	public:
		int n;
		Matrix<Type> el;

	public:
    // Given a positive-definite symmetric Matrix<Type> a[1..n][1..n], this routine constructs its Cholesky
    // decomposition A = L * L^T. On input, only the upper triangle of a need be given; it is not
    // modified. The Cholesky factor L is returned in the lower triangle of el, including diagonal elements.
		CholeskySolver(const Matrix<Type>& a) : n(a.RowNum()), el(a)
		{
			// Perform Cholesky decomposition
			for (int i = 0; i < n; i++)
			{
				for (int j = i; j < n; j++)
				{
					Type sum = el[i][j];
					
					// Subtract contributions from previous columns
					for (int k = 0; k < i; k++)
						sum -= el[i][k] * el[j][k];
					
					if (i == j)
					{
						// Diagonal element
						if (sum <= 0.0)
							throw SingularMatrixError("CholeskySolver: Matrix is not positive definite");
						
						el[i][i] = std::sqrt(sum);
					}
					else
					{
						// Off-diagonal element
						el[j][i] = sum / el[i][i];
					}
				}
			}
			
			// Zero out upper triangle (keeping only lower triangular L)
			for (int i = 0; i < n; i++)
				for (int j = i + 1; j < n; j++)
					el[i][j] = 0.0;
		}
		
		void Solve(const Vector<Type>& b, Vector<Type>& x)
		{
			// Solves the set of n linear equations A * x = b, where A is a positive-definite symmetric Matrix<Type>.
			// b[1..n] is input as the right-hand side Vector<Type>. 
			// The solution Vector<Type> is returned in x[1..n].
			// Uses forward and backward substitution: A*x = b => L*L^T*x = b
			// First solve L*y = b (forward substitution), then solve L^T*x = y (backward substitution)
			
			if (b.size() != n)
				throw VectorDimensionError("CholeskySolver::Solve - Vector size mismatch", n, b.size());
			
			x.Resize(n);
			
			// Forward substitution: solve L*y = b for y
			for (int i = 0; i < n; i++)
			{
				Type sum = b[i];
				for (int k = 0; k < i; k++)
					sum -= el[i][k] * x[k];
				x[i] = sum / el[i][i];
			}
			
			// Backward substitution: solve L^T*x = y for x
			for (int i = n - 1; i >= 0; i--)
			{
				Type sum = x[i];
				for (int k = i + 1; k < n; k++)
					sum -= el[k][i] * x[k];
				x[i] = sum / el[i][i];
			}
		}
		
		Vector<Type> Solve(const Vector<Type>& b)
		{
			Vector<Type> x(b.size());
			Solve(b, x);
			return x;
		}
		
		void inverse(Matrix<Type>& ainv)
		{
			// Computes the inverse of the original matrix A using the Cholesky decomposition
			// A^-1 = (L*L^T)^-1 = (L^T)^-1 * L^-1
			
			ainv.Resize(n, n);
			Vector<Type> ei(n), col(n);
			
			// Solve A * ainv[,j] = e_j for each column of the inverse
			for (int j = 0; j < n; j++)
			{
				// Set up unit vector e_j
				for (int i = 0; i < n; i++)
					ei[i] = (i == j) ? 1.0 : 0.0;
				
				// Solve A * col = e_j
				Solve(ei, col);
				
				// Store result in j-th column of ainv
				for (int i = 0; i < n; i++)
					ainv[i][j] = col[i];
			}
		}
		
		Type logdet()
		{
			// Computes log(det(A)) where A = L*L^T
			// det(A) = det(L*L^T) = det(L)^2 = (product of diagonal elements of L)^2
			// log(det(A)) = 2 * log(det(L)) = 2 * sum(log(L[i][i]))
			Type sum = 0.0;
			for (int i = 0; i < n; i++)
				sum += std::log(el[i][i]);
			return 2.0 * sum;
		}
	};

	///////////////////////   QR DECOMPOSITION    /////////////////////////////
	// QR decomposition using Householder reflections
	// Decomposes A = Q*R where Q is orthogonal and R is upper triangular
	// Works for both square and overdetermined (m >= n) systems
	template<class Type>
	class QRSolver
	{
	public:
		int m;              // number of rows
		int n;              // number of columns
		Matrix<Type> QR;    // Combined QR storage: R in upper triangle, Householder vectors in lower
		Vector<Type> c;     // Diagonal of R (stored separately)
		Vector<Type> d;     // Householder scaling factors
		bool sing;          // Singularity flag
		int num_reflections; // Number of Householder reflections performed (for determinant sign)

	public:
		// Constructs the QR decomposition of a[m][n] (m >= n)
		// Uses Householder reflections to compute Q and R such that A = Q*R
		// On output, the upper triangular matrix R is stored in the upper triangle and diagonal of QR
		// The Householder vectors are stored in the lower triangle of QR
		QRSolver(const Matrix<Type>& a) : m(a.RowNum()), n(a.ColNum()), QR(a), c(n), d(n), sing(false), num_reflections(0)
		{
			if (m < n)
				throw MatrixDimensionError("QRSolver: Matrix must have m >= n (rows >= columns)", m, n, m, n);

			int i, j, k;
			Type scale, sigma, sum, tau;
			Vector<Type> vec(m);

			// Perform Householder reduction
			// For square matrices: process n-1 columns (last has no elements below diagonal)
			// For overdetermined: process all n columns (last column still has elements below diagonal)
			int ncols = (m == n) ? n - 1 : n;
			for (k = 0; k < ncols; k++)
			{
				// Compute the norm of the k-th column below the diagonal
				scale = 0.0;
				for (i = k; i < m; i++)
					scale = std::max(scale, Abs(QR[i][k]));

				if (scale == 0.0)
				{
					// Singular case
					sing = true;
					c[k] = d[k] = 0.0;
				}
				else
				{
					// Form the Householder vector
					for (i = k; i < m; i++)
						QR[i][k] /= scale;

					sum = 0.0;
					for (i = k; i < m; i++)
						sum += QR[i][k] * QR[i][k];

					// Choose sign of sigma to avoid cancellation errors
					sigma = (QR[k][k] >= 0.0 ? std::sqrt(sum) : -std::sqrt(sum));
					QR[k][k] += sigma;
					c[k] = sigma * QR[k][k];
					d[k] = -scale * sigma;

					// Count this reflection for determinant
					num_reflections++;

					// Apply the transformation to remaining columns
					for (j = k + 1; j < n; j++)
					{
						sum = 0.0;
						for (i = k; i < m; i++)
							sum += QR[i][k] * QR[i][j];

						tau = sum / c[k];

						for (i = k; i < m; i++)
							QR[i][j] -= tau * QR[i][k];
					}
				}
			}

			// For square matrices, handle the last diagonal element separately
			if (m == n)
			{
				d[n - 1] = QR[n - 1][n - 1];
				if (d[n - 1] == 0.0)
					sing = true;
			}
		}

		// Solves the set of n linear equations A*x = b for a square system (m == n)
		// Uses back-substitution on R after applying Q^T to b
		void Solve(const Vector<Type>& b, Vector<Type>& x)
		{
			if (m != n)
				throw MatrixDimensionError("QRSolver::Solve - Use LeastSquaresSolve for overdetermined systems (m > n)", m, n, m, m);
			if (b.size() != m)
				throw VectorDimensionError("QRSolver::Solve - Vector size mismatch", m, b.size());
			if (sing)
				throw SingularMatrixError("QRSolver::Solve - Singular matrix");

			// Apply Q^T to b
			QtMultiply(b, x);

			// Back-substitution on R
			RSolve(x, x);
		}

		Vector<Type> Solve(const Vector<Type>& b)
		{
			Vector<Type> x(n);
			Solve(b, x);
			return x;
		}

		// Least-squares solution for overdetermined systems (m > n)
		// Minimizes ||Ax - b||â‚‚ by solving R*x = Q^T*b
		void LeastSquaresSolve(const Vector<Type>& b, Vector<Type>& x)
		{
			if (b.size() != m)
				throw VectorDimensionError("QRSolver::LeastSquaresSolve - Vector size mismatch", m, b.size());
			if (sing)
				throw SingularMatrixError("QRSolver::LeastSquaresSolve - Singular matrix");

			// Apply Q^T to b
			Vector<Type> qtb(m);
			QtMultiply(b, qtb);

			// Back-substitution on R (using only first n elements of qtb)
			x.Resize(n);
			for (int i = 0; i < n; i++)
				x[i] = qtb[i];
			
			RSolve(x, x);
		}

		Vector<Type> LeastSquaresSolve(const Vector<Type>& b)
		{
			Vector<Type> x(n);
			LeastSquaresSolve(b, x);
			return x;
		}

		// Solves R*x = b where R is upper triangular (stored in QR)
		// b and x can be the same vector (in-place operation)
		void RSolve(const Vector<Type>& b, Vector<Type>& x)
		{
			if (b.size() != n)
				throw VectorDimensionError("QRSolver::RSolve - Vector size mismatch", n, b.size());
			if (sing)
				throw SingularMatrixError("QRSolver::RSolve - Singular matrix");

			x.Resize(n);
			for (int i = 0; i < n; i++)
				x[i] = b[i];

			// Back-substitution
			for (int i = n - 1; i >= 0; i--)
			{
				Type sum = x[i];
				for (int j = i + 1; j < n; j++)
					sum -= QR[i][j] * x[j];
				x[i] = sum / d[i];
			}
		}

		// Multiplies Q^T * b and stores result in qtb
		// Uses the Householder vectors stored in QR
		void QtMultiply(const Vector<Type>& b, Vector<Type>& qtb)
		{
			if (b.size() != m)
				throw VectorDimensionError("QRSolver::QtMultiply - Vector size mismatch", m, b.size());

			qtb.Resize(m);
			for (int i = 0; i < m; i++)
				qtb[i] = b[i];

			// Apply Householder transformations (n-1 for square, n for overdetermined)
			int ncols = (m == n) ? n - 1 : n;
			for (int k = 0; k < ncols; k++)
			{
				if (c[k] != 0.0)
				{
					Type sum = 0.0;
					for (int i = k; i < m; i++)
						sum += QR[i][k] * qtb[i];

					Type tau = sum / c[k];

					for (int i = k; i < m; i++)
						qtb[i] -= tau * QR[i][k];
				}
			}
		}

		// Multiplies Q * b and stores result in qb
		// Useful for computing residuals and verifying decomposition
		void QMultiply(const Vector<Type>& b, Vector<Type>& qb)
		{
			if (b.size() != m)
				throw VectorDimensionError("QRSolver::QMultiply - Vector size mismatch", m, b.size());

			qb.Resize(m);
			for (int i = 0; i < m; i++)
				qb[i] = b[i];

			// Apply Householder transformations in reverse order (n-1 for square, n for overdetermined)
			int ncols = (m == n) ? n - 1 : n;
			for (int k = ncols - 1; k >= 0; k--)
			{
				if (c[k] != 0.0)
				{
					Type sum = 0.0;
					for (int i = k; i < m; i++)
						sum += QR[i][k] * qb[i];

					Type tau = sum / c[k];

					for (int i = k; i < m; i++)
						qb[i] -= tau * QR[i][k];
				}
			}
		}

		// Extract the upper triangular matrix R
		Matrix<Type> GetR() const
		{
			Matrix<Type> R(n, n);
			for (int i = 0; i < n; i++)
			{
				for (int j = 0; j < n; j++)
				{
					if (j >= i)
						R[i][j] = (i == j) ? d[i] : QR[i][j];
					else
						R[i][j] = 0.0;
				}
			}
			return R;
		}

		// Extract the orthogonal matrix Q (expensive - use sparingly)
		Matrix<Type> GetQ() const
		{
			Matrix<Type> Q(m, n);
			
			// Initialize Q as I (first n columns)
			for (int i = 0; i < m; i++)
				for (int j = 0; j < n; j++)
					Q[i][j] = (i == j) ? 1.0 : 0.0;

			// Apply Householder transformations in reverse order
			for (int k = n - 1; k >= 0; k--)
			{
				if (c[k] != 0.0)
				{
					for (int j = 0; j < n; j++)
					{
						Type sum = 0.0;
						for (int i = k; i < m; i++)
							sum += QR[i][k] * Q[i][j];

						Type tau = sum / c[k];

						for (int i = k; i < m; i++)
							Q[i][j] -= tau * QR[i][k];
					}
				}
			}
			return Q;
		}

		// Compute determinant (only for square matrices)
		// det(A) = det(Q) * det(R), where det(Q) = (-1)^num_reflections and det(R) = product of diagonal
		Type det() const
		{
			if (m != n)
				throw MatrixDimensionError("QRSolver::det - Determinant only defined for square matrices", m, n, m, m);
			if (sing)
				return 0.0;

			Type dd = 1.0;
			for (int i = 0; i < n; i++)
				dd *= d[i];
			
			// Each Householder reflection has determinant -1
			// So det(Q) = (-1)^num_reflections
			if (num_reflections % 2 == 1)
				dd = -dd;
				
			return dd;
		}

		// Matrix inversion using QR decomposition (only for square matrices)
		void inverse(Matrix<Type>& ainv)
		{
			if (m != n)
				throw MatrixDimensionError("QRSolver::inverse - Inverse only defined for square matrices", m, n, m, m);
			if (sing)
				throw SingularMatrixError("QRSolver::inverse - Cannot invert singular matrix");

			ainv.Resize(n, n);
			Vector<Type> ei(n), col(n);

			// Solve A * ainv[,j] = e_j for each column of the inverse
			for (int j = 0; j < n; j++)
			{
				// Set up unit vector e_j
				for (int i = 0; i < n; i++)
					ei[i] = (i == j) ? 1.0 : 0.0;

				// Solve A * col = e_j
				Solve(ei, col);

				// Store result in j-th column of ainv
				for (int i = 0; i < n; i++)
					ainv[i][j] = col[i];
			}
		}
  };

	/////////////////////////////////   SVD DECOMPOSITION      /////////////////////////////  
	class SVDecompositionSolver
	{
	private:
		int m, n;
		Matrix<Real> u, v;
		Vector<Real> w;
		Real eps, tsh;

		// Helper function: numerically stable sqrt(a^2 + b^2)
		Real pythag(const Real a, const Real b) const {
			Real absa = std::abs(a), absb = std::abs(b);
			return (absa > absb ? absa * std::sqrt(1.0 + (absb / absa) * (absb / absa)) :
				(absb == 0.0 ? 0.0 : absb * std::sqrt(1.0 + (absa / absb) * (absa / absb))));
		}

		// Core SVD decomposition using Householder reduction and QR iteration
		void decompose();

		// Reorder singular values in descending order
		void reorder();

	public:
		Vector<Real> getW() const { return w; }
		Matrix<Real> getU() const { return u; }
		Matrix<Real> getV() const { return v; }

	public:
		SVDecompositionSolver(const Matrix<Real>& a) : m(a.RowNum()), n(a.ColNum()), u(a), v(n, n), w(n)
		{
			// Given a Matrix<Real> a[m][n], this routine computes its singular value decomposition, A = UÂ·WÂ·V^T
			// The Matrix U replaces a on output (stored in u)
			// The diagonal matrix of singular values W is output as a vector w[n]
			// The matrix V (not the transpose V^T) is output as v[n][n]
			
			eps = std::numeric_limits<Real>::epsilon();
			decompose();
			reorder();
			tsh = 0.5 * std::sqrt(m + n + 1.0) * w[0] * eps;
		}

		Real inv_condition() {
			return (w[0] <= 0. || w[n - 1] <= 0.) ? 0. : w[n - 1] / w[0];
		}

		void Solve(const Vector<Real>& b, Vector<Real>& x, Real thresh = -1.)
		{
			// Solve AÂ·x = b for a vector x using the pseudoinverse of A as obtained by SVD. If positive,
			// thresh is the threshold value below which singular values are considered as zero. If thresh is
			// negative, a default based on expected roundoff error is used.
			
			Real tsh = (thresh >= 0. ? thresh : 0.5 * std::sqrt(m + n + 1.0) * w[0] * eps);
			
			Vector<Real> tmp(n);
			// Calculate U^T Â· b
			for (int j = 0; j < n; j++)
			{
				Real s = 0.0;
				if (w[j] > tsh)  // Only include non-zero singular values
				{
					for (int i = 0; i < m; i++)
						s += u[i][j] * b[i];
					s /= w[j];  // Multiply by inverse singular value
				}
				tmp[j] = s;
			}
			
			// Calculate x = V Â· tmp
			for (int j = 0; j < n; j++)
			{
				Real s = 0.0;
				for (int jj = 0; jj < n; jj++)
					s += v[j][jj] * tmp[jj];
				x[j] = s;
			}
		}

		Vector<Real> Solve(const Vector<Real>& b, Real thresh = -1.)
		{
			Vector<Real> x(n);
			Solve(b, x, thresh);
			return x;
		}

		// Solves m sets of n equations AÂ·X = B using the pseudoinverse of A. The right-hand sides are
		// input as b[m][p], while x[n][p] returns the solutions. thresh as above.
		void Solve(const Matrix<Real>& b, Matrix<Real>& x, Real thresh = -1.)
		{
			int p = b.ColNum();
			if (b.RowNum() != m || x.RowNum() != n || x.ColNum() != p)
				throw MatrixDimensionError("SVD::Solve - bad dimensions", m, n, b.RowNum(), x.RowNum());
			
			Vector<Real> bcol(m), xcol(n);
			for (int j = 0; j < p; j++)
			{
				// Extract column j from b
				for (int i = 0; i < m; i++)
					bcol[i] = b[i][j];
				
				// Solve for column j
				Solve(bcol, xcol, thresh);
				
				// Store result in column j of x
				for (int i = 0; i < n; i++)
					x[i][j] = xcol[i];
			}
		}

		// Return the rank of A, after zeroing any singular values smaller than thresh. If thresh is
		// negative, a default value based on estimated roundoff is used.        
		int Rank(Real thresh = -1.) {
			Real tsh = (thresh >= 0. ? thresh : 0.5 * std::sqrt(m + n + 1.0) * w[0] * eps);
			int rank = 0;
			for (int j = 0; j < n; j++)
				if (w[j] > tsh) rank++;
			return rank;
		}

		// Return the nullity of A, after zeroing any singular values smaller than thresh. Default value as above.
		int Nullity(Real thresh = -1.) {
			Real tsh = (thresh >= 0. ? thresh : 0.5 * std::sqrt(m + n + 1.0) * w[0] * eps);
			int nullity = 0;
			for (int j = 0; j < n; j++)
				if (w[j] <= tsh) nullity++;
			return nullity;
		}

		// Gives an orthonormal basis for the range of A as the columns of a returned matrix. thresh as above.
		Matrix<Real> Range(Real thresh = -1.) {
			Real tsh = (thresh >= 0. ? thresh : 0.5 * std::sqrt(m + n + 1.0) * w[0] * eps);
			int rank = Rank(tsh);
			
			Matrix<Real> range(m, rank);
			int col = 0;
			for (int j = 0; j < n; j++)
			{
				if (w[j] > tsh)
				{
					for (int i = 0; i < m; i++)
						range[i][col] = u[i][j];
					col++;
				}
			}
			return range;
		}

		// Gives an orthonormal basis for the nullspace of A as the columns of a returned matrix. thresh as above
		Matrix<Real> Nullspace(Real thresh = -1.) {
			Real tsh = (thresh >= 0. ? thresh : 0.5 * std::sqrt(m + n + 1.0) * w[0] * eps);
			int nullity = Nullity(tsh);
			
			Matrix<Real> nullspace(n, nullity);
			int col = 0;
			for (int j = 0; j < n; j++)
			{
				if (w[j] <= tsh)
				{
					for (int i = 0; i < n; i++)
						nullspace[i][col] = v[i][j];
					col++;
				}
			}
			return nullspace;
		}
	};

	///////////////////// SVDecompositionSolver Implementation /////////////////////

	inline void SVDecompositionSolver::decompose()
	{
		bool flag;
		int i, its, j, jj, k, l, nm;
		Real anorm, c, f, g, h, s, scale, x, y, z;
		Vector<Real> rv1(n);

		g = scale = anorm = 0.0;

		// Householder reduction to bidiagonal form
		for (i = 0; i < n; i++)
		{
			l = i + 2;
			rv1[i] = scale * g;
			g = s = scale = 0.0;

			if (i < m)
			{
				for (k = i; k < m; k++) scale += std::abs(u[k][i]);
				if (scale != 0.0)
				{
					for (k = i; k < m; k++)
					{
						u[k][i] /= scale;
						s += u[k][i] * u[k][i];
					}
					f = u[i][i];
					g = -std::copysign(std::sqrt(s), f);
					h = f * g - s;
					u[i][i] = f - g;
					for (j = l - 1; j < n; j++)
					{
						for (s = 0.0, k = i; k < m; k++) s += u[k][i] * u[k][j];
						f = s / h;
						for (k = i; k < m; k++) u[k][j] += f * u[k][i];
					}
					for (k = i; k < m; k++) u[k][i] *= scale;
				}
			}

			w[i] = scale * g;
			g = s = scale = 0.0;

			if (i + 1 <= m && i + 1 != n)
			{
				for (k = l - 1; k < n; k++) scale += std::abs(u[i][k]);
				if (scale != 0.0)
				{
					for (k = l - 1; k < n; k++)
					{
						u[i][k] /= scale;
						s += u[i][k] * u[i][k];
					}
					f = u[i][l - 1];
					g = -std::copysign(std::sqrt(s), f);
					h = f * g - s;
					u[i][l - 1] = f - g;
					for (k = l - 1; k < n; k++) rv1[k] = u[i][k] / h;
					for (j = l - 1; j < m; j++)
					{
						for (s = 0.0, k = l - 1; k < n; k++) s += u[j][k] * u[i][k];
						for (k = l - 1; k < n; k++) u[j][k] += s * rv1[k];
					}
					for (k = l - 1; k < n; k++) u[i][k] *= scale;
				}
			}
			anorm = std::max(anorm, (std::abs(w[i]) + std::abs(rv1[i])));
		}

		// Accumulation of right-hand transformations
		for (i = n - 1; i >= 0; i--)
		{
			if (i < n - 1)
			{
				if (g != 0.0)
				{
					for (j = l; j < n; j++)
						v[j][i] = (u[i][j] / u[i][l]) / g;
					for (j = l; j < n; j++)
					{
						for (s = 0.0, k = l; k < n; k++) s += u[i][k] * v[k][j];
						for (k = l; k < n; k++) v[k][j] += s * v[k][i];
					}
				}
				for (j = l; j < n; j++) v[i][j] = v[j][i] = 0.0;
			}
			v[i][i] = 1.0;
			g = rv1[i];
			l = i;
		}

		// Accumulation of left-hand transformations
		for (i = std::min(m, n) - 1; i >= 0; i--)
		{
			l = i + 1;
			g = w[i];
			for (j = l; j < n; j++) u[i][j] = 0.0;
			if (g != 0.0)
			{
				g = 1.0 / g;
				for (j = l; j < n; j++)
				{
					for (s = 0.0, k = l; k < m; k++) s += u[k][i] * u[k][j];
					f = (s / u[i][i]) * g;
					for (k = i; k < m; k++) u[k][j] += f * u[k][i];
				}
				for (j = i; j < m; j++) u[j][i] *= g;
			}
			else
				for (j = i; j < m; j++) u[j][i] = 0.0;
			++u[i][i];
		}

		// Diagonalization of the bidiagonal form via QR iteration
		for (k = n - 1; k >= 0; k--)
		{
			for (its = 0; its < 30; its++)
			{
				flag = true;
				for (l = k; l >= 0; l--)
				{
					nm = l - 1;
					if (l == 0 || std::abs(rv1[l]) <= eps * anorm)
					{
						flag = false;
						break;
					}
					if (std::abs(w[nm]) <= eps * anorm) break;
				}

				if (flag)
				{
					c = 0.0;
					s = 1.0;
					for (i = l; i < k + 1; i++)
					{
						f = s * rv1[i];
						rv1[i] = c * rv1[i];
						if (std::abs(f) <= eps * anorm) break;
						g = w[i];
						h = pythag(f, g);
						w[i] = h;
						h = 1.0 / h;
						c = g * h;
						s = -f * h;
						for (j = 0; j < m; j++)
						{
							y = u[j][nm];
							z = u[j][i];
							u[j][nm] = y * c + z * s;
							u[j][i] = z * c - y * s;
						}
					}
				}

				z = w[k];
				if (l == k)
				{
					if (z < 0.0)
					{
						w[k] = -z;
						for (j = 0; j < n; j++) v[j][k] = -v[j][k];
					}
					break;
				}

				if (its == 29)
						throw ConvergenceError("SVD: no convergence in 30 iterations", 30);
				x = w[l];
				nm = k - 1;
				y = w[nm];
				g = rv1[nm];
				h = rv1[k];
				f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
				g = pythag(f, 1.0);
				f = ((x - z) * (x + z) + h * ((y / (f + std::copysign(g, f))) - h)) / x;
				c = s = 1.0;

				for (j = l; j <= nm; j++)
				{
					i = j + 1;
					g = rv1[i];
					y = w[i];
					h = s * g;
					g = c * g;
					z = pythag(f, h);
					rv1[j] = z;
					c = f / z;
					s = h / z;
					f = x * c + g * s;
					g = g * c - x * s;
					h = y * s;
					y *= c;
					for (jj = 0; jj < n; jj++)
					{
						x = v[jj][j];
						z = v[jj][i];
						v[jj][j] = x * c + z * s;
						v[jj][i] = z * c - x * s;
					}
					z = pythag(f, h);
					w[j] = z;
					if (z)
					{
						z = 1.0 / z;
						c = f * z;
						s = h * z;
					}
					f = c * g + s * y;
					x = c * y - s * g;
					for (jj = 0; jj < m; jj++)
					{
						y = u[jj][j];
						z = u[jj][i];
						u[jj][j] = y * c + z * s;
						u[jj][i] = z * c - y * s;
					}
				}
				rv1[l] = 0.0;
				rv1[k] = f;
				w[k] = x;
			}
		}
	}

	inline void SVDecompositionSolver::reorder()
	{
		int i, j, k, s, inc = 1;
		Real sw;
		Vector<Real> su(m), sv(n);

		// Shell sort to order singular values in descending order
		do { inc *= 3; inc++; } while (inc <= n);
		do {
			inc /= 3;
			for (i = inc; i < n; i++)
			{
				sw = w[i];
				for (k = 0; k < m; k++) su[k] = u[k][i];
				for (k = 0; k < n; k++) sv[k] = v[k][i];
				j = i;
				while (w[j - inc] < sw)
				{
					w[j] = w[j - inc];
					for (k = 0; k < m; k++) u[k][j] = u[k][j - inc];
					for (k = 0; k < n; k++) v[k][j] = v[k][j - inc];
					j -= inc;
					if (j < inc) break;
				}
				w[j] = sw;
				for (k = 0; k < m; k++) u[k][j] = su[k];
				for (k = 0; k < n; k++) v[k][j] = sv[k];
			}
		} while (inc > 1);

		// Flip signs for consistent sign convention
		for (k = 0; k < n; k++)
		{
			s = 0;
			for (i = 0; i < m; i++) if (u[i][k] < 0.) s++;
			for (j = 0; j < n; j++) if (v[j][k] < 0.) s++;
			if (s > (m + n) / 2)
			{
				for (i = 0; i < m; i++) u[i][k] = -u[i][k];
				for (j = 0; j < n; j++) v[j][k] = -v[j][k];
			}
		}
	}
}


///////////////////////////   mml/core/LinAlgEqSolvers_iterative.h   ///////////////////////////



namespace MML
{
	/**
	 * @brief Result structure for iterative linear equation solvers
	 * 
	 * Contains solution vector along with convergence information
	 */
	struct IterativeSolverResult
	{
		Vector<Real> solution;      ///< Solution vector x
		int          iterations;    ///< Number of iterations performed
		Real         residual;      ///< Final residual norm ||Ax - b||
		bool         converged;     ///< True if converged within tolerance
		
		IterativeSolverResult() : iterations(0), residual(0.0), converged(false) {}
		IterativeSolverResult(const Vector<Real>& sol, int iter, Real res, bool conv)
			: solution(sol), iterations(iter), residual(res), converged(conv) {}
	};

	/**
	 * @brief Jacobi iterative method for solving linear systems Ax = b
	 * 
	 * The Jacobi method is a classical iterative technique that updates each component
	 * of the solution using only values from the previous iteration:
	 * 
	 *   x_i^(k+1) = (1/a_ii) * (b_i - Î£_{jâ‰ i} a_ij * x_j^(k))
	 * 
	 * @par Convergence Properties:
	 * - Guaranteed to converge for strictly diagonally dominant matrices
	 * - Converges for symmetric positive definite matrices
	 * - Each iteration can be parallelized (all updates independent)
	 * - Generally slower than Gauss-Seidel but more parallelizable
	 * 
	 * @par Convergence Rate:
	 * The spectral radius Ï(Dâ»Â¹(L+U)) determines convergence rate.
	 * For tridiagonal Poisson: Ï â‰ˆ 1 - Ï€Â²/(2nÂ²), very slow for large n.
	 * 
	 * @see GaussSeidelSolver, SORSolver
	 */
	class JacobiSolver
	{
	public:
		/**
		 * @brief Solve Ax = b using Jacobi iteration
		 * 
		 * @param A Coefficient matrix (must be square, non-zero diagonal)
		 * @param b Right-hand side vector
		 * @param x0 Initial guess (if empty, uses zero vector)
		 * @param tol Convergence tolerance for relative residual ||Ax-b||/||b||
		 * @param maxIter Maximum number of iterations
		 * @return IterativeSolverResult containing solution and convergence info
		 * 
		 * @throws MatrixDimensionError if dimensions don't match
		 * @throws SingularMatrixError if any diagonal element is zero
		 */
		static IterativeSolverResult Solve(const Matrix<Real>& A, 
		                                    const Vector<Real>& b,
		                                    const Vector<Real>& x0 = Vector<Real>(),
		                                    Real tol = 1e-10,
		                                    int maxIter = 1000)
		{
			int n = A.RowNum();
			
			// Dimension checks
			if (A.ColNum() != n)
				throw MatrixDimensionError("JacobiSolver::Solve - matrix must be square", n, A.ColNum(), -1, -1);
			if (b.size() != n)
				throw MatrixDimensionError("JacobiSolver::Solve - vector b dimension mismatch", n, n, b.size(), -1);
			
			// Check for zero diagonal elements
			for (int i = 0; i < n; i++)
			{
				if (A(i, i) == 0.0)
					throw SingularMatrixError("JacobiSolver::Solve - zero diagonal element at row " + std::to_string(i));
			}
			
			// Initialize solution vector
			Vector<Real> x(n);
			if (x0.size() == n)
				x = x0;
			else
				for (int i = 0; i < n; i++) x[i] = 0.0;
			
			Vector<Real> x_new(n);
			Real b_norm = b.NormL2();
			if (b_norm == 0.0) b_norm = 1.0;  // Avoid division by zero
			
			int iter = 0;
			Real residual = 0.0;
			bool converged = false;
			
			for (iter = 1; iter <= maxIter; iter++)
			{
				// Jacobi iteration: x_new[i] = (b[i] - sum_{j!=i} A[i][j]*x[j]) / A[i][i]
				for (int i = 0; i < n; i++)
				{
					Real sigma = 0.0;
					for (int j = 0; j < n; j++)
					{
						if (j != i)
							sigma += A(i, j) * x[j];
					}
					x_new[i] = (b[i] - sigma) / A(i, i);
				}
				
				// Compute residual ||Ax_new - b||
				Vector<Real> r = A * x_new - b;
				residual = r.NormL2() / b_norm;
				
				// Check convergence
				if (residual < tol)
				{
					converged = true;
					x = x_new;
					break;
				}
				
				// Update for next iteration
				x = x_new;
			}
			
			return IterativeSolverResult(x, iter, residual, converged);
		}
		
		/**
		 * @brief Simple solve returning only solution vector
		 * @throws std::runtime_error if solver doesn't converge
		 */
		static Vector<Real> SolveSimple(const Matrix<Real>& A, 
		                                 const Vector<Real>& b,
		                                 Real tol = 1e-10,
		                                 int maxIter = 1000)
		{
			auto result = Solve(A, b, Vector<Real>(), tol, maxIter);
			if (!result.converged)
				throw ConvergenceError("JacobiSolver::SolveSimple - failed to converge after " + 
				                       std::to_string(result.iterations) + " iterations",
				                       result.iterations, result.residual);
			return result.solution;
		}
	};

	/**
	 * @brief Gauss-Seidel iterative method for solving linear systems Ax = b
	 * 
	 * The Gauss-Seidel method improves on Jacobi by using updated values
	 * immediately as they are computed:
	 * 
	 *   x_i^(k+1) = (1/a_ii) * (b_i - Î£_{j<i} a_ij * x_j^(k+1) - Î£_{j>i} a_ij * x_j^(k))
	 * 
	 * @par Convergence Properties:
	 * - Guaranteed to converge for strictly diagonally dominant matrices
	 * - Guaranteed to converge for symmetric positive definite matrices
	 * - Generally converges faster than Jacobi (about 2x for many problems)
	 * - Cannot be easily parallelized (sequential dependencies)
	 * 
	 * @par Convergence Rate:
	 * The spectral radius Ï((D+L)â»Â¹U) determines convergence rate.
	 * For tridiagonal Poisson: Ï_GS â‰ˆ Ï_JÂ², roughly twice as fast as Jacobi.
	 * 
	 * @see JacobiSolver, SORSolver
	 */
	class GaussSeidelSolver
	{
	public:
		/**
		 * @brief Solve Ax = b using Gauss-Seidel iteration
		 * 
		 * @param A Coefficient matrix (must be square, non-zero diagonal)
		 * @param b Right-hand side vector
		 * @param x0 Initial guess (if empty, uses zero vector)
		 * @param tol Convergence tolerance for relative residual ||Ax-b||/||b||
		 * @param maxIter Maximum number of iterations
		 * @return IterativeSolverResult containing solution and convergence info
		 * 
		 * @throws MatrixDimensionError if dimensions don't match
		 * @throws SingularMatrixError if any diagonal element is zero
		 */
		static IterativeSolverResult Solve(const Matrix<Real>& A, 
		                                    const Vector<Real>& b,
		                                    const Vector<Real>& x0 = Vector<Real>(),
		                                    Real tol = 1e-10,
		                                    int maxIter = 1000)
		{
			int n = A.RowNum();
			
			// Dimension checks
			if (A.ColNum() != n)
				throw MatrixDimensionError("GaussSeidelSolver::Solve - matrix must be square", n, A.ColNum(), -1, -1);
			if (b.size() != n)
				throw MatrixDimensionError("GaussSeidelSolver::Solve - vector b dimension mismatch", n, n, b.size(), -1);
			
			// Check for zero diagonal elements
			for (int i = 0; i < n; i++)
			{
				if (A(i, i) == 0.0)
					throw SingularMatrixError("GaussSeidelSolver::Solve - zero diagonal element at row " + std::to_string(i));
			}
			
			// Initialize solution vector
			Vector<Real> x(n);
			if (x0.size() == n)
				x = x0;
			else
				for (int i = 0; i < n; i++) x[i] = 0.0;
			
			Real b_norm = b.NormL2();
			if (b_norm == 0.0) b_norm = 1.0;
			
			int iter = 0;
			Real residual = 0.0;
			bool converged = false;
			
			for (iter = 1; iter <= maxIter; iter++)
			{
				// Gauss-Seidel iteration: use updated values immediately
				for (int i = 0; i < n; i++)
				{
					Real sigma = 0.0;
					// Use new values for j < i (already computed this iteration)
					for (int j = 0; j < i; j++)
						sigma += A(i, j) * x[j];
					// Use old values for j > i
					for (int j = i + 1; j < n; j++)
						sigma += A(i, j) * x[j];
					
					x[i] = (b[i] - sigma) / A(i, i);
				}
				
				// Compute residual ||Ax - b||
				Vector<Real> r = A * x - b;
				residual = r.NormL2() / b_norm;
				
				// Check convergence
				if (residual < tol)
				{
					converged = true;
					break;
				}
			}
			
			return IterativeSolverResult(x, iter, residual, converged);
		}
		
		/**
		 * @brief Simple solve returning only solution vector
		 * @throws std::runtime_error if solver doesn't converge
		 */
		static Vector<Real> SolveSimple(const Matrix<Real>& A, 
		                                 const Vector<Real>& b,
		                                 Real tol = 1e-10,
		                                 int maxIter = 1000)
		{
			auto result = Solve(A, b, Vector<Real>(), tol, maxIter);
			if (!result.converged)
				throw ConvergenceError("GaussSeidelSolver::SolveSimple - failed to converge after " + 
				                       std::to_string(result.iterations) + " iterations",
				                       result.iterations, result.residual);
			return result.solution;
		}
	};

	/**
	 * @brief Successive Over-Relaxation (SOR) method for solving linear systems Ax = b
	 * 
	 * SOR is a generalization of Gauss-Seidel that introduces a relaxation parameter Ï‰:
	 * 
	 *   x_i^(k+1) = (1-Ï‰)*x_i^(k) + (Ï‰/a_ii) * (b_i - Î£_{j<i} a_ij * x_j^(k+1) - Î£_{j>i} a_ij * x_j^(k))
	 * 
	 * or equivalently:
	 *   x_i^(k+1) = x_i^(k) + Ï‰ * (x_i^GS - x_i^(k))
	 * 
	 * where x_i^GS is the Gauss-Seidel update.
	 * 
	 * @par Relaxation Parameter Ï‰:
	 * - Ï‰ = 1: Reduces to Gauss-Seidel
	 * - 0 < Ï‰ < 1: Under-relaxation (can help convergence for some problems)
	 * - 1 < Ï‰ < 2: Over-relaxation (can significantly accelerate convergence)
	 * - Ï‰ â‰¥ 2 or Ï‰ â‰¤ 0: Method diverges
	 * 
	 * @par Optimal Ï‰ Selection:
	 * For tridiagonal systems from Poisson equation:
	 *   Ï‰_opt = 2 / (1 + sin(Ï€/n)) â‰ˆ 2 - 2Ï€/n
	 * 
	 * This can reduce iterations from O(nÂ²) to O(n).
	 * 
	 * @par Convergence Properties:
	 * - Converges for 0 < Ï‰ < 2 if A is symmetric positive definite
	 * - With optimal Ï‰, convergence can be dramatically faster than Gauss-Seidel
	 * 
	 * @see JacobiSolver, GaussSeidelSolver
	 */
	class SORSolver
	{
	public:
		/**
		 * @brief Solve Ax = b using Successive Over-Relaxation
		 * 
		 * @param A Coefficient matrix (must be square, non-zero diagonal)
		 * @param b Right-hand side vector
		 * @param omega Relaxation parameter (0 < Ï‰ < 2 for convergence)
		 * @param x0 Initial guess (if empty, uses zero vector)
		 * @param tol Convergence tolerance for relative residual ||Ax-b||/||b||
		 * @param maxIter Maximum number of iterations
		 * @return IterativeSolverResult containing solution and convergence info
		 * 
		 * @throws MatrixDimensionError if dimensions don't match
		 * @throws SingularMatrixError if any diagonal element is zero
		 * @throws std::invalid_argument if omega not in (0, 2)
		 */
		static IterativeSolverResult Solve(const Matrix<Real>& A, 
		                                    const Vector<Real>& b,
		                                    Real omega,
		                                    const Vector<Real>& x0 = Vector<Real>(),
		                                    Real tol = 1e-10,
		                                    int maxIter = 1000)
		{
			// Validate omega
			if (omega <= 0.0 || omega >= 2.0)
				throw NumericalMethodError("SORSolver::Solve - omega must be in (0, 2), got " + std::to_string(omega));
			
			int n = A.RowNum();
			
			// Dimension checks
			if (A.ColNum() != n)
				throw MatrixDimensionError("SORSolver::Solve - matrix must be square", n, A.ColNum(), -1, -1);
			if (b.size() != n)
				throw MatrixDimensionError("SORSolver::Solve - vector b dimension mismatch", n, n, b.size(), -1);
			
			// Check for zero diagonal elements
			for (int i = 0; i < n; i++)
			{
				if (A(i, i) == 0.0)
					throw SingularMatrixError("SORSolver::Solve - zero diagonal element at row " + std::to_string(i));
			}
			
			// Initialize solution vector
			Vector<Real> x(n);
			if (x0.size() == n)
				x = x0;
			else
				for (int i = 0; i < n; i++) x[i] = 0.0;
			
			Real b_norm = b.NormL2();
			if (b_norm == 0.0) b_norm = 1.0;
			
			int iter = 0;
			Real residual = 0.0;
			bool converged = false;
			
			for (iter = 1; iter <= maxIter; iter++)
			{
				// SOR iteration
				for (int i = 0; i < n; i++)
				{
					Real sigma = 0.0;
					// Use new values for j < i
					for (int j = 0; j < i; j++)
						sigma += A(i, j) * x[j];
					// Use old values for j > i
					for (int j = i + 1; j < n; j++)
						sigma += A(i, j) * x[j];
					
					// Gauss-Seidel update
					Real x_gs = (b[i] - sigma) / A(i, i);
					
					// SOR: weighted average of old value and Gauss-Seidel update
					x[i] = (1.0 - omega) * x[i] + omega * x_gs;
				}
				
				// Compute residual ||Ax - b||
				Vector<Real> r = A * x - b;
				residual = r.NormL2() / b_norm;
				
				// Check convergence
				if (residual < tol)
				{
					converged = true;
					break;
				}
			}
			
			return IterativeSolverResult(x, iter, residual, converged);
		}
		
		/**
		 * @brief Solve with automatic omega selection for tridiagonal systems
		 * 
		 * Uses the optimal Ï‰ formula: Ï‰ = 2 / (1 + sin(Ï€/n))
		 * This is optimal for tridiagonal systems from discretized Poisson equation.
		 * For other systems, may not be optimal but often gives good results.
		 */
		static IterativeSolverResult SolveOptimal(const Matrix<Real>& A, 
		                                           const Vector<Real>& b,
		                                           const Vector<Real>& x0 = Vector<Real>(),
		                                           Real tol = 1e-10,
		                                           int maxIter = 1000)
		{
			int n = A.RowNum();
			Real omega = 2.0 / (1.0 + std::sin(Constants::PI / n));
			return Solve(A, b, omega, x0, tol, maxIter);
		}
		
		/**
		 * @brief Simple solve returning only solution vector
		 * @throws std::runtime_error if solver doesn't converge
		 */
		static Vector<Real> SolveSimple(const Matrix<Real>& A, 
		                                 const Vector<Real>& b,
		                                 Real omega,
		                                 Real tol = 1e-10,
		                                 int maxIter = 1000)
		{
			auto result = Solve(A, b, omega, Vector<Real>(), tol, maxIter);
			if (!result.converged)
				throw ConvergenceError("SORSolver::SolveSimple - failed to converge after " + 
				                       std::to_string(result.iterations) + " iterations",
				                       result.iterations, result.residual);
			return result.solution;
		}
		
		/**
		 * @brief Estimate optimal omega empirically by trying several values
		 * 
		 * Performs a small number of iterations with different omega values
		 * and returns the one that gives the smallest residual.
		 * 
		 * @param A Coefficient matrix
		 * @param b Right-hand side vector
		 * @param numSamples Number of omega values to try (default 10)
		 * @param testIter Number of iterations for each test (default 50)
		 * @return Estimated optimal omega value
		 */
		static Real EstimateOptimalOmega(const Matrix<Real>& A,
		                                  const Vector<Real>& b,
		                                  int numSamples = 10,
		                                  int testIter = 50)
		{
			Real bestOmega = 1.0;
			Real bestResidual = std::numeric_limits<Real>::max();
			
			// Try omega values from 1.0 to 1.95
			for (int i = 0; i <= numSamples; i++)
			{
				Real omega = 1.0 + 0.95 * i / numSamples;
				auto result = Solve(A, b, omega, Vector<Real>(), PrecisionValues<Real>::EigenSolverZeroThreshold, testIter);
				if (result.residual < bestResidual)
				{
					bestResidual = result.residual;
					bestOmega = omega;
				}
			}
			
			return bestOmega;
		}
	};

} // namespace MML


///////////////////////////   mml/core/MatrixUtils.h   ///////////////////////////




namespace MML
{
	namespace Utils
	{
		// function returning whether Matrix is nilpotent
		template<class Type>
		bool IsNilpotent(const Matrix<Type>& A)
		{
			int N = A.RowNum();
			if (N != A.ColNum())
				throw MatrixDimensionError("IsNilpotent - must be square matrix", N, A.ColNum(), -1, -1);
			
			Matrix<Type> M = A;
			for (int k = 1; k < N; k++)
			{
				M = A * M;
				if (M.IsZero())
					return true;
			}
			return false;
		}

		template<class Type>
		bool IsUnipotent(const Matrix<Type>& A)
		{
			int N = A.RowNum();
			if (N != A.ColNum())
				throw MatrixDimensionError("IsUnipotent - must be square matrix", N, A.ColNum(), -1, -1);

			Matrix<Type> B = A - Matrix<Type>::GetUnitMatrix(N);
			Matrix<Type> M = B;
			for (int k = 1; k < N; k++)
			{
				if (M.IsZero())
					return true;
				M = B * M;
			}
			return M.IsZero();
		}

		// Faddeev-Leverrier algorithm for characteristic polynomial, determinant and inverse matrix
		void FaddeevAlg(const Matrix<Real>& A, PolynomRealFunc& outCharPoly, Real& outDet, Matrix<Real>& outInv)
		{
			int N = A.RowNum();

			Matrix<Real> nullMat(N, N);		// null matrix
			auto identMat = Matrix<Real>::GetUnitMatrix(N);

			Vector<Matrix<Real>> M(N + 1, nullMat);

			outCharPoly.SetDegree(N);

			M[0] = nullMat;
			outCharPoly[N] = 1.0;
			for (int k = 1; k <= A.RowNum(); k++)
			{
				M[k] = A * M[k - 1] + outCharPoly[N - k + 1] * identMat;
				outCharPoly[N - k] = -1.0 / k * (A * M[k]).Trace();
			}

			outDet = std::pow(-1.0, N) * outCharPoly[0];
			outInv = M[N] / outDet; 
		}
	
		// Using LU decomposition to compute the determinant
		template<class Type>
		Type Det(const Matrix<Type>& A)
		{
			try
			{
				LUSolver<Type> lu(A);

				return lu.det();
			}
			catch(const SingularMatrixError&)
			{
				return 0.0;
			}
		}

		// Calculating the rank of a matrix using Gaussian elimination
		template<class Type>
		int Rank(const Matrix<Type>& A, Real EPS = Defaults::RankAlgEPS)
		{
			int rows = A.RowNum();
			int cols = A.ColNum();
			Matrix<Type> mat = A;			// Make a copy to preserve the original

			int rank = 0;
			std::vector<bool> row_selected(rows, false);

			for (int col = 0; col < cols; ++col)
			{
				int pivot_row = -1;
				for (int row = 0; row < rows; ++row)
				{
					if (!row_selected[row] && std::abs(mat(row, col)) > EPS)
					{
						pivot_row = row;
						break;
					}
				}
				if (pivot_row == -1)
					continue;

				++rank;
				row_selected[pivot_row] = true;

				// Eliminate below
				for (int row = 0; row < rows; ++row)
				{
					if (row != pivot_row)
					{
						Type factor = mat(row, col) / mat(pivot_row, col);
						for (int k = col; k < cols; ++k)
							mat(row, k) -= factor * mat(pivot_row, k);
					}
				}
			}
			return rank;
		}
	}
} // namespace MML



///////////////////////////   mml/core/Derivation/DerivationBase.h   ///////////////////////////



namespace MML
{
	namespace Derivation
	{
		static inline const Real NDer1_h = 2 * std::sqrt(Constants::Eps);
		static inline const Real NDer2_h = std::pow(3 * Constants::Eps, 1.0 / 3.0);
		static inline const Real NDer4_h = std::pow(11.25 * Constants::Eps, 1.0 / 5.0);     // 0.0012009323661373839 for double!
		static inline const Real NDer6_h = std::pow(Constants::Eps / 168.0, 1.0 / 7.0);
		static inline const Real NDer8_h = std::pow(551.25 * Constants::Eps, 1.0 / 9.0);
	}
}


///////////////////////////   mml/core/Derivation/DerivationRealFunction.h   ///////////////////////////



namespace MML
{
	namespace Derivation
	{
		/********************************************************************************************************************/
		/********                               Numerical derivatives of FIRST order                                 ********/
		/********************************************************************************************************************/
		static Real NDer1(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			Real yh = f(x + h);
			Real y0 = f(x);
			Real diff = yh - y0;
			if (error)
			{
				Real ym = f(x - h);
				Real ypph = std::abs(yh - 2 * y0 + ym) / h;

				*error = ypph / 2 + (std::abs(yh) + std::abs(y0)) * Constants::Eps / h;
			}
			return diff / h;
		}
		static Real NDer1(const IRealFunction& f, Real x, Real* error)
		{
			// Error bound ~eps^1/2
			// Note that this estimate of h differs from the best estimate by a factor of sqrt((|f(x)| + |f(x+h)|)/|f''(x)|).
			// Since this factor is invariant under the scaling f -> kf, then we are somewhat justified in approximating it by 1.
			// This approximation will get better as we move to higher orders of accuracy.
			return NDer1(f, x, NDer1_h, error);
		}
		static Real NDer1(const IRealFunction& f, Real x)
		{
			return NDer1(f, x, NDer1_h, nullptr);
		}
		
		static Real NDer1Left(const IRealFunction& f, Real x, Real* error = nullptr) 
		{ return NDer1(f, x - 2 * NDer1_h, NDer1_h, error); }
		static Real NDer1Right(const IRealFunction& f, Real x, Real* error = nullptr) 
		{ return NDer1(f, x + 2 * NDer1_h, NDer1_h, error); }
		static Real NDer1Left(const IRealFunction& f, Real x, Real h, Real* error = nullptr) 
		{ return NDer1(f, x - 2 * h, h, error); }
		static Real NDer1Right(const IRealFunction& f, Real x, Real h, Real* error = nullptr) 
		{ return NDer1(f, x + 2 * h, h, error); }

		/********************************************************************************************************************/
		/********                               Numerical derivatives of SECOND order                                ********/
		/********************************************************************************************************************/
		static Real NDer2(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			Real yh = f(x + h);
			Real ymh = f(x - h);
			
			// Check for non-finite function values
			if (std::isnan(yh) || std::isinf(yh) || std::isnan(ymh) || std::isinf(ymh))
				throw NumericalMethodError("Non-finite function values in numerical derivative calculation");
			
			Real diff = yh - ymh;
			if (error)
			{
				Real y2h = f(x + 2 * h);
				Real ym2h = f(x - 2 * h);
				*error = Constants::Eps * (std::abs(yh) + std::abs(ymh)) / (2 * h) + 
								 std::abs((y2h - ym2h) / 2 - diff) / (6 * h);
			}
			
			Real result = diff / (2 * h);
			
			// Check for non-finite result
			if (std::isnan(result) || std::isinf(result))
				throw NumericalMethodError("Non-finite result in numerical derivative calculation");
			
			return result;
		}
		static Real NDer2(const IRealFunction& f, Real x, Real* error)
		{
			// Error bound ~eps^2/3
			// See the previous discussion to understand determination of h and the error bound.
			// Series[(f[x+h] - f[x-h])/(2*h), {h, 0, 4}]

			return NDer2(f, x, NDer2_h, error);
		}
		static Real NDer2(const IRealFunction& f, Real x)
		{
			return NDer2(f, x, NDer2_h, nullptr);
		}
		
		static Real NDer2Left(const IRealFunction& f, Real x, Real* error = nullptr) { return NDer2(f, x - 2 * NDer2_h, NDer2_h, error); }
		static Real NDer2Right(const IRealFunction& f, Real x, Real* error = nullptr) { return NDer2(f, x + 2 * NDer2_h, NDer2_h, error); }
		static Real NDer2Left(const IRealFunction& f, Real x, Real h, Real* error = nullptr) { return NDer2(f, x - 3 * h, h, error); }
		static Real NDer2Right(const IRealFunction& f, Real x, Real h, Real* error = nullptr) { return NDer2(f, x + 3 * h, h, error); }

		/********************************************************************************************************************/
		/********                               Numerical derivatives of FOURTH order                                ********/
		/********************************************************************************************************************/
		static Real NDer4(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			Real yh = f(x + h);
			Real ymh = f(x - h);
			Real y2h = f(x + 2 * h);
			Real ym2h = f(x - 2 * h);

			// Check for non-finite function values
			if (!std::isfinite(yh) || !std::isfinite(ymh) || !std::isfinite(y2h) || !std::isfinite(ym2h))
				throw NumericalMethodError("Non-finite function values in numerical derivative calculation");

			Real y2 = ym2h - y2h;
			Real y1 = yh - ymh;

			if (error)
			{
				// Mathematica code to extract the remainder:
				// Series[(f[x-2*h]+ 8*f[x+h] - 8*f[x-h] - f[x+2*h])/(12*h), {h, 0, 7}]
				Real y3h = f(x + 3 * h);
				Real ym3h = f(x - 3 * h);

				// Error from fifth derivative:
				*error = std::abs((y3h - ym3h) / 2 + 2 * (ym2h - y2h) + 5 * (yh - ymh) / 2) / (30 * h);
				// Error from function evaluation:
				*error += Constants::Eps * (std::abs(y2h) + std::abs(ym2h) + 
																				8 * (std::abs(ymh) + std::abs(yh))) / (12 * h);
			}
			
			Real result = (y2 + 8 * y1) / (12 * h);
			
			// Check for non-finite result
			if (!std::isfinite(result))
				throw NumericalMethodError("Non-finite result in numerical derivative calculation");
			
			return result;
		}
		static Real NDer4(const IRealFunction& f, Real x, Real* error)
		{
			// Error bound ~eps^4/5
			return NDer4(f, x, NDer4_h, error);
		}
		static Real NDer4(const IRealFunction& f, Real x)
		{
			return NDer4(f, x, NDer4_h, nullptr);
		}

		static Real NDer4Left(const IRealFunction& f, Real x, Real* error = nullptr) { return NDer4(f, x - 4 * NDer4_h, NDer4_h, error); }
		static Real NDer4Right(const IRealFunction& f, Real x, Real* error = nullptr) { return NDer4(f, x + 4 * NDer4_h, NDer4_h, error); }
		static Real NDer4Left(const IRealFunction& f, Real x, Real h, Real* error = nullptr) { return NDer4(f, x - 4 * h, h, error); }
		static Real NDer4Right(const IRealFunction& f, Real x, Real h, Real* error = nullptr) { return NDer4(f, x + 4 * h, h, error); }

		/********************************************************************************************************************/
		/********                               Numerical derivatives of SIXTH order                                 ********/
		/********************************************************************************************************************/
		static Real NDer6(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			const Real eps = (std::numeric_limits<Real>::epsilon)();

			Real yh = f(x + h);
			Real ymh = f(x - h);
			Real y1 = yh - ymh;
			Real y2 = f(x - 2 * h) - f(x + 2 * h);
			Real y3 = f(x + 3 * h) - f(x - 3 * h);

			if (error)
			{
				// Mathematica code to generate fd scheme for 7th derivative:
				// Sum[(-1)^i*Binomial[7, i]*(f[x+(3-i)*h] + f[x+(4-i)*h])/2, {i, 0, 7}]
				// Mathematica to demonstrate that this is a finite difference formula for 7th derivative:
				// Series[(f[x+4*h]-f[x-4*h] + 6*(f[x-3*h] - f[x+3*h]) + 14*(f[x-h] - f[x+h] + f[x+2*h] - f[x-2*h]))/2, {h, 0, 15}]
				Real y7 = (f(x + 4 * h) - f(x - 4 * h) - 6 * y3 - 14 * y1 - 14 * y2) / 2;

				*error = std::abs(y7) / (140 * h) + 5 * (std::abs(yh) + std::abs(ymh)) * Constants::Eps / h;
			}
			return (y3 + 9 * y2 + 45 * y1) / (60 * h);
		}
		static Real NDer6(const IRealFunction& f, Real x, Real* error)
		{
			// Error bound ~eps^6/7
			// Error: h^6f^(7)(x)/140 + 5|f(x)|eps/h
			return NDer6(f, x, NDer6_h, error);
		}
		static Real NDer6(const IRealFunction& f, Real x)
		{
			// Error bound ~eps^6/7
			// Error: h^6f^(7)(x)/140 + 5|f(x)|eps/h
			return NDer6(f, x, NDer6_h, nullptr);
		}

		static Real NDer6Left(const IRealFunction& f, Real x, Real* error = nullptr) { return NDer6(f, x - 5 * NDer6_h, NDer6_h, error); }
		static Real NDer6Right(const IRealFunction& f, Real x, Real* error = nullptr) { return NDer6(f, x + 5 * NDer6_h, NDer6_h, error); }
		static Real NDer6Left(const IRealFunction& f, Real x, Real h, Real* error = nullptr) { return NDer6(f, x - 5 * h, h, error); }
		static Real NDer6Right(const IRealFunction& f, Real x, Real h, Real* error = nullptr) { return NDer6(f, x + 5 * h, h, error); }

		/********************************************************************************************************************/
		/********                               Numerical derivatives of EIGHTH order                                ********/
		/********************************************************************************************************************/
		static Real NDer8(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			Real yh = f(x + h);
			Real ymh = f(x - h);
			Real y1 = yh - ymh;
			Real y2 = f(x - 2 * h) - f(x + 2 * h);
			Real y3 = f(x + 3 * h) - f(x - 3 * h);
			Real y4 = f(x - 4 * h) - f(x + 4 * h);

			Real tmp1 = 3 * y4 / 8 + 4 * y3;
			Real tmp2 = 21 * y2 + 84 * y1;

			if (error)
			{
				// Mathematica code to generate fd scheme for 7th derivative:
				// Sum[(-1)^i*Binomial[9, i]*(f[x+(4-i)*h] + f[x+(5-i)*h])/2, {i, 0, 9}]
				// Mathematica to demonstrate that this is a finite difference formula for 7th derivative:
				// Series[(f[x+5*h]-f[x- 5*h])/2 + 4*(f[x-4*h] - f[x+4*h]) + 27*(f[x+3*h] - f[x-3*h])/2 + 24*(f[x-2*h]  - f[x+2*h]) + 21*(f[x+h] - f[x-h]), {h, 0, 15}]
				Real f9 = (f(x + 5 * h) - f(x - 5 * h)) / 2 + 4 * y4 + 27 * y3 / 2 + 24 * y2 + 21 * y1;

				*error = std::abs(f9) / (630 * h) + 7 * (std::abs(yh) + std::abs(ymh)) * Constants::Eps / h;
			}
			return (tmp1 + tmp2) / (105 * h);
		}
		static Real NDer8(const IRealFunction& f, Real x, Real* error)
		{
			// Error bound ~eps^8/9.
			// In Real precision, we only expect to lose two digits of precision while using this formula, at the cost of 8 function evaluations.
			// Error: h^8|f^(9)(x)|/630 + 7|f(x)|eps/h assuming 7 unstabilized additions.
			// Mathematica code to get the error:
			// Series[(f[x+h]-f[x-h])*(4/5) + (1/5)*(f[x-2*h] - f[x+2*h]) + (4/105)*(f[x+3*h] - f[x-3*h]) + (1/280)*(f[x-4*h] - f[x+4*h]), {h, 0, 9}]
			// If we used Kahan summation, we could get the max error down to h^8|f^(9)(x)|/630 + |f(x)|eps/h.

			return NDer8(f, x, NDer8_h, error);
		}
		static Real NDer8(const IRealFunction& f, Real x)
		{
			return NDer8(f, x, NDer8_h, nullptr);
		}

		static Real NDer8Left(const IRealFunction& f, Real x, Real* error = nullptr) { return NDer8(f, x - 6 * NDer8_h, NDer8_h, error); }
		static Real NDer8Right(const IRealFunction& f, Real x, Real* error = nullptr) { return NDer8(f, x + 6 * NDer8_h, NDer8_h, error); }
		static Real NDer8Left(const IRealFunction& f, Real x, Real h, Real* error = nullptr) { return NDer8(f, x - 6 * h, h, error); }
		static Real NDer8Right(const IRealFunction& f, Real x, Real h, Real* error = nullptr) { return NDer8(f, x + 6 * h, h, error); }

		/********************************************************************************************************************/
		/********                                      SECOND DERIVATIVES                                            ********/
		/********  NOTE: Direct finite difference formulas (not derivatives of derivatives!)                        ********/
		/********        NSecDer2: 3 function evals (O(hÂ²) accuracy)                                                ********/
		/********        NSecDer4: 5 function evals (O(hâ´) accuracy)                                                ********/
		/********************************************************************************************************************/
		
		// f''(x) â‰ˆ [f(x-h) - 2f(x) + f(x+h)] / hÂ²
		// Second-order accurate (O(hÂ²)), 3 function evaluations
		static Real NSecDer2(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			Real y0 = f(x);
			Real yh = f(x + h);
			Real ymh = f(x - h);
			
			Real h2 = h * h;
			Real result = (ymh - 2.0 * y0 + yh) / h2;
			
			if (error)
			{
				// Error estimate using 4th derivative approximation
				Real y2h = f(x + 2*h);
				Real ym2h = f(x - 2*h);
				Real f4_approx = std::abs(ym2h - 4*ymh + 6*y0 - 4*yh + y2h) / h2;
				
				*error = f4_approx * h2 / 12.0 + 
				         Constants::Eps * (std::abs(ymh) + 2*std::abs(y0) + std::abs(yh)) / h2;
			}
			
			return result;
		}
		static Real NSecDer2(const IRealFunction& f, Real x, Real* error = nullptr)
		{
			return NSecDer2(f, x, NDer2_h, error);
		}

		// f''(x) â‰ˆ [-f(x-2h) + 16f(x-h) - 30f(x) + 16f(x+h) - f(x+2h)] / (12hÂ²)
		// Fourth-order accurate (O(hâ´)), 5 function evaluations
		static Real NSecDer4(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			Real y0 = f(x);
			Real yh = f(x + h);
			Real ymh = f(x - h);
			Real y2h = f(x + 2*h);
			Real ym2h = f(x - 2*h);
			
			Real h2 = h * h;
			Real result = (-ym2h + 16.0*ymh - 30.0*y0 + 16.0*yh - y2h) / (12.0 * h2);
			
			if (error)
			{
				// Error estimate using 6th derivative approximation
				Real y3h = f(x + 3*h);
				Real ym3h = f(x - 3*h);
				Real f6_approx = std::abs(ym3h - 6*ym2h + 15*ymh - 20*y0 + 15*yh - 6*y2h + y3h) / h2;
				
				*error = f6_approx * h2 * h2 / 90.0 + 
				         Constants::Eps * (std::abs(ym2h) + 16*std::abs(ymh) + 30*std::abs(y0) + 
				                           16*std::abs(yh) + std::abs(y2h)) / (12.0 * h2);
			}
			
			return result;
		}
		static Real NSecDer4(const IRealFunction& f, Real x, Real* error = nullptr)
		{
			return NSecDer4(f, x, NDer4_h, error);
		}

		/********************************************************************************************************************/
		/********                                       THIRD DERIVATIVES                                            ********/
		/********  NOTE: Direct finite difference formulas (not derivatives of derivatives!)                        ********/
		/********        NThirdDer2: 4 function evals (O(hÂ²) accuracy)                                              ********/
		/********        NThirdDer4: 6 function evals (O(hâ´) accuracy)                                              ********/
		/********************************************************************************************************************/
		
		// f'''(x) â‰ˆ [-f(x-2h) + 2f(x-h) - 2f(x+h) + f(x+2h)] / (2hÂ³)
		// Second-order accurate (O(hÂ²)), 4 function evaluations
		static Real NThirdDer2(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			Real yh = f(x + h);
			Real ymh = f(x - h);
			Real y2h = f(x + 2*h);
			Real ym2h = f(x - 2*h);
			
			Real h3 = h * h * h;
			Real result = (-ym2h + 2.0*ymh - 2.0*yh + y2h) / (2.0 * h3);
			
			if (error)
			{
				// Error estimate using 5th derivative approximation
				Real y3h = f(x + 3*h);
				Real ym3h = f(x - 3*h);
				Real f5_approx = std::abs(ym3h - 3*ym2h + 5*ymh - 5*yh + 3*y2h - y3h) / h3;
				
				*error = f5_approx * h * h / 4.0 + 
				         Constants::Eps * (std::abs(ym2h) + 2*std::abs(ymh) + 2*std::abs(yh) + std::abs(y2h)) / (2.0 * h3);
			}
			
			return result;
		}
		static Real NThirdDer2(const IRealFunction& f, Real x, Real* error = nullptr)
		{
			// Use larger step size for third derivatives (hÂ³ in denominator needs bigger h)
			return NThirdDer2(f, x, NDer4_h, error);
		}

		// f'''(x) â‰ˆ [f(x-3h) - 8f(x-2h) + 13f(x-h) - 13f(x+h) + 8f(x+2h) - f(x+3h)] / (8hÂ³)
		// Fourth-order accurate (O(hâ´)), 6 function evaluations
		static Real NThirdDer4(const IRealFunction& f, Real x, Real h, Real* error = nullptr)
		{
			Real yh = f(x + h);
			Real ymh = f(x - h);
			Real y2h = f(x + 2*h);
			Real ym2h = f(x - 2*h);
			Real y3h = f(x + 3*h);
			Real ym3h = f(x - 3*h);
			
			Real h3 = h * h * h;
			Real result = (ym3h - 8.0*ym2h + 13.0*ymh - 13.0*yh + 8.0*y2h - y3h) / (8.0 * h3);
			
			if (error)
			{
				// Error estimate using 7th derivative approximation
				Real y4h = f(x + 4*h);
				Real ym4h = f(x - 4*h);
				Real f7_approx = std::abs(ym4h - 4*ym3h + 9*ym2h - 13*ymh + 13*yh - 9*y2h + 4*y3h - y4h) / h3;
				
				*error = f7_approx * h * h * h * h / 120.0 + 
				         Constants::Eps * (std::abs(ym3h) + 8*std::abs(ym2h) + 13*std::abs(ymh) + 
				                           13*std::abs(yh) + 8*std::abs(y2h) + std::abs(y3h)) / (8.0 * h3);
			}
			
			return result;
		}
		static Real NThirdDer4(const IRealFunction& f, Real x, Real* error = nullptr)
		{
			return NThirdDer4(f, x, NDer4_h, error);
		}

		/********************************************************************************************************************/
		/********                            Definitions of default derivation functions                             ********/
		/********************************************************************************************************************/
		static inline Real(*Derive)(const IRealFunction& f, Real x) = Derivation::NDer4;
		static inline Real(*DeriveErr)(const IRealFunction& f, 
																	 Real x, Real* error) = Derivation::NDer4;
		static inline Real(*DeriveSec)(const IRealFunction& f, 
																	 Real x, Real* error) = Derivation::NSecDer4;
		static inline Real(*DeriveThird)(const IRealFunction& f, 
																		 Real x, Real* error) = Derivation::NThirdDer2;
	}
}


///////////////////////////   mml/core/Derivation/DerivationScalarFunction.h   ///////////////////////////




namespace MML
{
	namespace Derivation
	{
		/********************************************************************************************************************/
		/********                               Numerical derivatives of FIRST order                                 ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer1Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, 
														 Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x = point;
			Real y0 = f(x);

			x[deriv_index] = orig_x + h;
			Real yh = f(x);

			Real diff = yh - y0;
			if (error)
			{
				x[deriv_index] = orig_x - h;
				Real ym = f(x);
				Real ypph = std::abs(yh - 2 * y0 + ym) / h;
				*error = ypph / 2 + (std::abs(yh) + std::abs(y0)) * Constants::Eps / h;
			}
			return diff / h;
		}
		template <int N>
		static Real NDer1Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, 
														 Real* error = nullptr)
		{
			return NDer1Partial(f, deriv_index, point, NDer1_h, error);
		}
		template <int N>
		static VectorN<Real, N> NDer1PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, 
																							Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer1Partial(f, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer1Partial(f, i, point, h);
			}

			return ret;
		}
		template <int N>
		static VectorN<Real, N> NDer1PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, 
																							VectorN<Real, N>* error = nullptr)
		{
			return NDer1PartialByAll(f, point, NDer1_h, error);
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of SECOND order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer2Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			auto    x = point;
			x[deriv_index] = orig_x + h;
			Real yh = f(x);

			x[deriv_index] = orig_x - h;
			Real ymh = f(x);

			Real diff = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 2 * h;
				Real y2h = f(x);

				x[deriv_index] = orig_x - 2 * h;
				Real ym2h = f(x);

				*error = Constants::Eps * (std::abs(yh) + std::abs(ymh)) / (2 * h) + std::abs((y2h - ym2h) / 2 - diff) / (6 * h);
			}

			return diff / (2 * h);
		}
		template <int N>
		static Real NDer2Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer2Partial(f, deriv_index, point, NDer2_h, error);
		}
		
		template <int N>
		static VectorN<Real, N> NDer2PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer2Partial(f, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer2Partial(f, i, point, h);
			}

			return ret;
		}
		template <int N>
		static VectorN<Real, N> NDer2PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, VectorN<Real, N>* error = nullptr)
		{
			return NDer2PartialByAll(f, point, NDer2_h, error);
		}
		
		/********************************************************************************************************************/
		/********                               Numerical derivatives of FOURTH order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer4Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, 
														 Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f(x);

			x[deriv_index] = orig_x - h;
			Real ymh = f(x);

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f(x);

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f(x);

			Real y2 = ym2h - y2h;
			Real y1 = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 3 * h;
				Real y3h = f(x);

				x[deriv_index] = orig_x - 3 * h;
				Real ym3h = f(x);

				*error = std::abs((y3h - ym3h) / 2 + 2 * (ym2h - y2h) + 5 * (yh - ymh) / 2) / (30 * h);
				*error += Constants::Eps * (std::abs(y2h) + std::abs(ym2h) + 
																				8 * (std::abs(ymh) + std::abs(yh))) / (12 * h);
			}
			return (y2 + 8 * y1) / (12 * h);
		}
		template <int N>
		static Real NDer4Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer4Partial(f, deriv_index, point, NDer4_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer4PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer4Partial(f, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer4Partial(f, i, point, h);
			}

			return ret;
		}
		template <int N>
		static VectorN<Real, N> NDer4PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, VectorN<Real, N>* error = nullptr)
		{
			return NDer4PartialByAll(f, point, NDer4_h, error);
		}
		
		/********************************************************************************************************************/
		/********                               Numerical derivatives of SIXTH order                                 ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer6Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };

			x[deriv_index] = orig_x + h;
			Real yh = f(x);

			x[deriv_index] = orig_x - h;
			Real ymh = f(x);

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f(x);

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f(x);

			x[deriv_index] = orig_x + 3 * h;
			Real y3h = f(x);

			x[deriv_index] = orig_x - 3 * h;
			Real ym3h = f(x);

			Real y1 = yh - ymh;
			Real y2 = ym2h - y2h;
			Real y3 = y3h - ym3h;

			if (error)
			{
				x[deriv_index] = orig_x + 4 * h;
				Real y4h = f(x);

				x[deriv_index] = orig_x - 4 * h;
				Real ym4h = f(x);

				Real y7 = (y4h - ym4h - 6 * y3 - 14 * y1 - 14 * y2) / 2;

				*error = std::abs(y7) / (140 * h) + 5 * (std::abs(yh) + std::abs(ymh)) * Constants::Eps / h;
			}
			return (y3 + 9 * y2 + 45 * y1) / (60 * h);
		}
		template <int N>
		static Real NDer6Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer6Partial(f, deriv_index, point, NDer6_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer6PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer6Partial(f, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer6Partial(f, i, point, h);
			}

			return ret;
		}
		template <int N>
		static VectorN<Real, N> NDer6PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, VectorN<Real, N>* error = nullptr)
		{
			return NDer6PartialByAll(f, point, NDer6_h, error);
		}
		
		/********************************************************************************************************************/
		/********                               Numerical derivatives of EIGHTH order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer8Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };

			x[deriv_index] = orig_x + h;
			Real yh = f(x);

			x[deriv_index] = orig_x - h;
			Real ymh = f(x);

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f(x);

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f(x);

			x[deriv_index] = orig_x + 3 * h;
			Real y3h = f(x);

			x[deriv_index] = orig_x - 3 * h;
			Real ym3h = f(x);

			x[deriv_index] = orig_x + 4 * h;
			Real y4h = f(x);

			x[deriv_index] = orig_x - 4 * h;
			Real ym4h = f(x);

			Real y1 = yh - ymh;
			Real y2 = ym2h - y2h;
			Real y3 = y3h - ym3h;
			Real y4 = ym4h - y4h;

			Real tmp1 = 3 * y4 / 8 + 4 * y3;
			Real tmp2 = 21 * y2 + 84 * y1;

			if (error)
			{
				x[deriv_index] = orig_x + 5 * h;
				Real y5h = f(x);

				x[deriv_index] = orig_x - 5 * h;
				Real ym5h = f(x);

				Real f9 = (y5h - ym5h) / 2 + 4 * y4 + 27 * y3 / 2 + 24 * y2 + 21 * y1;

				*error = std::abs(f9) / (630 * h) + 7 * (std::abs(yh) + std::abs(ymh)) * Constants::Eps / h;
			}

			return (tmp1 + tmp2) / (105 * h);
		}
		template <int N>
		static Real NDer8Partial(const IScalarFunction<N>& f, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer8Partial(f, deriv_index, point, NDer8_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer8PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer8Partial(f, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer8Partial(f, i, point, h);
			}

			return ret;
		}
		template <int N>
		static VectorN<Real, N> NDer8PartialByAll(const IScalarFunction<N>& f, const VectorN<Real, N>& point, VectorN<Real, N>* error = nullptr)
		{
			return NDer8PartialByAll(f, point, NDer8_h, error);
		}
		
		/********************************************************************************************************************/
		/********                                      SECOND PARTIAL DERIVATIVES                                    ********/
		/********  NOTE: Direct finite difference formulas optimized for minimal function evaluations                ********/
		/********        For mixed partials (der_ind1 != der_ind2): âˆ‚Â²f/âˆ‚xâˆ‚y                                        ********/
		/********        For pure partials (der_ind1 == der_ind2): âˆ‚Â²f/âˆ‚xÂ²                                          ********/
		/********                                                                                                    ********/
		/********        NSecDer2Partial: O(hÂ²) accuracy, 4-9 function evals depending on pure/mixed                ********/
		/********        NSecDer4Partial: O(hâ´) accuracy, 5-13 function evals depending on pure/mixed               ********/
		/********************************************************************************************************************/
		
		// Second-order accurate (O(hÂ²)) second partial derivative
		// For pure second partial (âˆ‚Â²f/âˆ‚xáµ¢Â²): [f(x-h) - 2f(x) + f(x+h)] / hÂ² - 3 function evaluations
		// For mixed partial (âˆ‚Â²f/âˆ‚xáµ¢âˆ‚xâ±¼): [f(x+h_i+h_j) - f(x+h_i-h_j) - f(x-h_i+h_j) + f(x-h_i-h_j)] / (4hÂ²) - 4 evaluations
		template <int N>
		static Real NSecDer2Partial(const IScalarFunction<N>& f, int der_ind1, int der_ind2, 
		                            const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real h2 = h * h;
			
			if (der_ind1 == der_ind2)
			{
				// Pure second partial âˆ‚Â²f/âˆ‚xáµ¢Â² - use standard 3-point formula
				auto x_plus = point;
				auto x_minus = point;
				
				x_plus[der_ind1] = point[der_ind1] + h;
				x_minus[der_ind1] = point[der_ind1] - h;
				
				Real f0 = f(point);
				Real fh = f(x_plus);
				Real fmh = f(x_minus);
				
				Real result = (fmh - 2.0*f0 + fh) / h2;
				
				if (error)
				{
					// Error estimate using 4th derivative
					auto x_2plus = point;
					auto x_2minus = point;
					x_2plus[der_ind1] = point[der_ind1] + 2*h;
					x_2minus[der_ind1] = point[der_ind1] - 2*h;
					
					Real f4_approx = std::abs(f(x_2minus) - 4.0*fmh + 6.0*f0 - 4.0*fh + f(x_2plus)) / h2;
					*error = f4_approx * h2 / 12.0 + 
					         Constants::Eps * (std::abs(fmh) + 2*std::abs(f0) + std::abs(fh)) / h2;
				}
				
				return result;
			}
			else
			{
				// Mixed partial âˆ‚Â²f/âˆ‚xáµ¢âˆ‚xâ±¼ - use 4-point cross-difference formula
				auto x_pp = point;  // +h in both directions
				auto x_pm = point;  // +h in i, -h in j
				auto x_mp = point;  // -h in i, +h in j
				auto x_mm = point;  // -h in both directions
				
				x_pp[der_ind1] = point[der_ind1] + h;
				x_pp[der_ind2] = point[der_ind2] + h;
				
				x_pm[der_ind1] = point[der_ind1] + h;
				x_pm[der_ind2] = point[der_ind2] - h;
				
				x_mp[der_ind1] = point[der_ind1] - h;
				x_mp[der_ind2] = point[der_ind2] + h;
				
				x_mm[der_ind1] = point[der_ind1] - h;
				x_mm[der_ind2] = point[der_ind2] - h;
				
				Real fpp = f(x_pp);
				Real fpm = f(x_pm);
				Real fmp = f(x_mp);
				Real fmm = f(x_mm);
				
				Real result = (fpp - fpm - fmp + fmm) / (4.0 * h2);
				
				if (error)
				{
					// Approximate error using higher-order differences
					*error = Constants::Eps * (std::abs(fpp) + std::abs(fpm) + 
					                           std::abs(fmp) + std::abs(fmm)) / (4.0 * h2);
				}
				
				return result;
			}
		}
		template <int N>
		static Real NSecDer2Partial(const IScalarFunction<N>& f, int der_ind1, int der_ind2, 
		                            const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NSecDer2Partial(f, der_ind1, der_ind2, point, NDer2_h, error);
		}

		// Fourth-order accurate (O(hâ´)) second partial derivative
		// For pure second partial (âˆ‚Â²f/âˆ‚xáµ¢Â²): [-f(x-2h) + 16f(x-h) - 30f(x) + 16f(x+h) - f(x+2h)] / (12hÂ²) - 5 evaluations
		// For mixed partial (âˆ‚Â²f/âˆ‚xáµ¢âˆ‚xâ±¼): Higher-order cross-difference stencil - 13 evaluations
		template <int N>
		static Real NSecDer4Partial(const IScalarFunction<N>& f, int der_ind1, int der_ind2, 
		                            const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real h2 = h * h;
			
			if (der_ind1 == der_ind2)
			{
				// Pure second partial âˆ‚Â²f/âˆ‚xáµ¢Â² - use 5-point formula
				auto x = point;
				Real x_orig = point[der_ind1];
				
				Real f0 = f(point);
				
				x[der_ind1] = x_orig + h;
				Real fh = f(x);
				
				x[der_ind1] = x_orig - h;
				Real fmh = f(x);
				
				x[der_ind1] = x_orig + 2*h;
				Real f2h = f(x);
				
				x[der_ind1] = x_orig - 2*h;
				Real fm2h = f(x);
				
				Real result = (-fm2h + 16.0*fmh - 30.0*f0 + 16.0*fh - f2h) / (12.0 * h2);
				
				if (error)
				{
					// Error estimate using 6th derivative
					x[der_ind1] = x_orig + 3*h;
					Real f3h = f(x);
					x[der_ind1] = x_orig - 3*h;
					Real fm3h = f(x);
					
					Real f6_approx = std::abs(fm3h - 6.0*fm2h + 15.0*fmh - 20.0*f0 + 15.0*fh - 6.0*f2h + f3h) / h2;
					*error = f6_approx * h2 * h2 / 90.0 + 
					         Constants::Eps * (std::abs(fm2h) + 16*std::abs(fmh) + 30*std::abs(f0) + 
					                           16*std::abs(fh) + std::abs(f2h)) / (12.0 * h2);
				}
				
				return result;
			}
			else
			{
				// Mixed partial âˆ‚Â²f/âˆ‚xáµ¢âˆ‚xâ±¼ using Richardson extrapolation for O(hâ´) accuracy
				// 
				// Standard 4-point cross-difference formula (O(hÂ²)):
				//   D_h = [f(x+h,y+h) - f(x+h,y-h) - f(x-h,y+h) + f(x-h,y-h)] / (4hÂ²)
				//
				// Richardson extrapolation with step h and 2h:
				//   D_h  = exact + cÂ·hÂ² + O(hâ´)
				//   D_2h = exact + 4cÂ·hÂ² + O(hâ´)
				//   (4Â·D_h - D_2h) / 3 = exact + O(hâ´)
				//
				// Simplifying: (16Â·d1 - d2) / (48Â·hÂ²) where:
				//   d1 = f(Â±h,Â±h) cross-difference
				//   d2 = f(Â±2h,Â±2h) cross-difference
				
				Real x_i = point[der_ind1];
				Real x_j = point[der_ind2];
				
				auto eval = [&](Real di, Real dj) {
					auto x = point;
					x[der_ind1] = x_i + di * h;
					x[der_ind2] = x_j + dj * h;
					return f(x);
				};
				
				// Cross-difference at step h
				Real f_p1_p1 = eval( 1,  1);
				Real f_p1_m1 = eval( 1, -1);
				Real f_m1_p1 = eval(-1,  1);
				Real f_m1_m1 = eval(-1, -1);
				Real d1 = (f_p1_p1 - f_p1_m1 - f_m1_p1 + f_m1_m1);
				
				// Cross-difference at step 2h  
				Real f_p2_p2 = eval( 2,  2);
				Real f_p2_m2 = eval( 2, -2);
				Real f_m2_p2 = eval(-2,  2);
				Real f_m2_m2 = eval(-2, -2);
				Real d2 = (f_p2_p2 - f_p2_m2 - f_m2_p2 + f_m2_m2);
				
				// Richardson extrapolation: (4Â·D_h - D_2h) / 3 = (16Â·d1 - d2) / (48Â·hÂ²)
				Real result = (16.0 * d1 - d2) / (48.0 * h2);
				
				if (error)
				{
					*error = Constants::Eps * (std::abs(f_p1_p1) + std::abs(f_p1_m1) + 
					                           std::abs(f_m1_p1) + std::abs(f_m1_m1)) / (4.0 * h2);
				}
				
				return result;
			}
		}
		template <int N>
		static Real NSecDer4Partial(const IScalarFunction<N>& f, int der_ind1, int der_ind2, 
		                            const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NSecDer4Partial(f, der_ind1, der_ind2, point, NDer4_h, error);
		}

		/********************************************************************************************************************/
		/********                            Definitions of default derivation functions                             ********/
		/********************************************************************************************************************/
		template<int N>
		static inline Real(*DerivePartial)(const IScalarFunction<N>& f, int deriv_index, 
																			 const VectorN<Real, N>& point, Real* error) = Derivation::NDer4Partial;
		template<int N>
		static inline Real(*DeriveSecPartial)(const IScalarFunction<N>& f, int der_ind1, int der_ind2, 
																					const VectorN<Real, N>& point, Real* error) = Derivation::NSecDer4Partial;
		template<int N>
		static inline VectorN<Real, N>(*DerivePartialAll)(const IScalarFunction<N>& f, const VectorN<Real, N>& point, 
																											VectorN<Real, N>* error) = Derivation::NDer4PartialByAll;
	}
}


///////////////////////////   mml/core/Derivation/DerivationVectorFunction.h   ///////////////////////////




namespace MML
{
	namespace Derivation
	{
		/********************************************************************************************************************/
		/********                               Numerical derivatives of FIRST order                                 ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer1Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, 
														 const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			auto x = point;

			Real x_orig = x[deriv_index];
			Real y0 = f(x)[func_index];

			x[deriv_index] = x_orig + h;
			Real yh = f(x)[func_index];

			Real diff = yh - y0;
			if (error)
			{
				x[deriv_index] = x_orig - h;
				Real ym = f(x)[func_index];
				Real ypph = std::abs(yh - 2 * y0 + ym) / h;
				*error = ypph / 2 + (std::abs(yh) + std::abs(y0)) * Constants::Eps / h;
			}
			return diff / h;
		}

		template <int N>
		static Real NDer1Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, 
														 const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer1Partial(f, func_index, deriv_index, point, NDer1_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer1PartialByAll(const IVectorFunction<N>& f, int func_index, 
																						  const VectorN<Real, N>& point, Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer1Partial(f, func_index, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer1Partial(f, func_index, i, point, h);
			}

			return ret;
		}

		template <int N>
		static VectorN<Real, N> NDer1PartialByAll(const IVectorFunction<N>& f, int func_index, 
																							const VectorN<Real, N>& point, VectorN<Real, N>* error = nullptr)
		{
			return NDer1PartialByAll(f, func_index, point, NDer1_h, error);
		}

		template <int N>
		static MatrixNM<Real, N, N> NDer1PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, 
																										 Real h, MatrixNM<Real, N, N>* error = nullptr)
		{
			MatrixNM<Real, N, N> ret;

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
				{
					if (error)
						ret(i, j) = NDer1Partial(f, i, j, point, h, &((*error)(i, j)));
					else
						ret(i, j) = NDer1Partial(f, i, j, point, h);
				}

			return ret;
		}

		template <int N>
		static MatrixNM<Real, N, N> NDer1PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, 
																										 MatrixNM<Real, N, N>* error = nullptr)
		{
			return NDer1PartialAllByAll(f, point, NDer1_h, error);
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of SECOND order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer2Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, 
														 const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f(x)[func_index];

			x[deriv_index] = orig_x - h;
			Real ymh = f(x)[func_index];

			Real diff = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 2 * h;
				Real y2h = f(x)[func_index];

				x[deriv_index] = orig_x - 2 * h;
				Real ym2h = f(x)[func_index];

				*error = Constants::Eps * (std::abs(yh) +  std::abs(ymh)) / (2 * h) + 
								 std::abs((y2h - ym2h) / 2 - diff) / (6 * h);
			}

			return diff / (2 * h);
		}
		template <int N>
		static Real NDer2Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer2Partial(f, func_index, deriv_index, point, NDer2_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer2PartialByAll(const IVectorFunction<N>& f, int func_index, const VectorN<Real, N>& point, Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer2Partial(f, func_index, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer2Partial(f, func_index, i, point, h);
			}

			return ret;
		}

		template <int N>
		static VectorN<Real, N> NDer2PartialByAll(const IVectorFunction<N>& f, int func_index, const VectorN<Real, N>& point, VectorN<Real, N>* error = nullptr)
		{
			return NDer2PartialByAll(f, func_index, point, NDer2_h, error);
		}

		template <int N>
		static MatrixNM<Real, N, N> NDer2PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, Real h, MatrixNM<Real, N, N>* error = nullptr)
		{
			MatrixNM<Real, N, N> ret;

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
				{
					if (error)
						ret(i, j) = NDer2Partial(f, i, j, point, h, &((*error)(i, j)));
					else
						ret(i, j) = NDer2Partial(f, i, j, point, h);
				}

			return ret;
		}

		template <int N>
		static MatrixNM<Real, N, N> NDer2PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, MatrixNM<Real, N, N>* error = nullptr)
		{
			return NDer2PartialAllByAll(f, point, NDer2_h, error);
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of FOURTH order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer4Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, const VectorN<Real, N>& point, Real h, 
														 Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f(x)[func_index];

			x[deriv_index] = orig_x - h;
			Real ymh = f(x)[func_index];

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f(x)[func_index];

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f(x)[func_index];

			Real y2 = ym2h - y2h;
			Real y1 = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 3 * h;
				Real y3h = f(x)[func_index];

				x[deriv_index] = orig_x - 3 * h;
				Real ym3h = f(x)[func_index];

				*error = std::abs((y3h - ym3h) / 2 + 2 * (ym2h - y2h) + 5 * (yh - ymh) / 2) / (30 * h);
				*error += Constants::Eps * (std::abs(y2h) + std::abs(ym2h) + 8 * (std::abs(ymh) + std::abs(yh))) / (12 * h);
			}
			return (y2 + 8 * y1) / (12 * h);
		}
		template <int N>
		static Real NDer4Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, const VectorN<Real, N>& point, 
														 Real* error = nullptr)
		{
			return NDer4Partial(f, func_index, deriv_index, point, NDer4_h, error);
		}
		template <int N>
		static VectorN<Real, N> NDer4PartialByAll(const IVectorFunction<N>& f, int func_index, const VectorN<Real, N>& point, Real h, 
																							VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer4Partial(f, func_index, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer4Partial(f, func_index, i, point, h);
			}

			return ret;
		}
		template <int N>
		static VectorN<Real, N> NDer4PartialByAll(const IVectorFunction<N>& f, int func_index, const VectorN<Real, N>& point, 
																							VectorN<Real, N>* error = nullptr)
		{
			return NDer4PartialByAll(f, func_index, point, NDer4_h, error);
		}

		template <int N>
		static MatrixNM<Real, N, N> NDer4PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, Real h, 
																										 MatrixNM<Real, N, N>* error = nullptr)
		{
			MatrixNM<Real, N, N> ret;

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
				{
					if (error)
						ret(i, j) = NDer4Partial(f, i, j, point, h, &((*error)(i, j)));
					else
						ret(i, j) = NDer4Partial(f, i, j, point, h);
				}

			return ret;
		}
		template <int N>
		static MatrixNM<Real, N, N> NDer4PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, 
																										 MatrixNM<Real, N, N>* error = nullptr)
		{
			return NDer4PartialAllByAll(f, point, NDer4_h, error);
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of SIXTH order                                 ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer6Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };

			x[deriv_index] = orig_x + h;
			Real yh = f(x)[func_index];

			x[deriv_index] = orig_x - h;
			Real ymh = f(x)[func_index];

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f(x)[func_index];

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f(x)[func_index];

			x[deriv_index] = orig_x + 3 * h;
			Real y3h = f(x)[func_index];

			x[deriv_index] = orig_x - 3 * h;
			Real ym3h = f(x)[func_index];

			Real y1 = yh - ymh;
			Real y2 = ym2h - y2h;
			Real y3 = y3h - ym3h;

			if (error)
			{
				x[deriv_index] = orig_x + 4 * h;
				Real y4h = f(x)[func_index];

				x[deriv_index] = orig_x - 4 * h;
				Real ym4h = f(x)[func_index];

				Real y7 = (y4h - ym4h - 6 * y3 - 14 * y1 - 14 * y2) / 2;

				*error = std::abs(y7) / (140 * h) + 5 * (std::abs(yh) + std::abs(ymh)) * Constants::Eps / h;
			}
			return (y3 + 9 * y2 + 45 * y1) / (60 * h);
		}
		template <int N>
		static Real NDer6Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer6Partial(f, func_index, deriv_index, point, NDer6_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer6PartialByAll(const IVectorFunction<N>& f, int func_index, const VectorN<Real, N>& point, Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer6Partial(f, func_index, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer6Partial(f, func_index, i, point, h);
			}

			return ret;
		}
		template <int N>
		static VectorN<Real, N> NDer6PartialByAll(const IVectorFunction<N>& f, int func_index, const VectorN<Real, N>& point, VectorN<Real, N>* error = nullptr)
		{
			return NDer6PartialByAll(f, func_index, point, NDer6_h, error);
		}

		template <int N>
		static MatrixNM<Real, N, N> NDer6PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, Real h, MatrixNM<Real, N, N>* error = nullptr)
		{
			MatrixNM<Real, N, N> ret;

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
				{
					if (error)
						ret(i, j) = NDer6Partial(f, i, j, point, h, &((*error)(i, j)));
					else
						ret(i, j) = NDer6Partial(f, i, j, point, h);
				}

			return ret;
		}
		template <int N>
		static MatrixNM<Real, N, N> NDer6PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, MatrixNM<Real, N, N>* error = nullptr)
		{
			return NDer6PartialAllByAll(f, point, NDer6_h, error);
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of EIGHTH order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer8Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };

			x[deriv_index] = orig_x + h;
			Real yh = f(x)[func_index];

			x[deriv_index] = orig_x - h;
			Real ymh = f(x)[func_index];

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f(x)[func_index];

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f(x)[func_index];

			x[deriv_index] = orig_x + 3 * h;
			Real y3h = f(x)[func_index];

			x[deriv_index] = orig_x - 3 * h;
			Real ym3h = f(x)[func_index];

			x[deriv_index] = orig_x + 4 * h;
			Real y4h = f(x)[func_index];

			x[deriv_index] = orig_x - 4 * h;
			Real ym4h = f(x)[func_index];

			Real y1 = yh - ymh;
			Real y2 = ym2h - y2h;
			Real y3 = y3h - ym3h;
			Real y4 = ym4h - y4h;

			Real tmp1 = 3 * y4 / 8 + 4 * y3;
			Real tmp2 = 21 * y2 + 84 * y1;

			if (error)
			{
				x[deriv_index] = orig_x + 5 * h;
				Real y5h = f(x)[func_index];

				x[deriv_index] = orig_x - 5 * h;
				Real ym5h = f(x)[func_index];

				Real f9 = (y5h - ym5h) / 2 + 4 * y4 + 27 * y3 / 2 + 24 * y2 + 21 * y1;

				*error = std::abs(f9) / (630 * h) + 7 * (std::abs(yh) + std::abs(ymh)) * Constants::Eps / h;
			}

			return (tmp1 + tmp2) / (105 * h);
		}
		template <int N>
		static Real NDer8Partial(const IVectorFunction<N>& f, int func_index, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer8Partial(f, func_index, deriv_index, point, NDer8_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer8PartialByAll(const IVectorFunction<N>& f, int func_index, const VectorN<Real, N>& point, Real h, VectorN<Real, N>* error = nullptr)
		{
			VectorN<Real, N> ret;

			for (int i = 0; i < N; i++)
			{
				if (error)
					ret[i] = NDer8Partial(f, func_index, i, point, h, &(*error)[i]);
				else
					ret[i] = NDer8Partial(f, func_index, i, point, h);
			}

			return ret;
		}

		template <int N>
		static VectorN<Real, N> NDer8PartialByAll(const IVectorFunction<N>& f, int func_index, const VectorN<Real, N>& point, VectorN<Real, N>* error = nullptr)
		{
			return NDer8PartialByAll(f, func_index, point, NDer8_h, error);
		}

		template <int N>
		static MatrixNM<Real, N, N> NDer8PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, Real h, MatrixNM<Real, N, N>* error = nullptr)
		{
			MatrixNM<Real, N, N> ret;

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
				{
					if (error)
						ret(i, j) = NDer8Partial(f, i, j, point, h, &((*error)(i, j)));
					else
						ret(i, j) = NDer8Partial(f, i, j, point, h);
				}

			return ret;
		}

		template <int N>
		static MatrixNM<Real, N, N> NDer8PartialAllByAll(const IVectorFunction<N>& f, const VectorN<Real, N>& point, MatrixNM<Real, N, N>* error = nullptr)
		{
			return NDer8PartialAllByAll(f, point, NDer8_h, error);
		}

		/********************************************************************************************************************/
		/********                            Definitions of default derivation functions                             ********/
		/********************************************************************************************************************/
		template<int N>
		static inline Real(*DeriveVecPartial)(const IVectorFunction<N>& f, int func_index, int deriv_index, 
																					const VectorN<Real, N>& point, Real* error) = Derivation::NDer4Partial;
		template<int N>
		static inline VectorN<Real, N>(*DeriveVecPartialAll)(const IVectorFunction<N>& f, int func_index, 
																												 const VectorN<Real, N>& point, 
																												 VectorN<Real, N>* error) = Derivation::NDer4PartialByAll;
		template<int N>
		static inline MatrixNM<Real, N, N>(*DeriveVecPartialAllByAll)(const IVectorFunction<N>& f, const VectorN<Real, N>& point, 
																																	MatrixNM<Real, N, N>* error) = Derivation::NDer4PartialAllByAll;

	}
}

///////////////////////////   mml/core/Derivation/DerivationParametricCurve.h   ///////////////////////////




namespace MML
{
	namespace Derivation
	{
		/********************************************************************************************************************/
		/********                               Numerical derivatives of FIRST order                                 ********/
		/********************************************************************************************************************/
		template <int N>
		static VectorN<Real, N> NDer1(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> y0 = f(t);
			VectorN<Real, N> diff = yh - y0;

			if (error)
			{
				VectorN<Real, N> ym = f(t - h);
				VectorN<Real, N> ypph_vec = yh - 2 * y0 + ym;

				Real ypph = ypph_vec.NormL2() / h;

				*error = ypph / 2 + (yh.NormL2() + y0.NormL2()) * Constants::Eps / h;
			}
			return diff / h;
		}

		template <int N>
		static VectorN<Real, N> NDer1(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			return NDer1(f, t, NDer1_h, error);
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of SECOND order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static VectorN<Real, N> NDer2(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> ymh = f(t - h);
			VectorN<Real, N> diff = yh - ymh;

			if (error)
			{
				VectorN<Real, N> yth = f(t + 2 * h);
				VectorN<Real, N> ymth = f(t - 2 * h);

				*error = Constants::Eps * ((yh + ymh) / (2 * h)).NormL2() + std::abs(((yth - ymth) / 2 - diff).NormL2()) / (6 * h);
			}
			return diff / (2 * h);
		}

		template <int N>
		static VectorN<Real, N> NDer2(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			return NDer2(f, t, NDer2_h, error);
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of FOURTH order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static VectorN<Real, N> NDer4(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> ymh = f(t - h);
			VectorN<Real, N> y2h = f(t + 2 * h);
			VectorN<Real, N> ym2h = f(t - 2 * h);

			VectorN<Real, N> y2 = ym2h - y2h;
			VectorN<Real, N> y1 = yh - ymh;

			if (error)
			{
				VectorN<Real, N> y3h = f(t + 3 * h);
				VectorN<Real, N> ym3h = f(t - 3 * h);

				*error = std::abs((y3h - ym3h).NormL2() / 2 + 2 * (ym2h - y2h).NormL2() + 5 * (yh - ymh).NormL2() / 2) / (30 * h);
				*error += Constants::Eps * (y2h.NormL2() + ym2h.NormL2() + 8 * (ymh.NormL2() + yh.NormL2())) / (12 * h);
			}
			return (y2 + 8 * y1) / (12 * h);
		}

		template <int N>
		static VectorN<Real, N> NDer4(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			return NDer4(f, t, NDer4_h, error);
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of SIXTH order                                 ********/
		/********************************************************************************************************************/
		template <int N>
		static VectorN<Real, N> NDer6(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> ymh = f(t - h);
			VectorN<Real, N> y1 = yh - ymh;
			VectorN<Real, N> y2 = f(t - 2 * h) - f(t + 2 * h);
			VectorN<Real, N> y3 = f(t + 3 * h) - f(t - 3 * h);

			if (error)
			{
				VectorN<Real, N> y7 = (f(t + 4 * h) - f(t - 4 * h) - 6 * y3 - 14 * y1 - 14 * y2) / 2;

				*error = y7.NormL2() / (140 * h) + 5 * (yh.NormL2() + ymh.NormL2()) * Constants::Eps / h;
			}
			return (y3 + 9 * y2 + 45 * y1) / (60 * h);
		}

		template <int N>
		static VectorN<Real, N> NDer6(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			return NDer6(f, t, NDer6_h, error);
		}	
		/********************************************************************************************************************/
		/********                               Numerical derivatives of EIGHTH order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static VectorN<Real, N> NDer8(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> ymh = f(t - h);
			VectorN<Real, N> y1 = yh - ymh;
			VectorN<Real, N> y2 = f(t - 2 * h) - f(t + 2 * h);
			VectorN<Real, N> y3 = f(t + 3 * h) - f(t - 3 * h);
			VectorN<Real, N> y4 = f(t - 4 * h) - f(t + 4 * h);

			VectorN<Real, N> tmp1 = 3 * y4 / 8 + 4 * y3;
			VectorN<Real, N> tmp2 = 21 * y2 + 84 * y1;

			if (error)
			{
				VectorN<Real, N> f9 = (f(t + 5 * h) - f(t - 5 * h)) / 2 + 4 * y4 + 27 * y3 / 2 + 24 * y2 + 21 * y1;

				*error = f9.NormL2() / (630 * h) + 7 * (yh.NormL2() + ymh.NormL2()) * Constants::Eps / h;
			}
			return (tmp1 + tmp2) / (105 * h);
		}

		template <int N>
		static VectorN<Real, N> NDer8(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			return NDer8(f, t, NDer8_h, error);
		}

		/********************************************************************************************************************/
		/********                                      SECOND DERIVATIVES                                            ********/
		/********  NOTE: Direct finite difference formulas (not derivatives of derivatives!)                        ********/
		/********        NSecDer2: 3 function evals (O(hÂ²) accuracy)                                                ********/
		/********        NSecDer4: 5 function evals (O(hâ´) accuracy)                                                ********/
		/********************************************************************************************************************/
		
		// f''(t) â‰ˆ [f(t-h) - 2f(t) + f(t+h)] / hÂ²
		// Second-order accurate (O(hÂ²)), 3 function evaluations
		template <int N>
		static VectorN<Real, N> NSecDer2(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> y0 = f(t);
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> ymh = f(t - h);
			
			Real h2 = h * h;
			VectorN<Real, N> result = (ymh - 2.0 * y0 + yh) / h2;
			
			if (error)
			{
				// Error estimate using 4th derivative approximation
				VectorN<Real, N> y2h = f(t + 2*h);
				VectorN<Real, N> ym2h = f(t - 2*h);
				Real f4_approx = (ym2h - 4.0*ymh + 6.0*y0 - 4.0*yh + y2h).NormL2() / h2;
				
				*error = f4_approx * h2 / 12.0 + 
				         Constants::Eps * (ymh.NormL2() + 2*y0.NormL2() + yh.NormL2()) / h2;
			}
			
			return result;
		}
		template <int N>
		static VectorN<Real, N> NSecDer2(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			return NSecDer2(f, t, NDer2_h, error);
		}

		// f''(t) â‰ˆ [-f(t-2h) + 16f(t-h) - 30f(t) + 16f(t+h) - f(t+2h)] / (12hÂ²)
		// Fourth-order accurate (O(hâ´)), 5 function evaluations
		template <int N>
		static VectorN<Real, N> NSecDer4(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> y0 = f(t);
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> ymh = f(t - h);
			VectorN<Real, N> y2h = f(t + 2*h);
			VectorN<Real, N> ym2h = f(t - 2*h);
			
			Real h2 = h * h;
			VectorN<Real, N> result = (-ym2h + 16.0*ymh - 30.0*y0 + 16.0*yh - y2h) / (12.0 * h2);
			
			if (error)
			{
				// Error estimate using 6th derivative approximation
				VectorN<Real, N> y3h = f(t + 3*h);
				VectorN<Real, N> ym3h = f(t - 3*h);
				Real f6_approx = (ym3h - 6.0*ym2h + 15.0*ymh - 20.0*y0 + 15.0*yh - 6.0*y2h + y3h).NormL2() / h2;
				
				*error = f6_approx * h2 * h2 / 90.0 + 
				         Constants::Eps * (ym2h.NormL2() + 16*ymh.NormL2() + 30*y0.NormL2() + 
				                           16*yh.NormL2() + y2h.NormL2()) / (12.0 * h2);
			}
			
			return result;
		}
		template <int N>
		static VectorN<Real, N> NSecDer4(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			return NSecDer4(f, t, NDer4_h, error);
		}

		/********************************************************************************************************************/
		/********                                       THIRD DERIVATIVES                                            ********/
		/********  NOTE: Direct finite difference formulas (not derivatives of derivatives!)                        ********/
		/********        NThirdDer2: 4 function evals (O(hÂ²) accuracy)                                              ********/
		/********        NThirdDer4: 6 function evals (O(hâ´) accuracy)                                              ********/
		/********************************************************************************************************************/
		
		// f'''(t) â‰ˆ [-f(t-2h) + 2f(t-h) - 2f(t+h) + f(t+2h)] / (2hÂ³)
		// Second-order accurate (O(hÂ²)), 4 function evaluations
		template <int N>
		static VectorN<Real, N> NThirdDer2(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> ymh = f(t - h);
			VectorN<Real, N> y2h = f(t + 2*h);
			VectorN<Real, N> ym2h = f(t - 2*h);
			
			Real h3 = h * h * h;
			VectorN<Real, N> result = (-ym2h + 2.0*ymh - 2.0*yh + y2h) / (2.0 * h3);
			
			if (error)
			{
				// Error estimate using 5th derivative approximation
				VectorN<Real, N> y3h = f(t + 3*h);
				VectorN<Real, N> ym3h = f(t - 3*h);
				Real f5_approx = (ym3h - 3.0*ym2h + 5.0*ymh - 5.0*yh + 3.0*y2h - y3h).NormL2() / h3;
				
				*error = f5_approx * h * h / 4.0 + 
				         Constants::Eps * (ym2h.NormL2() + 2*ymh.NormL2() + 2*yh.NormL2() + y2h.NormL2()) / (2.0 * h3);
			}
			
			return result;
		}
		template <int N>
		static VectorN<Real, N> NThirdDer2(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			// Use larger step size for third derivatives (hÂ³ in denominator needs bigger h)
			return NThirdDer2(f, t, NDer4_h, error);
		}

		// f'''(t) â‰ˆ [f(t-3h) - 8f(t-2h) + 13f(t-h) - 13f(t+h) + 8f(t+2h) - f(t+3h)] / (8hÂ³)
		// Fourth-order accurate (O(hâ´)), 6 function evaluations
		template <int N>
		static VectorN<Real, N> NThirdDer4(const IParametricCurve<N>& f, Real t, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(t + h);
			VectorN<Real, N> ymh = f(t - h);
			VectorN<Real, N> y2h = f(t + 2*h);
			VectorN<Real, N> ym2h = f(t - 2*h);
			VectorN<Real, N> y3h = f(t + 3*h);
			VectorN<Real, N> ym3h = f(t - 3*h);
			
			Real h3 = h * h * h;
			VectorN<Real, N> result = (ym3h - 8.0*ym2h + 13.0*ymh - 13.0*yh + 8.0*y2h - y3h) / (8.0 * h3);
			
			if (error)
			{
				// Error estimate using 7th derivative approximation
				VectorN<Real, N> y4h = f(t + 4*h);
				VectorN<Real, N> ym4h = f(t - 4*h);
				Real f7_approx = (ym4h - 4.0*ym3h + 9.0*ym2h - 13.0*ymh + 13.0*yh - 9.0*y2h + 4.0*y3h - y4h).NormL2() / h3;
				
				*error = f7_approx * h * h * h * h / 120.0 + 
				         Constants::Eps * (ym3h.NormL2() + 8*ym2h.NormL2() + 13*ymh.NormL2() + 
				                           13*yh.NormL2() + 8*y2h.NormL2() + y3h.NormL2()) / (8.0 * h3);
			}
			
			return result;
		}
		template <int N>
		static VectorN<Real, N> NThirdDer4(const IParametricCurve<N>& f, Real t, Real* error = nullptr)
		{
			return NThirdDer4(f, t, NDer4_h, error);
		}
		
		/********************************************************************************************************************/
		/********                            Definitions of default derivation functions                             ********/
		/********************************************************************************************************************/
		template<int N>
		static inline VectorN<Real, N>(*DeriveCurve)(const IParametricCurve<N>& f, 
																								 Real x, Real* error) = Derivation::NDer4;
		template<int N>
		static inline VectorN<Real, N>(*DeriveCurveSec)(const IParametricCurve<N>& f, 
																										Real x, Real* error) = Derivation::NSecDer4;
		template<int N>
		static inline VectorN<Real, N>(*DeriveCurveThird)(const IParametricCurve<N>& f, 
																											Real x, Real* error) = Derivation::NThirdDer4;

	}
}


///////////////////////////   mml/core/Derivation/DerivationParametricSurface.h   ///////////////////////////




namespace MML
{
	namespace Derivation
	{
		///////////////////////             FIRST DERIVATIONS              //////////////////////////
		
		/********************************************************************************************************************/
		/********                               Numerical derivatives of FIRST order                                 ********/
		/********************************************************************************************************************/
		template <int N>
		static VectorN<Real, N> NDer1_u(const IParametricSurfaceRect<N>& f, Real u, Real w, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(u + h, w);
			VectorN<Real, N> y0 = f(u, w);
			VectorN<Real, N> diff = yh - y0;

			if (error)
			{
				VectorN<Real, N> ym = f(u - h, w);
				VectorN<Real, N> ypph_vec = yh - 2 * y0 + ym;

				Real ypph = ypph_vec.NormL2() / h;

				*error = ypph / 2 + (yh.NormL2() + y0.NormL2()) * Constants::Eps / h;
			}
			return diff / h;
		}
		template <int N>
		static VectorN<Real, N> NDer1_u(const IParametricSurfaceRect<N>& f, Real u, Real w, Real* error = nullptr)
		{
			return NDer1_u(f, u, w, NDer1_h, error);
		}
		template <int N>
		static VectorN<Real, N> NDer1_w(const IParametricSurfaceRect<N>& f, Real u, Real w, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(u, w + h);
			VectorN<Real, N> y0 = f(u, w);
			VectorN<Real, N> diff = yh - y0;

			if (error)
			{
				VectorN<Real, N> ym = f(u, w - h);
				VectorN<Real, N> ypph_vec = yh - 2 * y0 + ym;

				Real ypph = ypph_vec.NormL2() / h;

				*error = ypph / 2 + (yh.NormL2() + y0.NormL2()) * Constants::Eps / h;
			}
			return diff / h;
		}
		template <int N>
		static VectorN<Real, N> NDer1_w(const IParametricSurfaceRect<N>& f, Real u, Real w, Real* error = nullptr)
		{
			return NDer1_w(f, u, w, NDer1_h, error);
		}
	
		/********************************************************************************************************************/
		/********                               Numerical derivatives of SECOND order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static VectorN<Real, N> NDer2_u(const IParametricSurfaceRect<N>& f, Real u, Real w, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(u + h, w);
			VectorN<Real, N> ymh = f(u - h, w);
			VectorN<Real, N> diff = yh - ymh;

			if (error)
			{
				VectorN<Real, N> yth = f(u + 2 * h, w);
				VectorN<Real, N> ymth = f(u - 2 * h, w);

				*error = Constants::Eps * ((yh + ymh) / (2 * h)).NormL2() + std::abs(((yth - ymth) / 2 - diff).NormL2()) / (6 * h);
			}
			return diff / (2 * h);
		}
		template <int N>
		static VectorN<Real, N> NDer2_u(const IParametricSurfaceRect<N>& f, Real u, Real w, Real* error = nullptr)
		{
			return NDer2_u(f, u, w, NDer2_h, error);
		}
		template <int N>
		static VectorN<Real, N> NDer2_w(const IParametricSurfaceRect<N>& f, Real u, Real w, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(u, w + h);
			VectorN<Real, N> ymh = f(u, w - h);
			VectorN<Real, N> diff = yh - ymh;
			if (error)
			{
				VectorN<Real, N> yth = f(u, w + 2 * h);
				VectorN<Real, N> ymth = f(u, w - 2 * h);
				*error = Constants::Eps * ((yh + ymh) / (2 * h)).NormL2() + std::abs(((yth - ymth) / 2 - diff).NormL2()) / (6 * h);
			}
			return diff / (2 * h);
		}
		template <int N>
		static VectorN<Real, N> NDer2_w(const IParametricSurfaceRect<N>& f, Real u, Real w, Real* error = nullptr)
		{
			return NDer2_w(f, u, w, NDer2_h, error);
		}

		/********************************************************************************************************************/
		/********                                      SECOND DERIVATIVES                                            ********/
		/********************************************************************************************************************/
		template <int N>
		static VectorN<Real, N> NDer2_uu(const IParametricSurfaceRect<N>& f, Real u, Real w, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(u + h, w);
			VectorN<Real, N> ym = f(u - h, w);
			VectorN<Real, N> y0 = f(u, w);
			VectorN<Real, N> diff = yh - 2 * y0 + ym;
			if (error)
			{
				Real ypph = diff.NormL2() / (h * h);
				*error = ypph / 2 + (yh.NormL2() + ym.NormL2() + y0.NormL2()) * Constants::Eps / (h * h);
			}
			return diff / (h * h);
		}
		template <int N>
		static VectorN<Real, N> NDer2_uu(const IParametricSurfaceRect<N>& f, Real u, Real w, Real* error = nullptr)
		{
			return NDer2_uu(f, u, w, NDer2_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer2_uw(const IParametricSurfaceRect<N>& f, Real u, Real w, Real h, Real* error = nullptr)
		{
			// Correct formula for mixed partial derivative: âˆ‚Â²f/âˆ‚uâˆ‚w
			// Use central difference: [f(u+h,w+h) - f(u+h,w-h) - f(u-h,w+h) + f(u-h,w-h)] / (4hÂ²)
			VectorN<Real, N> fpp = f(u + h, w + h);  // f(u+h, w+h)
			VectorN<Real, N> fpm = f(u + h, w - h);  // f(u+h, w-h)
			VectorN<Real, N> fmp = f(u - h, w + h);  // f(u-h, w+h)
			VectorN<Real, N> fmm = f(u - h, w - h);  // f(u-h, w-h)
			
			VectorN<Real, N> diff = fpp - fpm - fmp + fmm;
			
			if (error)
			{
				// Error estimate for mixed partial
				Real norm_sum = fpp.NormL2() + fpm.NormL2() + fmp.NormL2() + fmm.NormL2();
				*error = norm_sum * Constants::Eps / (4 * h * h);
			}
			return diff / (4 * h * h);
		}
		template <int N>
		static VectorN<Real, N> NDer2_uw(const IParametricSurfaceRect<N>& f, Real u, Real w, Real* error = nullptr)
		{
			return NDer2_uw(f, u, w, NDer2_h, error);
		}

		template <int N>
		static VectorN<Real, N> NDer2_ww(const IParametricSurfaceRect<N>& f, Real u, Real w, Real h, Real* error = nullptr)
		{
			VectorN<Real, N> yh = f(u, w + h);
			VectorN<Real, N> ym = f(u, w - h);
			VectorN<Real, N> y0 = f(u, w);
			VectorN<Real, N> diff = yh - 2 * y0 + ym;
			if (error)
			{
				Real ypph = diff.NormL2() / (h * h);
				*error = ypph / 2 + (yh.NormL2() + ym.NormL2() + y0.NormL2()) * Constants::Eps / (h * h);
			}
			return diff / (h * h);
		}
		template <int N>
		static VectorN<Real, N> NDer2_ww(const IParametricSurfaceRect<N>& f, Real u, Real w, Real* error = nullptr)
		{
			return NDer2_ww(f, u, w, NDer2_h, error);
		}
	}
}


///////////////////////////   mml/core/Derivation/DerivationTensorField.h   ///////////////////////////





namespace MML
{
	namespace Derivation
	{
		/********************************************************************************************************************/
		/********                               Numerical derivatives of FIRST order                                 ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer1Partial(const ITensorField2<N>& f, int i, int j, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			auto x = point;

			Real x_orig = x[deriv_index];
			Real y0 = f.Component(i, j, x);

			x[deriv_index] = x_orig + h;
			Real yh = f.Component(i, j, x);

			Real diff = yh - y0;
			if (error)
			{
				x[deriv_index] = x_orig - h;
				Real ym = f.Component(i, j, x);
				Real ypph = std::abs(yh - 2 * y0 + ym) / h;
				*error = ypph / 2 + (std::abs(yh) + std::abs(y0)) * Constants::Eps / h;
			}
			return diff / h;
		}

		template <int N>
		static Real NDer1Partial(const ITensorField2<N>& f, int i, int j, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer1Partial(f, i, j, deriv_index, point, NDer1_h, error);
		}

		template <int N>
		static Real NDer1Partial(const ITensorField3<N>& f, int i, int j, int k, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer1Partial(f, i, j, k, deriv_index, point, NDer1_h, error);
		}

		template <int N>
		static Real NDer1Partial(const ITensorField3<N>& f, int i, int j, int k, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			auto x = point;

			Real x_orig = x[deriv_index];
			Real y0 = f.Component(i, j, k, x);

			x[deriv_index] = x_orig + h;
			Real yh = f.Component(i, j, k, x);

			Real diff = yh - y0;
			if (error)
			{
				x[deriv_index] = x_orig - h;
				Real ym = f.Component(i, j, k, x);
				Real ypph = std::abs(yh - 2 * y0 + ym) / h;
				*error = ypph / 2 + (std::abs(yh) + std::abs(y0)) * Constants::Eps / h;
			}
			return diff / h;
		}

		template <int N>
		static Real NDer1Partial(const ITensorField4<N>& f, int i, int j, int k, int l, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer1Partial(f, i, j, k, l, deriv_index, point, NDer1_h, error);
		}

		template <int N>
		static Real NDer1Partial(const ITensorField4<N>& f, int i, int j, int k, int l, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			auto x = point;

			Real x_orig = x[deriv_index];
			Real y0 = f.Component(i, j, k, l, x);

			x[deriv_index] = x_orig + h;
			Real yh = f.Component(i, j, k, l, x);

			Real diff = yh - y0;
			if (error)
			{
				x[deriv_index] = x_orig - h;
				Real ym = f.Component(i, j, k, l, x);
				Real ypph = std::abs(yh - 2 * y0 + ym) / h;
				*error = ypph / 2 + (std::abs(yh) + std::abs(y0)) * Constants::Eps / h;
			}
			return diff / h;
		}

		/********************************************************************************************************************/
		/********                               Numerical derivatives of SECOND order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer2Partial(const ITensorField2<N>& f, int i, int j, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f.Component(i, j, x);

			x[deriv_index] = orig_x - h;
			Real ymh = f.Component(i, j, x);

			Real diff = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 2 * h;
				Real y2h = f.Component(i, j, x);

				x[deriv_index] = orig_x - 2 * h;
				Real ym2h = f.Component(i, j, x);

				*error = Constants::Eps * (std::abs(yh) + std::abs(ymh)) / (2 * h) + std::abs((y2h - ym2h) / 2 - diff) / (6 * h);
			}

			return diff / (2 * h);
		}

		template <int N>
		static Real NDer2Partial(const ITensorField2<N>& f, int i, int j, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer2Partial(f, i, j, deriv_index, point, NDer2_h, error);
		}

		template <int N>
		static Real NDer2Partial(const ITensorField3<N>& f, int i, int j, int k, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer2Partial(f, i, j, k, deriv_index, point, NDer2_h, error);
		}

		template <int N>
		static Real NDer2Partial(const ITensorField3<N>& f, int i, int j, int k, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f.Component(i, j, k, x);

			x[deriv_index] = orig_x - h;
			Real ymh = f.Component(i, j, k, x);

			Real diff = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 2 * h;
				Real y2h = f.Component(i, j, k, x);

				x[deriv_index] = orig_x - 2 * h;
				Real ym2h = f.Component(i, j, k, x);

				*error = Constants::Eps * (std::abs(yh) + std::abs(ymh)) / (2 * h) + std::abs((y2h - ym2h) / 2 - diff) / (6 * h);
			}

			return diff / (2 * h);
		}

		template <int N>
		static Real NDer2Partial(const ITensorField4<N>& f, int i, int j, int k, int l, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer2Partial(f, i, j, k, l, deriv_index, point, NDer2_h, error);
		}

		template <int N>
		static Real NDer2Partial(const ITensorField4<N>& f, int i, int j, int k, int l, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f.Component(i, j, k, l, x);

			x[deriv_index] = orig_x - h;
			Real ymh = f.Component(i, j, k, l, x);

			Real diff = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 2 * h;
				Real y2h = f.Component(i, j, k, l, x);

				x[deriv_index] = orig_x - 2 * h;
				Real ym2h = f.Component(i, j, k, l, x);

				*error = Constants::Eps * (std::abs(yh) + std::abs(ymh)) / (2 * h) + std::abs((y2h - ym2h) / 2 - diff) / (6 * h);
			}

			return diff / (2 * h);
		}
		
		/********************************************************************************************************************/
		/********                               Numerical derivatives of FOURTH order                                ********/
		/********************************************************************************************************************/
		template <int N>
		static Real NDer4Partial(const ITensorField2<N>& f, int i, int j, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f.Component(i, j, x);

			x[deriv_index] = orig_x - h;
			Real ymh = f.Component(i, j, x);

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f.Component(i, j, x);

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f.Component(i, j, x);

			Real y2 = ym2h - y2h;
			Real y1 = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 3 * h;
				Real y3h = f.Component(i, j, x);

				x[deriv_index] = orig_x - 3 * h;
				Real ym3h = f.Component(i, j, x);

				*error = std::abs((y3h - ym3h) / 2 + 2 * (ym2h - y2h) + 5 * (yh - ymh) / 2) / (30 * h);
				*error += Constants::Eps * (std::abs(y2h) + std::abs(ym2h) + 8 * (std::abs(ymh) + std::abs(yh))) / (12 * h);
			}
			return (y2 + 8 * y1) / (12 * h);
		}

		template <int N>
		static Real NDer4Partial(const ITensorField2<N>& f, int i, int j, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer4Partial(f, i, j, deriv_index, point, NDer4_h, error);
		}

		template <int N>
		static Real NDer4Partial(const ITensorField3<N>& f, int i, int j, int k, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer4Partial(f, i, j, k, deriv_index, point, NDer4_h, error);
		}

		template <int N>
		static Real NDer4Partial(const ITensorField3<N>& f, int i, int j, int k, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f.Component(i, j, k, x);

			x[deriv_index] = orig_x - h;
			Real ymh = f.Component(i, j, k, x);

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f.Component(i, j, k, x);

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f.Component(i, j, k, x);

			Real y2 = ym2h - y2h;
			Real y1 = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 3 * h;
				Real y3h = f.Component(i, j, k, x);

				x[deriv_index] = orig_x - 3 * h;
				Real ym3h = f.Component(i, j, k, x);

				*error = std::abs((y3h - ym3h) / 2 + 2 * (ym2h - y2h) + 5 * (yh - ymh) / 2) / (30 * h);
				*error += Constants::Eps * (std::abs(y2h) + std::abs(ym2h) + 8 * (std::abs(ymh) + std::abs(yh))) / (12 * h);
			}
			return (y2 + 8 * y1) / (12 * h);
		}


		template <int N>
		static Real NDer4Partial(const ITensorField4<N>& f, int i, int j, int k, int l, int deriv_index, const VectorN<Real, N>& point, Real* error = nullptr)
		{
			return NDer4Partial(f, i, j, k, l, deriv_index, point, NDer4_h, error);
		}

		template <int N>
		static Real NDer4Partial(const ITensorField4<N>& f, int i, int j, int k, int l, int deriv_index, const VectorN<Real, N>& point, Real h, Real* error = nullptr)
		{
			Real     orig_x = point[deriv_index];

			VectorN<Real, N> x{ point };
			x[deriv_index] = orig_x + h;
			Real yh = f.Component(i, j, k, l, x);

			x[deriv_index] = orig_x - h;
			Real ymh = f.Component(i, j, k, l, x);

			x[deriv_index] = orig_x + 2 * h;
			Real y2h = f.Component(i, j, k, l, x);

			x[deriv_index] = orig_x - 2 * h;
			Real ym2h = f.Component(i, j, k, l, x);

			Real y2 = ym2h - y2h;
			Real y1 = yh - ymh;

			if (error)
			{
				x[deriv_index] = orig_x + 3 * h;
				Real y3h = f.Component(i, j, k, l, x);

				x[deriv_index] = orig_x - 3 * h;
				Real ym3h = f.Component(i, j, k, l, x);

				*error = std::abs((y3h - ym3h) / 2 + 2 * (ym2h - y2h) + 5 * (yh - ymh) / 2) / (30 * h);
				*error += Constants::Eps * (std::abs(y2h) + std::abs(ym2h) + 8 * (std::abs(ymh) + std::abs(yh))) / (12 * h);
			}
			return (y2 + 8 * y1) / (12 * h);
		}
	}
}


///////////////////////////   mml/core/Derivation/Jacobians.h   ///////////////////////////





namespace MML
{
	namespace Derivation
	{
		/********************************************************************************************************************/
		/********                                      CALCULATING JACOBIANS                                         ********/
		/********************************************************************************************************************/
  	template<int N>
		static MatrixNM<Real, N, N> calcJacobian(const IVectorFunction<N>& func, const VectorN<Real, N>& pos)
		{
			MatrixNM<Real, N, N> jac;

			for (int i = 0; i < N; ++i)
				for (int j = 0; j < N; ++j)
				{
					jac(i, j) = NDer4Partial(func, i, j, pos);
				}

			return jac;
		}

    template<int N, int M>
		static MatrixNM<Real, M, N> calcJacobian(const IVectorFunctionNM<N, M>& func, const VectorN<Real, N>& pos)
		{
			MatrixNM<Real, M, N> jac;

			for (int i = 0; i < M; ++i)
				for (int j = 0; j < N; ++j)
				{
					jac(i, j) = Derivation::NDer4Partial(func, i, j, pos);
				}

			return jac;
		}    
  };
}


///////////////////////////   mml/core/Integration.h   ///////////////////////////




///////////////////////////   mml/core/Integration/Integration1D.h   ///////////////////////////





namespace MML
{

	enum IntegrationMethod { TRAP, SIMPSON, ROMBERG, GAUSS10 };

	class IQuadrature {
	protected:
		int _currStep = 0;

	public:
		// Returns the nth stage of refinement of the extended trapezoidal rule.
		virtual Real next() = 0;
	};

	class TrapIntegrator : IQuadrature
	{
	public:
		Real _a, _b, _currSum;
		const IRealFunction& _func;

		TrapIntegrator(const IRealFunction& func, Real a, Real b) 
			:	_func(func), _a(a), _b(b), _currSum(0.0)	{	}

		Real next() {
			Real x, sum, del;
			int subDivNum, j;

			_currStep++;
			if (_currStep == 1) {
				return (_currSum = 0.5 * (_b - _a) * (_func(_a) + _func(_b)));
			}
			else {
				for (subDivNum = 1, j = 1; j < _currStep - 1; j++)
					subDivNum *= 2;

				del = (_b - _a) / subDivNum;
				x = _a + 0.5 * del;

				for (sum = 0.0, j = 0; j < subDivNum; j++, x += del)
					sum += _func(x);

				_currSum = 0.5 * (_currSum + (_b - _a) * sum / subDivNum);

				return _currSum;
			}
		}
	};

	// Using extended trapezoidal rule, returns the integral of the function func from a to b.
	// Returns IntegrationResult with convergence status and diagnostics.
	// Parameter eps sets the desired fractional accuracy.
	static IntegrationResult IntegrateTrap(const IRealFunction& func, Real a, Real b,
																		 const Real eps = Defaults::TrapezoidIntegrationEPS)	{
		int		j;
		Real	currSum, oldSum = 0.0;

		TrapIntegrator t(func, a, b);

		for (j = 0; j < Defaults::TrapezoidIntegrationMaxSteps; j++)
		{
			currSum = t.next();

			if (j > 5) {
				Real error = std::abs(currSum - oldSum);
				if ( error < eps * std::abs(oldSum) || (currSum == 0.0 && oldSum == 0.0) )
				{
					return IntegrationResult(currSum, error, j, true);
				}
			}

			oldSum = currSum;
		}
		// Did not converge within max iterations
		Real final_error = std::abs(currSum - oldSum);
		return IntegrationResult(currSum, final_error, j, false);
	}
	
	// Legacy interface with output parameters (deprecated)
	static Real IntegrateTrap(const IRealFunction& func, Real a, Real b,
												int* doneSteps, Real* achievedPrec,
												const Real eps = Defaults::TrapezoidIntegrationEPS)	{
		auto result = IntegrateTrap(func, a, b, eps);
		if (doneSteps != nullptr)			*doneSteps = result.iterations;
		if (achievedPrec != nullptr)  *achievedPrec = result.error_estimate;
		return result.value;
	}

	// Using Simpson's rule, returns the integral of the function func from a to b.
	// Returns IntegrationResult with convergence status and diagnostics.
	// Parameter eps sets the desired fractional accuracy.
	static IntegrationResult IntegrateSimpson(const IRealFunction& func, Real a, Real b,
																			 const Real eps = Defaults::SimpsonIntegrationEPS)
	{
		int j;
		Real currSum, st, ost = 0.0, oldSum = 0.0;

		TrapIntegrator t(func, a, b);

		for (j = 0; j < Defaults::SimpsonIntegrationMaxSteps; j++)
		{
			st = t.next();

			currSum = (4.0 * st - ost) / 3.0;

			if (j > 5) {
				Real error = std::abs(currSum - oldSum);
				if (error < eps * std::abs(oldSum) || (currSum == 0.0 && oldSum == 0.0))
				{
					return IntegrationResult(currSum, error, j, true);
				}
			}

			oldSum = currSum;
			ost = st;
		}
		// Did not converge within max iterations
		Real final_error = std::abs(currSum - oldSum);
		return IntegrationResult(currSum, final_error, j, false);
	}
	
	// Legacy interface with output parameters (deprecated)
	static Real IntegrateSimpson(const IRealFunction& func, Real a, Real b, 
													 int* doneSteps, Real* achievedPrec,
													 const Real eps = Defaults::SimpsonIntegrationEPS)
	{
		auto result = IntegrateSimpson(func, a, b, eps);
		if (doneSteps != nullptr)			*doneSteps = result.iterations;
		if (achievedPrec != nullptr)	*achievedPrec = result.error_estimate;
		return result.value;
	}

	/**
	 * @brief IntegrateRomberg - Romberg integration using Richardson extrapolation.
	 *
	 * Romberg integration is an adaptive method that achieves very high accuracy by
	 * combining the trapezoidal rule with Richardson extrapolation. It builds a tableau
	 * of estimates and extrapolates to the limit hâ†’0, eliminating error terms successively.
	 *
	 * ALGORITHM:
	 * 1. Compute successive trapezoidal approximations T(h), T(h/2), T(h/4), ...
	 * 2. Apply Richardson extrapolation (polynomial interpolation) to extrapolate to h=0
	 * 3. The extrapolation uses Neville's algorithm on the sequence hÂ², (h/2)Â², (h/4)Â², ...
	 * 4. Convergence is detected when the extrapolated value stabilizes
	 *
	 * CONVERGENCE:
	 * For analytic functions, convergence is exponentially fast: O(h^(2K)) where K is
	 * the number of extrapolation steps (default K=5). This makes Romberg one of the
	 * fastest methods for smooth, analytic integrands.
	 *
	 * ADVANTAGES:
	 * - Very fast convergence for smooth functions (faster than Simpson)
	 * - Achieves high accuracy with relatively few function evaluations
	 * - Built-in error estimation from extrapolation
	 *
	 * DISADVANTAGES:
	 * - Requires smooth (analytic) integrand for optimal performance
	 * - Poor performance on functions with discontinuous derivatives
	 * - More complex than simple quadrature rules
	 *
	 * USE CASES:
	 * - High-precision integration of smooth functions
	 * - Scientific computing where accuracy is paramount
	 * - When function evaluations are expensive but function is analytic
	 *
	 * COMPLEXITY: O(2^n) function evaluations for n refinement steps
	 *
	 * @param func The function to integrate
	 * @param a Lower bound of integration
	 * @param b Upper bound of integration
	 * @param eps Desired relative accuracy (default: Defaults::RombergIntegrationEPS)
	 * @return IntegrationResult with value, error estimate, iterations, convergence status
	 *
	 * @note Reference: Numerical Recipes Â§4.3 "Romberg Integration"
	 */
	static IntegrationResult IntegrateRomberg(const IRealFunction& func, Real a, Real b,
																						const Real eps = Defaults::RombergIntegrationEPS)
	{
		const int JMAX = Defaults::RombergIntegrationMaxSteps;
		const int K = Defaults::RombergIntegrationUsedPnts;  // Number of points for polynomial extrapolation
		
		std::vector<Real> s(JMAX);      // Successive trapezoidal approximations
		std::vector<Real> h(JMAX + 1);  // Step sizes squared: h[j] = (initial_h / 2^j)^2
		
		h[0] = 1.0;
		TrapIntegrator trap(func, a, b);
		
		Real ss = 0.0;  // Extrapolated result
		Real dss = 0.0; // Error estimate from extrapolation
		
		for (int j = 0; j < JMAX; j++)
		{
			s[j] = trap.next();
			
			if (j >= K - 1)
			{
				// Perform polynomial extrapolation using Neville's algorithm
				// Extrapolate to h=0 using the last K points
				std::vector<Real> c(K), d(K);
				
				int ns = 0;
				Real dif = std::abs(h[j - K + 1]);
				
				// Initialize c and d arrays with the last K values of s
				for (int i = 0; i < K; i++)
				{
					Real dift = std::abs(h[j - K + 1 + i]);
					if (dift < dif)
					{
						ns = i;
						dif = dift;
					}
					c[i] = s[j - K + 1 + i];
					d[i] = s[j - K + 1 + i];
				}
				
				// Initial best guess
				ss = s[j - K + 1 + ns];
				ns--;
				
				// Neville's algorithm: build up the extrapolation tableau
				for (int m = 1; m < K; m++)
				{
					for (int i = 0; i < K - m; i++)
					{
						Real ho = h[j - K + 1 + i];
						Real hp = h[j - K + 1 + i + m];
						Real w = c[i + 1] - d[i];
						Real den = ho - hp;
						
						if (den == 0.0)
						{
							// This should not happen with proper h values
							return IntegrationResult(ss, std::abs(dss), j + 1, false);
						}
						
						den = w / den;
						d[i] = hp * den;
						c[i] = ho * den;
					}
					
					// Decide which correction to add (from c or d)
					if (2 * (ns + 1) < (K - m))
						dss = c[ns + 1];
					else
						dss = d[ns--];
					
					ss += dss;
				}
				
				// Check for convergence
				if (std::abs(dss) <= eps * std::abs(ss) || (ss == 0.0 && dss == 0.0))
				{
					return IntegrationResult(ss, std::abs(dss), j + 1, true);
				}
			}
			
			// Prepare for next iteration: h_new = h_old / 4 (because we're extrapolating in hÂ²)
			h[j + 1] = 0.25 * h[j];
		}
		
		// Did not converge within max iterations
		return IntegrationResult(ss, std::abs(dss), JMAX, false);
	}
	
	// Legacy interface with output parameters (deprecated)
	static Real IntegrateRomberg(const IRealFunction& func, Real a, Real b, 
													 int* doneSteps, Real* achievedPrec,
													 const Real eps = Defaults::RombergIntegrationEPS)
	{
		auto result = IntegrateRomberg(func, a, b, eps);
		if (doneSteps != nullptr)			*doneSteps = result.iterations;
		if (achievedPrec != nullptr)	*achievedPrec = result.error_estimate;
		return result.value;
	}

	/**
	 * @brief IntegrateGauss10 - Ten-point Gauss-Legendre quadrature.
	 *
	 * Gauss-Legendre quadrature achieves the highest algebraic accuracy possible
	 * for a given number of function evaluations. With 10 points, it exactly
	 * integrates polynomials up to degree 19 (2n-1 rule).
	 *
	 * ALGORITHM:
	 * Uses pre-computed abscissas (zeros of Legendre polynomial P_10) and weights
	 * to evaluate: âˆ«f(x)dx â‰ˆ Î£ w_i * f(x_i)
	 *
	 * The nodes and weights are transformed from [-1,1] to [a,b] via linear mapping.
	 *
	 * CHARACTERISTICS:
	 * - Fixed-order method: exactly 10 function evaluations per call
	 * - No adaptive refinement or error estimation
	 * - Extremely fast for smooth functions
	 * - Exact for polynomials of degree â‰¤ 19
	 *
	 * ADVANTAGES:
	 * - Very fast (only 10 function evaluations)
	 * - High accuracy for smooth functions
	 * - No iteration overhead
	 * - Deterministic behavior
	 *
	 * DISADVANTAGES:
	 * - No built-in error estimation (returned error_estimate is 0)
	 * - Cannot adapt to function complexity
	 * - May be inaccurate for highly oscillatory or singular functions
	 * - Fixed precision - cannot be improved without using more points
	 *
	 * USE CASES:
	 * - Quick integration of smooth functions
	 * - Inner loops where speed is critical
	 * - Polynomial or near-polynomial integrands
	 * - When approximate error bounds are known a priori
	 *
	 * @param func The function to integrate
	 * @param a Lower bound of integration
	 * @param b Upper bound of integration
	 * @return IntegrationResult with value, 0 error estimate (not available), 1 iteration, converged=true
	 *
	 * @note Error estimate is 0 because this is a non-adaptive method.
	 *       Use adaptive methods (Romberg, Simpson) when error bounds are needed.
	 * @note Reference: Abramowitz & Stegun, Table 25.4 for nodes and weights
	 */
	static IntegrationResult IntegrateGauss10(const IRealFunction& func, const Real a, const Real b)
	{
		// Pre-computed Gauss-Legendre nodes (positive only, symmetric about 0)
		static const Real x[] = { 0.1488743389816312, 0.4333953941292472,
		                          0.6794095682990244, 0.8650633666889845, 0.9739065285171717 };
		// Pre-computed Gauss-Legendre weights (for the corresponding nodes)
		static const Real w[] = { 0.2955242247147529, 0.2692667193099963,
		                          0.2190863625159821, 0.1494513491505806, 0.0666713443086881 };
		
		// Transform from [-1,1] to [a,b]: x_mapped = xm + xr * x_i
		Real xm = 0.5 * (b + a);  // Midpoint
		Real xr = 0.5 * (b - a);  // Half-width (scale factor)
		
		Real s = 0;
		for (int j = 0; j < 5; j++) 
		{
			Real dx = xr * x[j];
			s += w[j] * (func(xm + dx) + func(xm - dx));
		}
		Real result = s * xr;
		
		// Return IntegrationResult for API consistency
		// Note: Gauss quadrature has no built-in error estimate (non-adaptive)
		// iterations=1 indicates single-pass evaluation (10 function calls)
		return IntegrationResult(result, 0.0, 1, true);
	}
	
	// Legacy interface for backward compatibility (returns raw Real)
	static Real IntegrateGauss10Raw(const IRealFunction& func, const Real a, const Real b)
	{
		return IntegrateGauss10(func, a, b).value;
	}

	/**
	 * @brief Unified integration function with explicit method selection.
	 *
	 * This is the recommended way to perform 1D integration - explicitly specify
	 * the integration method rather than relying on global state.
	 *
	 * @param func The function to integrate
	 * @param a Lower bound of integration
	 * @param b Upper bound of integration
	 * @param method Integration method to use (default: TRAP)
	 * @param eps Desired relative accuracy (not used for GAUSS10)
	 * @return IntegrationResult with value, error estimate, iterations, convergence status
	 *
	 * Example:
	 * @code
	 *   auto result = Integrate(f, 0.0, 1.0, SIMPSON, 1e-8);
	 *   if (!result.converged) { ... }
	 * @endcode
	 */
	static IntegrationResult Integrate(const IRealFunction& func, Real a, Real b,
	                                   IntegrationMethod method = TRAP,
	                                   Real eps = Defaults::TrapezoidIntegrationEPS)
	{
		switch (method)
		{
		case TRAP:
			return IntegrateTrap(func, a, b, eps);
		case SIMPSON:
			return IntegrateSimpson(func, a, b, eps);
		case ROMBERG:
			return IntegrateRomberg(func, a, b, eps);
		case GAUSS10:
			return IntegrateGauss10(func, a, b);
		default:
			return IntegrateTrap(func, a, b, eps);
		}
	}

	/**
	 * @brief Template-based integration with compile-time method selection.
	 *
	 * Zero-overhead method selection using compile-time dispatch.
	 * Use this when the method is known at compile time for best performance.
	 *
	 * @tparam Method Integration method (compile-time constant)
	 * @param func The function to integrate
	 * @param a Lower bound of integration
	 * @param b Upper bound of integration
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, iterations, convergence status
	 *
	 * Example:
	 * @code
	 *   auto result = Integrate<SIMPSON>(f, 0.0, 1.0, 1e-10);
	 * @endcode
	 */
	template<IntegrationMethod Method = TRAP>
	static IntegrationResult Integrate(const IRealFunction& func, Real a, Real b,
	                                   Real eps = Defaults::TrapezoidIntegrationEPS)
	{
		if constexpr (Method == TRAP)
			return IntegrateTrap(func, a, b, eps);
		else if constexpr (Method == SIMPSON)
			return IntegrateSimpson(func, a, b, eps);
		else if constexpr (Method == ROMBERG)
			return IntegrateRomberg(func, a, b, eps);
		else if constexpr (Method == GAUSS10)
			return IntegrateGauss10(func, a, b);
		else
			return IntegrateTrap(func, a, b, eps);
	}

	// ============================================================================
	// DEPRECATED: Global function pointer
	// ============================================================================
	// This global mutable function pointer is DEPRECATED and will be removed.
	// 
	// Problems with this approach:
	// 1. Process-global mutable state - thread-unsafe
	// 2. Hidden coupling across translation units
	// 3. Hard-to-debug behavior changes
	// 
	// Migration path:
	//   OLD: Integrate = IntegrateSimpson;
	//        auto result = Integrate(f, a, b, eps);
	//
	//   NEW: auto result = Integrate(f, a, b, SIMPSON, eps);
	//    or: auto result = Integrate<SIMPSON>(f, a, b, eps);
	//    or: auto result = IntegrateSimpson(f, a, b, eps);  // Direct call
	//
	// The function pointer is kept temporarily for backward compatibility but
	// should not be used in new code.
	// ============================================================================
	[[deprecated("Use Integrate(func, a, b, method, eps) or call IntegrateTrap/Simpson/Romberg directly")]]
	static inline IntegrationResult IntegrateDefault(const MML::IRealFunction& f, Real a, Real b, Real eps) {
		return IntegrateTrap(f, a, b, eps);
	}
}


///////////////////////////   mml/core/Integration/Integration2D.h   ///////////////////////////




namespace MML
{
	struct Integral2DInner : public IRealFunction
	{
		mutable Real				_currX;
		const IScalarFunction<2>& _funcToIntegrate;

		Integral2DInner(const IScalarFunction<2>& func) : _currX(0.0), _funcToIntegrate(func) {}

		Real operator()(const Real y) const
		{
			VectorN<Real, 2> v{ _currX, y };
			return _funcToIntegrate(v);
		}
	};

	struct Integral2DOuter : public IRealFunction
	{
		mutable Integral2DInner _fInner;

		IntegrationMethod			_integrMethod;
		const IScalarFunction<2>&		_funcToIntegrate;

		Real(*_yRangeLow)(Real);
		Real(*_yRangeUpp)(Real);

		Integral2DOuter(const IScalarFunction<2>& func, IntegrationMethod inMethod, 
										Real yy1(Real), Real yy2(Real)) 
				: _yRangeLow(yy1), _yRangeUpp(yy2), 
					_fInner(func), _funcToIntegrate(func), _integrMethod(inMethod)	{	}

		// for given x, will return (ie. integrate function over Y-range)
		Real operator()(const Real x) const
		{
			_fInner._currX = x;
			switch (_integrMethod)
			{
				case SIMPSON:
					return IntegrateSimpson(_fInner, _yRangeLow(x), _yRangeUpp(x));
				case ROMBERG:
					return IntegrateRomberg(_fInner, _yRangeLow(x), _yRangeUpp(x));
				case GAUSS10:
					return IntegrateGauss10(_fInner, _yRangeLow(x), _yRangeUpp(x));
				default:
					return IntegrateTrap(_fInner, _yRangeLow(x), _yRangeUpp(x));
			}
		}
	};

	static IntegrationResult Integrate2D(const IScalarFunction<2>& func, IntegrationMethod method, 
																			 const Real x1, const Real x2, 
																			 Real y1(Real), Real y2(Real))
	{
		Integral2DOuter f1(func, method, y1, y2);

		switch (method)
		{
			case SIMPSON:
				return IntegrateSimpson(f1, x1, x2);
			case ROMBERG:
				return IntegrateRomberg(f1, x1, x2);
			case GAUSS10:
				return IntegrateGauss10(f1, x1, x2);  // Now returns IntegrationResult directly
			default:
				return IntegrateTrap(f1, x1, x2);
		}
	}
}


///////////////////////////   mml/core/Integration/Integration3D.h   ///////////////////////////




namespace MML
{
	struct Integral3DInnermost : public IRealFunction
	{
		mutable Real					_currX, _currY;
		const IScalarFunction<3>&		_funcToIntegrate;
		IntegrationMethod				_integrMethod;

		Integral3DInnermost(const IScalarFunction<3>& func, IntegrationMethod method = GAUSS10) 
			: _funcToIntegrate(func), _currX{ 0 }, _currY{ 0 }, _integrMethod(method) {}
		
		Real operator()(const Real z) const
		{
			VectorN<Real, 3> v{ _currX, _currY, z };

			return _funcToIntegrate(v);
		}
	};

	struct Integral3DInner : public IRealFunction
	{
		mutable Integral3DInnermost _fInnermost;

		const IScalarFunction<3>& _funcToIntegrate;
		IntegrationMethod			_integrMethod;

		Real(*_zRangeLow)(Real, Real);
		Real(*_zRangeUpp)(Real, Real);

		Integral3DInner(const IScalarFunction<3>& func, IntegrationMethod method,
										Real zz1(Real, Real), Real zz2(Real, Real)) 
			: _zRangeLow(zz1), _zRangeUpp(zz2), _funcToIntegrate(func), 
			  _fInnermost(func, method), _integrMethod(method) {}

		Real operator()(const Real y) const
		{
			_fInnermost._currY = y;

			switch (_integrMethod)
			{
				case SIMPSON:
					return IntegrateSimpson(_fInnermost, 
											_zRangeLow(_fInnermost._currX, y), 
											_zRangeUpp(_fInnermost._currX, y));
				case ROMBERG:
					return IntegrateRomberg(_fInnermost, 
											_zRangeLow(_fInnermost._currX, y), 
											_zRangeUpp(_fInnermost._currX, y));
				case GAUSS10:
					return IntegrateGauss10(_fInnermost, 
											_zRangeLow(_fInnermost._currX, y), 
											_zRangeUpp(_fInnermost._currX, y));
				default:  // TRAP
					return IntegrateTrap(_fInnermost, 
										 _zRangeLow(_fInnermost._currX, y), 
										 _zRangeUpp(_fInnermost._currX, y));
			}
		}
	};

	struct Integral3DOuter : public IRealFunction
	{
		mutable Integral3DInner _fInner;

		const IScalarFunction<3>& _funcToIntegrate;
		IntegrationMethod			_integrMethod;
		Real(*_yRangeLow)(Real);
		Real(*_yRangeUpp)(Real);

		Integral3DOuter(const IScalarFunction<3>& func, IntegrationMethod method,
						Real yy1(Real), Real yy2(Real), 
						Real z1(Real, Real), Real z2(Real, Real)) 
			: _yRangeLow(yy1), _yRangeUpp(yy2), _funcToIntegrate(func), 
			  _fInner(func, method, z1, z2), _integrMethod(method)
		{
		}

		Real operator()(const Real x) const
		{
			_fInner._fInnermost._currX = x;

			switch (_integrMethod)
			{
				case SIMPSON:
					return IntegrateSimpson(_fInner, _yRangeLow(x), _yRangeUpp(x));
				case ROMBERG:
					return IntegrateRomberg(_fInner, _yRangeLow(x), _yRangeUpp(x));
				case GAUSS10:
					return IntegrateGauss10(_fInner, _yRangeLow(x), _yRangeUpp(x));
				default:  // TRAP
					return IntegrateTrap(_fInner, _yRangeLow(x), _yRangeUpp(x));
			}
		}
	};

	/// 3D integration with selectable method (TRAP, SIMPSON, ROMBERG, GAUSS10)
	static IntegrationResult Integrate3D(const IScalarFunction<3>& func, 
										 IntegrationMethod method,
										 const Real x1, const Real x2, 
										 Real y1(Real), Real y2(Real),
										 Real z1(Real, Real), Real z2(Real, Real))
	{
		Integral3DOuter f1(func, method, y1, y2, z1, z2);

		switch (method)
		{
			case SIMPSON:
				return IntegrateSimpson(f1, x1, x2);
			case ROMBERG:
				return IntegrateRomberg(f1, x1, x2);
			case GAUSS10:
				return IntegrateGauss10(f1, x1, x2);
			default:  // TRAP
				return IntegrateTrap(f1, x1, x2);
		}
	}

	/// 3D integration with default GAUSS10 method (backward compatible)
	static IntegrationResult Integrate3D(const IScalarFunction<3>& func, 
										 const Real x1, const Real x2, 
										 Real y1(Real), Real y2(Real),
										 Real z1(Real, Real), Real z2(Real, Real))
	{
		return Integrate3D(func, GAUSS10, x1, x2, y1, y2, z1, z2);
	}	
}


///////////////////////////   mml/core/Integration/GaussianQuadrature.h   ///////////////////////////




namespace MML
{
	/**
	 * @brief Result structure for Gaussian quadrature computation
	 */
	struct GaussQuadratureRule {
		std::vector<Real> nodes;    ///< Quadrature nodes (abscissas)
		std::vector<Real> weights;  ///< Quadrature weights
		int n;                      ///< Number of points
		
		GaussQuadratureRule(int numPoints) : nodes(numPoints), weights(numPoints), n(numPoints) {}
	};

	/*************************************************************************/
	/*****                   GAUSS-LEGENDRE                              *****/
	/*************************************************************************/

	/**
	 * @brief Compute Gauss-Legendre quadrature nodes and weights
	 *
	 * Gauss-Legendre quadrature integrates with weight function w(x) = 1 on [-1, 1].
	 * With n points, it exactly integrates polynomials of degree â‰¤ 2n-1.
	 *
	 * The nodes are roots of the Legendre polynomial Pâ‚™(x), and the weights are
	 * computed from the derivative of Pâ‚™ at each node.
	 *
	 * ALGORITHM:
	 * 1. Use asymptotic formula for initial node estimates
	 * 2. Newton-Raphson iteration to find exact roots of Pâ‚™(x)
	 * 3. Compute weights from the derivative Pâ‚™'(xáµ¢)
	 *
	 * @param[out] x Vector of nodes (size determines n)
	 * @param[out] w Vector of weights (same size as x)
	 * @param x1 Lower bound of integration interval (default -1)
	 * @param x2 Upper bound of integration interval (default +1)
	 *
	 * @note For interval [a,b], nodes and weights are automatically transformed.
	 */
	static void GaussLegendre(std::vector<Real>& x, std::vector<Real>& w,
	                          Real x1 = -1.0, Real x2 = 1.0)
	{
		const Real EPS = 1.0e-14;
		const Real PI = Constants::PI;
		
		int n = static_cast<int>(x.size());
		if (w.size() != x.size())
			throw VectorDimensionError("GaussLegendre: x and w must have same size", static_cast<int>(x.size()), static_cast<int>(w.size()));
		
		int m = (n + 1) / 2;  // Exploit symmetry
		Real xm = 0.5 * (x2 + x1);  // Midpoint
		Real xl = 0.5 * (x2 - x1);  // Half-width
		
		for (int i = 0; i < m; i++)
		{
			// Initial approximation for i-th root using asymptotic formula
			Real z = std::cos(PI * (i + 0.75) / (n + 0.5));
			
			// Newton-Raphson iteration
			Real z1, pp;
			do {
				Real p1 = 1.0;
				Real p2 = 0.0;
				
				// Evaluate Legendre polynomial Pâ‚™(z) using recurrence
				for (int j = 0; j < n; j++)
				{
					Real p3 = p2;
					p2 = p1;
					p1 = ((2.0 * j + 1.0) * z * p2 - j * p3) / (j + 1);
				}
				
				// Derivative: Pâ‚™'(z) = n(zPâ‚™ - Pâ‚™â‚‹â‚)/(zÂ² - 1)
				pp = n * (z * p1 - p2) / (z * z - 1.0);
				
				z1 = z;
				z = z1 - p1 / pp;  // Newton update
			} while (std::abs(z - z1) > EPS);
			
			// Store symmetric nodes and weights
			x[i] = xm - xl * z;
			x[n - 1 - i] = xm + xl * z;
			w[i] = 2.0 * xl / ((1.0 - z * z) * pp * pp);
			w[n - 1 - i] = w[i];
		}
	}

	/**
	 * @brief Compute n-point Gauss-Legendre rule and return as structure
	 */
	static GaussQuadratureRule GaussLegendreRule(int n, Real a = -1.0, Real b = 1.0)
	{
		GaussQuadratureRule rule(n);
		GaussLegendre(rule.nodes, rule.weights, a, b);
		return rule;
	}

	/*************************************************************************/
	/*****                   GAUSS-LAGUERRE                              *****/
	/*************************************************************************/

	/**
	 * @brief Compute Gauss-Laguerre quadrature nodes and weights
	 *
	 * Gauss-Laguerre quadrature integrates with weight function w(x) = x^Î± e^(-x) on [0, âˆž).
	 * This is ideal for integrals of the form:
	 *   âˆ«â‚€^âˆž x^Î± e^(-x) f(x) dx â‰ˆ Î£ wáµ¢ f(xáµ¢)
	 *
	 * The nodes are roots of the generalized Laguerre polynomial Lâ‚™^(Î±)(x).
	 *
	 * COMMON VALUES OF Î±:
	 * - Î± = 0: Standard Laguerre (most common)
	 * - Î± = -0.5: For âˆ« f(x)/âˆšx Â· e^(-x) dx
	 * - Î± = 0.5: For âˆ« âˆšx Â· f(x) Â· e^(-x) dx
	 *
	 * @param[out] x Vector of nodes (size determines n)
	 * @param[out] w Vector of weights (same size as x)
	 * @param alpha Exponent parameter Î± (default 0)
	 */
	static void GaussLaguerre(std::vector<Real>& x, std::vector<Real>& w, Real alpha = 0.0)
	{
		const int MAXIT = 10;
		const Real EPS = 1.0e-14;
		
		int n = static_cast<int>(x.size());
		if (w.size() != x.size())
			throw VectorDimensionError("GaussLaguerre: x and w must have same size", static_cast<int>(x.size()), static_cast<int>(w.size()));
		
		for (int i = 0; i < n; i++)
		{
			// Initial approximation for roots
			Real z;
			if (i == 0) {
				z = (1.0 + alpha) * (3.0 + 0.92 * alpha) / (1.0 + 2.4 * n + 1.8 * alpha);
			} else if (i == 1) {
				z = x[0] + (15.0 + 6.25 * alpha) / (1.0 + 0.9 * alpha + 2.5 * n);
			} else {
				Real ai = i - 1;
				z = x[i-1] + ((1.0 + 2.55 * ai) / (1.9 * ai) + 1.26 * ai * alpha / 
				              (1.0 + 3.5 * ai)) * (x[i-1] - x[i-2]) / (1.0 + 0.3 * alpha);
			}
			
			// Newton-Raphson iteration
			int its;
			Real pp, p2;
			for (its = 0; its < MAXIT; its++)
			{
				Real p1 = 1.0;
				p2 = 0.0;
				
				// Evaluate Laguerre polynomial using recurrence
				for (int j = 0; j < n; j++)
				{
					Real p3 = p2;
					p2 = p1;
					p1 = ((2 * j + 1 + alpha - z) * p2 - (j + alpha) * p3) / (j + 1);
				}
				
				// Derivative
				pp = (n * p1 - (n + alpha) * p2) / z;
				
				Real z1 = z;
				z = z1 - p1 / pp;
				if (std::abs(z - z1) <= EPS) break;
			}
			if (its >= MAXIT)
				throw IntegrationTooManySteps("GaussLaguerre: too many iterations", MAXIT);
			
			x[i] = z;
			// Weight formula using gamma functions
			w[i] = -std::exp(Functions::LGamma(alpha + n) - Functions::LGamma(static_cast<Real>(n))) 
			       / (pp * n * p2);
		}
	}

	/**
	 * @brief Compute n-point Gauss-Laguerre rule and return as structure
	 */
	static GaussQuadratureRule GaussLaguerreRule(int n, Real alpha = 0.0)
	{
		GaussQuadratureRule rule(n);
		GaussLaguerre(rule.nodes, rule.weights, alpha);
		return rule;
	}

	/*************************************************************************/
	/*****                    GAUSS-HERMITE                              *****/
	/*************************************************************************/

	/**
	 * @brief Compute Gauss-Hermite quadrature nodes and weights
	 *
	 * Gauss-Hermite quadrature integrates with weight function w(x) = e^(-xÂ²) on (-âˆž, âˆž).
	 * This is ideal for integrals of the form:
	 *   âˆ«_{-âˆž}^âˆž e^(-xÂ²) f(x) dx â‰ˆ Î£ wáµ¢ f(xáµ¢)
	 *
	 * The nodes are roots of the Hermite polynomial Hâ‚™(x).
	 *
	 * APPLICATIONS:
	 * - Quantum mechanics (harmonic oscillator)
	 * - Probability (Gaussian integrals)
	 * - Statistical mechanics
	 *
	 * @param[out] x Vector of nodes (size determines n)
	 * @param[out] w Vector of weights (same size as x)
	 */
	static void GaussHermite(std::vector<Real>& x, std::vector<Real>& w)
	{
		const Real EPS = 3.0e-14;  // Slightly relaxed for robustness
		const Real PIM4 = 0.7511255444649425;  // Ï€^(-1/4)
		const int MAXIT = 15;  // Increased for edge cases
		
		int n = static_cast<int>(x.size());
		if (w.size() != x.size())
			throw VectorDimensionError("GaussHermite: x and w must have same size", static_cast<int>(x.size()), static_cast<int>(w.size()));
		
		int m = (n + 1) / 2;  // Exploit symmetry
		Real z = 0.0;  // Moved outside loop - needed for initial guess formulas
		
		for (int i = 0; i < m; i++)
		{
			// Initial approximation for roots (z preserves value from previous iteration)
			if (i == 0) {
				z = std::sqrt(static_cast<Real>(2 * n + 1)) - 
				    1.85575 * std::pow(static_cast<Real>(2 * n + 1), -0.16667);
			} else if (i == 1) {
				z = z - 1.14 * std::pow(static_cast<Real>(n), 0.426) / z;
			} else if (i == 2) {
				z = 1.86 * z - 0.86 * x[0];
			} else if (i == 3) {
				z = 1.91 * z - 0.91 * x[1];
			} else {
				z = 2.0 * z - x[i - 2];
			}
			
			// Newton-Raphson iteration
			int its;
			Real pp;
			for (its = 0; its < MAXIT; its++)
			{
				Real p1 = PIM4;
				Real p2 = 0.0;
				
				// Evaluate Hermite polynomial using recurrence (normalized form)
				for (int j = 0; j < n; j++)
				{
					Real p3 = p2;
					p2 = p1;
					p1 = z * std::sqrt(2.0 / (j + 1)) * p2 - 
					     std::sqrt(static_cast<Real>(j) / (j + 1)) * p3;
				}
				
				// Derivative
				pp = std::sqrt(static_cast<Real>(2 * n)) * p2;
				
				Real z1 = z;
				z = z1 - p1 / pp;
				if (std::abs(z - z1) <= EPS) break;
			}
			if (its >= MAXIT)
				throw IntegrationTooManySteps("GaussHermite: too many iterations", MAXIT);
			
			// Store symmetric nodes and weights
			x[i] = z;
			x[n - 1 - i] = -z;
			w[i] = 2.0 / (pp * pp);
			w[n - 1 - i] = w[i];
		}
	}

	/**
	 * @brief Compute n-point Gauss-Hermite rule and return as structure
	 */
	static GaussQuadratureRule GaussHermiteRule(int n)
	{
		GaussQuadratureRule rule(n);
		GaussHermite(rule.nodes, rule.weights);
		return rule;
	}

	/*************************************************************************/
	/*****                    GAUSS-JACOBI                               *****/
	/*************************************************************************/

	/**
	 * @brief Compute Gauss-Jacobi quadrature nodes and weights
	 *
	 * Gauss-Jacobi quadrature integrates with weight function 
	 * w(x) = (1-x)^Î± (1+x)^Î² on [-1, 1].
	 *
	 * This generalizes several other quadrature rules:
	 * - Î± = Î² = 0: Gauss-Legendre
	 * - Î± = Î² = -0.5: Gauss-Chebyshev of the first kind
	 * - Î± = Î² = 0.5: Gauss-Chebyshev of the second kind
	 *
	 * APPLICATIONS:
	 * - Integrals with endpoint singularities
	 * - Weighted polynomial approximation
	 * - Spectral methods
	 *
	 * @param[out] x Vector of nodes (size determines n)
	 * @param[out] w Vector of weights (same size as x)
	 * @param alpha Parameter Î± (must be > -1)
	 * @param beta Parameter Î² (must be > -1)
	 */
	static void GaussJacobi(std::vector<Real>& x, std::vector<Real>& w, 
	                        Real alpha, Real beta)
	{
		const int MAXIT = 15;  // Increased for edge cases like Î±=Î²=0
		const Real EPS = 3.0e-14;  // Slightly relaxed for robustness
		
		int n = static_cast<int>(x.size());
		if (w.size() != x.size())
			throw VectorDimensionError("GaussJacobi: x and w must have same size", static_cast<int>(x.size()), static_cast<int>(w.size()));
		if (alpha <= -1.0 || beta <= -1.0)
			throw NumericalMethodError("GaussJacobi: alpha and beta must be > -1");
		
		Real alfbet = alpha + beta;
		Real z = 0.0;  // Moved outside loop - needed for initial guess formulas
		
		for (int i = 0; i < n; i++)
		{
			// Initial approximation for roots (z preserves value from previous iteration)
			if (i == 0) {
				Real an = alpha / n;
				Real bn = beta / n;
				Real r1 = (1.0 + alpha) * (2.78 / (4.0 + n * n) + 0.768 * an / n);
				Real r2 = 1.0 + 1.48 * an + 0.96 * bn + 0.452 * an * an + 0.83 * an * bn;
				z = 1.0 - r1 / r2;
			} else if (i == 1) {
				Real r1 = (4.1 + alpha) / ((1.0 + alpha) * (1.0 + 0.156 * alpha));
				Real r2 = 1.0 + 0.06 * (n - 8.0) * (1.0 + 0.12 * alpha) / n;
				Real r3 = 1.0 + 0.012 * beta * (1.0 + 0.25 * std::abs(alpha)) / n;
				z = z - (1.0 - z) * r1 * r2 * r3;
			} else if (i == 2) {
				Real r1 = (1.67 + 0.28 * alpha) / (1.0 + 0.37 * alpha);
				Real r2 = 1.0 + 0.22 * (n - 8.0) / n;
				Real r3 = 1.0 + 8.0 * beta / ((6.28 + beta) * n * n);
				z = z - (x[0] - z) * r1 * r2 * r3;
			} else if (i == n - 2) {
				Real r1 = (1.0 + 0.235 * beta) / (0.766 + 0.119 * beta);
				Real r2 = 1.0 / (1.0 + 0.639 * (n - 4.0) / (1.0 + 0.71 * (n - 4.0)));
				Real r3 = 1.0 / (1.0 + 20.0 * alpha / ((7.5 + alpha) * n * n));
				z = z + (z - x[n - 4]) * r1 * r2 * r3;
			} else if (i == n - 1) {
				Real r1 = (1.0 + 0.37 * beta) / (1.67 + 0.28 * beta);
				Real r2 = 1.0 / (1.0 + 0.22 * (n - 8.0) / n);
				Real r3 = 1.0 / (1.0 + 8.0 * alpha / ((6.28 + alpha) * n * n));
				z = z + (z - x[n - 3]) * r1 * r2 * r3;
			} else {
				z = 3.0 * x[i - 1] - 3.0 * x[i - 2] + x[i - 3];
			}
			
			// Newton-Raphson iteration
			int its;
			Real pp, p2;
			for (its = 0; its < MAXIT; its++)
			{
				Real temp = 2.0 + alfbet;
				Real p1 = (alpha - beta + temp * z) / 2.0;
				p2 = 1.0;
				
				// Evaluate Jacobi polynomial using recurrence
				for (int j = 2; j <= n; j++)
				{
					Real p3 = p2;
					p2 = p1;
					temp = 2 * j + alfbet;
					Real a = 2 * j * (j + alfbet) * (temp - 2.0);
					Real b = (temp - 1.0) * (alpha * alpha - beta * beta + temp * (temp - 2.0) * z);
					Real c = 2.0 * (j - 1 + alpha) * (j - 1 + beta) * temp;
					p1 = (b * p2 - c * p3) / a;
				}
				
				// Derivative
				Real temp2 = 2 * n + alfbet;
				pp = (n * (alpha - beta - temp2 * z) * p1 + 
				      2.0 * (n + alpha) * (n + beta) * p2) / (temp2 * (1.0 - z * z));
				
				Real z1 = z;
				z = z1 - p1 / pp;
				if (std::abs(z - z1) <= EPS) break;
			}
			if (its >= MAXIT)
				throw IntegrationTooManySteps("GaussJacobi: too many iterations", MAXIT);
			
			x[i] = z;
			// Weight formula using gamma functions - computed in log domain to avoid overflow
			// For extreme parameters (large n, Î±, Î²), exp(LGamma(...)) can overflow
			Real temp = 2 * n + alfbet;
			Real log_weight = Functions::LGamma(alpha + n) + Functions::LGamma(beta + n) -
			                  Functions::LGamma(n + 1.0) - Functions::LGamma(n + alfbet + 1.0) +
			                  alfbet * std::log(2.0);
			
			// Check for overflow before calling exp() (exp(709) â‰ˆ 1.7e308, near DBL_MAX)
			if (log_weight > 700.0) {
				throw NumericalMethodError("GaussJacobi: weight computation overflow for given parameters (log_weight=" + std::to_string(log_weight) + ")");
			}
			w[i] = std::exp(log_weight) * temp / (pp * p2);
		}
	}

	/**
	 * @brief Compute n-point Gauss-Jacobi rule and return as structure
	 */
	static GaussQuadratureRule GaussJacobiRule(int n, Real alpha, Real beta)
	{
		GaussQuadratureRule rule(n);
		GaussJacobi(rule.nodes, rule.weights, alpha, beta);
		return rule;
	}

	/*************************************************************************/
	/*****              GAUSS-CHEBYSHEV (Special Cases)                  *****/
	/*************************************************************************/

	/**
	 * @brief Compute Gauss-Chebyshev quadrature of the first kind
	 *
	 * Weight function: w(x) = 1/âˆš(1-xÂ²) on [-1, 1]
	 * This is Gauss-Jacobi with Î± = Î² = -1/2
	 *
	 * The nodes and weights have closed-form expressions:
	 *   xáµ¢ = cos((2i+1)Ï€/(2n))
	 *   wáµ¢ = Ï€/n
	 */
	static void GaussChebyshev1(std::vector<Real>& x, std::vector<Real>& w)
	{
		int n = static_cast<int>(x.size());
		if (w.size() != x.size())
			throw VectorDimensionError("GaussChebyshev1: x and w must have same size", static_cast<int>(x.size()), static_cast<int>(w.size()));
		
		Real wgt = Constants::PI / n;
		for (int i = 0; i < n; i++)
		{
			x[i] = std::cos(Constants::PI * (2 * i + 1) / (2.0 * n));
			w[i] = wgt;
		}
	}

	/**
	 * @brief Compute Gauss-Chebyshev quadrature of the second kind
	 *
	 * Weight function: w(x) = âˆš(1-xÂ²) on [-1, 1]
	 * This is Gauss-Jacobi with Î± = Î² = 1/2
	 *
	 * The nodes and weights have closed-form expressions:
	 *   xáµ¢ = cos((i+1)Ï€/(n+1))
	 *   wáµ¢ = Ï€/(n+1) Â· sinÂ²((i+1)Ï€/(n+1))
	 */
	static void GaussChebyshev2(std::vector<Real>& x, std::vector<Real>& w)
	{
		int n = static_cast<int>(x.size());
		if (w.size() != x.size())
			throw VectorDimensionError("GaussChebyshev2: x and w must have same size", static_cast<int>(x.size()), static_cast<int>(w.size()));
		
		for (int i = 0; i < n; i++)
		{
			Real theta = Constants::PI * (i + 1) / (n + 1);
			x[i] = std::cos(theta);
			Real s = std::sin(theta);
			w[i] = Constants::PI / (n + 1) * s * s;
		}
	}

	/**
	 * @brief Compute n-point Gauss-Chebyshev Type 1 rule and return as structure
	 */
	static GaussQuadratureRule GaussChebyshev1Rule(int n)
	{
		GaussQuadratureRule rule(n);
		GaussChebyshev1(rule.nodes, rule.weights);
		return rule;
	}

	/**
	 * @brief Compute n-point Gauss-Chebyshev Type 2 rule and return as structure
	 */
	static GaussQuadratureRule GaussChebyshev2Rule(int n)
	{
		GaussQuadratureRule rule(n);
		GaussChebyshev2(rule.nodes, rule.weights);
		return rule;
	}

	/*************************************************************************/
	/*****              INTEGRATION USING COMPUTED RULES                 *****/
	/*************************************************************************/

	/**
	 * @brief Integrate using a pre-computed Gaussian quadrature rule
	 *
	 * @param func Function to integrate
	 * @param rule Pre-computed quadrature rule (nodes and weights)
	 * @return Approximate integral value
	 */
	static Real IntegrateWithRule(const IRealFunction& func, const GaussQuadratureRule& rule)
	{
		Real sum = 0.0;
		for (int i = 0; i < rule.n; i++)
		{
			sum += rule.weights[i] * func(rule.nodes[i]);
		}
		return sum;
	}

	/**
	 * @brief Integrate f(x) on [a,b] using n-point Gauss-Legendre
	 *
	 * Convenience function that computes the rule and evaluates the integral.
	 *
	 * @param func Function to integrate
	 * @param a Lower bound
	 * @param b Upper bound
	 * @param n Number of quadrature points (default 20)
	 * @return IntegrationResult with value (error_estimate = 0 for non-adaptive)
	 */
	static IntegrationResult IntegrateGaussLegendre(const IRealFunction& func, 
	                                                 Real a, Real b, int n = 20)
	{
		auto rule = GaussLegendreRule(n, a, b);
		Real value = IntegrateWithRule(func, rule);
		return IntegrationResult(value, 0.0, 1, true);
	}

	/**
	 * @brief Integrate f(x)Â·x^Î±Â·e^(-x) on [0,âˆž) using n-point Gauss-Laguerre
	 *
	 * Note: The weight function x^Î±Â·e^(-x) is built into the quadrature.
	 * You supply f(x) without the weight.
	 *
	 * @param func Function f(x) to integrate (not including weight)
	 * @param n Number of quadrature points (default 20)
	 * @param alpha Exponent parameter (default 0)
	 * @return IntegrationResult
	 */
	static IntegrationResult IntegrateGaussLaguerre(const IRealFunction& func, 
	                                                 int n = 20, Real alpha = 0.0)
	{
		auto rule = GaussLaguerreRule(n, alpha);
		Real value = IntegrateWithRule(func, rule);
		return IntegrationResult(value, 0.0, 1, true);
	}

	/**
	 * @brief Integrate f(x)Â·e^(-xÂ²) on (-âˆž,âˆž) using n-point Gauss-Hermite
	 *
	 * Note: The weight function e^(-xÂ²) is built into the quadrature.
	 * You supply f(x) without the weight.
	 *
	 * @param func Function f(x) to integrate (not including weight)
	 * @param n Number of quadrature points (default 20)
	 * @return IntegrationResult
	 */
	static IntegrationResult IntegrateGaussHermite(const IRealFunction& func, int n = 20)
	{
		auto rule = GaussHermiteRule(n);
		Real value = IntegrateWithRule(func, rule);
		return IntegrationResult(value, 0.0, 1, true);
	}

	/**
	 * @brief Integrate f(x)Â·(1-x)^Î±Â·(1+x)^Î² on [-1,1] using n-point Gauss-Jacobi
	 *
	 * Note: The weight function (1-x)^Î±Â·(1+x)^Î² is built into the quadrature.
	 * You supply f(x) without the weight.
	 *
	 * Special cases:
	 * - Î± = Î² = 0: Gauss-Legendre
	 * - Î± = Î² = -0.5: Gauss-Chebyshev of the first kind
	 * - Î± = Î² = 0.5: Gauss-Chebyshev of the second kind
	 *
	 * @param func Function f(x) to integrate (not including weight)
	 * @param alpha Parameter Î± (must be > -1)
	 * @param beta Parameter Î² (must be > -1)
	 * @param n Number of quadrature points (default 20)
	 * @return IntegrationResult
	 */
	static IntegrationResult IntegrateGaussJacobi(const IRealFunction& func, 
	                                               Real alpha, Real beta, int n = 20)
	{
		auto rule = GaussJacobiRule(n, alpha, beta);
		Real value = IntegrateWithRule(func, rule);
		return IntegrationResult(value, 0.0, 1, true);
	}

	/**
	 * @brief Integrate f(x)/âˆš(1-xÂ²) on [-1,1] using n-point Gauss-Chebyshev (first kind)
	 *
	 * Note: The weight function 1/âˆš(1-xÂ²) is built into the quadrature.
	 * You supply f(x) without the weight.
	 *
	 * This is particularly efficient because weights and nodes have closed-form expressions.
	 *
	 * @param func Function f(x) to integrate (not including weight)
	 * @param n Number of quadrature points (default 20)
	 * @return IntegrationResult
	 */
	static IntegrationResult IntegrateGaussChebyshev1(const IRealFunction& func, int n = 20)
	{
		auto rule = GaussChebyshev1Rule(n);
		Real value = IntegrateWithRule(func, rule);
		return IntegrationResult(value, 0.0, 1, true);
	}

	/**
	 * @brief Integrate f(x)Â·âˆš(1-xÂ²) on [-1,1] using n-point Gauss-Chebyshev (second kind)
	 *
	 * Note: The weight function âˆš(1-xÂ²) is built into the quadrature.
	 * You supply f(x) without the weight.
	 *
	 * This is particularly efficient because weights and nodes have closed-form expressions.
	 *
	 * @param func Function f(x) to integrate (not including weight)
	 * @param n Number of quadrature points (default 20)
	 * @return IntegrationResult
	 */
	static IntegrationResult IntegrateGaussChebyshev2(const IRealFunction& func, int n = 20)
	{
		auto rule = GaussChebyshev2Rule(n);
		Real value = IntegrateWithRule(func, rule);
		return IntegrationResult(value, 0.0, 1, true);
	}

} // namespace MML


///////////////////////////   mml/core/Integration/IntegrationImproper.h   ///////////////////////////




namespace MML
{
	/**
	 * @brief Open midpoint quadrature for use with improper integrals.
	 *
	 * Unlike the trapezoidal rule, the midpoint rule never evaluates the function
	 * at the endpoints. This is essential for improper integrals where the integrand
	 * may be singular or undefined at the boundaries.
	 *
	 * The midpoint rule uses the extended open formula:
	 *   âˆ«[a,b] f(x) dx â‰ˆ h * Î£ f(xáµ¢)  where xáµ¢ = a + (i + 0.5)h
	 *
	 * Refinement is done by tripling the number of points (not doubling),
	 * which allows reuse of previous function evaluations.
	 */
	class MidpointIntegrator : public IQuadrature
	{
	public:
		Real _a, _b, _currSum;
		const IRealFunction& _func;

		MidpointIntegrator(const IRealFunction& func, Real a, Real b)
			: _func(func), _a(a), _b(b), _currSum(0.0) {}

		Real next() override {
			int it, j;
			Real x, tnm, sum, del, ddel;

			_currStep++;
			if (_currStep == 1) {
				return (_currSum = (_b - _a) * _func(0.5 * (_a + _b)));
			}
			else {
				for (it = 1, j = 1; j < _currStep - 1; j++) 
					it *= 3;  // Triple the subdivisions each step
				tnm = it;
				del = (_b - _a) / (3.0 * tnm);
				ddel = del + del;
				x = _a + 0.5 * del;
				sum = 0.0;
				for (j = 0; j < it; j++) {
					sum += _func(x);
					x += ddel;
					sum += _func(x);
					x += del;
				}
				_currSum = (_currSum + (_b - _a) * sum / tnm) / 3.0;
				return _currSum;
			}
		}
	};

	/**
	 * @brief Transformed integrator for âˆ«[a, âˆž) f(x) dx
	 *
	 * Uses the substitution x = a + 1/t - 1, transforming [a, âˆž) to (0, 1].
	 * The transformed integrand is f(a + 1/t - 1) / tÂ²
	 */
	class UpperInfTransform : public IRealFunction
	{
	private:
		const IRealFunction& _func;
		Real _a;  // Lower bound
		
	public:
		UpperInfTransform(const IRealFunction& func, Real a) 
			: _func(func), _a(a) {}

		Real operator()(Real t) const override {
			if (t <= 0.0) return 0.0;  // Limit as t â†’ 0âº
			Real x = _a + 1.0/t - 1.0;
			return _func(x) / (t * t);
		}
	};

	/**
	 * @brief Transformed integrator for âˆ«(-âˆž, b] f(x) dx
	 *
	 * Uses the substitution x = b - 1/t + 1, transforming (-âˆž, b] to (0, 1].
	 * The transformed integrand is f(b - 1/t + 1) / tÂ²
	 */
	class LowerInfTransform : public IRealFunction
	{
	private:
		const IRealFunction& _func;
		Real _b;  // Upper bound
		
	public:
		LowerInfTransform(const IRealFunction& func, Real b) 
			: _func(func), _b(b) {}

		Real operator()(Real t) const override {
			if (t <= 0.0) return 0.0;  // Limit as t â†’ 0âº
			Real x = _b - 1.0/t + 1.0;
			return _func(x) / (t * t);
		}
	};

	/**
	 * @brief Open Romberg integration using midpoint rule.
	 *
	 * Similar to standard Romberg but uses the midpoint rule which never
	 * evaluates at endpoints. Essential for improper integrals.
	 *
	 * The step size reduction is h â†’ h/9 (not h/4) because midpoint
	 * refinement triples subdivisions (error goes as hÂ², so hÂ²â†’hÂ²/9).
	 */
	static IntegrationResult IntegrateOpen(const IRealFunction& func, Real a, Real b,
	                                       const Real eps = Defaults::RombergIntegrationEPS)
	{
		const int JMAX = Defaults::RombergIntegrationMaxSteps;
		const int K = Defaults::RombergIntegrationUsedPnts;
		
		std::vector<Real> s(JMAX);
		std::vector<Real> h(JMAX + 1);
		
		h[0] = 1.0;
		MidpointIntegrator mid(func, a, b);
		
		Real ss = 0.0;
		Real dss = 0.0;
		
		for (int j = 0; j < JMAX; j++)
		{
			s[j] = mid.next();
			
			if (j >= K - 1)
			{
				// Neville's algorithm for polynomial extrapolation to h=0
				std::vector<Real> c(K), d(K);
				int ns = 0;
				Real dif = std::abs(h[j - K + 1]);
				
				for (int i = 0; i < K; i++)
				{
					Real dift = std::abs(h[j - K + 1 + i]);
					if (dift < dif) { ns = i; dif = dift; }
					c[i] = s[j - K + 1 + i];
					d[i] = s[j - K + 1 + i];
				}
				
				ss = s[j - K + 1 + ns];
				ns--;
				
				for (int m = 1; m < K; m++)
				{
					for (int i = 0; i < K - m; i++)
					{
						Real ho = h[j - K + 1 + i];
						Real hp = h[j - K + 1 + i + m];
						Real w = c[i + 1] - d[i];
						Real den = ho - hp;
						if (den == 0.0)
							return IntegrationResult(ss, std::abs(dss), j + 1, false);
						den = w / den;
						d[i] = hp * den;
						c[i] = ho * den;
					}
					dss = (2 * (ns + 1) < (K - m)) ? c[ns + 1] : d[ns--];
					ss += dss;
				}
				
				if (std::abs(dss) <= eps * std::abs(ss) || (ss == 0.0 && dss == 0.0))
					return IntegrationResult(ss, std::abs(dss), j + 1, true);
			}
			
			// h â†’ h/9 for midpoint rule (not h/4 as in trapezoidal)
			h[j + 1] = h[j] / 9.0;
		}
		
		return IntegrationResult(ss, std::abs(dss), JMAX, false);
	}

	/*************************************************************************/
	/*****                  SEMI-INFINITE INTEGRALS                      *****/
	/*************************************************************************/

	/**
	 * @brief Integrate f(x) from a to infinity: âˆ«[a, âˆž) f(x) dx
	 *
	 * Computes the improper integral over a semi-infinite interval extending
	 * to positive infinity. Uses variable substitution to transform the
	 * infinite interval to a finite one.
	 *
	 * MATHEMATICAL TRANSFORMATION:
	 * The substitution t = 1/(x - a + 1) maps [a, âˆž) â†’ (0, 1]:
	 *   - x = a + 1/t - 1
	 *   - dx = -dt/tÂ²
	 *   - âˆ«[a,âˆž) f(x) dx = âˆ«(0,1] f(a + 1/t - 1) / tÂ² dt
	 *
	 * CONVERGENCE:
	 * The integral converges if f(x) = O(1/x^(1+Îµ)) as x â†’ âˆž for some Îµ > 0.
	 * Faster decay (e.g., exponential) leads to faster numerical convergence.
	 *
	 * @param func Function to integrate (must be well-behaved for x â‰¥ a)
	 * @param a Lower bound of integration (finite)
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, and convergence status
	 *
	 * @example
	 *   // âˆ«[0,âˆž) e^(-x) dx = 1
	 *   RealFunction f{ [](Real x) { return std::exp(-x); } };
	 *   auto result = IntegrateUpperInf(f, 0.0);
	 *
	 *   // âˆ«[1,âˆž) 1/xÂ² dx = 1
	 *   RealFunction g{ [](Real x) { return 1.0/(x*x); } };
	 *   auto result = IntegrateUpperInf(g, 1.0);
	 */
	static IntegrationResult IntegrateUpperInf(const IRealFunction& func, Real a,
	                                           const Real eps = Defaults::RombergIntegrationEPS)
	{
		UpperInfTransform transformed(func, a);
		return IntegrateOpen(transformed, 0.0, 1.0, eps);
	}

	/**
	 * @brief Integrate f(x) from negative infinity to b: âˆ«(-âˆž, b] f(x) dx
	 *
	 * Computes the improper integral over a semi-infinite interval extending
	 * to negative infinity.
	 *
	 * MATHEMATICAL TRANSFORMATION:
	 * The substitution t = 1/(b - x + 1) maps (-âˆž, b] â†’ (0, 1]:
	 *   - x = b - 1/t + 1
	 *   - dx = dt/tÂ²
	 *   - âˆ«(-âˆž,b] f(x) dx = âˆ«(0,1] f(b - 1/t + 1) / tÂ² dt
	 *
	 * @param func Function to integrate (must be well-behaved for x â‰¤ b)
	 * @param b Upper bound of integration (finite)
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, and convergence status
	 *
	 * @example
	 *   // âˆ«(-âˆž,0] e^x dx = 1
	 *   RealFunction f{ [](Real x) { return std::exp(x); } };
	 *   auto result = IntegrateLowerInf(f, 0.0);
	 */
	static IntegrationResult IntegrateLowerInf(const IRealFunction& func, Real b,
	                                           const Real eps = Defaults::RombergIntegrationEPS)
	{
		LowerInfTransform transformed(func, b);
		return IntegrateOpen(transformed, 0.0, 1.0, eps);
	}

	/**
	 * @brief Integrate f(x) from negative infinity to positive infinity: âˆ«(-âˆž, âˆž) f(x) dx
	 *
	 * Computes the improper integral over the entire real line. The integral
	 * is split at x = 0 into two semi-infinite integrals.
	 *
	 * ALGORITHM:
	 * âˆ«(-âˆž, âˆž) f(x) dx = âˆ«(-âˆž, 0] f(x) dx + âˆ«[0, âˆž) f(x) dx
	 *
	 * The split point is x = 0 by default, which works well for symmetric
	 * functions. For asymmetric functions, consider using the overload
	 * with a custom split point.
	 *
	 * CONVERGENCE:
	 * Requires f(x) â†’ 0 fast enough as x â†’ Â±âˆž:
	 *   - f(x) = O(1/|x|^(1+Îµ)) is sufficient
	 *   - Gaussian decay e^(-xÂ²) converges very fast
	 *   - Lorentzian decay 1/(1+xÂ²) converges well
	 *
	 * @param func Function to integrate
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, and convergence status
	 *
	 * @example
	 *   // âˆ«(-âˆž,âˆž) e^(-xÂ²) dx = âˆšÏ€
	 *   RealFunction gaussian{ [](Real x) { return std::exp(-x*x); } };
	 *   auto result = IntegrateInf(gaussian);
	 *   // result.value â‰ˆ 1.7724538509...
	 *
	 *   // âˆ«(-âˆž,âˆž) 1/(1+xÂ²) dx = Ï€
	 *   RealFunction lorentz{ [](Real x) { return 1.0/(1.0 + x*x); } };
	 *   auto result = IntegrateInf(lorentz);
	 */
	static IntegrationResult IntegrateInf(const IRealFunction& func,
	                                      const Real eps = Defaults::RombergIntegrationEPS)
	{
		// Split at x = 0
		auto left  = IntegrateLowerInf(func, 0.0, eps);
		auto right = IntegrateUpperInf(func, 0.0, eps);
		
		return IntegrationResult(
			left.value + right.value,
			left.error_estimate + right.error_estimate,
			left.iterations + right.iterations,
			left.converged && right.converged
		);
	}

	/**
	 * @brief Integrate f(x) from negative infinity to positive infinity with custom split point
	 *
	 * For functions that are not symmetric about x = 0, or have features
	 * concentrated in a particular region, specifying a custom split point
	 * can improve accuracy and convergence.
	 *
	 * @param func Function to integrate
	 * @param splitPoint The x value at which to split the integral
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, and convergence status
	 *
	 * @example
	 *   // Function peaked near x = 5
	 *   RealFunction peaked{ [](Real x) { return std::exp(-(x-5)*(x-5)); } };
	 *   auto result = IntegrateInfSplit(peaked, 5.0);  // Split near the peak
	 */
	static IntegrationResult IntegrateInfSplit(const IRealFunction& func, Real splitPoint,
	                                           const Real eps = Defaults::RombergIntegrationEPS)
	{
		auto left  = IntegrateLowerInf(func, splitPoint, eps);
		auto right = IntegrateUpperInf(func, splitPoint, eps);
		
		return IntegrationResult(
			left.value + right.value,
			left.error_estimate + right.error_estimate,
			left.iterations + right.iterations,
			left.converged && right.converged
		);
	}

	/*************************************************************************/
	/*****              SINGULAR INTEGRALS - ENDPOINT SINGULARITIES      *****/
	/*************************************************************************/

	/**
	 * @brief Transformed integrator for lower endpoint singularity
	 *
	 * For integrals with an integrable singularity at x = a, like:
	 *   âˆ«[a, b] f(x)/âˆš(x-a) dx  or  âˆ«[a, b] f(x)/(x-a)^Î± dx  (0 < Î± < 1)
	 *
	 * Uses the substitution tÂ² = x - a, which maps [a, b] â†’ [0, âˆš(b-a)]:
	 *   - x = a + tÂ²
	 *   - dx = 2t dt
	 *   - âˆš(x-a) = t
	 *   - âˆ«[a,b] g(x) dx = âˆ«[0,âˆš(b-a)] g(a + tÂ²) Â· 2t dt
	 *
	 * The factor of 2t cancels the 1/âˆš(x-a) = 1/t singularity, making the
	 * integrand finite and well-behaved at t = 0.
	 *
	 * This transformation is ideal for inverse square-root singularities
	 * and works well for weaker singularities too.
	 */
	class LowerSingularTransform : public IRealFunction
	{
	private:
		const IRealFunction& _func;
		Real _a;  // Singular point (lower bound)
		
	public:
		LowerSingularTransform(const IRealFunction& func, Real a) 
			: _func(func), _a(a) {}

		Real operator()(Real t) const override {
			// x = a + tÂ², dx = 2t dt
			Real x = _a + t * t;
			return _func(x) * 2.0 * t;
		}
	};

	/**
	 * @brief Transformed integrator for upper endpoint singularity
	 *
	 * For integrals with an integrable singularity at x = b, like:
	 *   âˆ«[a, b] f(x)/âˆš(b-x) dx  or  âˆ«[a, b] f(x)/(b-x)^Î± dx  (0 < Î± < 1)
	 *
	 * Uses the substitution tÂ² = b - x, which maps [a, b] â†’ [0, âˆš(b-a)]:
	 *   - x = b - tÂ²
	 *   - dx = -2t dt
	 *   - âˆš(b-x) = t
	 *   - âˆ«[a,b] g(x) dx = âˆ«[0,âˆš(b-a)] g(b - tÂ²) Â· 2t dt
	 *
	 * The factor of 2t cancels the 1/âˆš(b-x) = 1/t singularity.
	 */
	class UpperSingularTransform : public IRealFunction
	{
	private:
		const IRealFunction& _func;
		Real _b;  // Singular point (upper bound)
		
	public:
		UpperSingularTransform(const IRealFunction& func, Real b) 
			: _func(func), _b(b) {}

		Real operator()(Real t) const override {
			// x = b - tÂ², dx = -2t dt, but we integrate from 0 to âˆš(b-a) so sign absorbed
			Real x = _b - t * t;
			return _func(x) * 2.0 * t;
		}
	};

	/**
	 * @brief Integrate with singularity at lower bound: âˆ«[a, b] f(x) dx where f has singularity at x = a
	 *
	 * Handles integrals where the integrand has an integrable singularity at the
	 * lower endpoint. The singularity is typically of the form 1/âˆš(x-a) or
	 * 1/(x-a)^Î± where 0 < Î± < 1.
	 *
	 * MATHEMATICAL TRANSFORMATION:
	 * Uses the substitution tÂ² = x - a:
	 *   âˆ«[a,b] f(x) dx = âˆ«[0,âˆš(b-a)] f(a + tÂ²) Â· 2t dt
	 *
	 * IMPORTANT: The function f should already include the singular behavior.
	 * The transformation removes the square-root singularity by the Jacobian 2t.
	 *
	 * EXAMPLES:
	 * - âˆ«[0,1] 1/âˆšx dx = 2  (singularity at x=0)
	 * - âˆ«[0,1] x/âˆšx dx = âˆ«[0,1] âˆšx dx = 2/3
	 * - âˆ«[0,1] ln(x)/âˆšx dx = -4 (double singularity)
	 *
	 * @param func Function to integrate (may be singular at x = a)
	 * @param a Lower bound with singularity
	 * @param b Upper bound (finite, no singularity)
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, and convergence status
	 *
	 * @example
	 *   // âˆ«[0,1] 1/âˆšx dx = 2
	 *   RealFunction f{ [](Real x) { return 1.0/std::sqrt(x); } };
	 *   auto result = IntegrateLowerSingular(f, 0.0, 1.0);
	 *   // result.value â‰ˆ 2.0
	 */
	static IntegrationResult IntegrateLowerSingular(const IRealFunction& func, Real a, Real b,
	                                                const Real eps = Defaults::RombergIntegrationEPS)
	{
		LowerSingularTransform transformed(func, a);
		Real upper = std::sqrt(b - a);
		// Use open integration (midpoint) to avoid endpoint issues
		return IntegrateOpen(transformed, 0.0, upper, eps);
	}

	/**
	 * @brief Integrate with singularity at upper bound: âˆ«[a, b] f(x) dx where f has singularity at x = b
	 *
	 * Handles integrals where the integrand has an integrable singularity at the
	 * upper endpoint.
	 *
	 * MATHEMATICAL TRANSFORMATION:
	 * Uses the substitution tÂ² = b - x:
	 *   âˆ«[a,b] f(x) dx = âˆ«[0,âˆš(b-a)] f(b - tÂ²) Â· 2t dt
	 *
	 * @param func Function to integrate (may be singular at x = b)
	 * @param a Lower bound (finite, no singularity)
	 * @param b Upper bound with singularity
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, and convergence status
	 *
	 * @example
	 *   // âˆ«[0,1] 1/âˆš(1-x) dx = 2
	 *   RealFunction f{ [](Real x) { return 1.0/std::sqrt(1.0 - x); } };
	 *   auto result = IntegrateUpperSingular(f, 0.0, 1.0);
	 *   // result.value â‰ˆ 2.0
	 */
	static IntegrationResult IntegrateUpperSingular(const IRealFunction& func, Real a, Real b,
	                                                const Real eps = Defaults::RombergIntegrationEPS)
	{
		UpperSingularTransform transformed(func, b);
		Real upper = std::sqrt(b - a);
		return IntegrateOpen(transformed, 0.0, upper, eps);
	}

	/**
	 * @brief Integrate with singularities at both endpoints
	 *
	 * Handles integrals where the integrand has integrable singularities at both
	 * endpoints a and b. The integral is split at the midpoint.
	 *
	 * ALGORITHM:
	 * âˆ«[a,b] f(x) dx = âˆ«[a,m] f(x) dx + âˆ«[m,b] f(x) dx
	 * where m = (a+b)/2, and each half is handled with the appropriate
	 * endpoint singularity transformation.
	 *
	 * @param func Function to integrate (may be singular at x = a and x = b)
	 * @param a Lower bound with singularity
	 * @param b Upper bound with singularity
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, and convergence status
	 *
	 * @example
	 *   // âˆ«[0,1] 1/âˆš(x(1-x)) dx = Ï€  (Beta function B(1/2, 1/2))
	 *   RealFunction f{ [](Real x) { return 1.0/std::sqrt(x*(1.0-x)); } };
	 *   auto result = IntegrateBothSingular(f, 0.0, 1.0);
	 *   // result.value â‰ˆ Ï€
	 */
	static IntegrationResult IntegrateBothSingular(const IRealFunction& func, Real a, Real b,
	                                               const Real eps = Defaults::RombergIntegrationEPS)
	{
		Real mid = 0.5 * (a + b);
		auto left = IntegrateLowerSingular(func, a, mid, eps);
		auto right = IntegrateUpperSingular(func, mid, b, eps);
		
		return IntegrationResult(
			left.value + right.value,
			left.error_estimate + right.error_estimate,
			left.iterations + right.iterations,
			left.converged && right.converged
		);
	}

	/**
	 * @brief Integrate with interior singularity: âˆ«[a, b] f(x) dx where f has singularity at x = c âˆˆ (a, b)
	 *
	 * Handles integrals where the integrand has an integrable singularity at an
	 * interior point c. The integral is split at c and each part is handled
	 * with the appropriate endpoint transformation.
	 *
	 * ALGORITHM:
	 * âˆ«[a,b] f(x) dx = âˆ«[a,c] f(x) dx + âˆ«[c,b] f(x) dx
	 * where the first integral has an upper singularity at c, and the second
	 * has a lower singularity at c.
	 *
	 * @param func Function to integrate (may be singular at x = c)
	 * @param a Lower bound (finite, no singularity)
	 * @param b Upper bound (finite, no singularity)
	 * @param c Interior singular point (a < c < b)
	 * @param eps Desired relative accuracy
	 * @return IntegrationResult with value, error estimate, and convergence status
	 *
	 * @example
	 *   // âˆ«[-1,1] 1/âˆš|x| dx = 4  (singularity at x=0)
	 *   RealFunction f{ [](Real x) { return 1.0/std::sqrt(std::abs(x)); } };
	 *   auto result = IntegrateInteriorSingular(f, -1.0, 1.0, 0.0);
	 *   // result.value â‰ˆ 4.0
	 */
	static IntegrationResult IntegrateInteriorSingular(const IRealFunction& func, Real a, Real b, Real c,
	                                                   const Real eps = Defaults::RombergIntegrationEPS)
	{
		if (c <= a || c >= b)
			throw std::invalid_argument("IntegrateInteriorSingular: singular point c must be in (a, b)");
		
		auto left = IntegrateUpperSingular(func, a, c, eps);
		auto right = IntegrateLowerSingular(func, c, b, eps);
		
		return IntegrationResult(
			left.value + right.value,
			left.error_estimate + right.error_estimate,
			left.iterations + right.iterations,
			left.converged && right.converged
		);
	}

	/*************************************************************************/
	/*****              CONVENIENCE ALIASES & CONSTANTS                  *****/
	/*************************************************************************/

	/// Mathematical infinity constant for readable function calls
	constexpr Real PosInfinity = std::numeric_limits<Real>::infinity();
	constexpr Real NegInfinity = -std::numeric_limits<Real>::infinity();

} // namespace MML


///////////////////////////   mml/core/Integration/PathIntegration.h   ///////////////////////////






namespace MML
{
	class PathIntegration
	{
		template<int N>
		class HelperCurveLen : public IRealFunction
		{
			const IParametricCurve<N>& _curve;
		public:
			HelperCurveLen(const IParametricCurve<N>& curve) : _curve(curve) {}

			Real operator()(Real t) const
			{
				auto tangent_vec = Derivation::DeriveCurve<N>(_curve, t, nullptr);
				return tangent_vec.NormL2();
			}
		};

		template<int N>
		class HelperCurveMass : public IRealFunction
		{
			const IParametricCurve<N>& _curve;
			const IRealFunction& _density;	
		public:
			HelperCurveMass(const IParametricCurve<N>& curve, const IRealFunction &density) : _curve(curve), _density(density) {}

			Real operator()(Real t) const
			{
				auto tangent_vec = Derivation::DeriveCurve<N>(_curve, t, nullptr);
				return tangent_vec.NormL2() * _density(t);
			}
		};

		template<int N>
		class HelperLineIntegralScalarFunc : public IRealFunction
		{
			const IScalarFunction<N>& _scalar_field;
			const IParametricCurve<N>& _curve;
		public:
			HelperLineIntegralScalarFunc(const IScalarFunction<N>& scalarField, const IParametricCurve<N>& curve) 
					: _scalar_field(scalarField), _curve(curve) {}

			Real operator()(Real t) const
			{
				auto tangent_vec = Derivation::DeriveCurve<N>(_curve, t, nullptr);

				auto field_val = _scalar_field(_curve(t));
				auto ret = field_val * tangent_vec.NormL2();

				return ret;
			}
		};

		template<int N>
		class HelperLineIntegralVectorFunc : public IRealFunction
		{
			const IVectorFunction<N>& _vector_field;
			const IParametricCurve<N>& _curve;
		public:
			HelperLineIntegralVectorFunc(const IVectorFunction<N>& vectorField, const IParametricCurve<N>& curve) 
					: _vector_field(vectorField), _curve(curve) {}

			Real operator()(Real t) const
			{
				auto tangent_vec = Derivation::DeriveCurve<N>(_curve, t, nullptr);
				auto field_vec = _vector_field(_curve(t));

				return Utils::ScalarProduct<N>(tangent_vec, field_vec);
			}
		};

	public:
		template<int N>
		static Real ParametricCurveLength(const IParametricCurve<N>& curve, const Real a, const Real b)
		{
			HelperCurveLen helper(curve);

			return IntegrateTrap(helper, a, b);
		}
		
		template<int N>
		static Real ParametricCurveMass(const IParametricCurve<N>& curve, const IRealFunction &density, 
																		const Real a, const Real b)
		{
      HelperCurveMass<N> helper(curve, density);
      
      return IntegrateTrap(helper, a, b);
		}

		static Real LineIntegral(const IScalarFunction<3>& scalarField, const IParametricCurve<3>& curve, 
														 const Real t1, const Real t2, const Real eps = Defaults::WorkIntegralPrecision)
		{
			HelperLineIntegralScalarFunc helper(scalarField, curve);

			return IntegrateTrap(helper, t1, t2, nullptr, nullptr, eps);
		}

		static Real LineIntegral(const IVectorFunction<3>& vectorField, const IParametricCurve<3>& curve, 
														 const Real t1, const Real t2, const Real eps = Defaults::LineIntegralPrecision)
		{
			HelperLineIntegralVectorFunc helper(vectorField, curve);

			return IntegrateTrap(helper, t1, t2, nullptr, nullptr, eps);
		}
	};
} // end namespace


///////////////////////////   mml/core/Integration/SurfaceIntegration.h   ///////////////////////////





namespace MML
{
	class SurfaceIntegration
	{
	public:
		// povrsinski integral preko
		// - ParametricSurface
		// - ParametricSurfaceRect
		// - SolidSurfaces3D -> 
		//		- SurfacesWithTriangles
		// 		- SurfacesWithRects
    // IParametricSurface integration on rectangular patch
	  // Uses finite differences to compute surface normals and integrates over parameter domain [x1,x2] x [y1,y2]
	  static Real SurfaceIntegral(const IVectorFunction<3>& vectorField, const IParametricSurfaceRect<3>& surface, 
                                const Real x1, const Real x2, const Real y1, const Real y2, 
                                int numU = 20, int numV = 20)
	  {
      if (x2 <= x1 || y2 <= y1)
        return 0.0;  // Invalid parameter range

      Real du = (x2 - x1) / numU;
      Real dv = (y2 - y1) / numV;
      Real total = 0.0;

      // Integrate using midpoint rule with adaptive normal computation
      for (int i = 0; i < numU; i++)
      {
        for (int j = 0; j < numV; j++)
        {
          // Midpoint of current patch
          Real u = x1 + (i + 0.5) * du;
          Real v = y1 + (j + 0.5) * dv;

          // Compute surface point at midpoint
          VectorN<Real, 3> point = surface(u, v);

          // Compute partial derivatives using finite differences
          Real h = PrecisionValues<Real>::DerivativeStepSize;  // Small step for numerical derivative

          VectorN<Real, 3> point_u_plus = surface(u + h, v);
          VectorN<Real, 3> point_u_minus = surface(u - h, v);
          VectorN<Real, 3> dS_du = (point_u_plus - point_u_minus) / (2.0 * h);

          VectorN<Real, 3> point_v_plus = surface(u, v + h);
          VectorN<Real, 3> point_v_minus = surface(u, v - h);
          VectorN<Real, 3> dS_dv = (point_v_plus - point_v_minus) / (2.0 * h);

          // Compute cross product: dS/du x dS/dv
          Vector3Cartesian partial_u(dS_du[0], dS_du[1], dS_du[2]);
          Vector3Cartesian partial_v(dS_dv[0], dS_dv[1], dS_dv[2]);
          Vector3Cartesian crossProd = VectorProduct(partial_u, partial_v);
          
          // Area element magnitude (not normalized yet)
          Real dS_magnitude = crossProd.NormL2();
          if (dS_magnitude < PrecisionValues<Real>::SurfaceNormalThreshold)
            continue;  // Degenerate patch

          // Unit normal
          Vector3Cartesian normal = crossProd / dS_magnitude;

          // Evaluate vector field at surface point
          Vector3Cartesian fieldValue = vectorField(Vector3Cartesian(point[0], point[1], point[2]));

          // Flux contribution: (F Â· n) * dS where dS = |âˆ‚S/âˆ‚u Ã— âˆ‚S/âˆ‚v| * du * dv
          Real dotProduct = ScalarProduct(normal, fieldValue);
          Real patchArea = dS_magnitude * du * dv;

          total += dotProduct * patchArea;
        }
      }

      return total;
		}

    ////////////////////////////////////////////////////////////////////////////////////////////
		// Surface integral over a solid with triangular surfaces (using Triangle3D)
		static Real SurfaceIntegral(const IVectorFunction<3>& vectorField, const BodyWithTriangleSurfaces& solid, Real eps = 0.001)
		{
			Real total = 0.0;
			for (int i = 0; i < solid.GetSurfaceCount(); i++)
				total += SurfaceIntegral(vectorField, solid.GetSurface(i), eps);
			return total;
		}

		// Surface integral over a single triangle (with recursive refinement)
		static Real SurfaceIntegral(const IVectorFunction<3>& vectorField, const Triangle3D& triangle, Real eps, int maxLevel = 7)
		{
			Real result = CalcSurfaceContrib(vectorField, triangle);

			return SurfaceIntegralImproveRecursively(vectorField, triangle, result, eps, maxLevel);
		}

		// Recursive refinement for triangle surface integration
		static Real SurfaceIntegralImproveRecursively(const IVectorFunction<3>& vectorField, const Triangle3D& triangle, Real prev_value, Real eps, int level)
		{
			// Subdivide triangle into 4 smaller triangles by connecting edge midpoints
			Pnt3Cart m12 = (triangle.Pnt1() + triangle.Pnt2()) / 2.0;
			Pnt3Cart m23 = (triangle.Pnt2() + triangle.Pnt3()) / 2.0;
			Pnt3Cart m31 = (triangle.Pnt3() + triangle.Pnt1()) / 2.0;

			Triangle3D t1(triangle.Pnt1(), m12, m31);
			Triangle3D t2(m12, triangle.Pnt2(), m23);
			Triangle3D t3(m31, m23, triangle.Pnt3());
			Triangle3D t4(m12, m23, m31);

			Real result = 0.0;
			result += CalcSurfaceContrib(vectorField, t1);
			result += CalcSurfaceContrib(vectorField, t2);
			result += CalcSurfaceContrib(vectorField, t3);
			result += CalcSurfaceContrib(vectorField, t4);

			if (fabs(result - prev_value) < eps || level == 0)
			{
				return result;
			}
			else
			{
				Real new_result = 0.0;
				new_result += SurfaceIntegralImproveRecursively(vectorField, t1, result, eps, level - 1);
				new_result += SurfaceIntegralImproveRecursively(vectorField, t2, result, eps, level - 1);
				new_result += SurfaceIntegralImproveRecursively(vectorField, t3, result, eps, level - 1);
				new_result += SurfaceIntegralImproveRecursively(vectorField, t4, result, eps, level - 1);
				return new_result;
			}
		}

		// Calculate the contribution of a single triangle (center-point rule)
		static Real CalcSurfaceContrib(const IVectorFunction<3>& vectorField, const Triangle3D& triangle)
		{
			// Compute normal using cross product of two edges
			Vec3Cart edge1(triangle.Pnt1(), triangle.Pnt2());
			Vec3Cart edge2(triangle.Pnt1(), triangle.Pnt3());
			Vec3Cart normal = VectorProduct(edge1, edge2).GetAsUnitVector();

			// Area using Heron's formula (already available as triangle.Area())
			Real area = triangle.Area();

			// Center (centroid) of the triangle
			Pnt3Cart center = (triangle.Pnt1() + triangle.Pnt2() + triangle.Pnt3()) / 3.0;

			Vector3Cartesian value = vectorField(Vector3Cartesian(center.X(), center.Y(), center.Z()));
			Real dotProduct = ScalarProduct(normal, value);

			return dotProduct * area;
		}

    ////////////////////////////////////////////////////////////////////////////////////////////
		// surface integral over a solid with rectangular surfaces
		static Real SurfaceIntegral(const IVectorFunction<3>& vectorField, const BodyWithRectSurfaces& solid, Real eps = 0.001)
		{
			Real total = 0.0;
			for (int i = 0; i < solid.GetSurfaceCount(); i++)
				total += SurfaceIntegral(vectorField, solid.GetSurface(i), eps);

			return total;
		}

		// Adaptive surface integration using eps for convergence, maxLevel for safety limit
		static Real SurfaceIntegral(const IVectorFunction<3>& vectorField, const RectSurface3D& surface, Real eps, int maxLevel = 7)
		{
			Real result = CalcSurfaceContrib(vectorField, surface);

			return SurfaceIntegralImproveRecursively(vectorField, surface, result, eps, maxLevel);
		}

		static Real SurfaceIntegralImproveRecursively(const IVectorFunction<3>& vectorField, const RectSurface3D& surface, Real prev_value, Real eps, int level)
		{
			// now we will calculate integral for surface divided to 4 equal parts
			Point3Cartesian pnt_mid12 = (surface._pnt1 + surface._pnt2) / 2.0;
			Point3Cartesian pnt_mid23 = (surface._pnt2 + surface._pnt3) / 2.0;
			Point3Cartesian pnt_mid34 = (surface._pnt3 + surface._pnt4) / 2.0;
			Point3Cartesian pnt_mid41 = (surface._pnt4 + surface._pnt1) / 2.0;
			Point3Cartesian center = surface.getCenter();

			RectSurface3D s1(surface._pnt1, pnt_mid12, center, pnt_mid41);
			RectSurface3D s2(pnt_mid12, surface._pnt2, pnt_mid23, center);
			RectSurface3D s3(center, pnt_mid23, surface._pnt3, pnt_mid34);
			RectSurface3D s4(pnt_mid41, center, pnt_mid34, surface._pnt4);

			// Calculate contributions for each subsurface
			Real contrib1 = CalcSurfaceContrib(vectorField, s1);
			Real contrib2 = CalcSurfaceContrib(vectorField, s2);
			Real contrib3 = CalcSurfaceContrib(vectorField, s3);
			Real contrib4 = CalcSurfaceContrib(vectorField, s4);
			Real result = contrib1 + contrib2 + contrib3 + contrib4;

			// compare to prev_value - if converged or max level reached, return result
			if (fabs(result - prev_value) < eps || level == 0)
			{
				return result;
			}
			else
			{
				// Need more refinement - recursively improve each subsurface
				Real new_result = 0.0;

				new_result += SurfaceIntegralImproveRecursively(vectorField, s1, contrib1, eps, level - 1);
				new_result += SurfaceIntegralImproveRecursively(vectorField, s2, contrib2, eps, level - 1);
				new_result += SurfaceIntegralImproveRecursively(vectorField, s3, contrib3, eps, level - 1);
				new_result += SurfaceIntegralImproveRecursively(vectorField, s4, contrib4, eps, level - 1);

				return new_result;
			}
		}

		static Real CalcSurfaceContrib(const IVectorFunction<3>& vectorField, const RectSurface3D& surface)
		{
			Real result = 0.0;
			Vector3Cartesian    normal = surface.getNormal();
			Real area = surface.getArea();
			Point3Cartesian    center = surface.getCenter();

			Vector3Cartesian    value = vectorField(Vector3Cartesian(center.X(), center.Y(), center.Z()));

			Real dotProduct = ScalarProduct(normal, value);

			result = dotProduct * area;

			return result;
		}
	};
} // end namespace


///////////////////////////   mml/core/FunctionHelpers.h   ///////////////////////////





namespace MML
{
	///////////////////////////////////////////////////////////////////////////////////////////
	///                              TAYLOR SERIES EXPANSION                                ///
	///////////////////////////////////////////////////////////////////////////////////////////
	// Compute polynomial approximation of f(x) around point a using Taylor expansion:
	// f(x) â‰ˆ f(a) + f'(a)(x-a) + f''(a)(x-a)Â²/2! + f'''(a)(x-a)Â³/3! + ...
	// 
	// Note on derivative accuracy: Higher derivatives use lower-order methods because
	// they require more function evaluations. This balances accuracy with efficiency.
	///////////////////////////////////////////////////////////////////////////////////////////

	inline PolynomRealFunc TaylorSeries2(const IRealFunction& f, Real a)
	{
		PolynomRealFunc ret(2);

		Real val = f(a);
		Real coef1 = Derivation::NDer6(f, a);           // f'(a), 6th order accuracy
		Real coef2 = Derivation::NSecDer4(f, a) / 2.0;  // f''(a)/2!, 4th order accuracy

		// Convert from Taylor form to standard polynomial: p(x) = c0 + c1*x + c2*xÂ²
		ret[0] = val - coef1 * a + coef2 * POW2(a);
		ret[1] = coef1 - 2.0 * coef2 * a;
		ret[2] = coef2;

		return ret;
	}

	inline PolynomRealFunc TaylorSeries3(const IRealFunction& f, Real a)
	{
		PolynomRealFunc ret(3);

		Real val = f(a);
		Real coef1 = Derivation::NDer6(f, a);            // f'(a), 6th order accuracy
		Real coef2 = Derivation::NSecDer4(f, a) / 2.0;   // f''(a)/2!, 4th order accuracy
		Real coef3 = Derivation::NThirdDer2(f, a) / 6.0; // f'''(a)/3!, 2nd order accuracy

		// Convert from Taylor form to standard polynomial: p(x) = c0 + c1*x + c2*xÂ² + c3*xÂ³
		ret[0] = val - coef1 * a + coef2 * POW2(a) - coef3 * pow(a, 3);
		ret[1] = coef1 - 2.0 * coef2 * a + 3.0 * coef3 * POW2(a);
		ret[2] = coef2 - 3.0 * coef3 * a;
		ret[3] = coef3;

		return ret;
	}

	// Note: TaylorSeries4 is not implemented because Derivation doesn't have NFourthDer
	// If fourth derivative support is added to Derivation.h, TaylorSeries4 can be added here.

	///////////////////////////////////////////////////////////////////////////////////////////
	///                         FIRST DERIVATIVE WRAPPER CLASSES                            ///
	///////////////////////////////////////////////////////////////////////////////////////////
	// These classes wrap a function and return its numerical derivative.
	// The number suffix indicates the order of accuracy of the numerical method.
	// 
	// WARNING: These store a reference to the original function. Ensure the original
	// function outlives these wrapper objects to avoid dangling references.
	///////////////////////////////////////////////////////////////////////////////////////////

	class RealFuncDerived1 : public IRealFunction
	{
		const IRealFunction& _f;
		Real _step;
	public:
		RealFuncDerived1(const IRealFunction& f) : _f(f), _step(0.0) {}
		RealFuncDerived1(const IRealFunction& f, Real step) : _f(f), _step(step) {}

		Real operator()(Real x) const {
			return _step != 0.0 ? Derivation::NDer1(_f, x, _step) : Derivation::NDer1(_f, x);
		}
	};

	class RealFuncDerived2 : public IRealFunction
	{
		const IRealFunction& _f;
		Real _step;
	public:
		RealFuncDerived2(const IRealFunction& f) : _f(f), _step(0.0) {}
		RealFuncDerived2(const IRealFunction& f, Real step) : _f(f), _step(step) {}

		Real operator()(Real x) const {
			return _step != 0.0 ? Derivation::NDer2(_f, x, _step) : Derivation::NDer2(_f, x);
		}
	};

	class RealFuncDerived4 : public IRealFunction
	{
		const IRealFunction& _f;
		Real _step;
	public:
		RealFuncDerived4(const IRealFunction& f) : _f(f), _step(0.0) {}
		RealFuncDerived4(const IRealFunction& f, Real step) : _f(f), _step(step) {}

		Real operator()(Real x) const {
			return _step != 0.0 ? Derivation::NDer4(_f, x, _step) : Derivation::NDer4(_f, x);
		}
	};

	class RealFuncDerived6 : public IRealFunction
	{
		const IRealFunction& _f;
		Real _step;
	public:
		RealFuncDerived6(const IRealFunction& f) : _f(f), _step(0.0) {}
		RealFuncDerived6(const IRealFunction& f, Real step) : _f(f), _step(step) {}

		Real operator()(Real x) const {
			return _step != 0.0 ? Derivation::NDer6(_f, x, _step) : Derivation::NDer6(_f, x);
		}
	};

	class RealFuncDerived8 : public IRealFunction
	{
		const IRealFunction& _f;
		Real _step;
	public:
		RealFuncDerived8(const IRealFunction& f) : _f(f), _step(0.0) {}
		RealFuncDerived8(const IRealFunction& f, Real step) : _f(f), _step(step) {}

		Real operator()(Real x) const {
			return _step != 0.0 ? Derivation::NDer8(_f, x, _step) : Derivation::NDer8(_f, x);
		}
	};

	///////////////////////////////////////////////////////////////////////////////////////////
	///                        SECOND DERIVATIVE WRAPPER CLASSES                            ///
	///////////////////////////////////////////////////////////////////////////////////////////

	class RealFuncSecondDerived2 : public IRealFunction
	{
		const IRealFunction& _f;
		Real _step;
	public:
		RealFuncSecondDerived2(const IRealFunction& f) : _f(f), _step(0.0) {}
		RealFuncSecondDerived2(const IRealFunction& f, Real step) : _f(f), _step(step) {}

		Real operator()(Real x) const {
			return _step != 0.0 ? Derivation::NSecDer2(_f, x, _step) : Derivation::NSecDer2(_f, x);
		}
	};

	class RealFuncSecondDerived4 : public IRealFunction
	{
		const IRealFunction& _f;
		Real _step;
	public:
		RealFuncSecondDerived4(const IRealFunction& f) : _f(f), _step(0.0) {}
		RealFuncSecondDerived4(const IRealFunction& f, Real step) : _f(f), _step(step) {}

		Real operator()(Real x) const {
			return _step != 0.0 ? Derivation::NSecDer4(_f, x, _step) : Derivation::NSecDer4(_f, x);
		}
	};

	class RealFuncSecondDerived6 : public IRealFunction
	{
		const IRealFunction& _f;
		Real _step;
	public:
		RealFuncSecondDerived6(const IRealFunction& f) : _f(f), _step(0.0) {}
		RealFuncSecondDerived6(const IRealFunction& f, Real step) : _f(f), _step(step) {}

		Real operator()(Real x) const {
			return _step != 0.0 ? Derivation::NSecDer4(_f, x, _step, nullptr) : Derivation::NSecDer4(_f, x, nullptr);
		}
	};

	///////////////////////////////////////////////////////////////////////////////////////////
	///                      FUNCTION ARITHMETIC HELPER CLASSES                             ///
	///////////////////////////////////////////////////////////////////////////////////////////
	// Classes for performing arithmetic operations on functions.
	// All classes store references - ensure original functions outlive these wrappers.
	///////////////////////////////////////////////////////////////////////////////////////////

	// Sum: h(x) = f(x) + g(x)
	class RealFuncSum : public IRealFunction
	{
		const IRealFunction& _f1;
		const IRealFunction& _f2;
	public:
		RealFuncSum(const IRealFunction& f1, const IRealFunction& f2) : _f1(f1), _f2(f2) {}
		Real operator()(Real x) const { return _f1(x) + _f2(x); }
	};

	// Difference: h(x) = f(x) - g(x)
	class RealFuncDiff : public IRealFunction
	{
		const IRealFunction& _f1;
		const IRealFunction& _f2;
	public:
		RealFuncDiff(const IRealFunction& f1, const IRealFunction& f2) : _f1(f1), _f2(f2) {}
		Real operator()(Real x) const { return _f1(x) - _f2(x); }
	};
	// Backward compatibility alias
	using RealFuncDiffHelper = RealFuncDiff;

	// Product: h(x) = f(x) * g(x)
	class RealFuncProduct : public IRealFunction
	{
		const IRealFunction& _f1;
		const IRealFunction& _f2;
	public:
		RealFuncProduct(const IRealFunction& f1, const IRealFunction& f2) : _f1(f1), _f2(f2) {}
		Real operator()(Real x) const { return _f1(x) * _f2(x); }
	};

	// Quotient: h(x) = f(x) / g(x)
	// WARNING: No division-by-zero check for performance. Ensure g(x) â‰  0 in your domain.
	class RealFuncQuotient : public IRealFunction
	{
		const IRealFunction& _f1;
		const IRealFunction& _f2;
	public:
		RealFuncQuotient(const IRealFunction& f1, const IRealFunction& f2) : _f1(f1), _f2(f2) {}
		Real operator()(Real x) const { return _f1(x) / _f2(x); }
	};

	// Composition: h(x) = f(g(x))
	class RealFuncCompose : public IRealFunction
	{
		const IRealFunction& _outer;  // f
		const IRealFunction& _inner;  // g
	public:
		RealFuncCompose(const IRealFunction& outer, const IRealFunction& inner) 
			: _outer(outer), _inner(inner) {}
		Real operator()(Real x) const { return _outer(_inner(x)); }
	};

	// Scalar multiplication: h(x) = c * f(x)
	class RealFuncScale : public IRealFunction
	{
		const IRealFunction& _f;
		Real _scale;
	public:
		RealFuncScale(const IRealFunction& f, Real scale) : _f(f), _scale(scale) {}
		Real operator()(Real x) const { return _scale * _f(x); }
	};

	// Scalar addition (shift): h(x) = f(x) + c
	class RealFuncShift : public IRealFunction
	{
		const IRealFunction& _f;
		Real _shift;
	public:
		RealFuncShift(const IRealFunction& f, Real shift) : _f(f), _shift(shift) {}
		Real operator()(Real x) const { return _f(x) + _shift; }
	};

	// Negation: h(x) = -f(x)
	class RealFuncNegate : public IRealFunction
	{
		const IRealFunction& _f;
	public:
		RealFuncNegate(const IRealFunction& f) : _f(f) {}
		Real operator()(Real x) const { return -_f(x); }
	};

	// Absolute value: h(x) = |f(x)|
	class RealFuncAbs : public IRealFunction
	{
		const IRealFunction& _f;
	public:
		RealFuncAbs(const IRealFunction& f) : _f(f) {}
		Real operator()(Real x) const { return std::abs(_f(x)); }
	};

	// Power: h(x) = f(x)^n
	class RealFuncPow : public IRealFunction
	{
		const IRealFunction& _f;
		Real _power;
	public:
		RealFuncPow(const IRealFunction& f, Real power) : _f(f), _power(power) {}
		Real operator()(Real x) const { return std::pow(_f(x), _power); }
	};

	///////////////////////////////////////////////////////////////////////////////////////////
	///                        COMPARISON / DISTANCE HELPER CLASSES                         ///
	///////////////////////////////////////////////////////////////////////////////////////////
	// Useful for computing norms and comparing functions.
	///////////////////////////////////////////////////////////////////////////////////////////

	// Absolute difference: h(x) = |f(x) - g(x)|
	class RealFuncAbsDiff : public IRealFunction
	{
		const IRealFunction& _f1;
		const IRealFunction& _f2;
	public:
		RealFuncAbsDiff(const IRealFunction& f1, const IRealFunction& f2) : _f1(f1), _f2(f2) {}
		Real operator()(Real x) const { return std::abs(_f1(x) - _f2(x)); }
	};
	// Backward compatibility alias
	using RealFuncAbsDiffHelper = RealFuncAbsDiff;

	// Squared difference: h(x) = (f(x) - g(x))Â²
	// Useful for LÂ² norm computation
	class RealFuncDiffSqr : public IRealFunction
	{
		const IRealFunction& _f1;
		const IRealFunction& _f2;
	public:
		RealFuncDiffSqr(const IRealFunction& f1, const IRealFunction& f2) : _f1(f1), _f2(f2) {}
		Real operator()(Real x) const { return POW2(_f1(x) - _f2(x)); }
	};
	// Backward compatibility alias
	using RealFuncDiffSqrHelper = RealFuncDiffSqr;

} // end namespace


///////////////////////////   mml/core/MetricTensor.h   ///////////////////////////




namespace MML
{
	template<int N>
	class MetricTensorField : public ITensorField2<N>
	{
	public:
		MetricTensorField() : ITensorField2<N>(2, 0) { }
		MetricTensorField(int numContra, int numCo) : ITensorField2<N>(numContra, numCo) { }

		// implementing operator() required by IFunction interface
		virtual Tensor2<N>   operator()(const VectorN<Real, N>& pos) const override
		{
			Tensor2<N> ret(this->getNumContravar(), this->getNumCovar());

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					ret(i, j) = this->Component(i, j, pos);

			return ret;
		}

		// Get the covariant metric tensor components at a point (gáµ¢â±¼)
		MatrixNM<Real, N, N> GetCovariantMetric(const VectorN<Real, N>& pos) const
		{
			MatrixNM<Real, N, N> g_covar;
			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					g_covar[i][j] = this->Component(i, j, pos);
			return g_covar;
		}

		// Get the contravariant metric tensor components at a point (gâ±Ê² = inverse of gáµ¢â±¼)
		MatrixNM<Real, N, N> GetContravariantMetric(const VectorN<Real, N>& pos) const
		{
			MatrixNM<Real, N, N> g_covar = GetCovariantMetric(pos);
			return g_covar.GetInverse();
		}

		Real GetChristoffelSymbolFirstKind(int i, int j, int k, const VectorN<Real, N>& pos) const
		{
			const MetricTensorField<N>& g = *this;

			Real gamma_ijk = 0.0;
			for (int m = 0; m < N; m++)
			{
				gamma_ijk += g.Component(m, k, pos) * GetChristoffelSymbolSecondKind(m, i, j, pos);
			}
			return gamma_ijk;
		}
		Real GetChristoffelSymbolSecondKind(int i, int j, int k, const VectorN<Real, N>& pos) const
		{
			const MetricTensorField<N>& g = *this;

			// Î“â±â±¼â‚– = Â½ gâ±Ë¡ (âˆ‚â±¼gâ‚—â‚– + âˆ‚â‚–gâ‚—â±¼ - âˆ‚â‚—gâ±¼â‚–)
			// Need contravariant metric gâ±Ë¡ to raise the index
			MatrixNM<Real, N, N> g_contravar = GetContravariantMetric(pos);

			Real gamma_ijk = 0.0;
			for (int l = 0; l < N; l++)
			{
				Real coef1 = Derivation::NDer4Partial<N>(g, l, k, j, pos, nullptr);  // âˆ‚â±¼gâ‚—â‚–
				Real coef2 = Derivation::NDer4Partial<N>(g, l, j, k, pos, nullptr);  // âˆ‚â‚–gâ‚—â±¼
				Real coef3 = Derivation::NDer4Partial<N>(g, j, k, l, pos, nullptr);  // âˆ‚â‚—gâ±¼â‚–

				gamma_ijk += 0.5 * g_contravar[i][l] * (coef1 + coef2 - coef3);
			}
			return gamma_ijk;
		}

		VectorN<Real, N> CovariantDerivativeContravar(const IVectorFunction<N>& func, int j, 
																									const VectorN<Real, N>& pos) const
		{
			VectorN<Real, N> ret;
			VectorN<Real, N> vec_val = func(pos);

			for (int i = 0; i < N; i++) {
				Real comp_val = Derivation::DeriveVecPartial<N>(func, i, j, pos, nullptr);

				for (int k = 0; k < N; k++)
					comp_val += GetChristoffelSymbolSecondKind(i, k, j, pos) * vec_val[k];

				ret[i] = comp_val;
			}
			return ret;
		}
		Real CovariantDerivativeContravarComp(const IVectorFunction<N>& func, int i, int j, 
																					const VectorN<Real, N>& pos) const
		{
			Real ret = Derivation::DeriveVecPartial<N>(func, i, j, pos, nullptr);

			for (int k = 0; k < N; k++)
				ret += GetChristoffelSymbolSecondKind(i, k, j, pos) * func(pos)[k];

			return ret;
		}

		VectorN<Real, N> CovariantDerivativeCovar(const IVectorFunction<N>& func, int j, 
																							const VectorN<Real, N>& pos) const
		{
			VectorN<Real, N> ret;
			VectorN<Real, N> vec_val = func(pos);

			for (int i = 0; i < N; i++) {
				Real comp_val = Derivation::DeriveVecPartial<N>(func, i, j, pos, nullptr);

				for (int k = 0; k < N; k++)
					comp_val -= GetChristoffelSymbolSecondKind(k, i, j, pos) * vec_val[k];

				ret[i] = comp_val;
			}
			return ret;
		}
		Real CovariantDerivativeCovarComp(const IVectorFunction<N>& func, int i, int j, 
																			const VectorN<Real, N>& pos) const
		{
			Real comp_val = Derivation::DeriveVecPartial<N>(func, i, j, pos, nullptr);

			for (int k = 0; k < N; k++)
				comp_val -= GetChristoffelSymbolSecondKind(k, i, j, pos) * func(pos)[k];

			return comp_val;
		}
	};

	class MetricTensorCartesian3D : public MetricTensorField<3>
	{
	public:
		MetricTensorCartesian3D() : MetricTensorField<3>(2, 0) { }

		Real Component(int i, int j, const VectorN<Real, 3>& pos) const
		{
			if (i == j)
				return 1.0;
			else
				return 0.0;
		}
	};

	class MetricTensorSpherical : public MetricTensorField<3>
	{
	public:
		MetricTensorSpherical() : MetricTensorField<3>(0, 2) { }

		virtual  Real Component(int i, int j, const VectorN<Real, 3>& pos) const override
		{
			if (i == 0 && j == 0)
				return 1.0;
			else if (i == 1 && j == 1)
				return POW2(pos[0]);
			else if (i == 2 && j == 2)
				return pos[0] * pos[0] * sin(pos[1]) * sin(pos[1]);
			else
				return 0.0;
		}
	};
	class MetricTensorSphericalContravar : public MetricTensorField<3>
	{
	public:
		MetricTensorSphericalContravar() : MetricTensorField<3>(2, 0) { }

		virtual Real Component(int i, int j, const VectorN<Real, 3>& pos) const
		{
			if (i == 0 && j == 0)
				return 1.0;
			else if (i == 1 && j == 1)
				return 1 / (pos[0] * pos[0]);
			else if (i == 2 && j == 2)
				return 1 / (pos[0] * pos[0] * sin(pos[1]) * sin(pos[1]));
			else
				return 0.0;
		}
	};
	class MetricTensorCylindrical : public MetricTensorField<3>
	{
	public:
		MetricTensorCylindrical() : MetricTensorField<3>(2, 0) { }

		virtual Real Component(int i, int j, const VectorN<Real, 3>& pos) const
		{
			if (i == 0 && j == 0)
				return 1.0;
			else if (i == 1 && j == 1)
				return pos[0] * pos[0];
			else if (i == 2 && j == 2)
				return 1.0;
			else
				return 0.0;
		}
	};

	template<typename VectorFrom, typename VectorTo, int N>
	class MetricTensorFromCoordTransf : public MetricTensorField<N>
	{
		const ICoordTransfWithInverse<VectorFrom, VectorTo, N>& _coordTransf;

	public:
		MetricTensorFromCoordTransf(ICoordTransfWithInverse<VectorFrom, VectorTo, N>& inTransf) : _coordTransf(inTransf)
		{ }

		virtual Real Component(int i, int j, const VectorN<Real, N>& pos) const
		{
			Real g_ij = 0.0;
			for (int k = 0; k < N; k++)
			{
				auto der_k_by_i = Derivation::DerivePartial<N>(_coordTransf.coordTransfFunc(k), i, pos, nullptr);
				auto der_k_by_j = Derivation::DerivePartial<N>(_coordTransf.coordTransfFunc(k), j, pos, nullptr);

				g_ij += der_k_by_i * der_k_by_j;
			}
			return g_ij;
		}
	};

	class MetricTensorMinkowski : public MetricTensorField<4>
	{
	public:
		MetricTensorMinkowski() : MetricTensorField<4>(2, 0) {}

		virtual Real Component(int i, int j, const VectorN<Real, 4>& pos) const override
		{
			if (i == 0 && j == 0)
				return -1.0;
			else if (i == 1 && j == 1)
				return 1.0;
			else if (i == 2 && j == 2)
				return 1.0;
			else if (i == 3 && j == 3)
				return 1.0;
			else
				return 0.0;
		}
	};
}

///////////////////////////   mml/core/Fields.h   ///////////////////////////


#ifdef MML_USE_SINGLE_HEADER
#else



#endif


namespace MML::Fields
{
	////////////////////             INVERSE RADIAL FIELD                /////////////////
	// Potential fields
	static Real InverseRadialPotentialFieldCart(const VectorN<Real, 3>& x) { return 1.0 / x.NormL2(); }
	static Real InverseRadialPotentialFieldCart(Real constant, const VectorN<Real, 3>& x) { return constant / x.NormL2(); }
	static Real InverseRadialPotentialFieldSpher(const VectorN<Real, 3>& x) { return 1.0 / x[0]; }
	static Real InverseRadialPotentialFieldSpher(Real constant, const VectorN<Real, 3>& x) { return constant / x[0]; }
	static Real InverseRadialPotentialFieldCyl(const VectorN<Real, 3>& x) { return 1.0 / sqrt(x[0] * x[0] + x[2] * x[2]); }
	static Real InverseRadialPotentialFieldCyl(Real constant, const VectorN<Real, 3>& x) { return constant / sqrt(x[0] * x[0] + x[2] * x[2]); }

	// Force fields
	// NOTE: Cannot change to Vector3Cartesian - VectorFunction<3> interface requires VectorN<Real,3> function pointers
	static VectorN<Real, 3> InverseRadialPotentialForceFieldCart(const VectorN<Real, 3>& x)
	{
		return (-1) * x / std::pow((x).NormL2(), 3);
	}
	static VectorN<Real, 3> InverseRadialPotentialForceFieldCart(Real constant, const VectorN<Real, 3>& x)
	{
		return -constant * x / std::pow((x).NormL2(), 3);
	}
	// can't be Vector3Spherical, because in that case we can't form a ScalarFunction<3> out of it :()
	static VectorN<Real, 3> InverseRadialPotentialForceFieldSph(const VectorN<Real, 3>& x)
	{
		return VectorN<Real, 3>{-1 / (x[0] * x[0]), 0.0, 0.0};
	}
	static VectorN<Real, 3> InverseRadialPotentialForceFieldSph(Real constant, const VectorN<Real, 3>& x)
	{
		return VectorN<Real, 3>{-constant / (x[0] * x[0]), 0.0, 0.0};
	}

	class InverseRadialFieldCart : public IScalarFunction<3>
	{
	protected:
		Real _constant;
	public:
		InverseRadialFieldCart() : _constant(-1.0) {}
		InverseRadialFieldCart(Real constant) : _constant(constant) {}

		Real operator()(const VectorN<Real, 3>& x) const { return _constant * Fields::InverseRadialPotentialFieldCart(x); }
	};
	class InverseRadialFieldSpher : public IScalarFunction<3>
	{
	protected:
		Real _constant;
	public:
		InverseRadialFieldSpher() : _constant(-1.0) {}
		InverseRadialFieldSpher(Real constant) : _constant(constant) {}

		Real operator()(const VectorN<Real, 3>& x) const { return _constant * InverseRadialPotentialFieldSpher(x); }
	};

	class InverseRadialForceFieldCart : public IVectorFunction<3>
	{
	private:
		Real _constant;
	public:
		InverseRadialForceFieldCart() : _constant(-1.0) {}
		InverseRadialForceFieldCart(Real constant) : _constant(constant) {}

		VectorN<Real, 3> operator()(const VectorN<Real, 3>& x) const { return _constant * Fields::InverseRadialPotentialForceFieldCart(x); }
	};
	class InverseRadialForceFieldSpher : public IVectorFunction<3>
	{
	private:
		Real _constant;
	public:
		InverseRadialForceFieldSpher() : _constant(-1.0) {}
		InverseRadialForceFieldSpher(Real constant) : _constant(constant) {}

		VectorN<Real, 3> operator()(const VectorN<Real, 3>& x) const { return _constant * InverseRadialPotentialForceFieldSph(x); }
	};
	// TODO - dodati multibody gravity
	// TODO - dodati InfiniteLineCurrentField
	// TODO - dodati InfinitePlaneCurrentField

}


///////////////////////////   mml/core/CoordTransf.h   ///////////////////////////





namespace MML
{
	template<typename VectorFrom, typename VectorTo, int N>
	class CoordTransf : public virtual ICoordTransf<VectorFrom, VectorTo, N>
	{
	public:
		// inherited from IVectorFunction
		VectorN<Real, N> operator()(const VectorN<Real, N>& x) const
    {
      VectorN<Real, N> ret;
      for (int i = 0; i < N; i++)
        ret[i] = this->coordTransfFunc(i)(x);
      return ret;
    }

		virtual VectorTo   getBasisVec(int ind, const VectorFrom& pos)
		{
			VectorTo ret;

			for (int i = 0; i < N; i++)
				ret[i] = Derivation::NDer4Partial(this->coordTransfFunc(i), ind, pos);

			return ret;
		}
		virtual VectorFrom getInverseBasisVec(int ind, const VectorFrom& pos)
		{
			VectorFrom ret;

			for (int i = 0; i < N; i++)
				ret[i] = Derivation::NDer4Partial(this->coordTransfFunc(ind), i, pos);

			return ret;
		}

		MatrixNM<Real, N, N> jacobian(const VectorN<Real, N>& pos)
		{
			MatrixNM<Real, N, N> jac;

			for (int i = 0; i < N; ++i)
				for (int j = 0; j < N; ++j)
				{
					jac(i, j) = Derivation::NDer4Partial(this->coordTransfFunc(i), j, pos);
				}

			return jac;
		}

		VectorTo   transfVecContravariant(const VectorFrom& vec, const VectorFrom& pos)
		{
			VectorFrom ret;
			for (int i = 0; i < N; i++) {
				ret[i] = 0;
				for (int j = 0; j < N; j++)
					ret[i] += Derivation::NDer4Partial(this->coordTransfFunc(i), j, pos) * vec[j];
			}
			return ret;
		}
		VectorFrom transfInverseVecCovariant(const VectorTo& vec, const VectorFrom& pos)
		{
			VectorFrom ret;
			for (int i = 0; i < N; i++)
			{
				ret[i] = 0;
				for (int j = 0; j < N; j++)
					ret[i] += Derivation::NDer4Partial(this->coordTransfFunc(j), i, pos) * vec[j];
			}
			return ret;
		}
	};
 
	template<typename VectorFrom, typename VectorTo, int N>
	class CoordTransfWithInverse : public virtual CoordTransf<VectorFrom, VectorTo, N>,
																 public virtual ICoordTransfWithInverse<VectorFrom, VectorTo, N>
	{
	public:
		virtual VectorFrom getContravarBasisVec(int ind, const VectorTo& pos)
		{
			VectorFrom ret;

			for (int i = 0; i < N; i++)
				ret[i] = Derivation::NDer4Partial(this->inverseCoordTransfFunc(ind), i, pos);

			return ret;
		}
		virtual VectorTo   getInverseContravarBasisVec(int ind, const VectorTo& pos)
		{
			VectorFrom ret;

			for (int i = 0; i < N; i++)
				ret[i] = Derivation::NDer4Partial(this->inverseCoordTransfFunc(i), ind, pos);

			return ret;
		}

		VectorTo   transfVecCovariant(const VectorFrom& vec, const VectorTo& pos)
		{
			VectorTo ret;
			for (int i = 0; i < N; i++)
			{
				ret[i] = 0;
				for (int j = 0; j < N; j++)
					ret[i] += Derivation::NDer4Partial(this->inverseCoordTransfFunc(j), i, pos) * vec[j];
			}

			return ret;
		}
		VectorFrom transfInverseVecContravariant(const VectorTo& vec, const VectorTo& pos)
		{
			VectorFrom ret;
			for (int i = 0; i < N; i++)
			{
				ret[i] = 0;
				for (int j = 0; j < N; j++)
					ret[i] += Derivation::NDer4Partial(this->inverseCoordTransfFunc(i), j, pos, PrecisionValues<Real>::DerivativeStepSize) * vec[j];
			}

			return ret;
		}

		Tensor2<N> transfTensor2(const Tensor2<N>& tensor, const VectorFrom& pos)
		{
			Tensor2<N> ret(tensor.NumContravar(), tensor.NumCovar());

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
				{
					ret(i, j) = 0;
					for (int k = 0; k < N; k++)
						for (int l = 0; l < N; l++)
						{
							double coef1, coef2;
							if (tensor._isContravar[0])
								coef1 = Derivation::NDer1Partial(this->coordTransfFunc(i), k, pos);
							else
								coef1 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(k), i, pos);

							if (tensor._isContravar[1])
								coef2 = Derivation::NDer1Partial(this->coordTransfFunc(j), l, pos);
							else
								coef2 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(l), j, pos);

							ret(i, j) += coef1 * coef2 * tensor(k, l);
						}
				}

			return ret;
		}
		Tensor3<N> transfTensor3(const Tensor3<N>& tensor, const VectorFrom& pos)
		{
			Tensor3<N> ret(tensor.NumContravar(), tensor.NumCovar());

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					for (int k = 0; k < N; k++)
					{
						ret.Component(i, j, k) = 0;
						for (int l = 0; l < N; l++)
							for (int m = 0; m < N; m++)
								for (int n = 0; n < N; n++)
								{
									double coef1, coef2, coef3;
									if (tensor._isContravar[0])
										coef1 = Derivation::NDer1Partial(this->coordTransfFunc(i), l, pos);
									else
										coef1 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(l), i, pos);

									if (tensor._isContravar[1])
										coef2 = Derivation::NDer1Partial(this->coordTransfFunc(j), m, pos);
									else
										coef2 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(m), j, pos);

									if (tensor._isContravar[2])
										coef3 = Derivation::NDer1Partial(this->coordTransfFunc(k), n, pos);
									else
										coef3 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(n), k, pos);

									ret.Component(i, j, k) += coef1 * coef2 * coef3 * tensor.Component(l, m, n);
								}
					}

			return ret;
		}
		Tensor4<N> transfTensor4(const Tensor4<N>& tensor, const VectorFrom& pos)
		{
			Tensor4<N> ret(tensor.NumContravar(), tensor.NumCovar());

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					for (int k = 0; k < N; k++)
						for (int l = 0; l < N; l++)
						{
							ret[i][j][k][l] = 0;
							for (int m = 0; m < N; m++)
								for (int n = 0; n < N; n++)
									for (int o = 0; o < N; o++)
										for (int p = 0; p < N; p++)
										{
											double coef1, coef2, coef3, coef4;
											if (tensor._isContravar[0])
												coef1 = Derivation::NDer1Partial(this->coordTransfFunc(i), m, pos);
											else
												coef1 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(m), i, pos);

											if (tensor._isContravar[1])
												coef2 = Derivation::NDer1Partial(this->coordTransfFunc(j), n, pos);
											else
												coef2 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(n), j, pos);

											if (tensor._isContravar[2])
												coef3 = Derivation::NDer1Partial(this->coordTransfFunc(k), o, pos);
											else
												coef3 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(o), k, pos);

											if (tensor._isContravar[3])
												coef4 = Derivation::NDer1Partial(this->coordTransfFunc(l), p, pos);
											else
												coef4 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(p), l, pos);

											ret[i][j][k][l] += coef1 * coef2 * coef3 * coef4 * tensor[m][n][o][p];
										}
						}

			return ret;
		}
		Tensor5<N> transfTensor5(const Tensor5<N>& tensor, const VectorFrom& pos)
		{
			Tensor5<N> ret(tensor.NumContravar(), tensor.NumCovar());

			for (int i = 0; i < N; i++)
				for (int j = 0; j < N; j++)
					for (int k = 0; k < N; k++)
						for (int l = 0; l < N; l++)
							for (int m = 0; m < N; m++)
							{
								ret[i][j][k][l][m] = 0;
								for (int n = 0; n < N; n++)
									for (int o = 0; o < N; o++)
										for (int p = 0; p < N; p++)
											for (int q = 0; q < N; q++)
												for (int r = 0; r < N; r++)
												{
													double coef1, coef2, coef3, coef4, coef5;
													if (tensor._isContravar[0])
														coef1 = Derivation::NDer1Partial(this->coordTransfFunc(i), n, pos);
													else
														coef1 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(n), i, pos);

													if (tensor._isContravar[1])
														coef2 = Derivation::NDer1Partial(this->coordTransfFunc(j), o, pos);
													else
														coef2 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(o), j, pos);

													if (tensor._isContravar[2])
														coef3 = Derivation::NDer1Partial(this->coordTransfFunc(k), p, pos);
													else
														coef3 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(p), k, pos);

													if (tensor._isContravar[3])
														coef4 = Derivation::NDer1Partial(this->coordTransfFunc(l), q, pos);
													else
														coef4 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(q), l, pos);

													if (tensor._isContravar[4])
														coef4 = Derivation::NDer1Partial(this->coordTransfFunc(m), r, pos);
													else
														coef4 = Derivation::NDer1Partial(this->inverseCoordTransfFunc(r), m, pos);

													ret[i][j][k][l][m] += coef1 * coef2 * coef3 * coef4 * coef5 * tensor[n][o][p][q][r];
												}
							}

			return ret;
		}
	};
}


///////////////////////////   mml/core/CoordTransf/CoordTransf2D.h   ///////////////////////////




namespace MML
{
	class CoordTransfPolarToCartesian2D : public CoordTransfWithInverse<Vector2Polar, Vector2Cartesian, 2>
	{
		// q[0] = r     - radial distance
		// q[1] = phi   - polar angle
	public:
		static Real func1(const VectorN<Real, 2>& q) { return q[0] * cos(q[1]); }
		static Real func2(const VectorN<Real, 2>& q) { return q[0] * sin(q[1]); }

		// q[0] = x
		// q[1] = y
		static Real funcInverse1(const VectorN<Real, 2>& q) { return sqrt(q[0] * q[0] + q[1] * q[1]); }
		static Real funcInverse2(const VectorN<Real, 2>& q) { return atan2(q[1], q[0]); }

		inline static ScalarFunction<2> _func[2] = { ScalarFunction<2>{func1},
																								 ScalarFunction<2>{func2}
		};

		inline static ScalarFunction<2> _funcInverse[2] = { ScalarFunction<2>{funcInverse1},
																												ScalarFunction<2>{funcInverse2}
		};

		Vector2Cartesian     transf(const Vector2Polar& q) const { return Vector2Cartesian{ func1(q), func2(q) }; }
		Vector2Polar         transfInverse(const Vector2Cartesian& q) const { return Vector2Polar{ funcInverse1(q), funcInverse2(q) }; }

		const IScalarFunction<2>& coordTransfFunc(int i) const { return _func[i]; }
		const IScalarFunction<2>& inverseCoordTransfFunc(int i) const { return _funcInverse[i]; }
	};

	class CoordTransfCart2DRotation : public CoordTransfWithInverse<Vector2Cartesian, Vector2Cartesian, 2>
	{
	private:
		Real    _angle;
		MatrixNM<Real, 2, 2>  _transf;
		MatrixNM<Real, 2, 2>  _inverse;

		const ScalarFunctionFromStdFunc<2> _f1;
		const ScalarFunctionFromStdFunc<2> _f2;

		const ScalarFunctionFromStdFunc<2> _fInverse1;
		const ScalarFunctionFromStdFunc<2> _fInverse2;

	public:
		CoordTransfCart2DRotation(Real inAngle) : 
			_angle(inAngle),
			_f1([this](const VectorN<Real, 2>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 2>& q) { return func2(q); }),
			_fInverse1([this](const VectorN<Real, 2>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 2>& q) { return funcInverse2(q); })
			//_angle(inAngle),
			//_f1(std::function<Real(const VectorN<Real, 2>&)> { std::bind(&CoordTransfCart2DRotation::func1, this, std::placeholders::_1) }),
			//_f2(std::function<Real(const VectorN<Real, 2>&)> { std::bind(&CoordTransfCart2DRotation::func2, this, std::placeholders::_1) }),
			//_fInverse1(std::function<Real(const VectorN<Real, 2>&)> { std::bind(&CoordTransfCart2DRotation::funcInverse1, this, std::placeholders::_1) }),
			//_fInverse2(std::function<Real(const VectorN<Real, 2>&)> { std::bind(&CoordTransfCart2DRotation::funcInverse2, this, std::placeholders::_1) })
		{
			_transf[0][0] = cos(_angle);
			_transf[0][1] = -sin(_angle);
			_transf[1][0] = sin(_angle);
			_transf[1][1] = cos(_angle);

			_inverse[0][0] = cos(_angle);
			_inverse[0][1] = sin(_angle);
			_inverse[1][0] = -sin(_angle);
			_inverse[1][1] = cos(_angle);
		}

		Real func1(const VectorN<Real, 2>& q) const { return _transf[0][0] * q[0] + _transf[0][1] * q[1]; }
		Real func2(const VectorN<Real, 2>& q) const { return (_transf * q)[1]; }

		Real funcInverse1(const VectorN<Real, 2>& q) const { return (_inverse * q)[0]; }
		Real funcInverse2(const VectorN<Real, 2>& q) const { return (_inverse * q)[1]; }

		Vector2Cartesian    transf(const Vector2Cartesian& q) const { return Vector2Cartesian{ func1(q), func2(q) }; }
		Vector2Cartesian    transfInverse(const Vector2Cartesian& q) const { return Vector2Cartesian{ funcInverse1(q), funcInverse2(q) }; }

		const IScalarFunction<2>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else return _f2;
		}
		const IScalarFunction<2>& inverseCoordTransfFunc(int i) const
		{
			if (i == 0) return _fInverse1;
			else return _fInverse2;
		}
	};

	// oblique transformation in 2D, where Y axis is not at angle 90 degrees to X axis
	// but is at some angle _angle to X axis
	class CoordTransfObliqueToCartesian2D : public CoordTransfWithInverse<Vector2Cartesian, Vector2Cartesian, 2>
	{
	private:
		Real    _angle;

		const ScalarFunctionFromStdFunc<2> _f1;
		const ScalarFunctionFromStdFunc<2> _f2;

		const ScalarFunctionFromStdFunc<2> _fInverse1;
		const ScalarFunctionFromStdFunc<2> _fInverse2;

	public:
		CoordTransfObliqueToCartesian2D(Real inAngle)
			: _angle(inAngle),
			_f1([this](const VectorN<Real, 2>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 2>& q) { return func2(q); }),
			_fInverse1([this](const VectorN<Real, 2>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 2>& q) { return funcInverse2(q); })
		{
		}

		// Forward: oblique (q) â†’ Cartesian (x, y)
		Real func1(const VectorN<Real, 2>& q) const { return q[0] + q[1] * std::cos(_angle); }
		Real func2(const VectorN<Real, 2>& q) const { return q[1] * std::sin(_angle); }

		// Inverse: Cartesian (x, y) â†’ oblique (q)
		Real funcInverse2(const VectorN<Real, 2>& q) const { return q[1] / std::sin(_angle); }
		Real funcInverse1(const VectorN<Real, 2>& q) const { return q[0] - funcInverse2(q) * std::cos(_angle); }

		Vector2Cartesian transf(const Vector2Cartesian& q) const override { return Vector2Cartesian{ func1(q), func2(q) }; }
		Vector2Cartesian transfInverse(const Vector2Cartesian& q) const override { return Vector2Cartesian{ funcInverse1(q), funcInverse2(q) }; }

		const IScalarFunction<2>& coordTransfFunc(int i) const override
		{
			return (i == 0) ? _f1 : _f2;
		}
		const IScalarFunction<2>& inverseCoordTransfFunc(int i) const override
		{
			return (i == 0) ? _fInverse1 : _fInverse2;
		}
	};


	class CoordTransfCartesianToOblique2D : public CoordTransfWithInverse<Vector2Cartesian, Vector2Cartesian, 2>
	{
	private:
		Real    _angle;

		const ScalarFunctionFromStdFunc<2> _f1;
		const ScalarFunctionFromStdFunc<2> _f2;

		const ScalarFunctionFromStdFunc<2> _fInverse1;
		const ScalarFunctionFromStdFunc<2> _fInverse2;

	public:
		CoordTransfCartesianToOblique2D(Real inAngle)
			: _angle(inAngle),
			_f1([this](const VectorN<Real, 2>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 2>& q) { return func2(q); }),
			_fInverse1([this](const VectorN<Real, 2>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 2>& q) { return funcInverse2(q); })
		{	}

		// Forward: Cartesian (x, y) â†’ oblique (q)
		Real func2(const VectorN<Real, 2>& q) const { return q[1] / std::sin(_angle); }
		Real func1(const VectorN<Real, 2>& q) const { return q[0] - func2(q) * std::cos(_angle); }

		// Inverse: oblique (q) â†’ Cartesian (x, y)
		Real funcInverse1(const VectorN<Real, 2>& q) const { return q[0] + q[1] * std::cos(_angle); }
		Real funcInverse2(const VectorN<Real, 2>& q) const { return q[1] * std::sin(_angle); }

		Vector2Cartesian transf(const Vector2Cartesian& q) const override { return Vector2Cartesian{ func1(q), func2(q) }; }
		Vector2Cartesian transfInverse(const Vector2Cartesian& q) const override { return Vector2Cartesian{ funcInverse1(q), funcInverse2(q) }; }

		const IScalarFunction<2>& coordTransfFunc(int i) const override
		{
			return (i == 0) ? _f1 : _f2;
		}
		const IScalarFunction<2>& inverseCoordTransfFunc(int i) const override
		{
			return (i == 0) ? _fInverse1 : _fInverse2;
		}
	};

}


///////////////////////////   mml/core/CoordTransf/CoordTransf3D.h   ///////////////////////////



using namespace MML::Utils;

namespace MML
{
	class CoordTransfCart3DRotationXAxis : 
		public CoordTransfWithInverse<Vec3Cart, Vec3Cart, 3>
	{
	private:
		Real    _angle;
		MatrixNM<Real, 3, 3>  _transf;
		MatrixNM<Real, 3, 3>  _inverse;

		const ScalarFunctionFromStdFunc<3> _f1, _f2, _f3;
		const ScalarFunctionFromStdFunc<3> _fInverse1, _fInverse2, _fInverse3;

	public:
		CoordTransfCart3DRotationXAxis(Real inAngle) : _angle(inAngle),
			_f1([this](const VectorN<Real, 3>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 3>& q) { return func2(q); }),
			_f3([this](const VectorN<Real, 3>& q) { return func3(q); }),
			_fInverse1([this](const VectorN<Real, 3>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 3>& q) { return funcInverse2(q); }),
			_fInverse3([this](const VectorN<Real, 3>& q) { return funcInverse3(q); })
		{
			_transf[0][0] = 1.0;
			_transf[1][1] = cos(_angle);
			_transf[1][2] = -sin(_angle);
			_transf[2][1] = sin(_angle);
			_transf[2][2] = cos(_angle);

			_inverse[0][0] = 1.0;
			_inverse[1][1] = cos(_angle);
			_inverse[1][2] = sin(_angle);
			_inverse[2][1] = -sin(_angle);
			_inverse[2][2] = cos(_angle);
		}

		Real func1(const VectorN<Real, 3>& q) const { return q[0]; }
		Real func2(const VectorN<Real, 3>& q) const { return q[1] * cos(_angle) - q[2] * sin(_angle); }
		Real func3(const VectorN<Real, 3>& q) const { return q[1] * sin(_angle) + q[2] * cos(_angle); }

		Real funcInverse1(const VectorN<Real, 3>& q) const { return q[0]; }
		Real funcInverse2(const VectorN<Real, 3>& q) const { return q[1] * cos(_angle) + q[2] * sin(_angle); }
		Real funcInverse3(const VectorN<Real, 3>& q) const { return -q[1] * sin(_angle) + q[2] * cos(_angle); }

		Vec3Cart    transf(const Vec3Cart& q) const { return Vec3Cart{ func1(q), func2(q), func3(q) }; }
		Vec3Cart    transfInverse(const Vec3Cart& q) const { return Vec3Cart{ funcInverse1(q), funcInverse2(q), funcInverse3(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else return _f3;
		}
		const IScalarFunction<3>& inverseCoordTransfFunc(int i)const
		{
			if (i == 0) return _fInverse1;
			else if (i == 1) return _fInverse2;
			else return _fInverse3;
		}
	};
	class CoordTransfCart3DRotationYAxis : public CoordTransfWithInverse<Vec3Cart, Vec3Cart, 3>
	{
	private:
		Real    _angle;
		MatrixNM<Real, 3, 3>  _transf;
		MatrixNM<Real, 3, 3>  _inverse;

		const ScalarFunctionFromStdFunc<3> _f1, _f2, _f3;
		const ScalarFunctionFromStdFunc<3> _fInverse1, _fInverse2, _fInverse3;

	public:
		CoordTransfCart3DRotationYAxis(Real inAngle) : _angle(inAngle),
			_f1([this](const VectorN<Real, 3>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 3>& q) { return func2(q); }),
			_f3([this](const VectorN<Real, 3>& q) { return func3(q); }),
			_fInverse1([this](const VectorN<Real, 3>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 3>& q) { return funcInverse2(q); }),
			_fInverse3([this](const VectorN<Real, 3>& q) { return funcInverse3(q); }) 
		{
			_transf[0][0] = cos(_angle);
			_transf[0][2] = sin(_angle);
			_transf[1][1] = 1.0;
			_transf[2][0] = -sin(_angle);
			_transf[2][2] = cos(_angle);

			_inverse[0][0] = cos(_angle);
			_inverse[0][2] = -sin(_angle);
			_inverse[1][1] = 1.0;
			_inverse[2][0] = sin(_angle);
			_inverse[2][2] = cos(_angle);
		}

		Real func1(const VectorN<Real, 3>& q) const { return q[0] * cos(_angle) + q[2] * sin(_angle); }
		Real func2(const VectorN<Real, 3>& q) const { return q[1]; }
		Real func3(const VectorN<Real, 3>& q) const { return -q[0] * sin(_angle) + q[2] * cos(_angle); }

		Real funcInverse1(const VectorN<Real, 3>& q) const { return q[0] * cos(_angle) - q[2] * sin(_angle); }
		Real funcInverse2(const VectorN<Real, 3>& q) const { return q[1]; }
		Real funcInverse3(const VectorN<Real, 3>& q) const { return q[0] * sin(_angle) + q[2] * cos(_angle); }

		Vec3Cart    transf(const Vec3Cart& q) const { return Vec3Cart{ func1(q), func2(q), func3(q) }; }
		Vec3Cart    transfInverse(const Vec3Cart& q) const { return Vec3Cart{ funcInverse1(q), funcInverse2(q), funcInverse3(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else return _f3;
		}
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const
		{
			if (i == 0) return _fInverse1;
			else if (i == 1) return _fInverse2;
			else return _fInverse3;
		}
	};
	class CoordTransfCart3DRotationZAxis : public CoordTransfWithInverse<Vec3Cart, Vec3Cart, 3>
	{
	private:
		Real    _angle;
		MatrixNM<Real, 3, 3>  _transf;
		MatrixNM<Real, 3, 3>  _inverse;

		const ScalarFunctionFromStdFunc<3> _f1, _f2, _f3;
		const ScalarFunctionFromStdFunc<3> _fInverse1, _fInverse2, _fInverse3;

	public:
		CoordTransfCart3DRotationZAxis(Real inAngle) : _angle(inAngle),
			_f1([this](const VectorN<Real, 3>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 3>& q) { return func2(q); }),
			_f3([this](const VectorN<Real, 3>& q) { return func3(q); }),
			_fInverse1([this](const VectorN<Real, 3>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 3>& q) { return funcInverse2(q); }),
			_fInverse3([this](const VectorN<Real, 3>& q) { return funcInverse3(q); }) 
		{
			_transf[0][0] = cos(_angle);
			_transf[0][1] = -sin(_angle);
			_transf[1][0] = sin(_angle);
			_transf[1][1] = cos(_angle);
			_transf[2][2] = 1.0;

			_inverse[0][0] = cos(_angle);
			_inverse[0][1] = sin(_angle);
			_inverse[1][0] = -sin(_angle);
			_inverse[1][1] = cos(_angle);
			_inverse[2][2] = 1.0;
		}

		Real func1(const VectorN<Real, 3>& q) const { return q[0] * cos(_angle) - q[1] * sin(_angle); }
		Real func2(const VectorN<Real, 3>& q) const { return q[0] * sin(_angle) + q[1] * cos(_angle); }
		Real func3(const VectorN<Real, 3>& q) const { return q[2]; }

		Real funcInverse1(const VectorN<Real, 3>& q) const { return q[0] * cos(_angle) + q[1] * sin(_angle); }
		Real funcInverse2(const VectorN<Real, 3>& q) const { return -q[0] * sin(_angle) + q[1] * cos(_angle); }
		Real funcInverse3(const VectorN<Real, 3>& q) const { return q[2]; }

		Vec3Cart    transf(const Vec3Cart& q) const { return Vec3Cart{ func1(q), func2(q), func3(q) }; }
		Vec3Cart    transfInverse(const Vec3Cart& q) const { return Vec3Cart{ funcInverse1(q), funcInverse2(q), funcInverse3(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else return _f3;
		}
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const
		{
			if (i == 0) return _fInverse1;
			else if (i == 1) return _fInverse2;
			else return _fInverse3;
		}
	};

	// General orthogonal 3D Cartesian transformation, specified by Euler angles (ZXZ convention, physics standard)
	class CoordTransfCart3DRotationEuler : public CoordTransfWithInverse<Vec3Cart, Vec3Cart, 3>
	{
	private:
		Real _alpha; // rotation about Z axis
		Real _beta;  // rotation about X' axis
		Real _gamma; // rotation about Z'' axis

		MatrixNM<Real, 3, 3> _transf;
		MatrixNM<Real, 3, 3> _inverse;

		const ScalarFunctionFromStdFunc<3> _f1, _f2, _f3;
		const ScalarFunctionFromStdFunc<3> _fInverse1, _fInverse2, _fInverse3;

		// Helper: build rotation matrix for ZXZ convention
		static MatrixNM<Real, 3, 3> buildEulerZXZMatrix(Real alpha, Real beta, Real gamma)
		{
			Real ca = std::cos(alpha), sa = std::sin(alpha);
			Real cb = std::cos(beta), sb = std::sin(beta);
			Real cg = std::cos(gamma), sg = std::sin(gamma);

			MatrixNM<Real, 3, 3> m;
			m(0, 0) = ca * cb * cg - sa * sg;
			m(0, 1) = -ca * cb * sg - sa * cg;
			m(0, 2) = ca * sb;
			m(1, 0) = sa * cb * cg + ca * sg;
			m(1, 1) = -sa * cb * sg + ca * cg;
			m(1, 2) = sa * sb;
			m(2, 0) = -sb * cg;
			m(2, 1) = sb * sg;
			m(2, 2) = cb;
			return m;
		}

	public:
		// alpha, beta, gamma: ZXZ Euler angles (physics convention)
		CoordTransfCart3DRotationEuler(Real alpha, Real beta, Real gamma)
			: _alpha(alpha), _beta(beta), _gamma(gamma),
				_transf(buildEulerZXZMatrix(alpha, beta, gamma)),
				_inverse(buildEulerZXZMatrix(-gamma, -beta, -alpha)), // Inverse: reverse order and sign
				_f1([this](const VectorN<Real, 3>& q) { return func1(q); }),
				_f2([this](const VectorN<Real, 3>& q) { return func2(q); }),
				_f3([this](const VectorN<Real, 3>& q) { return func3(q); }),
				_fInverse1([this](const VectorN<Real, 3>& q) { return funcInverse1(q); }),
				_fInverse2([this](const VectorN<Real, 3>& q) { return funcInverse2(q); }),
				_fInverse3([this](const VectorN<Real, 3>& q) { return funcInverse3(q); })
		{	}

		Real func1(const VectorN<Real, 3>& q) const { return (_transf * q)[0]; }
		Real func2(const VectorN<Real, 3>& q) const { return (_transf * q)[1]; }
		Real func3(const VectorN<Real, 3>& q) const { return (_transf * q)[2]; }

		Real funcInverse1(const VectorN<Real, 3>& q) const { return (_inverse * q)[0]; }
		Real funcInverse2(const VectorN<Real, 3>& q) const { return (_inverse * q)[1]; }
		Real funcInverse3(const VectorN<Real, 3>& q) const { return (_inverse * q)[2]; }

		Vec3Cart transf(const Vec3Cart& q) const override
		{
			return Vec3Cart{ func1(q), func2(q), func3(q) };
		}
		Vec3Cart transfInverse(const Vec3Cart& q) const override
		{
			return Vec3Cart{ funcInverse1(q), funcInverse2(q), funcInverse3(q) };
		}

		const IScalarFunction<3>& coordTransfFunc(int i) const override
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else return _f3;
		}
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const override
		{
			if (i == 0) return _fInverse1;
			else if (i == 1) return _fInverse2;
			else return _fInverse3;
		}
	};

	// Performs tranformation from original (Cartesian) system to orthogonal system defined by 
	// its base vectors expressed in original system.
	class CoordTransf3DCartOrthogonal : public CoordTransfWithInverse<Vec3Cart, Vec3Cart, 3>
	{
	private:
		Vec3Cart _base[3];

		MatrixNM<Real, 3, 3> _transf;
		MatrixNM<Real, 3, 3> _transfInverse;

		const ScalarFunctionFromStdFunc<3> _f1, _f2, _f3;
		const ScalarFunctionFromStdFunc<3> _fInverse1, _fInverse2, _fInverse3;

		Real func1(const VectorN<Real, 3>& q) const { return (_transf * q)[0]; }
		Real func2(const VectorN<Real, 3>& q) const { return (_transf * q)[1]; }
		Real func3(const VectorN<Real, 3>& q) const { return (_transf * q)[2]; }

		Real funcInverse1(const VectorN<Real, 3>& q) const { return (_transfInverse * q)[0]; }
		Real funcInverse2(const VectorN<Real, 3>& q) const { return (_transfInverse * q)[1]; }
		Real funcInverse3(const VectorN<Real, 3>& q) const { return (_transfInverse * q)[2]; }

	public:
		CoordTransf3DCartOrthogonal(const VectorN<Real, 3>& b1, const VectorN<Real, 3>& b2, const VectorN<Real, 3>& b3) :
			_f1([this](const VectorN<Real, 3>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 3>& q) { return func2(q); }),
			_f3([this](const VectorN<Real, 3>& q) { return func3(q); }),
			_fInverse1([this](const VectorN<Real, 3>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 3>& q) { return funcInverse2(q); }),
			_fInverse3([this](const VectorN<Real, 3>& q) { return funcInverse3(q); }) 
		{
			// Convert to Vec3Cart for easier operations
			Vec3Cart base1(b1);
			Vec3Cart base2(b2);
			Vec3Cart base3(b3);

			// Check orthogonality (dot products should be zero)
			constexpr Real eps = PrecisionValues<Real>::OrthogonalityTolerance;
			if (std::abs(base1 * base2) > eps ||
					std::abs(base1 * base3) > eps ||
					std::abs(base2 * base3) > eps)
			{
				throw GeometryError("CoordTransf3DCartOrthogonal: Provided base vectors are not mutually orthogonal.");
			}

			_base[0] = b1;
			_base[1] = b2;
			_base[2] = b3;

			for (int i = 0; i < 3; i++) {
				for (int j = 0; j < 3; j++)
				{
					_transf(i, j) = _base[i][j];
					_transfInverse(i, j) = _base[j][i];
				}
			}
		}

		MatrixNM<Real, 3, 3> getTransfMatrix() { return _transf; }
		MatrixNM<Real, 3, 3> getInvTransfMatrix() { return _transfInverse; }

		Vec3Cart    transf(const Vec3Cart& q) const { return Vec3Cart{ func1(q), func2(q), func3(q) }; }
		Vec3Cart    transfInverse(const Vec3Cart& q) const { return Vec3Cart{ funcInverse1(q), funcInverse2(q), funcInverse3(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else return _f3;
		}
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const
		{
			if (i == 0) return _fInverse1;
			else if (i == 1) return _fInverse2;
			else return _fInverse3;
		}

		bool IsRightHanded()
		{
			Vec3Cart cross = VectorProduct(_base[0], _base[1]);
			if (cross.ScalarProduct(_base[2]) > 0.0)
				return true;
			else
				return false;
		}
	};

	// General 3D Cartesian transformation, given by matrix
	class CoordTransf3DCartGeneral : public CoordTransfWithInverse<Vec3Cart, Vec3Cart, 3>
	{
	private:
		Vec3Cart _base[3];

		MatrixNM<Real, 3, 3> _transf;
		MatrixNM<Real, 3, 3> _transfInverse;

		const ScalarFunctionFromStdFunc<3> _f1, _f2, _f3;
		const ScalarFunctionFromStdFunc<3> _fInverse1, _fInverse2, _fInverse3;

		Real func1(const VectorN<Real, 3>& q) const { return (_transf * q)[0]; }
		Real func2(const VectorN<Real, 3>& q) const { return (_transf * q)[1]; }
		Real func3(const VectorN<Real, 3>& q) const { return (_transf * q)[2]; }

		Real funcInverse1(const VectorN<Real, 3>& q) const { return (_transfInverse * q)[0]; }
		Real funcInverse2(const VectorN<Real, 3>& q) const { return (_transfInverse * q)[1]; }
		Real funcInverse3(const VectorN<Real, 3>& q) const { return (_transfInverse * q)[2]; }

	public:
		CoordTransf3DCartGeneral(const MatrixNM<Real, 3, 3>& transfMat) :
			_f1([this](const VectorN<Real, 3>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 3>& q) { return func2(q); }),
			_f3([this](const VectorN<Real, 3>& q) { return func3(q); }),
			_fInverse1([this](const VectorN<Real, 3>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 3>& q) { return funcInverse2(q); }),
			_fInverse3([this](const VectorN<Real, 3>& q) { return funcInverse3(q); })
		{
			// check that input matrix is not singular!


			_transf = transfMat;

			for (int i = 0; i < 3; i++) {
				for (int j = 0; j < 3; j++)
				{
					_base[i][j] = _transf(i, j);
					_transfInverse(i, j) = _transf[j][i];
				}
			}
		}

		MatrixNM<Real, 3, 3> getTransfMatrix() { return _transf; }
		MatrixNM<Real, 3, 3> getInvTransfMatrix() { return _transfInverse; }

		Vec3Cart    transf(const Vec3Cart& q) const { return Vec3Cart{ func1(q), func2(q), func3(q) }; }
		Vec3Cart    transfInverse(const Vec3Cart& q) const { return Vec3Cart{ funcInverse1(q), funcInverse2(q), funcInverse3(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else return _f3;
		}
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const
		{
			if (i == 0) return _fInverse1;
			else if (i == 1) return _fInverse2;
			else return _fInverse3;
		}

		bool IsRightHanded()
		{
			Vec3Cart cross = VectorProduct(_base[0], _base[1]);
			if (cross.ScalarProduct(_base[2]) > 0.0)
				return true;
			else
				return false;
		}
	};

	class CoordTransfCartesianToOblique3D : public CoordTransfWithInverse<Vec3Cart, Vec3Cart, 3>
	{
	private:
		Vec3Cart _base[3];					// base vectors as columns
		Vec3Cart _dual[3];					// dual basis
		MatrixNM<Real, 3, 3> _baseMat;      // columns = base vectors
		MatrixNM<Real, 3, 3> _baseMatInv;   // inverse of _baseMat

		const ScalarFunctionFromStdFunc<3> _f1, _f2, _f3;
		const ScalarFunctionFromStdFunc<3> _fInverse1, _fInverse2, _fInverse3;

		Real func1(const VectorN<Real, 3>& q) const { return Utils::ScalarProduct<3>(q, static_cast<const VectorN<Real, 3>&>(_dual[0])); }
		Real func2(const VectorN<Real, 3>& q) const { return Utils::ScalarProduct<3>(q, static_cast<const VectorN<Real, 3>&>(_dual[1])); }
		Real func3(const VectorN<Real, 3>& q) const { return Utils::ScalarProduct<3>(q, static_cast<const VectorN<Real, 3>&>(_dual[2])); }

		Real funcInverse1(const VectorN<Real, 3>& q) const { return (_baseMat * q)[0]; }
		Real funcInverse2(const VectorN<Real, 3>& q) const { return (_baseMat * q)[1]; }
		Real funcInverse3(const VectorN<Real, 3>& q) const { return (_baseMat * q)[2]; }

	public:
		CoordTransfCartesianToOblique3D(const VectorN<Real, 3>& b1, const VectorN<Real, 3>& b2, const VectorN<Real, 3>& b3) :
			_f1([this](const VectorN<Real, 3>& q) { return func1(q); }),
			_f2([this](const VectorN<Real, 3>& q) { return func2(q); }),
			_f3([this](const VectorN<Real, 3>& q) { return func3(q); }),
			_fInverse1([this](const VectorN<Real, 3>& q) { return funcInverse1(q); }),
			_fInverse2([this](const VectorN<Real, 3>& q) { return funcInverse2(q); }),
			_fInverse3([this](const VectorN<Real, 3>& q) { return funcInverse3(q); })
		{
			_base[0] = b1; _base[1] = b2; _base[2] = b3;

			for (int i = 0; i < 3; ++i) {
				_baseMat(0, i) = _base[i][0];
				_baseMat(1, i) = _base[i][1];
				_baseMat(2, i) = _base[i][2];
			}
			// Check for non-degeneracy
			Real V = ScalarProduct(_base[0], VectorProduct(_base[1], _base[2]));
			if (std::abs(V) < PrecisionValues<Real>::LinearDependenceTolerance)
				throw SingularMatrixError("Oblique base vectors are linearly dependent!", V);

		// Compute dual basis
		_dual[0] = (1 / V) * VectorProduct(_base[1], _base[2]);
		_dual[1] = (1 / V) * VectorProduct(_base[2], _base[0]);
		_dual[2] = (1 / V) * VectorProduct(_base[0], _base[1]);

		// Compute inverse of base matrix for alternative transformation method
		_baseMatInv = _baseMat.GetInverse();
	}		Vec3Cart    Base(int i) { return _base[i]; }
		Vec3Cart    Dual(int i) { return _dual[i]; }

		// Cartesian (input) â†’ Oblique (output)
		Vec3Cart transf(const Vec3Cart& cartesian) const {
			// q^i = dual_i â‹… cartesian
			return Vec3Cart{
					ScalarProduct(cartesian, _dual[0]),
					ScalarProduct(cartesian, _dual[1]),
					ScalarProduct(cartesian, _dual[2])
			};
			// Or, if you have _baseMatInv: return _baseMatInv * cartesian;
		}

		// Oblique (input) â†’ Cartesian (output)
		Vec3Cart transfInverse(const Vec3Cart& oblique) const {
			// r = q^i * base_i
			return _baseMat * oblique;
		}
		
		const IScalarFunction<3>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else return _f3;
		}
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const
		{
			if (i == 0) return _fInverse1;
			else if (i == 1) return _fInverse2;
			else return _fInverse3;
		}

		bool IsRightHanded()
		{
			Vec3Cart cross = VectorProduct(_base[0], _base[1]);
			if (ScalarProduct(cross, _base[2]) > 0.0)
				return true;
			else
				return false;
		}
	};

	/*****************************************************************************
	 * QUATERNION-BASED 3D ROTATION COORDINATE TRANSFORMATION
	 * 
	 * This class provides 3D coordinate transformations using quaternions,
	 * offering several advantages over matrix-based rotations:
	 * 
	 * ADVANTAGES:
	 * - Compact representation: 4 values instead of 9 matrix elements
	 * - No gimbal lock issues (unlike Euler angles)
	 * - Efficient composition: quaternion multiplication is faster than matrix
	 * - Smooth interpolation: SLERP provides natural rotation interpolation
	 * - Numerical stability: quaternions are easier to renormalize
	 * 
	 * USAGE:
	 * 1. Construct from quaternion:
	 *    Quaternion q = Quaternion::FromAxisAngle(Vec3Cart(0,0,1), PI/4);
	 *    CoordTransfCart3DRotationQuaternion rot(q);
	 * 
	 * 2. Construct from axis-angle:
	 *    CoordTransfCart3DRotationQuaternion rot(Vec3Cart(1,0,0), PI/2);
	 * 
	 * 3. Construct from rotation matrix:
	 *    MatrixNM<Real,3,3> mat = ...;
	 *    CoordTransfCart3DRotationQuaternion rot(mat);
	 * 
	 * 4. Apply transformation:
	 *    Vec3Cart v_rotated = rot.transf(v);
	 *    Vec3Cart v_original = rot.transfInverse(v_rotated);
	 * 
	 * INTEGRATION WITH OTHER ROTATION CLASSES:
	 * This class seamlessly integrates with existing CoordTransf3D rotation
	 * classes (RotationXAxis, RotationYAxis, etc.) through shared matrix
	 * representation, allowing mixing of quaternion and matrix rotations.
	 *****************************************************************************/
	class CoordTransfCart3DRotationQuaternion : 
		public CoordTransfWithInverse<Vec3Cart, Vec3Cart, 3>
	{
	private:
		Quaternion _quat;
		MatrixNM<Real, 3, 3> _transf;
		MatrixNM<Real, 3, 3> _inverse;

		const ScalarFunctionFromStdFunc<3> _f1, _f2, _f3;
		const ScalarFunctionFromStdFunc<3> _fInverse1, _fInverse2, _fInverse3;

		// Initialize transformation matrices from quaternion
		void initializeMatrices()
		{
			// Ensure quaternion is normalized for proper rotation
			if (!_quat.IsUnit(PrecisionValues<Real>::DefaultTolerance))
				_quat.Normalize();

			// Convert quaternion to rotation matrix
			_transf = _quat.ToRotationMatrix();

			// Inverse of rotation quaternion is its conjugate
			// For matrices: inverse of orthogonal matrix is its transpose
			Quaternion quat_inv = _quat.Conjugate();
			_inverse = quat_inv.ToRotationMatrix();
		}

	public:
		// Construct from quaternion
		explicit CoordTransfCart3DRotationQuaternion(const Quaternion& q) 
			: _quat(q),
				_f1([this](const VectorN<Real, 3>& v) { return func1(v); }),
				_f2([this](const VectorN<Real, 3>& v) { return func2(v); }),
				_f3([this](const VectorN<Real, 3>& v) { return func3(v); }),
				_fInverse1([this](const VectorN<Real, 3>& v) { return funcInverse1(v); }),
				_fInverse2([this](const VectorN<Real, 3>& v) { return funcInverse2(v); }),
				_fInverse3([this](const VectorN<Real, 3>& v) { return funcInverse3(v); })
		{
			initializeMatrices();
		}

		// Construct from axis-angle representation
		CoordTransfCart3DRotationQuaternion(const Vec3Cart& axis, Real angle)
			: _quat(Quaternion::FromAxisAngle(axis, angle)),
				_f1([this](const VectorN<Real, 3>& v) { return func1(v); }),
				_f2([this](const VectorN<Real, 3>& v) { return func2(v); }),
				_f3([this](const VectorN<Real, 3>& v) { return func3(v); }),
				_fInverse1([this](const VectorN<Real, 3>& v) { return funcInverse1(v); }),
				_fInverse2([this](const VectorN<Real, 3>& v) { return funcInverse2(v); }),
				_fInverse3([this](const VectorN<Real, 3>& v) { return funcInverse3(v); })
		{
			initializeMatrices();
		}

		// Construct from rotation matrix
		explicit CoordTransfCart3DRotationQuaternion(const MatrixNM<Real, 3, 3>& rotMatrix)
			: _quat(Quaternion::FromRotationMatrix(rotMatrix)),
				_f1([this](const VectorN<Real, 3>& v) { return func1(v); }),
				_f2([this](const VectorN<Real, 3>& v) { return func2(v); }),
				_f3([this](const VectorN<Real, 3>& v) { return func3(v); }),
				_fInverse1([this](const VectorN<Real, 3>& v) { return funcInverse1(v); }),
				_fInverse2([this](const VectorN<Real, 3>& v) { return funcInverse2(v); }),
				_fInverse3([this](const VectorN<Real, 3>& v) { return funcInverse3(v); })
		{
			initializeMatrices();
		}

		// Construct from Euler angles (ZYX convention: yaw, pitch, roll)
		static CoordTransfCart3DRotationQuaternion FromEulerZYX(Real yaw, Real pitch, Real roll)
		{
			return CoordTransfCart3DRotationQuaternion(
				Quaternion::FromEulerZYX(yaw, pitch, roll)
			);
		}

		// Construct from Euler angles (XYZ convention)
		static CoordTransfCart3DRotationQuaternion FromEulerXYZ(Real roll, Real pitch, Real yaw)
		{
			return CoordTransfCart3DRotationQuaternion(
				Quaternion::FromEulerXYZ(roll, pitch, yaw)
			);
		}

		// Transformation functions using matrix representation
		Real func1(const VectorN<Real, 3>& v) const 
		{ 
			return _transf[0][0] * v[0] + _transf[0][1] * v[1] + _transf[0][2] * v[2]; 
		}
		
		Real func2(const VectorN<Real, 3>& v) const 
		{ 
			return _transf[1][0] * v[0] + _transf[1][1] * v[1] + _transf[1][2] * v[2]; 
		}
		
		Real func3(const VectorN<Real, 3>& v) const 
		{ 
			return _transf[2][0] * v[0] + _transf[2][1] * v[1] + _transf[2][2] * v[2]; 
		}

		// Inverse transformation functions
		Real funcInverse1(const VectorN<Real, 3>& v) const 
		{ 
			return _inverse[0][0] * v[0] + _inverse[0][1] * v[1] + _inverse[0][2] * v[2]; 
		}
		
		Real funcInverse2(const VectorN<Real, 3>& v) const 
		{ 
			return _inverse[1][0] * v[0] + _inverse[1][1] * v[1] + _inverse[1][2] * v[2]; 
		}
		
		Real funcInverse3(const VectorN<Real, 3>& v) const 
		{ 
			return _inverse[2][0] * v[0] + _inverse[2][1] * v[1] + _inverse[2][2] * v[2]; 
		}

		// Apply transformation (using quaternion directly for efficiency)
		Vec3Cart transf(const Vec3Cart& v) const 
		{ 
			return _quat.Rotate(v);
		}

		// Apply inverse transformation
		Vec3Cart transfInverse(const Vec3Cart& v) const 
		{ 
			return _quat.Conjugate().Rotate(v);
		}

		// Interface implementation
		const IScalarFunction<3>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else return _f3;
		}

		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const
		{
			if (i == 0) return _fInverse1;
			else if (i == 1) return _fInverse2;
			else return _fInverse3;
		}

		// Accessors
		const Quaternion& GetQuaternion() const { return _quat; }
		const MatrixNM<Real, 3, 3>& GetTransformationMatrix() const { return _transf; }
		const MatrixNM<Real, 3, 3>& GetInverseMatrix() const { return _inverse; }

		// Get rotation axis and angle
		Vec3Cart GetRotationAxis() const { return _quat.GetRotationAxis(); }
		Real GetRotationAngle() const { return _quat.GetRotationAngle(); }

		// Composition: compose this rotation with another
		// Returns a new transformation representing this rotation followed by other
		CoordTransfCart3DRotationQuaternion Compose(
			const CoordTransfCart3DRotationQuaternion& other) const
		{
			return CoordTransfCart3DRotationQuaternion(other._quat * _quat);
		}

		// Interpolation between two rotations
		// t=0 returns this, t=1 returns other
		// Uses SLERP for smooth interpolation
		CoordTransfCart3DRotationQuaternion Interpolate(
			const CoordTransfCart3DRotationQuaternion& other, Real t) const
		{
			Quaternion interpolated = Quaternion::Slerp(_quat, other._quat, t);
			return CoordTransfCart3DRotationQuaternion(interpolated);
		}
	};
}


///////////////////////////   mml/core/CoordTransf/CoordTransfSpherical.h   ///////////////////////////




namespace MML
{
	///////////////////////////////////////////////////////////////////////////////
	// SPHERICAL COORDINATE SYSTEM CONVENTIONS
	//
	// This implementation follows the Mathematics/ISO 31-11 convention:
	//
	//   Coordinate ordering: (r, Î¸, Ï†)
	//   - r (radius):        radial distance from origin, r â‰¥ 0
	//   - Î¸ (theta):         polar angle (inclination) from positive z-axis, Î¸ âˆˆ [0, Ï€]
	//   - Ï† (phi):           azimuthal angle in xy-plane from positive x-axis, Ï† âˆˆ [0, 2Ï€) or (-Ï€, Ï€]
	//
	//   Transformation formulas:
	//     x = r sin(Î¸) cos(Ï†)
	//     y = r sin(Î¸) sin(Ï†)
	//     z = r cos(Î¸)
	//
	//   Inverse:
	//     r     = âˆš(xÂ² + yÂ² + zÂ²)
	//     Î¸     = arccos(z / r)
	//     Ï†     = atan2(y, x)
	//
	// ALTERNATIVE CONVENTIONS (not used here):
	//
	//   Physics convention (common in US physics textbooks):
	//     Often uses (r, Ï†, Î¸) ordering or defines Î¸ as azimuthal and Ï† as polar.
	//
	//   Geodesy/Geography:
	//     Uses (latitude, longitude, altitude) where latitude = 90Â° - Î¸ (colatitude).
	//
	// RATIONALE:
	//   The Math/ISO convention is used here because:
	//   - It's standard in differential geometry and tensor calculus
	//   - Î¸ ranges match typical polar angle definitions
	//   - It aligns with spherical harmonics conventions (Ylm)
	//   - Basis vectors are naturally ordered (âˆ‚r, âˆ‚Î¸, âˆ‚Ï†)
	//
	///////////////////////////////////////////////////////////////////////////////

	class CoordTransfSphericalToCartesian : public CoordTransfWithInverse<Vector3Spherical, Vector3Cartesian, 3>
	{
	private:
		// q[0] = r     - radial distance
		// q[1] = theta - inclination
		// q[2] = phi   - azimuthal angle
		static Real x(const VectorN<Real, 3>& q) { return q[0] * sin(q[1]) * cos(q[2]); }
		static Real y(const VectorN<Real, 3>& q) { return q[0] * sin(q[1]) * sin(q[2]); }
		static Real z(const VectorN<Real, 3>& q) { return q[0] * cos(q[1]); }

		// q[0] = x
		// q[1] = y
		// q[2] = z
		// THIS DOESN'T WORK :(
		// static Real r(const Vector3Cartesian& q)		 { return sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]); }
		static Real r(const VectorN<Real, 3>& q)		 { return sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]); }
		static Real theta(const VectorN<Real, 3>& q) { return acos(q[2] / sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2])); }
		static Real phi(const VectorN<Real, 3>& q)	 { return atan2(q[1], q[0]); }

		inline static ScalarFunction<3> _func[3] = { ScalarFunction<3>{x},
																								 ScalarFunction<3>{y},
																								 ScalarFunction<3>{z}
		};

		inline static ScalarFunction<3> _funcInverse[3] = { ScalarFunction<3>{r},
																												ScalarFunction<3>{theta},
																																ScalarFunction<3>{phi}
		};
	public:
		Vector3Cartesian     transf(const Vector3Spherical& q)				const override { return Vector3Cartesian{ x(q), y(q), z(q) }; }
		Vector3Spherical     transfInverse(const Vector3Cartesian& q) const override { return Vector3Spherical{ r(q), theta(q), phi(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i)				const override { return _func[i]; }
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const override { return _funcInverse[i]; }

		// explicit calculations of basis vectors
		virtual Vector3Cartesian getBasisVec(int ind, const Vector3Spherical& pos) override
		{
			const Real r = pos[0];
			const Real theta = pos[1];
			const Real phi = pos[2];
			switch (ind)
			{
			case 0: return Vector3Cartesian{ sin(theta) * cos(phi),     sin(theta) * sin(phi),      cos(theta) };
			case 1: return Vector3Cartesian{ r * cos(theta) * cos(phi), r * cos(theta) * sin(phi), -r * sin(theta) };
			case 2: return Vector3Cartesian{ -r * sin(theta) * sin(phi), r * sin(theta) * cos(phi),						  REAL(0.0) };
			default:
			return Vector3Cartesian{ REAL(0.0), REAL(0.0), REAL(0.0) };
			}
		}

		Vector3Cartesian getUnitBasisVec(int ind, const Vector3Spherical& pos)
		{
			const Real r = pos[0];
			const Real theta = pos[1];
			const Real phi = pos[2];
			switch (ind)
			{
			case 0: return Vector3Cartesian{ sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta) };
			case 1: return Vector3Cartesian{ cos(theta) * cos(phi), cos(theta) * sin(phi), -sin(theta) };
			case 2: return Vector3Cartesian{ -sin(phi), cos(phi), REAL(0.0) };
			default:
			return Vector3Cartesian{ REAL(0.0), REAL(0.0), REAL(0.0) };
			}
		}

		Vector3Spherical getInverseBasisVec(int ind, const Vector3Spherical& pos) override
		{
			const Real r = pos[0];
			const Real theta = pos[1];
			const Real phi = pos[2];
			switch(ind)
			{
			case 0: return Vector3Spherical{ sin(theta) * cos(phi), r * cos(theta) * cos(phi), -r * sin(theta) * sin(phi) };
			case 1: return Vector3Spherical{ sin(theta) * sin(phi), r * cos(theta) * sin(phi),  r * sin(theta) * cos(phi) };
			case 2: return Vector3Spherical{ cos(theta)           ,-r * sin(theta)           ,                        REAL(0.0) };
			default: 
			return Vector3Spherical{ REAL(0.0), REAL(0.0), REAL(0.0) };
			}
		}
		Vector3Spherical getInverseUnitBasisVec(int ind, const Vector3Spherical& pos)
		{
			const Real r = pos[0];
			const Real theta = pos[1];
			const Real phi = pos[2];
			switch(ind)
			{
			case 0: return Vector3Spherical{ sin(theta) * cos(phi),  cos(theta) * cos(phi), -sin(phi) };
			case 1: return Vector3Spherical{ sin(theta) * sin(phi),  cos(theta) * sin(phi),  cos(phi) };
			case 2: return Vector3Spherical{ cos(theta)           , -sin(theta)           ,  REAL(0.0) };
			default: 
			return Vector3Spherical{ REAL(0.0), REAL(0.0), REAL(0.0) };
			}
		}
	};

	class CoordTransfCartesianToSpherical : public CoordTransfWithInverse<Vector3Cartesian, Vector3Spherical, 3>
	{
	private:
		// q[0] = x
		// q[1] = y
		// q[2] = z
		static Real r(const VectorN<Real, 3>& q) { return sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]); }
		static Real theta(const VectorN<Real, 3>& q) { return acos(q[2] / sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2])); }
		static Real phi(const VectorN<Real, 3>& q) { return atan2(q[1], q[0]); }

		// q[0] = r     - radial distance
		// q[1] = theta - inclination
		// q[2] = phi   - azimuthal angle
		static Real x(const VectorN<Real, 3>& q) { return q[0] * sin(q[1]) * cos(q[2]); }
		static Real y(const VectorN<Real, 3>& q) { return q[0] * sin(q[1]) * sin(q[2]); }
		static Real z(const VectorN<Real, 3>& q) { return q[0] * cos(q[1]); }

		inline static ScalarFunction<3> _func[3] = { ScalarFunction<3>{r},
																								 ScalarFunction<3>{theta},
																								 ScalarFunction<3>{phi}
		};

		inline static ScalarFunction<3> _funcInverse[3] = { ScalarFunction<3>{x},
																												ScalarFunction<3>{y},
																												ScalarFunction<3>{z}
		};
	public:
		Vector3Spherical     transf(const Vector3Cartesian& q) const { return Vector3Spherical{ r(q), theta(q), phi(q) }; }
		Vector3Cartesian     transfInverse(const Vector3Spherical& q) const { return Vector3Cartesian{ x(q), y(q), z(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i) const { return _func[i]; }
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const { return _funcInverse[i]; }
	};


	static CoordTransfSphericalToCartesian      CoordTransfSpherToCart;
	static CoordTransfCartesianToSpherical      CoordTransfCartToSpher;
}


///////////////////////////   mml/core/CoordTransf/CoordTransfCylindrical.h   ///////////////////////////




namespace MML
{

	class CoordTransfCylindricalToCartesian : public CoordTransfWithInverse<Vector3Cylindrical, Vector3Cartesian, 3>
	{
	private:
		// q1 = r   - distance from symmetry axis
		// q2 = phi - angle to symmetry axis
		// q3 = z   - z
		static Real x(const VectorN<Real, 3>& q) { return q[0] * cos(q[1]); }
		static Real y(const VectorN<Real, 3>& q) { return q[0] * sin(q[1]); }
		static Real z(const VectorN<Real, 3>& q) { return q[2]; }

		// q[0] = x
		// q[1] = y
		// q[2] = z
		static Real r(const VectorN<Real, 3>& q) { return sqrt(q[0] * q[0] + q[1] * q[1]); }
		static Real phi(const VectorN<Real, 3>& q) { return atan2(q[1], q[0]); }
		// z-coordinate is the same, so we'll use for inverse the same function as for forward transformation

		inline static ScalarFunction<3> _func[3] = { ScalarFunction<3>{x},
																								 ScalarFunction<3>{y},
																								 ScalarFunction<3>{z}
		};

		inline static ScalarFunction<3> _funcInverse[3] = { ScalarFunction<3>{r},
																												ScalarFunction<3>{phi},
																												ScalarFunction<3>{z}
		};
	public:
		Vector3Cartesian     transf(const Vector3Cylindrical& q)      const { return Vector3Cartesian{ x(q), y(q), z(q) }; }
		Vector3Cylindrical   transfInverse(const Vector3Cartesian& q) const { return Vector3Cylindrical{ r(q), phi(q), z(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i)        const { return _func[i]; }
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const { return _funcInverse[i]; }
	};

	class CoordTransfCartesianToCylindrical : public CoordTransfWithInverse<Vector3Cartesian, Vector3Cylindrical, 3>
	{
	private:
		// q[0] = x
		// q[1] = y
		// q[2] = z
		static Real r(const VectorN<Real, 3>& q) { return sqrt(q[0] * q[0] + q[1] * q[1]); }
		static Real phi(const VectorN<Real, 3>& q) { return atan2(q[1], q[0]); }
		static Real z(const VectorN<Real, 3>& q) { return q[2]; }

		// q1 = r   - distance from symmetry axis
		// q2 = phi - angle to symmetry axis
		// q3 = z   - z
		static Real x(const VectorN<Real, 3>& q) { return q[0] * cos(q[1]); }
		static Real y(const VectorN<Real, 3>& q) { return q[0] * sin(q[1]); }

		inline static ScalarFunction<3> _func[3] = { ScalarFunction<3>{r},
																								 ScalarFunction<3>{phi},
																								 ScalarFunction<3>{z}
		};

		inline static ScalarFunction<3> _funcInverse[3] = { ScalarFunction<3>{x},
																												ScalarFunction<3>{y},
																												ScalarFunction<3>{z}
		};
	public:
		Vector3Cylindrical transf(const Vector3Cartesian& q)          const { return Vector3Cylindrical{ r(q), phi(q), z(q) }; }
		Vector3Cartesian   transfInverse(const Vector3Cylindrical& q) const { return Vector3Cartesian{ x(q), y(q), z(q) }; }

		const IScalarFunction<3>& coordTransfFunc(int i)        const { return _func[i]; }
		const IScalarFunction<3>& inverseCoordTransfFunc(int i) const { return _funcInverse[i]; }
	};

	static CoordTransfCartesianToCylindrical    CoordTransfCartToCyl;
	static CoordTransfCylindricalToCartesian    CoordTransfCylToCart;

}


///////////////////////////   mml/core/CoordTransf/CoordTransfLorentz.h   ///////////////////////////





namespace MML
{
	class CoordTransfLorentzXAxis : public CoordTransfWithInverse<Vector4Minkowski, Vector4Minkowski, 4>
	{
	private:
		Real    _velocity;			// expressed in units of c (speed of light)
		MatrixNM<Real, 4, 4>  _transf;
		MatrixNM<Real, 4, 4>  _inverse;

		const ScalarFunctionFromStdFunc<4> _f1, _f2, _f3, _f4;
		const ScalarFunctionFromStdFunc<4> _fInv1, _fInv2, _fInv3, _fInv4;

	public:
		CoordTransfLorentzXAxis(Real inVelocity) : _velocity(inVelocity),
			_f1(std::function<Real(const VectorN<Real, 4>&)> { std::bind(&CoordTransfLorentzXAxis::func1, this, std::placeholders::_1) }),
			_f2(std::function<Real(const VectorN<Real, 4>&)> { std::bind(&CoordTransfLorentzXAxis::func2, this, std::placeholders::_1) }),
			_f3(std::function<Real(const VectorN<Real, 4>&)> { std::bind(&CoordTransfLorentzXAxis::func3, this, std::placeholders::_1) }),
			_f4(std::function<Real(const VectorN<Real, 4>&)> { std::bind(&CoordTransfLorentzXAxis::func4, this, std::placeholders::_1) }),
			_fInv1(std::function<Real(const VectorN<Real, 4>&)> { std::bind(&CoordTransfLorentzXAxis::funcInverse1, this, std::placeholders::_1) }),
			_fInv2(std::function<Real(const VectorN<Real, 4>&)> { std::bind(&CoordTransfLorentzXAxis::funcInverse2, this, std::placeholders::_1) }),
			_fInv3(std::function<Real(const VectorN<Real, 4>&)> { std::bind(&CoordTransfLorentzXAxis::funcInverse3, this, std::placeholders::_1) }),
			_fInv4(std::function<Real(const VectorN<Real, 4>&)> { std::bind(&CoordTransfLorentzXAxis::funcInverse4, this, std::placeholders::_1) })
		{
			if (_velocity < 0.0 || _velocity >= 1.0)
				throw std::range_error("Invalid velocity for Lorentz transformation: must be in [0, 1).");

			Real gamma = REAL(1.0) / sqrt(REAL(1.0) - _velocity * _velocity);
			Real beta = _velocity;

			_transf[0][0] = gamma;
			_transf[0][1] = -beta * gamma;
			_transf[1][0] = -beta * gamma;
			_transf[1][1] = gamma;
			_transf[2][2] = 1.0;
			_transf[3][3] = 1.0;

		_inverse[0][0] = gamma;
		_inverse[0][1] = beta * gamma;
		_inverse[1][0] = beta * gamma;
		_inverse[1][1] = gamma;
		_inverse[2][2] = 1.0;
		_inverse[3][3] = 1.0;
		}

		Real func1(const VectorN<Real, 4>& q) const { return (_transf * q)[0]; }
		Real func2(const VectorN<Real, 4>& q) const { return (_transf * q)[1]; }
		Real func3(const VectorN<Real, 4>& q) const { return (_transf * q)[2]; }
		Real func4(const VectorN<Real, 4>& q) const { return (_transf * q)[3]; }

		Real funcInverse1(const VectorN<Real, 4>& q) const { return (_inverse * q)[0]; }
		Real funcInverse2(const VectorN<Real, 4>& q) const { return (_inverse * q)[1]; }
		Real funcInverse3(const VectorN<Real, 4>& q) const { return (_inverse * q)[2]; }
		Real funcInverse4(const VectorN<Real, 4>& q) const { return (_inverse * q)[3]; }

		Vector4Minkowski    transf(const Vector4Minkowski& q) const { return Vector4Minkowski{ func1(q), func2(q), func3(q), func4(q) }; }
		Vector4Minkowski    transfInverse(const Vector4Minkowski& q) const { return Vector4Minkowski{ funcInverse1(q), funcInverse2(q), funcInverse3(q), funcInverse4(q) }; }

		const IScalarFunction<4>& coordTransfFunc(int i) const
		{
			if (i == 0) return _f1;
			else if (i == 1) return _f2;
			else if (i == 2) return _f3;
			else return _f4;
		}
		const IScalarFunction<4>& inverseCoordTransfFunc(int i) const
		{
			if (i == 0) return _fInv1;
			else if (i == 1) return _fInv2;
			else if (i == 2) return _fInv3;
			else return _fInv4;
		}
	};
}


///////////////////////////   mml/core/CoordSystem.h   ///////////////////////////




namespace MML
{
	// FIXED referential frame, Cartesian local coordinates
	class ReferenceFrame3D
	{ 
		ReferenceFrame3D* _parentFrame = nullptr;
		std::vector<ReferenceFrame3D*> _childFrames;

	public:
		ReferenceFrame3D() {}
		ReferenceFrame3D(ReferenceFrame3D* parentFrame)
		{
			SetParentFrame(parentFrame);
		}

		void SetParentFrame(ReferenceFrame3D* parentFrame)
		{
			if (parentFrame != nullptr)
			{
				_parentFrame = parentFrame;
				parentFrame->AddChildFrame(this);
			}
			else
			{
				_parentFrame = nullptr;
			}
		}
		void AddChildFrame(ReferenceFrame3D* childFrame)
		{
			_childFrames.push_back(childFrame);
			childFrame->_parentFrame = this;
		}

		// get child origin position at T, with reference to parent frame
		virtual Vector3Cartesian GetOriginPositionAtTime(Real t) const
		{
			return Vector3Cartesian({ 0,0,0 });
		}

		// get LocalPoint position at time T, in parent frame
		virtual Vector3Cartesian GetLocalPosInParentFrameAtTime(const VectorN<Real, 3> &pos, Real t) const 
		{
			return pos;
		}
	};

	class InertialFrame3D : public ReferenceFrame3D
	{
		// u odnosu na drugi referential frame ima samo konstantu brzinu
		Vector3Cartesian _velocity;
		Vector3Cartesian _pos_at_0;

	public:
		InertialFrame3D() {}
		InertialFrame3D(ReferenceFrame3D* parentFrame)
		{
			SetParentFrame(parentFrame);
		}
		InertialFrame3D(ReferenceFrame3D* parentFrame, Vector3Cartesian velocity, Vector3Cartesian pos_at_0) : _velocity(velocity), _pos_at_0(pos_at_0)
		{
			SetParentFrame(parentFrame);
		}

		virtual Vector3Cartesian GetOriginPositionAtTime(Real t) const override 
		{
			return _pos_at_0 + t * _velocity;
		}
		virtual Vector3Cartesian GetLocalPosInParentFrameAtTime(const VectorN<Real, 3> &pos, Real t)  const override
		{
			return GetOriginPositionAtTime(t) + pos;
		}
	};

	class NonInertialFrame3D : public ReferenceFrame3D
	{
	public:
		NonInertialFrame3D() {}
		NonInertialFrame3D(ReferenceFrame3D* parentFrame)
		{
			SetParentFrame(parentFrame);
		}
		// getOriginPositionAtTime - vraca poziciju u odnosu na ReferentialFrame3D
		// getSpeedAtTime - vraca brzinu u odnosu na ReferentialFrame3D
	};

	// ovo je referentni frame koji se rotira oko nekog centra mase, i treba ga zamisliti kao kocku koja rotira oko CM
	class CircleOrbitingFrame3DCartesian : public NonInertialFrame3D
	{
		// koristimo Cartesian sustav - vraca pozicije u odnosu na CM oko kojeg orbitira U CARTESIAN KOORDINATAMA
		// Å¡to ukoliko parametre orbite ne zelim u Cartesian sustavu? - nova klasa CircleOrbitingFrame3DSpherical
	public:
		Real _radius;
		Real _speed;
		Real _period;
		Real _angle_at_t0;
		// normal to plane (axis of rotation), kad je ravnina orbite zakrenuta
		Vector3Cartesian _axis;

		CircleOrbitingFrame3DCartesian(ReferenceFrame3D* parentFrame, Real radius, Real period) : NonInertialFrame3D(parentFrame)
		{
			_radius = radius;
			// _speed = speed; // izracunati
			_period = period;
			_angle_at_t0 = 0;
		}
		CircleOrbitingFrame3DCartesian(ReferenceFrame3D* parentFrame, Real radius, Real period, Real angle_at_t0) : NonInertialFrame3D(parentFrame)
		{
			_radius = radius;
			_period = period;
			_angle_at_t0 = angle_at_t0;
		}
		CircleOrbitingFrame3DCartesian(ReferenceFrame3D* parentFrame, Real radius, Real period, Real orbit_inclination, Real angle_at_t0) : NonInertialFrame3D(parentFrame)
		{
			_radius = radius;
			_period = period;
			_angle_at_t0 = angle_at_t0;
			// calc axis based on inclination
		}

		virtual Vector3Cartesian GetOriginPositionAtTime(Real t) const override
		{
			// calculate rotational evolution of position of center of mass
			Real angle = _angle_at_t0 + 2 * Constants::PI * t / _period;
			// in z-plane!
			Vector3Cartesian CM_pos({ _radius * cos(angle), _radius * sin(angle), 0 });

			return CM_pos;
		}

		virtual Vector3Cartesian GetLocalPosInParentFrameAtTime(const VectorN<Real, 3> &pos, Real t) const override
		{
			// calculate evolution of position of center of mass
			Vector3Cartesian CM_pos = GetOriginPositionAtTime(t);

			// add local coordinates to CM position
			// BITNA PRETPOSTAVKA - kako naÅ¡ sustav rotira oko CM, njegova apsolutna orijentacije se ne mijenja
			// ie, Zemljina (lokalna) os rotacije je jednom nagnuta OD Sunca, a za sest mjeseci nagnuta PREMA Suncu
			return CM_pos + pos;
		}
	};

	class RotatingFrame3D : public NonInertialFrame3D
	{
		// ovaj frame koristi cilindriÄni sustav (generalna rotacija oko osi)
	public:
		Real _period;
		Real _angle_at_t0;
		VectorN<Real, 3> _axis;     // pretpostavljamo z-axis za pocetak

		RotatingFrame3D(ReferenceFrame3D* parentFrame, Real period, VectorN<Real, 3> axis) : NonInertialFrame3D(parentFrame)
		{
			_period = period;
			_axis = axis;
		}

		// get child origin position at T, with reference to parent frame
		virtual Vector3Cartesian GetOriginPositionAtTime(Real t) const override
		{
			return Vector3Cartesian({ 0,0,0 });
		}

		// get LocalPoint position at time T, in parent frame
		virtual Vector3Cartesian GetLocalPosInParentFrameAtTime(const VectorN<Real, 3> &pos, Real t) const override
		{
			// pos is in cylindrical coordinates
			
			Real angle = fmod(2 * Constants::PI / _period * t, 2 * Constants::PI);

			return VectorN<Real, 3>({ _axis[0] * cos(angle), _axis[1] * sin(angle), pos[2] });
		}
	};

	class SphericalRotatingFrame : public RotatingFrame3D
	{
		// ovaj frame radi sa spherical koordinatama
	public:
		SphericalRotatingFrame(ReferenceFrame3D* parentFrame, Real period, VectorN<Real, 3> axis)
			: RotatingFrame3D(parentFrame, period, axis) {}

		VectorN<Real, 3> GetPositionAtTime(Vector3Spherical pos, Real t)
		{
			return VectorN<Real, 3>({ 0,0,0 });
		}
	};

	class HardSphereRotatingFrame : public RotatingFrame3D
	{
		// lokalne koordinate - lat, long, h 
		// ima svoj CENTAR MASE u sredini sfere, i u odnosu na njega vraÄ‡a pozicije
		// koje su usuglasene s axisom rotacije (lat, long)
	public:
		// axis rotacije zadan base klasom
		double _radius;

		HardSphereRotatingFrame(ReferenceFrame3D* parentFrame, Real radius, Real period, VectorN<Real, 3> axis)
			: _radius(radius), RotatingFrame3D(parentFrame, period, axis) {}

		// get origin position at T, with reference to parent frame
		virtual Vector3Cartesian GetOriginPositionAtTime(Real t) const override
		{
			// it is NOT moving, only rotating
			return Vector3Cartesian({ 0,0,0 });
		}

		// get LocalPoint position at time T, in parent frame, meaning Cartesian coordinates
		virtual Vector3Cartesian GetLocalPosInParentFrameAtTime(const VectorN<Real, 3> &localPos, Real t) const override
		{
			Real latitudeDeg = localPos[0];
			Real longitudeDeg = localPos[1];
			Real h = localPos[2];

			// formirati sferni vektor, i vidjeti koliko se zarotira za T
		Vector3Spherical spherePos({Real(_radius + h), Real(Utils::DegToRad(90 - latitudeDeg)), Real(Utils::DegToRad(longitudeDeg)) });
			// transf u Cartesian
			Vector3Cartesian cartPos = CoordTransfSpherToCart.transf(spherePos);

			return cartPos;
		}
	};

	class RotatingSphereLocalCartesian : public InertialFrame3D
	{
		// u ctor dobije ref na HardSphereRotatingFrame, I TOCNO ODREDJENU TOCKU NA SFERI!!!
		// ima smisla - gleda nakon deltaT gdje je pozicija tocke u jednom i drugom
		const HardSphereRotatingFrame& _parentFrame;
		const Real _latitude;
		const Real _longitude;
	public:
		RotatingSphereLocalCartesian(const HardSphereRotatingFrame &parent, Real latitude, Real longitude)  : _parentFrame(parent), _latitude(latitude), _longitude(longitude)
		{
		}
		// kosi hitac zadan u lokalnom kartezijevom, i izracunam
		// onda vidim gdje je taj lokalni kartezije u trenutku deltaT, i da li se 
		// slaze TRENUTNA tocka (x,y,z) di je sletio hitac, s onom kako sam izracunao

		// get origin position at T, with reference to parent frame
		// UZETI U OBZIR DA SE ORIGIN TOCKA ROTIRA!!!
		virtual Vector3Cartesian GetOriginPositionAtTime(Real t) const override
		{
			// depends on HardSphere rotating period
			return Vector3Cartesian({ 0,0,0 });
		}

		// return type NISU CARTESIAN!!! - to su lat, long, h
		virtual Vector3Cartesian GetLocalPosInParentFrameAtTime(const VectorN<Real, 3> &localPos, Real t) const override
		{
			// VRIJEME IGNORIRAMO!!!
			// ukljuceno je u parent kalkulacije, i ovdje samo vracamo transf lokalnih (x, y, z) u (lat, long, h)
			Vector3Cartesian pos(localPos);

			double one_km_in_lat_deg = 1 / 111.32;
			double one_lat_deg_in_km = 2 * _parentFrame._radius * cos(Utils::DegToRad(_latitude)) * Constants::PI / 360;
			double one_km_in_long_deg = 1 / one_lat_deg_in_km;

			// local x axis is oriented towards east, y towards north
			// so dx is in longitude direction, dy in latitude direction
			double latitudeDeg = _latitude + pos[1] * one_km_in_lat_deg;
			double longitudeDeg = _longitude + pos[0] * one_km_in_long_deg;
			double h = localPos[2];								// h is equal to z locally


			Vector3Cartesian ret(latitudeDeg, longitudeDeg, h);

			return ret;
		}
	};

	// da li mi treba Local3D koji za parenta ima HardSphereRotatingFrameToSpherical?
	// lokalni sustav, baziran na TOCNO ODREDJENOJ TOCKI SFERE, s x, y i z
	// za njega NE TREBA davati lat, long i h jer vec ima, a x, y i z transformira lokalno

 
}


///////////////////////////   mml/core/FieldOperations.h   ///////////////////////////






namespace MML
{
	///////////////////////////////////////////////////////////////////////////////////////////
	/// ScalarFieldOperations - Differential operations on scalar fields
	///
	/// Provides gradient and Laplacian operations for scalar-valued functions of N variables.
	/// Supports:
	///   - Cartesian coordinates (any dimension N)
	///   - Spherical coordinates (3D): (r, Î¸, Ï†) where Î¸=polar, Ï†=azimuthal
	///   - Cylindrical coordinates (3D): (r, Ï†, z)
	///   - General curvilinear coordinates via metric tensor
	///
	/// Derivative accuracy can be controlled via der_order parameter (1, 2, 4, 6, or 8 points).
	///////////////////////////////////////////////////////////////////////////////////////////
	namespace ScalarFieldOperations
	{
		///////////////////////////////////////////////////////////////////////////////////////////
		//                           GENERAL COORDINATE OPERATIONS
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes gradient of scalar field in general curvilinear coordinates.
		///
		/// Uses the metric tensor to properly handle non-Cartesian coordinate systems.
		/// The gradient is computed as: âˆ‡f = gâ±Ê² âˆ‚â±¼f where gâ±Ê² is the contravariant metric.
		///
		/// @tparam N          Number of dimensions
		/// @param scalarField Scalar function f: â„á´º â†’ â„
		/// @param pos         Position vector in the coordinate system
		/// @param metricTensorField  Metric tensor field defining the coordinate geometry
		/// @return            Gradient vector âˆ‡f with contravariant components
		///
		/// @note For Cartesian coordinates, use GradientCart() which is more efficient.
		/// @see MetricTensorField, GradientCart
		template<int N>
		static VectorN<Real, N> Gradient(IScalarFunction<N>& scalarField, const VectorN<Real, N>& pos, 
																		 const MetricTensorField<N>& metricTensorField)
		{
			// Gradient in general coordinates: âˆ‡á¶  = gâ±Ê² âˆ‚áµ¢f
			// The partial derivatives âˆ‚áµ¢f give covariant components
			// We need the contravariant metric gâ±Ê² to raise indices
			VectorN<Real, N> covar_derivs = Derivation::DerivePartialAll<N>(scalarField, pos, nullptr);

			MatrixNM<Real, N, N> g_contravar = metricTensorField.GetContravariantMetric(pos);

			VectorN<Real, N> ret;
			for (int i = 0; i < N; i++)
			{
				ret[i] = 0.0;
				for (int j = 0; j < N; j++)
					ret[i] += g_contravar[i][j] * covar_derivs[j];
			}

			return ret;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                              GRADIENT - CARTESIAN
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes gradient of scalar field in Cartesian coordinates.
		///
		/// For f(xâ‚, xâ‚‚, ..., xâ‚™), returns âˆ‡f = (âˆ‚f/âˆ‚xâ‚, âˆ‚f/âˆ‚xâ‚‚, ..., âˆ‚f/âˆ‚xâ‚™)
		/// Uses default numerical differentiation (4-point formula).
		///
		/// @tparam N          Number of dimensions
		/// @param scalarField Scalar function f: â„á´º â†’ â„
		/// @param pos         Position vector (xâ‚, xâ‚‚, ..., xâ‚™)
		/// @return            Gradient vector âˆ‡f
		///
		/// @example
		///   // f(x,y,z) = xÂ² + 2y + 3z
		///   ScalarFunction<3> f([](auto& p){ return p[0]*p[0] + 2*p[1] + 3*p[2]; });
		///   auto grad = GradientCart(f, {1,1,1});  // Returns (2, 2, 3)
		template<int N>
		static VectorN<Real, N> GradientCart(const IScalarFunction<N>& scalarField, const VectorN<Real, N>& pos)
		{
			return Derivation::DerivePartialAll<N>(scalarField, pos, nullptr);
		}

		/// Computes gradient in Cartesian coordinates with specified derivative accuracy.
		///
		/// @tparam N          Number of dimensions
		/// @param scalarField Scalar function f: â„á´º â†’ â„
		/// @param pos         Position vector (xâ‚, xâ‚‚, ..., xâ‚™)
		/// @param der_order   Derivative accuracy: 1, 2, 4, 6, or 8 (higher = more accurate but slower)
		/// @return            Gradient vector âˆ‡f
		/// @throws std::invalid_argument if der_order is not in {1, 2, 4, 6, 8}
		template<int N>
		static VectorN<Real, N> GradientCart(const IScalarFunction<N>& scalarField, const VectorN<Real, N>& pos, 
																				 int der_order)
		{
			switch (der_order)
			{
			case 1: return Derivation::NDer1PartialByAll<N>(scalarField, pos, nullptr);
			case 2: return Derivation::NDer2PartialByAll<N>(scalarField, pos, nullptr);
			case 4: return Derivation::NDer4PartialByAll<N>(scalarField, pos, nullptr);
			case 6: return Derivation::NDer6PartialByAll<N>(scalarField, pos, nullptr);
			case 8: return Derivation::NDer8PartialByAll<N>(scalarField, pos, nullptr);
			default:
				throw std::invalid_argument("GradientCart: der_order must be in 1, 2, 4, 6 or 8");
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                              GRADIENT - SPHERICAL
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes gradient in spherical coordinates (r, Î¸, Ï†).
		///
		/// For spherical coordinates where:
		///   - r âˆˆ [0, âˆž)     : radial distance from origin
		///   - Î¸ âˆˆ [0, Ï€]     : polar angle from z-axis
		///   - Ï† âˆˆ [0, 2Ï€)    : azimuthal angle in xy-plane
		///
		/// Returns: âˆ‡f = (âˆ‚f/âˆ‚r, (1/r)âˆ‚f/âˆ‚Î¸, (1/rÂ·sinÎ¸)âˆ‚f/âˆ‚Ï†)
		///
		/// @param scalarField Scalar function f(r, Î¸, Ï†)
		/// @param pos         Position vector (r, Î¸, Ï†) in spherical coordinates
		/// @return            Gradient vector in spherical basis (Ãªáµ£, ÃªÎ¸, ÃªÏ†)
		///
		/// @warning Position must have r > 0 and Î¸ â‰  0, Ï€ to avoid singularities.
		static VectorN<Real, 3> GradientSpher(const IScalarFunction<3>& scalarField, const Vec3Sph& pos)
		{
			Vector3Spherical ret = Derivation::DerivePartialAll<3>(scalarField, pos, nullptr);

			ret[1] = ret[1] / pos[0];                    // Î¸-component: (1/r) âˆ‚f/âˆ‚Î¸
			ret[2] = ret[2] / (pos[0] * sin(pos[1]));    // Ï†-component: (1/rÂ·sinÎ¸) âˆ‚f/âˆ‚Ï†

			return ret;
		}

		/// Computes gradient in spherical coordinates with specified derivative accuracy.
		///
		/// @param scalarField Scalar function f(r, Î¸, Ï†)
		/// @param pos         Position vector (r, Î¸, Ï†)
		/// @param der_order   Derivative accuracy: 1, 2, 4, 6, or 8
		/// @return            Gradient vector in spherical basis
		/// @throws std::invalid_argument if der_order is not in {1, 2, 4, 6, 8}
		static Vec3Sph GradientSpher(const IScalarFunction<3>& scalarField, const Vec3Sph& pos, 
																 int der_order)
		{
			Vector3Spherical ret;

			switch (der_order)
			{
			case 1: ret = Derivation::NDer1PartialByAll<3>(scalarField, pos, nullptr); break;
			case 2: ret = Derivation::NDer2PartialByAll<3>(scalarField, pos, nullptr); break;
			case 4: ret = Derivation::NDer4PartialByAll<3>(scalarField, pos, nullptr); break;
			case 6: ret = Derivation::NDer6PartialByAll<3>(scalarField, pos, nullptr); break;
			case 8: ret = Derivation::NDer8PartialByAll<3>(scalarField, pos, nullptr); break;
			default:
				throw std::invalid_argument("GradientSpher: der_order must be in 1, 2, 4, 6 or 8");
			}

			ret[1] = ret[1] / pos[0];                    // Î¸-component
			ret[2] = ret[2] / (pos[0] * sin(pos[1]));    // Ï†-component

			return ret;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                              GRADIENT - CYLINDRICAL
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes gradient in cylindrical coordinates (r, Ï†, z).
		///
		/// For cylindrical coordinates where:
		///   - r âˆˆ [0, âˆž)     : radial distance from z-axis
		///   - Ï† âˆˆ [0, 2Ï€)    : azimuthal angle in xy-plane
		///   - z âˆˆ (-âˆž, âˆž)   : height along z-axis
		///
		/// Returns: âˆ‡f = (âˆ‚f/âˆ‚r, (1/r)âˆ‚f/âˆ‚Ï†, âˆ‚f/âˆ‚z)
		///
		/// @param scalarField Scalar function f(r, Ï†, z)
		/// @param pos         Position vector (r, Ï†, z) in cylindrical coordinates
		/// @return            Gradient vector in cylindrical basis (Ãªáµ£, ÃªÏ†, Ãªz)
		///
		/// @warning Position must have r > 0 to avoid singularity at z-axis.
		static Vec3Cyl GradientCyl(const IScalarFunction<3>& scalarField, const Vec3Cyl& pos)
		{
			Vector3Cylindrical ret = Derivation::DerivePartialAll<3>(scalarField, pos, nullptr);

			ret[1] = ret[1] / pos[0];    // Ï†-component: (1/r) âˆ‚f/âˆ‚Ï†

			return ret;
		}

		/// Computes gradient in cylindrical coordinates with specified derivative accuracy.
		///
		/// @param scalarField Scalar function f(r, Ï†, z)
		/// @param pos         Position vector (r, Ï†, z)
		/// @param der_order   Derivative accuracy: 1, 2, 4, 6, or 8
		/// @return            Gradient vector in cylindrical basis
		/// @throws std::invalid_argument if der_order is not in {1, 2, 4, 6, 8}
		static Vec3Cyl GradientCyl(const IScalarFunction<3>& scalarField, const Vec3Cyl& pos, 
															 int der_order)
		{
			Vector3Cylindrical ret;

			switch (der_order)
			{
			case 1: ret = Derivation::NDer1PartialByAll<3>(scalarField, pos, nullptr); break;
			case 2: ret = Derivation::NDer2PartialByAll<3>(scalarField, pos, nullptr); break;
			case 4: ret = Derivation::NDer4PartialByAll<3>(scalarField, pos, nullptr); break;
			case 6: ret = Derivation::NDer6PartialByAll<3>(scalarField, pos, nullptr); break;
			case 8: ret = Derivation::NDer8PartialByAll<3>(scalarField, pos, nullptr); break;
			default:
				throw std::invalid_argument("GradientCyl: der_order must be in 1, 2, 4, 6 or 8");
			}
			ret[1] = ret[1] / pos[0];    // Ï†-component

			return ret;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                                    LAPLACIAN
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes Laplacian of scalar field in Cartesian coordinates.
		///
		/// The Laplacian âˆ‡Â²f = Î£áµ¢ âˆ‚Â²f/âˆ‚xáµ¢Â² measures the "curvature" of the scalar field,
		/// or equivalently, how much the value at a point differs from the average
		/// of surrounding points. It appears in:
		///   - Heat equation: âˆ‚T/âˆ‚t = Î±âˆ‡Â²T
		///   - Wave equation: âˆ‚Â²u/âˆ‚tÂ² = cÂ²âˆ‡Â²u
		///   - Poisson equation: âˆ‡Â²Ï† = -Ï/Îµâ‚€
		///
		/// @tparam N          Number of dimensions
		/// @param scalarField Scalar function f: â„á´º â†’ â„
		/// @param pos         Position vector
		/// @return            Scalar Laplacian value âˆ‡Â²f
		///
		/// @example
		///   // f(x,y,z) = xÂ² + yÂ² + zÂ² (paraboloid)
		///   ScalarFunction<3> f([](auto& p){ return p[0]*p[0] + p[1]*p[1] + p[2]*p[2]; });
		///   Real lapl = LaplacianCart(f, {1,1,1});  // Returns 6.0 (constant curvature)
		template<int N>
		static Real LaplacianCart(const IScalarFunction<N>& scalarField, const VectorN<Real, N>& pos)
		{
			Real lapl = 0.0;
			for (int i = 0; i < N; i++)
				lapl += Derivation::DeriveSecPartial<N>(scalarField, i, i, pos, nullptr);

			return lapl;
		}

		/// Computes Laplacian of scalar field in spherical coordinates.
		///
		/// In spherical coordinates (r, Î¸, Ï†):
		///   âˆ‡Â²f = (1/rÂ²)âˆ‚/âˆ‚r(rÂ²âˆ‚f/âˆ‚r) + (1/rÂ²sinÎ¸)âˆ‚/âˆ‚Î¸(sinÎ¸Â·âˆ‚f/âˆ‚Î¸) + (1/rÂ²sinÂ²Î¸)âˆ‚Â²f/âˆ‚Ï†Â²
		///
		/// @param scalarField Scalar function f(r, Î¸, Ï†)
		/// @param pos         Position (r, Î¸, Ï†) with r > 0, 0 < Î¸ < Ï€
		/// @return            Scalar Laplacian value âˆ‡Â²f
		///
		/// @warning Singular at r = 0 and Î¸ = 0, Ï€ (coordinate singularities)
		static Real LaplacianSpher(const IScalarFunction<3>& scalarField, const Vec3Sph& pos)
		{
			const Real r = pos.R();
			const Real theta = pos.Theta();
			// Note: phi = pos.Phi() is not needed directly in the Laplacian formula

			// âˆ‡Â²f = âˆ‚Â²f/âˆ‚rÂ² + (2/r)âˆ‚f/âˆ‚r + (1/rÂ²sinÎ¸)[cosÎ¸Â·âˆ‚f/âˆ‚Î¸ + sinÎ¸Â·âˆ‚Â²f/âˆ‚Î¸Â²] + (1/rÂ²sinÂ²Î¸)âˆ‚Â²f/âˆ‚Ï†Â²
			//     = âˆ‚Â²f/âˆ‚rÂ² + (2/r)âˆ‚f/âˆ‚r + (cotÎ¸/rÂ²)âˆ‚f/âˆ‚Î¸ + (1/rÂ²)âˆ‚Â²f/âˆ‚Î¸Â² + (1/rÂ²sinÂ²Î¸)âˆ‚Â²f/âˆ‚Ï†Â²
			
			// Radial term: âˆ‚Â²f/âˆ‚rÂ²
			Real d2f_dr2 = Derivation::DeriveSecPartial<3>(scalarField, 0, 0, pos, nullptr);
			
			// Radial correction: (2/r)âˆ‚f/âˆ‚r
			Real df_dr = Derivation::DerivePartial<3>(scalarField, 0, pos, nullptr);
			Real radial_correction = (2.0 / r) * df_dr;
			
			// Polar (Î¸) term: (cotÎ¸/rÂ²)âˆ‚f/âˆ‚Î¸ + (1/rÂ²)âˆ‚Â²f/âˆ‚Î¸Â²
			Real df_dtheta = Derivation::DerivePartial<3>(scalarField, 1, pos, nullptr);
			Real d2f_dtheta2 = Derivation::DeriveSecPartial<3>(scalarField, 1, 1, pos, nullptr);
			Real theta_term = (cos(theta) / (r * r * sin(theta))) * df_dtheta + (1.0 / (r * r)) * d2f_dtheta2;
			
			// Azimuthal (Ï†) term: (1/rÂ²sinÂ²Î¸)âˆ‚Â²f/âˆ‚Ï†Â²
			Real d2f_dphi2 = Derivation::DeriveSecPartial<3>(scalarField, 2, 2, pos, nullptr);
			Real phi_term = (1.0 / (r * r * sin(theta) * sin(theta))) * d2f_dphi2;

			return d2f_dr2 + radial_correction + theta_term + phi_term;
		}

		/// Computes Laplacian of scalar field in cylindrical coordinates.
		///
		/// In cylindrical coordinates (r, Ï†, z):
		///   âˆ‡Â²f = (1/r)âˆ‚/âˆ‚r(rÂ·âˆ‚f/âˆ‚r) + (1/rÂ²)âˆ‚Â²f/âˆ‚Ï†Â² + âˆ‚Â²f/âˆ‚zÂ²
		///
		/// @param scalarField Scalar function f(r, Ï†, z)
		/// @param pos         Position (r, Ï†, z) with r > 0
		/// @return            Scalar Laplacian value âˆ‡Â²f
		///
		/// @warning Singular at r = 0 (z-axis singularity)
		static Real LaplacianCyl(const IScalarFunction<3>& scalarField, const Vec3Cyl& pos)
		{
			const Real r = pos[0];

			// âˆ‡Â²f = (1/r)âˆ‚/âˆ‚r(rÂ·âˆ‚f/âˆ‚r) + (1/rÂ²)âˆ‚Â²f/âˆ‚Ï†Â² + âˆ‚Â²f/âˆ‚zÂ²
			//     = (1/r)âˆ‚f/âˆ‚r + âˆ‚Â²f/âˆ‚rÂ² + (1/rÂ²)âˆ‚Â²f/âˆ‚Ï†Â² + âˆ‚Â²f/âˆ‚zÂ²
			
			// Radial term: (1/r)âˆ‚f/âˆ‚r + âˆ‚Â²f/âˆ‚rÂ²
			Real df_dr = Derivation::DerivePartial<3>(scalarField, 0, pos, nullptr);
			Real d2f_dr2 = Derivation::DeriveSecPartial<3>(scalarField, 0, 0, pos, nullptr);
			Real radial_term = (1.0 / r) * df_dr + d2f_dr2;
			
			// Azimuthal term: (1/rÂ²)âˆ‚Â²f/âˆ‚Ï†Â²
			Real d2f_dphi2 = Derivation::DeriveSecPartial<3>(scalarField, 1, 1, pos, nullptr);
			Real phi_term = (1.0 / (r * r)) * d2f_dphi2;
			
			// Axial term: âˆ‚Â²f/âˆ‚zÂ²
			Real d2f_dz2 = Derivation::DeriveSecPartial<3>(scalarField, 2, 2, pos, nullptr);

			return radial_term + phi_term + d2f_dz2;
		}
	};

	///////////////////////////////////////////////////////////////////////////////////////////
	/// VectorFieldOperations - Differential operations on vector fields
	///
	/// Provides divergence and curl operations for vector-valued functions.
	/// Supports:
	///   - Cartesian coordinates (any dimension N for divergence, 3D for curl)
	///   - Spherical coordinates (3D): (r, Î¸, Ï†)
	///   - Cylindrical coordinates (3D): (r, Ï†, z)
	///   - General curvilinear coordinates via metric tensor and Christoffel symbols
	///
	/// Physical interpretation:
	///   - Divergence: measures local "expansion" or "compression" of a flow field
	///   - Curl: measures local rotation or circulation of a flow field
	///////////////////////////////////////////////////////////////////////////////////////////
	namespace VectorFieldOperations
	{
		///////////////////////////////////////////////////////////////////////////////////////////
		//                           GENERAL COORDINATE OPERATIONS
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes divergence of vector field in general curvilinear coordinates.
		///
		/// Uses the metric tensor and Christoffel symbols to properly handle
		/// non-Cartesian coordinate systems. The divergence in general coordinates is:
		///   âˆ‡Â·F = âˆ‚áµ¢Fâ± + Î“â±áµ¢â‚– Fáµ
		///
		/// where Î“â±â±¼â‚– are the Christoffel symbols of the second kind.
		///
		/// @tparam N                Number of dimensions
		/// @param vectorField       Vector function F: â„á´º â†’ â„á´º
		/// @param pos               Position vector in the coordinate system
		/// @param metricTensorField Metric tensor field with Christoffel symbols
		/// @return                  Scalar divergence value âˆ‡Â·F
		///
		/// @note For Cartesian coordinates, use DivCart() which is more efficient.
		/// @see MetricTensorField, DivCart
		template<int N>
		static Real Divergence(const IVectorFunction<N>& vectorField, const VectorN<Real, N>& pos,
													const MetricTensorField<N>& metricTensorField)
		{
			Real div = 0.0;
			VectorN<Real, N> vec_val = vectorField(pos);

			for (int i = 0; i < N; i++)
			{
				// Standard partial derivative term: âˆ‚Fâ±/âˆ‚xâ±
				div += Derivation::DeriveVecPartial<N>(vectorField, i, i, pos, nullptr);

				// Christoffel symbol correction for curved coordinates: Î“â±áµ¢â‚– Fáµ
				for (int k = 0; k < N; k++)
				{
					div += vec_val[k] * metricTensorField.GetChristoffelSymbolSecondKind(i, i, k, pos);
				}
			}
			return div;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                              DIVERGENCE - CARTESIAN
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes divergence of vector field in Cartesian coordinates.
		///
		/// For F = (Fâ‚, Fâ‚‚, ..., Fâ‚™), returns âˆ‡Â·F = âˆ‚Fâ‚/âˆ‚xâ‚ + âˆ‚Fâ‚‚/âˆ‚xâ‚‚ + ... + âˆ‚Fâ‚™/âˆ‚xâ‚™
		///
		/// Physical interpretation:
		///   - div > 0: source (field "emanates" from the point)
		///   - div < 0: sink (field "converges" to the point)
		///   - div = 0: incompressible flow (volume-preserving)
		///
		/// @tparam N          Number of dimensions
		/// @param vectorField Vector function F: â„á´º â†’ â„á´º
		/// @param pos         Position vector
		/// @return            Scalar divergence value âˆ‡Â·F
		///
		/// @example
		///   // F(x,y,z) = (x, y, z) - radial outward field
		///   VectorFunction<3> F([](auto& p){ return p; });
		///   Real div = DivCart(F, {1,1,1});  // Returns 3.0 (uniform expansion)
		///
		///   // F(x,y,z) = (y, -x, 0) - rotation about z-axis
		///   VectorFunction<3> G([](auto& p){ return VectorN<Real,3>{p[1], -p[0], 0}; });
		///   Real div = DivCart(G, {1,1,1});  // Returns 0.0 (incompressible)
		template<int N>
		static Real DivCart(const IVectorFunction<N>& vectorField, const VectorN<Real, N>& pos)
		{
			Real div = 0.0;
			for (int i = 0; i < N; i++)
				div += Derivation::DeriveVecPartial<N>(vectorField, i, i, pos, nullptr);

			return div;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                              DIVERGENCE - SPHERICAL
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes divergence in spherical coordinates (r, Î¸, Ï†).
		///
		/// In spherical coordinates:
		///   âˆ‡Â·F = (1/rÂ²)âˆ‚(rÂ²Fáµ£)/âˆ‚r + (1/rÂ·sinÎ¸)âˆ‚(sinÎ¸Â·FÎ¸)/âˆ‚Î¸ + (1/rÂ·sinÎ¸)âˆ‚FÏ†/âˆ‚Ï†
		///
		/// @param vectorField Vector function F(r, Î¸, Ï†) = (Fáµ£, FÎ¸, FÏ†)
		/// @param x           Position (r, Î¸, Ï†) with r > 0, 0 < Î¸ < Ï€
		/// @return            Scalar divergence value âˆ‡Â·F
		///
		/// @warning Singular at r = 0 and Î¸ = 0, Ï€ (coordinate singularities)
		static Real DivSpher(const IVectorFunction<3>& vectorField, const VectorN<Real, 3>& x)
		{
			VectorN<Real, 3> vals = vectorField(x);

			VectorN<Real, 3> derivs;
			for (int i = 0; i < 3; i++)
				derivs[i] = Derivation::DeriveVecPartial<3>(vectorField, i, i, x, nullptr);

			Real div = 0.0;
			// r-component: (1/rÂ²)âˆ‚(rÂ²Fáµ£)/âˆ‚r = (2/r)Fáµ£ + âˆ‚Fáµ£/âˆ‚r
			div += 1 / (x[0] * x[0]) * (2 * x[0] * vals[0] + x[0] * x[0] * derivs[0]);
			// Î¸-component: (1/rÂ·sinÎ¸)âˆ‚(sinÎ¸Â·FÎ¸)/âˆ‚Î¸ = (cotÎ¸/r)FÎ¸ + (1/r)âˆ‚FÎ¸/âˆ‚Î¸
			div += 1 / (x[0] * sin(x[1])) * (cos(x[1]) * vals[1] + sin(x[1]) * derivs[1]);
			// Ï†-component: (1/rÂ·sinÎ¸)âˆ‚FÏ†/âˆ‚Ï†
			div += 1 / (x[0] * sin(x[1])) * derivs[2];

			return div;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                              DIVERGENCE - CYLINDRICAL
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes divergence in cylindrical coordinates (r, Ï†, z).
		///
		/// In cylindrical coordinates:
		///   âˆ‡Â·F = (1/r)âˆ‚(rÂ·Fáµ£)/âˆ‚r + (1/r)âˆ‚FÏ†/âˆ‚Ï† + âˆ‚Fz/âˆ‚z
		///
		/// @param vectorField Vector function F(r, Ï†, z) = (Fáµ£, FÏ†, Fz)
		/// @param x           Position (r, Ï†, z) with r > 0
		/// @return            Scalar divergence value âˆ‡Â·F
		///
		/// @warning Singular at r = 0 (z-axis singularity)
		static Real DivCyl(const IVectorFunction<3>& vectorField, const VectorN<Real, 3>& x)
		{
			VectorN<Real, 3> vals = vectorField(x);

			VectorN<Real, 3> derivs;
			for (int i = 0; i < 3; i++)
				derivs[i] = Derivation::DeriveVecPartial<3>(vectorField, i, i, x, nullptr);

			Real div = 0.0;
			// r-component: (1/r)âˆ‚(rÂ·Fáµ£)/âˆ‚r = (1/r)Fáµ£ + âˆ‚Fáµ£/âˆ‚r
			div += 1 / x[0] * (vals[0] + x[0] * derivs[0]);
			// Ï†-component: (1/r)âˆ‚FÏ†/âˆ‚Ï†
			div += 1 / x[0] * derivs[1];
			// z-component: âˆ‚Fz/âˆ‚z
			div += derivs[2];

			return div;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                                CURL - CARTESIAN
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes curl of vector field in 3D Cartesian coordinates.
		///
		/// The curl (âˆ‡Ã—F) measures the local rotation or circulation of a vector field.
		///
		/// In Cartesian coordinates:
		///   âˆ‡Ã—F = (âˆ‚Fz/âˆ‚y - âˆ‚Fy/âˆ‚z, âˆ‚Fx/âˆ‚z - âˆ‚Fz/âˆ‚x, âˆ‚Fy/âˆ‚x - âˆ‚Fx/âˆ‚y)
		///
		/// Physical interpretation:
		///   - |curl| > 0: field has rotational component at that point
		///   - curl = 0: field is irrotational (conservative)
		///   - Direction of curl indicates axis of rotation (right-hand rule)
		///
		/// @param vectorField Vector function F(x, y, z) = (Fx, Fy, Fz)
		/// @param pos         Position vector (x, y, z)
		/// @return            Curl vector âˆ‡Ã—F in Cartesian basis
		///
		/// @example
		///   // F(x,y,z) = (y, -x, 0) - rotation about z-axis
		///   VectorFunction<3> F([](auto& p){ return VectorN<Real,3>{p[1], -p[0], 0}; });
		///   auto curl = CurlCart(F, {1,1,1});  // Returns (0, 0, -2)
		///
		///   // Uniform field F = (1, 0, 0)
		///   VectorFunction<3> G([](auto& p){ return VectorN<Real,3>{1, 0, 0}; });
		///   auto curl = CurlCart(G, {1,1,1});  // Returns (0, 0, 0) - irrotational
		static Vec3Cart CurlCart(const IVectorFunction<3>& vectorField, const VectorN<Real, 3>& pos)
		{
			// âˆ‚Fz/âˆ‚y and âˆ‚Fy/âˆ‚z for x-component of curl
			Real dzdy = Derivation::DeriveVecPartial<3>(vectorField, 2, 1, pos, nullptr);
			Real dydz = Derivation::DeriveVecPartial<3>(vectorField, 1, 2, pos, nullptr);

			// âˆ‚Fx/âˆ‚z and âˆ‚Fz/âˆ‚x for y-component of curl
			Real dxdz = Derivation::DeriveVecPartial<3>(vectorField, 0, 2, pos, nullptr);
			Real dzdx = Derivation::DeriveVecPartial<3>(vectorField, 2, 0, pos, nullptr);

			// âˆ‚Fy/âˆ‚x and âˆ‚Fx/âˆ‚y for z-component of curl
			Real dydx = Derivation::DeriveVecPartial<3>(vectorField, 1, 0, pos, nullptr);
			Real dxdy = Derivation::DeriveVecPartial<3>(vectorField, 0, 1, pos, nullptr);

			Vector3Cartesian curl{ dzdy - dydz, dxdz - dzdx, dydx - dxdy };

			return curl;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                                CURL - SPHERICAL
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes curl of vector field in 3D spherical coordinates.
		///
		/// In spherical coordinates (r, Î¸, Ï†), the curl components are:
		///   (âˆ‡Ã—F)áµ£ = (1/rÂ·sinÎ¸)[âˆ‚(sinÎ¸Â·FÏ†)/âˆ‚Î¸ - âˆ‚FÎ¸/âˆ‚Ï†]
		///   (âˆ‡Ã—F)Î¸ = (1/r)[(1/sinÎ¸)âˆ‚Fáµ£/âˆ‚Ï† - âˆ‚(rÂ·FÏ†)/âˆ‚r]
		///   (âˆ‡Ã—F)Ï† = (1/r)[âˆ‚(rÂ·FÎ¸)/âˆ‚r - âˆ‚Fáµ£/âˆ‚Î¸]
		///
		/// @param vectorField Vector function F(r, Î¸, Ï†) = (Fáµ£, FÎ¸, FÏ†)
		/// @param pos         Position (r, Î¸, Ï†) with r > 0, 0 < Î¸ < Ï€
		/// @return            Curl vector âˆ‡Ã—F in spherical basis (Ãªáµ£, ÃªÎ¸, ÃªÏ†)
		///
		/// @warning Singular at r = 0 and Î¸ = 0, Ï€
		static Vec3Sph CurlSpher(const IVectorFunction<3>& vectorField, const VectorN<Real, 3>& pos)
		{
			VectorN<Real, 3> vals = vectorField(pos);

			// Partial derivatives of each component
			Real dphidtheta = Derivation::DeriveVecPartial<3>(vectorField, 2, 1, pos, nullptr);  // âˆ‚FÏ†/âˆ‚Î¸
			Real dthetadphi = Derivation::DeriveVecPartial<3>(vectorField, 1, 2, pos, nullptr);  // âˆ‚FÎ¸/âˆ‚Ï†

			Real drdphi = Derivation::DeriveVecPartial<3>(vectorField, 0, 2, pos, nullptr);      // âˆ‚Fáµ£/âˆ‚Ï†
			Real dphidr = Derivation::DeriveVecPartial<3>(vectorField, 2, 0, pos, nullptr);      // âˆ‚FÏ†/âˆ‚r

			Real dthetadr = Derivation::DeriveVecPartial<3>(vectorField, 1, 0, pos, nullptr);    // âˆ‚FÎ¸/âˆ‚r
			Real drdtheta = Derivation::DeriveVecPartial<3>(vectorField, 0, 1, pos, nullptr);    // âˆ‚Fáµ£/âˆ‚Î¸

			Vector3Spherical ret;
			const Real& r = pos[0];
			const Real& theta = pos[1];
			const Real& phi = pos[2];

			// r-component: (1/rÂ·sinÎ¸)[cosÎ¸Â·FÏ† + sinÎ¸Â·âˆ‚FÏ†/âˆ‚Î¸ - âˆ‚FÎ¸/âˆ‚Ï†]
			ret[0] = 1 / (r * sin(theta)) * (cos(theta) * vals[2] + sin(theta) * dphidtheta - dthetadphi);
			// Î¸-component: (1/r)[(1/sinÎ¸)âˆ‚Fáµ£/âˆ‚Ï† - FÏ† - rÂ·âˆ‚FÏ†/âˆ‚r]
			ret[1] = 1 / r * (1 / sin(theta) * drdphi - vals[2] - r * dphidr);
			// Ï†-component: (1/r)[FÎ¸ + rÂ·âˆ‚FÎ¸/âˆ‚r - âˆ‚Fáµ£/âˆ‚Î¸]
			ret[2] = 1 / r * (vals[1] + r * dthetadr - drdtheta);

			return ret;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		//                                CURL - CYLINDRICAL
		///////////////////////////////////////////////////////////////////////////////////////////

		/// Computes curl of vector field in 3D cylindrical coordinates.
		///
		/// In cylindrical coordinates (r, Ï†, z), the curl components are:
		///   (âˆ‡Ã—F)áµ£ = (1/r)âˆ‚Fz/âˆ‚Ï† - âˆ‚FÏ†/âˆ‚z
		///   (âˆ‡Ã—F)Ï† = âˆ‚Fáµ£/âˆ‚z - âˆ‚Fz/âˆ‚r
		///   (âˆ‡Ã—F)z = (1/r)[FÏ† + rÂ·âˆ‚FÏ†/âˆ‚r - âˆ‚Fáµ£/âˆ‚Ï†]
		///
		/// @param vectorField Vector function F(r, Ï†, z) = (Fáµ£, FÏ†, Fz)
		/// @param pos         Position (r, Ï†, z) with r > 0
		/// @return            Curl vector âˆ‡Ã—F in cylindrical basis (Ãªáµ£, ÃªÏ†, Ãªz)
		///
		/// @warning Singular at r = 0 (z-axis singularity)
		static Vec3Cyl CurlCyl(const IVectorFunction<3>& vectorField, const VectorN<Real, 3>& pos)
		{
			VectorN<Real, 3> vals = vectorField(pos);

			// Partial derivatives
			Real dzdphi = Derivation::DeriveVecPartial<3>(vectorField, 2, 1, pos, nullptr);  // âˆ‚Fz/âˆ‚Ï†
			Real dphidz = Derivation::DeriveVecPartial<3>(vectorField, 1, 2, pos, nullptr);  // âˆ‚FÏ†/âˆ‚z

			Real drdz = Derivation::DeriveVecPartial<3>(vectorField, 0, 2, pos, nullptr);    // âˆ‚Fáµ£/âˆ‚z
			Real dzdr = Derivation::DeriveVecPartial<3>(vectorField, 2, 0, pos, nullptr);    // âˆ‚Fz/âˆ‚r

			Real dphidr = Derivation::DeriveVecPartial<3>(vectorField, 1, 0, pos, nullptr);  // âˆ‚FÏ†/âˆ‚r
			Real drdphi = Derivation::DeriveVecPartial<3>(vectorField, 0, 1, pos, nullptr);  // âˆ‚Fáµ£/âˆ‚Ï†

			// r-component: (1/r)âˆ‚Fz/âˆ‚Ï† - âˆ‚FÏ†/âˆ‚z
			// Ï†-component: âˆ‚Fáµ£/âˆ‚z - âˆ‚Fz/âˆ‚r
			// z-component: (1/r)[FÏ† + rÂ·âˆ‚FÏ†/âˆ‚r - âˆ‚Fáµ£/âˆ‚Ï†]
			Vector3Cylindrical ret{
				(1 / pos[0] * dzdphi - dphidz), 
				drdz - dzdr, 
				1 / pos[0] * (vals[1] + pos[0] * dphidr - drdphi)
			};

			return ret;
		}
	};
}

///////////////////////////   mml/core/Curves.h   ///////////////////////////





namespace MML
{
	namespace Curves
	{
		/////////////////////////////              CARTESIAN PLANAR CURVES                  ///////////////////////////////
		// abstract class, providing basic Cartesian curves formulas in 2D
		class ICurveCartesian2D : public IParametricCurve<2>
		{
		public:
			Vec2Cart getTangent(Real t)
			{
				return Derivation::DeriveCurve<2>(*this, t, nullptr);
			}
			Vec2Cart getTangentUnit(Real t)
			{
				return getTangent(t).GetAsUnitVector();
			}
			Vec2Cart getNormal(Real t)
			{
				return Derivation::DeriveCurveSec<2>(*this, t, nullptr);
			}
			Vec2Cart getNormalUnit(Real t)
			{
				return getNormal(t).GetAsUnitVector();
			}
		};

		class Circle2DCurve : public ICurveCartesian2D
		{
			Real _radius;
			Pnt2Cart _center;
		public:
			Circle2DCurve() : _radius(1), _center(0, 0) {}
			Circle2DCurve(Real radius) : _radius(radius), _center(0,0) {}
			Circle2DCurve(Real radius, const Pnt2Cart& center) : _radius(radius), _center(center) {}

			Real getMinT() const { return 0.0; }
			Real getMaxT() const { return 2 * Constants::PI; }

			VectorN<Real, 2> operator()(Real t) const { 
				return MML::VectorN<Real, 2>{_center.X()+_radius* cos(t), _center.Y()+_radius* sin(t)}; 
			}
		};

		class LogSpiralCurve : public ICurveCartesian2D
		{
			Real _lambda, _c;
		public:
			LogSpiralCurve() : _lambda(-1), _c(1) {}
			LogSpiralCurve(Real lambda) : _lambda(lambda), _c(1) {
				if (lambda >= 0) throw std::invalid_argument("LogSpiralCurve: lambda must be negative.");
			}
			LogSpiralCurve(Real lambda, Real c) : _lambda(lambda), _c(c) {
				if (lambda >= 0) throw std::invalid_argument("LogSpiralCurve: lambda must be negative.");
				if (c == 0) throw std::invalid_argument("LogSpiralCurve: c must not be zero.");
			}

			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 2> operator()(Real t) const { return MML::VectorN<Real, 2>{exp(_lambda * t)* cos(t), exp(_lambda * t)* sin(t)}; }
		};

		class LemniscateCurve : public ICurveCartesian2D
		{
		public:
			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 2> operator()(Real t) const { return MML::VectorN<Real, 2>{cos(t) / (1 + sin(t) * sin(t)), sin(t)* cos(t) / (1 + sin(t) * sin(t))}; }
		};

		class DeltoidCurve : public ICurveCartesian2D
		{
			int _n;
		public:
			DeltoidCurve() : _n(1) {}
			DeltoidCurve(int n) : _n(n) {}

			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 2> operator()(Real t) const { return MML::VectorN<Real, 2>{2 * _n * cos(t) * (1 + cos(t)), 2 * _n * sin(t) * (1 - cos(t))}; }
		};

		class AstroidCurve : public ICurveCartesian2D
		{
			Real _c;
		public:
			AstroidCurve() : _c(1) {}
			AstroidCurve(Real c) : _c(c) {
				if (c <= 0) throw std::invalid_argument("AstroidCurve: c must be positive.");
			}

			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 2> operator()(Real t) const { return MML::VectorN<Real, 2>{_c* cos(t)* cos(t)* cos(t), _c* sin(t)* sin(t)* sin(t)}; }
		};

		class EpitrochoidCurve : public ICurveCartesian2D
		{
			Real _radius, _c;
			int _n;
		public:
			EpitrochoidCurve() : _radius(1), _c(1), _n(1) {}
			EpitrochoidCurve(Real radius, Real c, int n) : _radius(radius), _c(c), _n(n) {}

			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 2> operator()(Real t) const { return MML::VectorN<Real, 2>{cos(t) - _c * cos(_n * t), sin(t) - _c * sin(_n * t) }; }
		};

		class ArchimedeanSpiralCurve : public ICurveCartesian2D
		{
			Real _a;
		public:
			ArchimedeanSpiralCurve() : _a(1) {}
			ArchimedeanSpiralCurve(Real a) : _a(a) {}

			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 2> operator()(Real t) const { return MML::VectorN<Real, 2>{_a* t* cos(t), _a* t* sin(t)}; }
		};


		/////////////////////////////               POLAR PLANAR CURVES                  ///////////////////////////////
		// abstract class, providing basic polar curves formulas in 2D
		// QUESTION - does it returns polar coords???
		class ICurvePolar2D : public IParametricCurve<2>
		{
		public:
			Vec2Cart getTangent(Real t)
			{
				return Derivation::DeriveCurve<2>(*this, t, nullptr);
			}
			Vec2Cart getTangentUnit(Real t)
			{
				return getTangent(t).GetAsUnitVector();
			}
			Vec2Cart getNormal(Real t)
			{
				return Derivation::DeriveCurveSec<2>(*this, t, nullptr);
			}
			Vec2Cart getNormalUnit(Real t)
			{
				return getNormal(t).GetAsUnitVector();
			}
		};

		class Circle2DCurvePolar : public ICurvePolar2D
		{
			Real _radius;
			Pnt2Cart _center;

		public:
			Circle2DCurvePolar() : _radius(1), _center(0, 0) {}
			Circle2DCurvePolar(Real radius) : _radius(radius), _center(0, 0) {}
			Circle2DCurvePolar(Real radius, const Pnt2Cart& center) : _radius(radius), _center(center) {}
			
			Real getMinT() const { return 0.0; }
			Real getMaxT() const { return 2 * Constants::PI; }
			
			VectorN<Real, 2> operator()(Real t) const { return MML::VectorN<Real, 2>{_radius, t}; }
		};

		///////////////////////////////             CARTESIAN SPACE CURVES                  ///////////////////////////////
		// abstract class, providing basic curve formulas in 3D
		class ICurveCartesian3D : public IParametricCurve<3>
		{
		public:
			Vec3Cart getTangent(Real t) const
			{
				return Derivation::DeriveCurve<3>(*this, t, nullptr);
			}
			Vec3Cart getTangentUnit(Real t) const
			{
				return getTangent(t).GetAsUnitVector();
			}
			Vec3Cart getNormal(Real t) const
			{
				return Derivation::DeriveCurveSec<3>(*this, t, nullptr);
			}
			Vec3Cart getNormalUnit(Real t) const
			{
				// Principal normal via Frenet formula
				Vec3Cart y_der_1 = getTangent(t);
				Vec3Cart y_der_2 = getNormal(t);
				Vector3Cartesian vec_prod1 = VectorProduct(Vector3Cartesian(y_der_2), Vector3Cartesian(y_der_1));
				Vector3Cartesian res_vec = VectorProduct(Vector3Cartesian(y_der_1), vec_prod1);

				return Vec3Cart(res_vec / (y_der_1.NormL2() * vec_prod1.NormL2()));
			}
			Vec3Cart getBinormal(Real t) const
			{
				// Binormal: (r' Ã— r'') / |r' Ã— r''|
				Vec3Cart y_der_1 = getTangent(t);
				Vec3Cart y_der_2 = getNormal(t);
				Vector3Cartesian vec_prod1 = VectorProduct(Vector3Cartesian(y_der_1), Vector3Cartesian(y_der_2));
				return Vec3Cart(vec_prod1 / vec_prod1.NormL2());
			}

			Vec3Cart getCurvatureVector(Real t) const
			{
				Vec3Cart y_der_1 = getTangent(t);
				Vec3Cart y_der_2 = getNormal(t);

				Real		 res1 = pow(y_der_1.NormL2(), -2.0);
				Vec3Cart vec2 = y_der_2 - res1 * Utils::ScalarProduct(y_der_1, y_der_2) * y_der_1;

				return vec2 / res1;
			}
			
			virtual Real getCurvature(Real t) const
			{
				Vec3Cart y_der_1 = getTangent(t);

				Real				res1 = pow(y_der_1.NormL2(), -2.0);
				
				Vec3Cart y_der_2 = getNormal(t);
				Vec3Cart    vec2 = y_der_2 - res1 * Utils::ScalarProduct(y_der_1, y_der_2) * y_der_1;

				Real res2 = vec2.NormL2();

				return res1 * res2;
			}
			virtual Real getTorsion( Real t) const
			{
				Vec3Cart r_prime = getTangent(t); // First derivative
				Vec3Cart r_double_prime = getNormal(t); // Second derivative
				Vec3Cart r_triple_prime = Derivation::DeriveCurveThird<3>(*this, t, nullptr); // Third derivative

				Vec3Cart cross_product = VectorProduct(r_prime, r_double_prime);
				Real numerator = Utils::ScalarProduct(cross_product, r_triple_prime);
				Real denominator = pow(cross_product.NormL2(), 2);

				return numerator / denominator;
			}

			virtual Plane3D getOsculationPlane(Real t) const
			{
				return Plane3D(Vector3Cartesian((*this)(t)).getAsPoint(), Vector3Cartesian(getNormal(t)));
			}
			virtual Plane3D getNormalPlane(Real t) const
			{
				return Plane3D(Vector3Cartesian((*this)(t)).getAsPoint(), Vector3Cartesian(getTangentUnit(t)));
			}
			virtual Plane3D getRectifyingPlane(Real t) const
			{
				return Plane3D(Vector3Cartesian((*this)(t)).getAsPoint(), Vector3Cartesian(getBinormal(t)));
			}

			void getMovingTrihedron(Real t, Vector3Cartesian& tangent, Vector3Cartesian& normal, Vector3Cartesian& binormal)
			{
				tangent = Vector3Cartesian(getTangentUnit(t));
				normal = Vector3Cartesian(getNormalUnit(t));
				binormal = Vector3Cartesian(getBinormal(t));
			}

			bool isArcLengthParametrized(Real t1, Real t2, int numPoints = 100) const
			{
				Real delta = (t2 - t1) / numPoints;
				for (Real t = t1 + delta; t < t2; t += delta)
				{
					Real len = PathIntegration::ParametricCurveLength(*this, t1, t);
					if (fabs(len - (t - t1)) > PrecisionValues<Real>::DefaultToleranceRelaxed)
						return false;
				}
				return true;
			}
		};

		// concrete class, that can be initialized with function pointers or lambdas
		class CurveCartesian3D : public ICurveCartesian3D
		{
			Real _minT;
			Real _maxT;
			VectorN<Real, 3>(*_func)(Real);
		public:
			CurveCartesian3D(VectorN<Real, 3>(*inFunc)(Real)) 
				: _func(inFunc), _minT(Constants::NegInf), _maxT(Constants::PosInf) {}
			CurveCartesian3D(Real minT, Real maxT, VectorN<Real, 3>(*inFunc)(Real)) 
				: _func(inFunc), _minT(minT), _maxT(maxT) {}

			Real getMinT() const { return _minT; }
			Real getMaxT() const { return _maxT; }

			virtual VectorN<Real, 3> operator()(Real x) const { return _func(x); }
		};

		// example curves
		class LineCurve : public ICurveCartesian3D
		{
			Line3D  _line;
			Real _minT;
			Real _maxT;
		public:
			LineCurve(Real minT, Real maxT, const Point3Cartesian& pnt, const Vector3Cartesian& dir) : _line(pnt, dir), _minT(minT), _maxT(maxT) {}
			LineCurve(Real t1, const Point3Cartesian& pnt1, Real t2, const Point3Cartesian& pnt2)
			{
				// tocno samo ako je t1 = 0.0!!!
				_line.StartPoint() = pnt1;
				Vec3Cart dir = Vec3Cart(pnt1, pnt2);
				_line.Direction() = dir.NormL2() / (t2 - t1) * dir.GetAsUnitVector();
				_minT = t1;
				_maxT = t2;
			}

			Real getMinT() const { return _minT; }
			Real getMaxT() const { return _maxT; }

			VectorN<Real, 3> operator()(Real t) const
			{
				//if (t < _minT || t > _maxT)
				//	throw std::invalid_argument("LineCurve: t is out of range.");

				auto pnt = _line(t);
				return VectorN<Real, 3>{pnt.X(), pnt.Y(), pnt.Z()};
			}
		};

		class Circle3DXY : public ICurveCartesian3D {
			Real _radius;
		public:
			Circle3DXY() : _radius(1) {}
			Circle3DXY(Real radius) : _radius(radius) {}

			Real getMinT() const { return 0.0; }
			Real getMaxT() const { return 2 * Constants::PI; }

			VectorN<Real, 3> operator()(Real t) const { return MML::VectorN<Real, 3>{_radius* cos(t), _radius* sin(t), 0}; }
		};

		class Circle3DXZ : public ICurveCartesian3D {
			Real _radius;
		public:
			Circle3DXZ() : _radius(1) {}
			Circle3DXZ(Real radius) : _radius(radius) {}

			Real getMinT() const { return 0.0; }
			Real getMaxT() const { return 2 * Constants::PI; }

			VectorN<Real, 3> operator()(Real t) const { return MML::VectorN<Real, 3>{_radius* cos(t), 0, _radius* sin(t)}; }
		};

		class Circle3DYZ : public ICurveCartesian3D {
			Real _radius;
		public:
			Circle3DYZ() : _radius(1) {}
			Circle3DYZ(Real radius) : _radius(radius) {}

			Real getMinT() const { return 0.0; }
			Real getMaxT() const { return 2 * Constants::PI; }

			VectorN<Real, 3> operator()(Real t) const { return MML::VectorN<Real, 3>{0, _radius* cos(t), _radius* sin(t)}; }
		};

		class HelixCurve : public ICurveCartesian3D
		{
			Real _radius, _b;
		public:
			HelixCurve() : _radius(1.0), _b(1.0) {}
			HelixCurve(Real radius, Real b) : _radius(radius), _b(b) {}

			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 3> operator()(Real t) const { 
				return MML::VectorN<Real, 3>{_radius * cos(t), _radius * sin(t), _b * t}; 
			}

			Real getCurvature(Real t) const { return _radius / (POW2(_radius) + POW2(_b)); }
			Real getTorsion(Real t) const { return _b / (POW2(_radius) + POW2(_b)); }
		};

		class TwistedCubicCurve : public ICurveCartesian3D
		{
		public:
			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 3> operator()(Real t) const { return MML::VectorN<Real, 3>{t, t* t, t* t* t}; }
		};

		class ToroidalSpiralCurve : public ICurveCartesian3D
		{
			int _n;
			Real _scale = 1.0;

		public:
			ToroidalSpiralCurve() : _n(1) {}
			ToroidalSpiralCurve(int n) : _n(n) {}
			ToroidalSpiralCurve(Real scale) : _n(1), _scale(scale) {}
			ToroidalSpiralCurve(int n, Real scale) : _n(n), _scale(scale) {}

			Real getMinT() const { return Constants::NegInf; }
			Real getMaxT() const { return Constants::PosInf; }

			VectorN<Real, 3> operator()(Real t) const { return MML::VectorN<Real, 3>{(_scale* (4 + sin(_n * t))* cos(t)), _scale* (4 + sin(_n * t))* sin(t), _scale* cos(_n* t)}; }
		};

		// General circle, lying in plane with given normal, with given center position
		class Circle : public ICurveCartesian3D {
			Real _radius;
			Vec3Cart _normal;
			Pnt3Cart _center;
		public:
			Circle(Real radius, const Vec3Cart& normal, const Pnt3Cart& center) 
				: _radius(radius), _normal(normal), _center(center) 
			{
				if (normal.NormL2() == 0.0) throw std::invalid_argument("Circle3D: normal must not be zero vector.");
				_normal = normal.GetAsUnitVector();
			}

			Real getMinT() const { return 0.0; }
			Real getMaxT() const { return 2 * Constants::PI; }

			VectorN<Real, 3> operator()(Real t) const
			{
				Vec3Cart u, v;

				// Find two orthonormal (unit) vectors (u, v) perpendicular to _normal
				_normal.GetPerpendicularVectors(u, v);

				// Parametric equation for the circle in 3D
				Vec3Cart point = _center + _radius * (u * std::cos(t) + v * std::sin(t));

				return VectorN<Real, 3>{point.X(), point.Y(), point.Z()};
			}
		};
	}
}


///////////////////////////   mml/core/Surfaces.h   ///////////////////////////





using namespace MML::Utils;
using namespace MML::Derivation;

namespace MML
{
	namespace Surfaces
	{
		class ISurfaceCartesian : public IParametricSurfaceRect<3>	
		{
		public:
			virtual VectorN<Real, 3> Normal(Real u, Real w) const
			{
				// Compute partial derivatives
				Vec3Cart r_u = NDer1_u(*this, u, w);
				Vec3Cart r_w = NDer1_w(*this, u, w);

			// Compute cross product
			VectorN<Real, 3> n = VectorProduct(r_u, r_w);

			// Normalize
			Real norm = n.NormL2();
			constexpr Real eps = PrecisionValues<Real>::NumericalZeroThreshold;
			if (norm < eps)
				return VectorN<Real, 3>{0.0, 0.0, 0.0}; // Degenerate case

			return n / norm;
			}

			virtual void Tangents(Real u, Real w, VectorN<Real, 3>& tU, VectorN<Real, 3>& tW) const
			{
				// Compute tangent vector in the u direction
				tU = NDer1_u(*this, u, w);
				// Compute tangent vector in the w direction
				tW = NDer1_w(*this, u, w);
			}

			virtual void PrincipalCurvatures(Real u, Real w, Real& k1, Real& k2) const
			{
				// Get first and second fundamental form coefficients
				Real E, F, G;
				GetFirstNormalFormCoefficients(u, w, E, F, G);
				Real L, M, N;
				GetSecondNormalFormCoefficients(u, w, L, M, N);

				// Compute the invariants
				Real denom = E * G - F * F;
				constexpr Real eps = PrecisionValues<Real>::NumericalZeroThreshold;
				if (std::abs(denom) < eps) {
					k1 = k2 = 0.0;
					return;
				}

				// Trace and determinant of the shape operator
				Real H = (E * N + G * L - 2 * F * M) / (2 * denom); // mean curvature
				Real K = (L * N - M * M) / denom;                   // Gaussian curvature

				// Solve quadratic equation: k^2 - 2H k + K = 0
				Real discr = H * H - K;
				if (discr < 0) discr = 0; // Clamp for numerical stability

				Real sqrt_discr = std::sqrt(discr);
				k1 = H + sqrt_discr;
				k2 = H - sqrt_discr;
			}

			virtual void PrincipalDirections(Real u, Real w, VectorN<Real, 3>& dir1, VectorN<Real, 3>& dir2) const
			{
				// Get first and second fundamental form coefficients
				Real E, F, G;
				GetFirstNormalFormCoefficients(u, w, E, F, G);
				Real L, M, N;
				GetSecondNormalFormCoefficients(u, w, L, M, N);

				// Compute the invariants
				Real denom = E * G - F * F;
				constexpr Real eps = PrecisionValues<Real>::NumericalZeroThreshold;
				if (std::abs(denom) < eps) {
					dir1 = dir2 = VectorN<Real, 3>{ 0.0, 0.0, 0.0 };
					return;
				}

				// Get principal curvatures
				Real k1, k2;
				PrincipalCurvatures(u, w, k1, k2);

				// Tangent vectors
				VectorN<Real, 3> tU, tW;
				Tangents(u, w, tU, tW);

				// For each principal curvature, solve (II - k*I) v = 0 for v = (a, b)
				// That is:
				// [L - k*E, M - k*F] [a] = 0
				// [M - k*F, N - k*G] [b]   0

				auto getDirection = [&](Real k) -> VectorN<Real, 3> {
					Real a = M - k * F;
					Real b = L - k * E;
					if (std::abs(a) > std::abs(b)) {
						// Set v = (1, -b/a)
						Real v0 = 1.0;
						Real v1 = (a != 0.0) ? -b / a : 0.0;
						return (v0 * tU + v1 * tW).Normalized();
					}
					else if (std::abs(b) > eps) {
						// Set v = (-a/b, 1)
						Real v0 = (b != 0.0) ? -a / b : 0.0;
						Real v1 = 1.0;
						return (v0 * tU + v1 * tW).Normalized();
					}
					else {
						// Fallback: use tU
						return tU.Normalized();
					}
					};

				dir1 = getDirection(k1);
				dir2 = getDirection(k2);
			}

			virtual void		 GetFirstNormalFormCoefficients(Real u, Real w, Real& outE, Real& outF, Real& outG) const
			{
				// first, we need to calculate necessary derivatives
				VectorN<Real, 3> r_by_u = NDer1_u(*this, u, w);
				VectorN<Real, 3> r_by_w = NDer1_w(*this, u, w);

				outE = ScalarProduct(r_by_u, r_by_u);
				outF = ScalarProduct(r_by_u, r_by_w);
				outG = ScalarProduct(r_by_w, r_by_w);
			}
			VectorN<Real, 3> GetFirstNormalFormCoefficients(Real u, Real w) const
			{
				VectorN<Real, 3> ret;

				GetFirstNormalFormCoefficients(u, w, ret[0], ret[1], ret[2]);
				
				return ret;
			}
			virtual void		 GetSecondNormalFormCoefficients(Real u, Real w, Real &outL, Real &outM, Real &outN) const
			{
				// first, we need to calculate necessary derivatives
				Vec3Cart r_by_u = NDer1_u(*this, u, w);
				Vec3Cart r_by_w = NDer1_w(*this, u, w);
				
			// normal
			Vec3Cart n = VectorProduct(r_by_u, r_by_w).Normalized();				// now we can calculate second derivatives
				Vec3Cart r_by_uu = NDer2_uu(*this, u, w);
				Vec3Cart r_by_uw = NDer2_uw(*this, u, w);
				Vec3Cart r_by_ww = NDer2_ww(*this, u, w);

				outL = ScalarProduct(r_by_uu, n); // L
				outM = ScalarProduct(r_by_uw, n); // M
				outN = ScalarProduct(r_by_ww, n); // N
			}
			VectorN<Real, 3> GetSecondNormalFormCoefficients(Real u, Real w) const
			{
				VectorN<Real, 3> ret;

				GetSecondNormalFormCoefficients(u, w, ret[0], ret[1], ret[2]);

				return ret;
			}

			Real GaussianCurvature(Real u, Real w)
			{
				Real E, F, G;
				GetFirstNormalFormCoefficients(u, w, E, F, G);

				Real L, M, N;
				GetSecondNormalFormCoefficients(u, w, L, M, N);

				// Compute denominator and check for degeneracy
				Real denom = E * G - F * F;
				constexpr Real eps = PrecisionValues<Real>::NumericalZeroThreshold;
				if (std::abs(denom) < eps)
				{
					// Degenerate metric: curvature undefined
					return 0.0;
					// Alternatively: return std::numeric_limits<Real>::quiet_NaN();
				}

				// Gaussian curvature formula: K = (L*N - M^2) / (E*G - F^2)
				return (L * N - M * M) / denom;
			}

			Real MeanCurvature(Real u, Real w)
			{
				Real E, F, G;
				GetFirstNormalFormCoefficients(u, w, E, F, G);

				Real L, M, N;
				GetSecondNormalFormCoefficients(u, w, L, M, N);

				// Compute denominator and check for degeneracy
				Real denom = 2 * (E * G - F * F);
				constexpr Real eps = PrecisionValues<Real>::NumericalZeroThreshold;
				if (std::abs(denom) < eps)
				{
					// Degenerate metric: mean curvature undefined
					return 0.0;
					// Alternatively: return std::numeric_limits<Real>::quiet_NaN();
				}

				// Mean curvature formula: H = (E*N + G*L - 2*F*M) / (2*(E*G - F^2))
				return (E * N + G * L - 2 * F * M) / denom;
			}

			bool isRegular(Real u, Real w) const
			{
				// Compute tangent vectors
				Vec3Cart tU = NDer1_u(*this, u, w);
				Vec3Cart tW = NDer1_w(*this, u, w);

				// Compute normal vector (cross product)
				VectorN<Real, 3> n = VectorProduct(tU, tW);

				// If the norm is above a small threshold, the surface is regular at (u, w)
				constexpr Real eps = PrecisionValues<Real>::NumericalZeroThreshold;
				return n.NormL2() > eps;
			}
			bool isFlat(Real u, Real w, Real eps = PrecisionValues<Real>::DefaultToleranceRelaxed)
			{
				return std::abs(GaussianCurvature(u, w)) < eps;
			}
			bool isParabolic(Real u, Real w, Real eps = PrecisionValues<Real>::DefaultToleranceRelaxed)
			{
				return std::abs(GaussianCurvature(u, w)) < eps && !isFlat(u, w, eps);
			}
			bool isHyperbolic(Real u, Real w, Real eps = PrecisionValues<Real>::DefaultToleranceRelaxed)
			{
				return GaussianCurvature(u, w) < -eps;
			}
		};

		// plane surface, given by point and normal, with local (u, v) coordinate system
		class PlaneSurface : public ISurfaceCartesian
		{
			VectorN<Real, 3> _point, _normal;
			VectorN<Real, 3> _uAxis, _vAxis;

			Real _minU = Constants::NegInf, _maxU = Constants::PosInf;
			Real _minV = Constants::NegInf, _maxV = Constants::PosInf;

		public:
			PlaneSurface(const Vec3Cart& point, const Vec3Cart& normal, const Vec3Cart& uAxis, const Vec3Cart& vAxis,
									 Real minU, Real maxU,	Real minV, Real maxV) 
				: PlaneSurface(point, normal, uAxis, vAxis)
			{
				SetPlaneLimits(minU, maxU, minV, maxV);
			}
			// complete ctor, with all info given
			PlaneSurface(const Vec3Cart& point, const Vec3Cart& normal, const Vec3Cart& uAxis, const Vec3Cart& vAxis)
				: _point(point), _normal(normal), _uAxis(uAxis), _vAxis(vAxis)
			{
				// check that the uAxis and vAxis are orthogonal to the normal
				if (!normal.IsPerpendicularTo(uAxis) || !normal.IsPerpendicularTo(vAxis))
				{
					throw GeometryError("uAxis and vAxis must be orthogonal to the normal.");
				}
			}
			// this ctor gets only one local axis direction, the other is computed as cross product with normal
			PlaneSurface(const Vec3Cart& point, const Vec3Cart& normal, const Vec3Cart& uAxisDirection)
			{
				// first we have to make sure that the uAxisDirection is not parallel to the normal
				if (normal.IsParallelTo(uAxisDirection))
				{
					throw GeometryError("uAxisDirection must not be parallel to the normal.");
				}
				// then we have to project uAxisDirection onto the plane defined by point and normal
				_point = point;
				_normal = normal.Normalized();
				Vec3Cart uAxis = uAxisDirection - (uAxisDirection.ScalarProduct(_normal) * _normal);

				// now we can compute the vAxis as cross product of normal and uAxis
				_vAxis = VectorProduct(_normal, uAxis).Normalized();
			}
			// this ctor only gets point and normal, uAxis and vAxis are computed as orthogonal to normal
			// with uAxis trying to align as much as possible with x axis
			PlaneSurface(const Vec3Cart& point, const Vec3Cart& normal)
			{
				_point = point;
				_normal = normal.Normalized();

				// try to align uAxis with x axis, if normal is not parallel to x axis
				if (!normal.IsParallelTo(Vec3Cart(1,0,0)))
				{
					_uAxis = VectorProduct(normal, Vec3Cart(1,0,0)).Normalized();
				}
				else // if normal is parallel to x axis, align uAxis with y axis
				{
					_uAxis = VectorProduct(normal, Vec3Cart(0,1,0)).Normalized();
				}
				_vAxis = VectorProduct(normal, _uAxis).Normalized();
			}

			Real getMinU() const { return _minU; }
			Real getMaxU() const { return _maxU; }
			Real getMinW() const { return _minV; }
			Real getMaxW() const { return _maxV; }

			void SetPlaneLimits(Real minU, Real maxU, Real minV, Real maxV)
			{
				_minU = minU;
				_maxU = maxU;
				_minV = minV;
				_maxV = maxV;
			}

			VectorN<Real, 3> operator()(Real u, Real w) const
			{
				return _point + u * _uAxis + w * _vAxis;
			}
		};

		class Cylinder : public ISurfaceCartesian
		{
			Real _R, _H;
		public:
			Cylinder() : _R(1), _H(1) {}
			Cylinder(Real R, Real H) : _R(R), _H(H) {}

			Real getMinU() const { return 0; }
			Real getMaxU() const { return 2 * Constants::PI; }
			Real getMinW() const { return 0; }
			Real getMaxW() const { return _H; }

			VectorN<Real, 3> operator()(Real u, Real w) const { return VectorN<Real, 3>{_R* cos(u), _R* sin(u), w}; }
		};
		
		class Torus : public ISurfaceCartesian
		{
			Real _R, _r;
		public:
			Torus() : _R(1), _r(0.5) {}
			Torus(Real R, Real r) : _R(R), _r(r) {}

			Real getMinU() const { return 0; }
			Real getMaxU() const { return 2 * Constants::PI; }
			Real getMinW() const { return 0; }
			Real getMaxW() const { return 2 * Constants::PI; }

			VectorN<Real, 3> operator()(Real u, Real w) const { return MML::VectorN<Real, 3>{(_R + _r * cos(w)) * cos(u), (_R + _r * cos(w)) * sin(u), _r * sin(w)}; }
		};

		class Sphere : public ISurfaceCartesian
		{
			Real _R;
		public:
			Sphere() : _R(1) {}
			Sphere(Real R) : _R(R) {}

			Real getMinU() const { return 0; }
			Real getMaxU() const { return Constants::PI; }
			Real getMinW() const { return 0; }
			Real getMaxW() const { return 2 * Constants::PI; }

			VectorN<Real, 3> operator()(Real u, Real w) const { return MML::VectorN<Real, 3>{_R * sin(u)* cos(w), _R * sin(u)* sin(w), _R * cos(u)}; }
		};

		class MonkeySaddle : public ISurfaceCartesian
		{
		public:
			Real getMinU() const { return -10; }
			Real getMaxU() const { return 10; }
			Real getMinW() const { return -10; }
			Real getMaxW() const { return 10; }

			VectorN<Real, 3> operator()(Real u, Real w) const { return MML::VectorN<Real, 3>{u, w, u* (u * u - 3 * w * w)}; }
		};

		class MobiusStrip : public ISurfaceCartesian
		{
		public:
			Real getMinU() const { return 0; }
			Real getMaxU() const { return 2 * Constants::PI; }
			Real getMinW() const { return -1; }
			Real getMaxW() const { return 1; }

			VectorN<Real, 3> operator()(Real u, Real w) const { return MML::VectorN<Real, 3>{(1 + w * cos(u / 2)) * cos(u), (1 + w * cos(u / 2)) * sin(u), w * sin(u / 2)}; }
		};

		class Ellipsoid : public ISurfaceCartesian
		{
			Real _a, _b, _c;
		public:
			Ellipsoid() : _a(1), _b(1), _c(1) {}
			Ellipsoid(Real a, Real b, Real c) : _a(a), _b(b), _c(c) {}

		Real getMinU() const { return 0; }
		Real getMaxU() const { return Constants::PI; }
		Real getMinW() const { return 0; }
		Real getMaxW() const { return 2 * Constants::PI; }

		VectorN<Real, 3> operator()(Real u, Real w) const { return MML::VectorN<Real, 3>{_a * sin(u) * cos(w), _b * sin(u) * sin(w), _c * cos(u)}; }
		};

		class Hyperboloid : public ISurfaceCartesian
		{
			Real _a, _b, _c;
		public:
			Hyperboloid() : _a(1), _b(1), _c(1) {}
			Hyperboloid(Real a, Real b, Real c) : _a(a), _b(b), _c(c) {}

			Real getMinU() const { return 0; }
			Real getMaxU() const { return Constants::PI; }
			Real getMinW() const { return 0; }
			Real getMaxW() const { return 2 * Constants::PI; }

			VectorN<Real, 3> operator()(Real u, Real w) const { return MML::VectorN<Real, 3>{_a * cosh(u) * cos(w), _b * cosh(u) * sin(w), _c * sinh(u)}; }
		};

		class Paraboloid : public ISurfaceCartesian
		{
			Real _a, _h;
		public:
			Paraboloid() : _a(1), _h(1) {}
			Paraboloid(Real a, Real h) : _a(a), _h(h) {}

			Real getMinU() const { return -10; }
			Real getMaxU() const { return 10; }
			Real getMinW() const { return -10; }
			Real getMaxW() const { return 10; }

			VectorN<Real, 3> operator()(Real u, Real w) const { return MML::VectorN<Real, 3>{_a * sqrt(u/_h) * cos(w), _a * sqrt(u/_h) * sin(w), u}; }
		};
	} // end namespace Surfaces
}


///////////////////////////   mml/core/OrthogonalBasis.h   ///////////////////////////





namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // OrthogonalBasis - Interface for orthogonal function bases
    //
    // Defines the contract for orthogonal basis systems like:
    //   - Fourier basis (sin/cos or complex exponentials)
    //   - Legendre polynomials
    //   - Chebyshev polynomials
    //   - Hermite polynomials
    //   - Laguerre polynomials
    //
    // Key properties:
    //   - Basis functions Ï†â‚™(x) satisfy orthogonality: âŸ¨Ï†â‚˜, Ï†â‚™âŸ© = 0 for m â‰  n
    //   - Inner product defined with weight function: âŸ¨f,gâŸ© = âˆ« f(x)g(x)w(x) dx
    //   - Each basis function has a normalization constant
    ///////////////////////////////////////////////////////////////////////////////////////////
    class OrthogonalBasis
    {
    public:
        virtual ~OrthogonalBasis() = default;

        // Evaluate the nth basis function at x
        virtual Real Evaluate(int n, Real x) const = 0;

        // Weight function for inner product
        virtual Real WeightFunction(Real x) const = 0;

        // Normalization constant for nth basis function: ||Ï†â‚™||Â²
        virtual Real Normalization(int n) const = 0;

        // Domain bounds
        virtual Real DomainMin() const = 0;
        virtual Real DomainMax() const = 0;

        // Compute expansion coefficient for function f: câ‚™ = âŸ¨f, Ï†â‚™âŸ© / ||Ï†â‚™||Â²
        virtual Real ComputeCoefficient(const IRealFunction& f, int n, Real eps = 1e-10) const
        {
            // Helper class for integrand f(x) * Ï†â‚™(x) * w(x)
            class Integrand : public IRealFunction {
                const OrthogonalBasis& _basis;
                const IRealFunction& _f;
                int _n;
            public:
                Integrand(const OrthogonalBasis& basis, const IRealFunction& f, int n)
                    : _basis(basis), _f(f), _n(n) {}
                Real operator()(Real x) const override {
                    return _f(x) * _basis.Evaluate(_n, x) * _basis.WeightFunction(x);
                }
            };

            Integrand integrand(*this, f, n);
            Real inner_product = IntegrateTrap(integrand, DomainMin(), DomainMax(), eps).value;
            return inner_product / Normalization(n);
        }
    };
  }


///////////////////////////   mml/algorithms/EigenSolverHelpers.h   ///////////////////////////





namespace MML
{
  /**
   * @class EigenSolverHelpers
   * @brief Collection of verified building blocks for general eigenvalue computation
   */
  class EigenSolverHelpers
  {
  public:
    // =========================================================================
    // BUILDING BLOCK 1: HESSENBERG REDUCTION
    // =========================================================================

    /**
     * @struct HessenbergResult
     * @brief Result of Hessenberg reduction: H = Q^T * A * Q
     */
    struct HessenbergResult
    {
      Matrix<Real> H;    // Upper Hessenberg matrix
      Matrix<Real> Q;    // Orthogonal transformation matrix
      
      HessenbergResult(int n) : H(n, n), Q(n, n) {}
    };

    /**
     * Reduce matrix A to upper Hessenberg form using Householder reflections.
     * 
     * MATHEMATICAL DEFINITION:
     * Find orthogonal Q such that H = Q^T * A * Q is upper Hessenberg,
     * meaning H(i,j) = 0 for all i > j + 1.
     * 
     * The transformation preserves eigenvalues (similarity transformation).
     * 
     * @param A Input matrix (n x n)
     * @return HessenbergResult containing H and Q where H = Q^T * A * Q
     * 
     * ALGORITHM (Householder):
     * For k = 0, 1, ..., n-3:
     *   1. Let x = A(k+1:n, k) be the subdiagonal column
     *   2. Compute Householder vector v to zero x(1:end)
     *   3. Apply P = I - 2*v*v^T from left: A = P*A
     *   4. Apply P from right: A = A*P (similarity)
     *   5. Accumulate Q = Q * P
     * 
     * Complexity: O(10nÂ³/3) flops
     */
    static HessenbergResult ReduceToHessenberg(const Matrix<Real>& A)
    {
      int n = A.RowNum();
      HessenbergResult result(n);
      
      if (n <= 2)
      {
        result.H = A;
        result.Q = Matrix<Real>::GetUnitMatrix(n);
        return result;
      }
      
      // Copy A to H (we'll transform H in place)
      result.H = A;
      // Initialize Q as identity
      result.Q = Matrix<Real>::GetUnitMatrix(n);
      
      // Temporary storage for Householder vector
      Vector<Real> v(n);
      
      // For each column k, zero out elements below the subdiagonal
      for (int k = 0; k < n - 2; k++)
      {
        // Compute the norm of the column below the diagonal
        Real sigma = 0.0;
        for (int i = k + 1; i < n; i++)
          sigma += result.H(i, k) * result.H(i, k);
        sigma = std::sqrt(sigma);
        
        if (sigma < PrecisionValues<Real>::DivisionSafetyThreshold)
          continue;  // Column already zero below subdiagonal
        
        // Choose sign to avoid cancellation: sign opposite to H(k+1, k)
        if (result.H(k + 1, k) > 0.0)
          sigma = -sigma;
        
        // Build Householder vector v = [0, ..., 0, H(k+1,k) - sigma, H(k+2,k), ..., H(n-1,k)]
        // But we only need elements k+1 to n-1
        Real h_k1_k_minus_sigma = result.H(k + 1, k) - sigma;
        
        // Compute ||v||^2
        Real vNormSq = h_k1_k_minus_sigma * h_k1_k_minus_sigma;
        for (int i = k + 2; i < n; i++)
          vNormSq += result.H(i, k) * result.H(i, k);
        
        if (vNormSq < PrecisionValues<Real>::DivisionSafetyThreshold)
          continue;
        
        // beta = 2 / ||v||^2
        Real beta = 2.0 / vNormSq;
        
        // Store v in temporary array
        v[k + 1] = h_k1_k_minus_sigma;
        for (int i = k + 2; i < n; i++)
          v[i] = result.H(i, k);
        
        // Apply Householder from left: H = (I - beta*v*v^T) * H
        // H(i,j) -= beta * v(i) * sum_m(v(m) * H(m,j))
        for (int j = k; j < n; j++)
        {
          Real dot = 0.0;
          for (int i = k + 1; i < n; i++)
            dot += v[i] * result.H(i, j);
          
          for (int i = k + 1; i < n; i++)
            result.H(i, j) -= beta * v[i] * dot;
        }
        
        // Apply Householder from right: H = H * (I - beta*v*v^T)
        // H(i,j) -= beta * H(i,m) * v(m) * v(j)
        for (int i = 0; i < n; i++)
        {
          Real dot = 0.0;
          for (int j = k + 1; j < n; j++)
            dot += result.H(i, j) * v[j];
          
          for (int j = k + 1; j < n; j++)
            result.H(i, j) -= beta * dot * v[j];
        }
        
        // Accumulate Q: Q = Q * (I - beta*v*v^T)
        // Q(i,j) -= beta * Q(i,m) * v(m) * v(j)
        for (int i = 0; i < n; i++)
        {
          Real dot = 0.0;
          for (int j = k + 1; j < n; j++)
            dot += result.Q(i, j) * v[j];
          
          for (int j = k + 1; j < n; j++)
            result.Q(i, j) -= beta * dot * v[j];
        }
        
        // After applying transformation, H(k+1, k) should be sigma
        // and H(k+2:n-1, k) should be 0
        // Clean up the zeros explicitly
        result.H(k + 1, k) = sigma;
        for (int i = k + 2; i < n; i++)
          result.H(i, k) = 0.0;
      }
      
      return result;
    }

    /**
     * Check if matrix H is upper Hessenberg within tolerance.
     * Upper Hessenberg: H(i,j) = 0 for i > j + 1
     */
    static bool IsUpperHessenberg(const Matrix<Real>& H, Real tol = 1e-10)
    {
      int n = H.RowNum();
      for (int i = 2; i < n; i++)
        for (int j = 0; j < i - 1; j++)
          if (std::abs(H(i, j)) > tol)
            return false;
      return true;
    }

    /**
     * Check if matrix Q is orthogonal: Q^T * Q = I
     * Uses MML::Utils::IsOrthogonal from BaseUtils.h
     */
    static bool IsOrthogonal(const Matrix<Real>& Q, Real tol = 1e-10)
    {
      return Utils::IsOrthogonal(Q, tol);
    }

    /**
     * Compute trace (sum of diagonal elements)
     * Uses Matrix::Trace() member function
     */
    static Real Trace(const Matrix<Real>& A)
    {
      return A.Trace();
    }

    /**
     * Compute Q^T * A * Q to verify similarity transformation
     */
    static Matrix<Real> SimilarityTransform(const Matrix<Real>& Q, const Matrix<Real>& A)
    {
      int n = A.RowNum();
      Matrix<Real> temp(n, n);
      Matrix<Real> result(n, n);
      
      // temp = A * Q
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
        {
          temp(i, j) = 0.0;
          for (int k = 0; k < n; k++)
            temp(i, j) += A(i, k) * Q(k, j);
        }
      
      // result = Q^T * temp
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
        {
          result(i, j) = 0.0;
          for (int k = 0; k < n; k++)
            result(i, j) += Q(k, i) * temp(k, j);
        }
      
      return result;
    }

    /**
     * Compute maximum absolute difference between two matrices
     */
    static Real MaxAbsDiff(const Matrix<Real>& A, const Matrix<Real>& B)
    {
      Real maxDiff = 0.0;
      int n = A.RowNum();
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
          maxDiff = std::max(maxDiff, std::abs(A(i, j) - B(i, j)));
      return maxDiff;
    }

    // =========================================================================
    // BUILDING BLOCK 2: SINGLE QR STEP FOR HESSENBERG MATRIX
    // =========================================================================

    /**
     * @struct QRStepResult
     * @brief Result of single QR step: H_new = Q^T * H * Q
     */
    struct QRStepResult
    {
      Matrix<Real> H;      // Updated Hessenberg matrix
      Matrix<Real> Q;      // Orthogonal transformation (optional, for eigenvectors)
      Real shift;          // Shift used
      
      QRStepResult(int n) : H(n, n), Q(n, n), shift(0.0) {}
    };

    /**
     * Compute Wilkinson shift from bottom 2x2 submatrix of Hessenberg H.
     * 
     * For 2x2 block:
     *   [ a   b ]
     *   [ c   d ]
     * 
     * The Wilkinson shift Ïƒ is the eigenvalue of this block closest to d.
     * This choice provides cubic convergence for distinct eigenvalues.
     * 
     * Eigenvalues: Î» = (a+d)/2 Â± sqrt((a-d)Â²/4 + bc)
     * We want the one closer to d.
     */
    static Real WilkinsonShift(Real a, Real b, Real c, Real d)
    {
      // The eigenvalues of [[a,b],[c,d]] are:
      // Î» = (a+d)/2 Â± sqrt(((a-d)/2)Â² + bc)
      //
      // For numerical stability and to get the one closer to d:
      // Let Î´ = (a - d)/2
      // Î»â‚ = d + Î´ + sqrt(Î´Â² + bc)  
      // Î»â‚‚ = d + Î´ - sqrt(Î´Â² + bc)
      //
      // The one closer to d depends on sign of Î´
      
      Real delta = (a - d) / 2.0;
      Real disc = delta * delta + b * c;
      
      if (disc >= 0.0)
      {
        // Two real eigenvalues
        Real sqrtDisc = std::sqrt(disc);
        
        // Î»â‚ = (a+d)/2 + sqrt = d + Î´ + sqrt
        // Î»â‚‚ = (a+d)/2 - sqrt = d + Î´ - sqrt
        // Distance from d: |Î´ + sqrt| and |Î´ - sqrt|
        // The one closer is the one where Î´ and sqrt have opposite signs
        // i.e., |Î´ - sign(Î´)*sqrt|
        
        if (delta >= 0.0)
        {
          // Î´ >= 0, so Î»â‚‚ = d + Î´ - sqrt is closer to d
          return d + delta - sqrtDisc;
        }
        else
        {
          // Î´ < 0, so Î»â‚ = d + Î´ + sqrt is closer to d  
          return d + delta + sqrtDisc;
        }
      }
      else
      {
        // Complex eigenvalues - real part is (a+d)/2
        // For real QR, use the real part
        return (a + d) / 2.0;
      }
    }

    /**
     * Apply single shifted QR step to upper Hessenberg matrix.
     * 
     * ALGORITHM:
     * 1. Shift: H' = H - ÏƒI
     * 2. QR factorize H' using Givens rotations: H' = QR (stored in place)
     * 3. Reverse multiply: H_new = RQ + ÏƒI
     * 
     * For Hessenberg matrices, we only need n-1 Givens rotations,
     * one for each subdiagonal element.
     * 
     * The key insight is:
     * - Apply rotations from left: this zeros subdiagonal â†’ gives R
     * - Store the rotations in Q
     * - After all left rotations, apply them from right: R â†’ RQ
     * - The result RQ is similar to H' and hence to H
     * 
     * @param H Upper Hessenberg matrix (modified in place)
     * @param accumulateQ If true, returns Q; otherwise Q is identity
     * @param shift If provided, uses this shift; otherwise computes Wilkinson shift
     * @return QRStepResult with updated H and Q
     */
    static QRStepResult SingleQRStep(const Matrix<Real>& H, bool accumulateQ = true,
                                     Real* providedShift = nullptr)
    {
      int n = H.RowNum();
      QRStepResult result(n);
      result.H = H;
      result.Q = Matrix<Real>::GetUnitMatrix(n);
      
      if (n <= 1)
        return result;
      
      // Compute shift from bottom 2x2
      Real shift;
      if (providedShift != nullptr)
      {
        shift = *providedShift;
      }
      else
      {
        // Extract bottom 2x2: H[n-2:n-1, n-2:n-1]
        Real a = result.H(n - 2, n - 2);
        Real b = result.H(n - 2, n - 1);
        Real c = result.H(n - 1, n - 2);
        Real d = result.H(n - 1, n - 1);
        shift = WilkinsonShift(a, b, c, d);
      }
      result.shift = shift;
      
      // Apply shift: H = H - ÏƒI
      for (int i = 0; i < n; i++)
        result.H(i, i) -= shift;
      
      // Store Givens rotation parameters
      std::vector<Real> cosines(n - 1);
      std::vector<Real> sines(n - 1);
      
      // Phase 1: QR factorization - apply Givens from LEFT only to get R
      // For each subdiagonal element H(i+1, i), create rotation to zero it
      for (int i = 0; i < n - 1; i++)
      {
        Real a = result.H(i, i);
        Real b = result.H(i + 1, i);
        
        if (std::abs(b) < PrecisionValues<Real>::DivisionSafetyThreshold)
        {
          // No rotation needed
          cosines[i] = 1.0;
          sines[i] = 0.0;
          continue;
        }
        
        // Compute Givens rotation G such that G^T * [a; b] = [r; 0]
        // G = [c  s; -s  c] where c = a/r, s = b/r, r = sqrt(aÂ² + bÂ²)
        Real r = std::sqrt(a * a + b * b);
        Real c = a / r;
        Real s = b / r;
        
        cosines[i] = c;
        sines[i] = s;
        
        // Apply rotation from left: G^T * H
        // Affects rows i and i+1, all columns from i to n-1
        for (int j = i; j < n; j++)
        {
          Real t1 = result.H(i, j);
          Real t2 = result.H(i + 1, j);
          result.H(i, j)     =  c * t1 + s * t2;
          result.H(i + 1, j) = -s * t1 + c * t2;
        }
      }
      
      // At this point, result.H contains R (upper triangular)
      
      // Phase 2: Multiply R * Q by applying stored rotations from RIGHT
      // This gives RQ which is similar to H - ÏƒI
      for (int i = 0; i < n - 1; i++)
      {
        Real c = cosines[i];
        Real s = sines[i];
        
        if (c == 1.0 && s == 0.0)
          continue;
        
        // Apply rotation from right: H * G
        // For Hessenberg preservation: rotation G_{i,i+1} mixes columns i and i+1
        // The result is Hessenberg because each rotation only extends one row below diagonal
        // We affect rows 0 to i+1 (plus one row due to the implicit bulge chase)
        int rowMax = std::min(i + 2, n - 1);
        for (int j = 0; j <= rowMax; j++)
        {
          Real t1 = result.H(j, i);
          Real t2 = result.H(j, i + 1);
          result.H(j, i)     =  c * t1 + s * t2;
          result.H(j, i + 1) = -s * t1 + c * t2;
        }
        
        // Accumulate Q = Q * G for eigenvector computation
        if (accumulateQ)
        {
          for (int j = 0; j < n; j++)
          {
            Real t1 = result.Q(j, i);
            Real t2 = result.Q(j, i + 1);
            result.Q(j, i)     =  c * t1 + s * t2;
            result.Q(j, i + 1) = -s * t1 + c * t2;
          }
        }
      }
      
      // Unshift: H = H + ÏƒI
      for (int i = 0; i < n; i++)
        result.H(i, i) += shift;
      
      return result;
    }

    /**
     * Apply multiple QR steps until subdiagonal element converges or max iterations.
     * 
     * @param H Upper Hessenberg matrix
     * @param maxIter Maximum iterations
     * @param tol Convergence tolerance for subdiagonal
     * @return Number of iterations performed
     */
    static int MultipleQRSteps(Matrix<Real>& H, int maxIter = 30, Real tol = 1e-10)
    {
      int n = H.RowNum();
      if (n <= 1)
        return 0;
      
      for (int iter = 0; iter < maxIter; iter++)
      {
        // Check for convergence: is H(n-1, n-2) small?
        Real off = std::abs(H(n - 1, n - 2));
        Real diag = std::abs(H(n - 2, n - 2)) + std::abs(H(n - 1, n - 1));
        
        if (off < tol * diag || off < PrecisionValues<Real>::DivisionSafetyThreshold)
        {
          H(n - 1, n - 2) = 0.0;  // Force exact zero
          return iter + 1;
        }
        
        // Apply single QR step
        auto result = SingleQRStep(H, false);
        H = result.H;
      }
      
      return maxIter;  // Did not converge
    }

    // =========================================================================
    // BUILDING BLOCK 3: FRANCIS DOUBLE-SHIFT QR STEP
    // =========================================================================

    /**
     * @struct DoubleShiftResult
     * @brief Result of Francis double-shift QR step
     */
    struct DoubleShiftResult
    {
      Matrix<Real> H;      // Updated Hessenberg matrix
      Matrix<Real> Q;      // Accumulated orthogonal transformation
      Real sigma1_real;    // First shift (real part)
      Real sigma1_imag;    // First shift (imaginary part)  
      Real sigma2_real;    // Second shift (real part)
      Real sigma2_imag;    // Second shift (imaginary part)
      
      DoubleShiftResult(int n) : H(n, n), Q(n, n), 
        sigma1_real(0), sigma1_imag(0), sigma2_real(0), sigma2_imag(0) {}
    };

    /**
     * Apply Francis implicit double-shift QR step.
     * 
     * For complex conjugate eigenvalue pairs Ïƒ Â± iÏ„, the double shift
     * implicitly applies two QR steps while keeping all arithmetic real.
     * 
     * ALGORITHM:
     * 1. Compute shifts from bottom 2x2 block
     * 2. Form first column of M = (H - Ïƒâ‚I)(H - Ïƒâ‚‚I) = HÂ² - (Ïƒâ‚+Ïƒâ‚‚)H + Ïƒâ‚Ïƒâ‚‚I
     *    For complex conjugates: Ïƒâ‚+Ïƒâ‚‚ = 2*real, Ïƒâ‚Ïƒâ‚‚ = |Ïƒ|Â²
     * 3. Apply Householder to zero elements 2,3 of first column â†’ creates "bulge"
     * 4. Chase bulge down the matrix with Householder reflections
     * 5. Result: H undergoes implicit double QR step
     * 
     * This handles complex eigenvalues without complex arithmetic.
     * 
     * @param H Upper Hessenberg matrix (n >= 3)
     * @param iLo Starting index of active submatrix (usually 0)
     * @param iHi Ending index of active submatrix (usually n-1)
     * @param accumulateQ If true, accumulates Q for eigenvector computation
     * @return DoubleShiftResult with updated H and Q
     */
    static DoubleShiftResult FrancisDoubleShift(const Matrix<Real>& H, int iLo, int iHi, 
                                                 bool accumulateQ = true)
    {
      int n = H.RowNum();
      DoubleShiftResult result(n);
      result.H = H;
      result.Q = Matrix<Real>::GetUnitMatrix(n);
      
      int nn = iHi - iLo + 1;  // Size of active block
      if (nn < 3)
      {
        // For 2x2, just use single shift
        if (nn == 2)
        {
          auto single = SingleQRStep(result.H, accumulateQ);
          result.H = single.H;
          result.Q = single.Q;
        }
        return result;
      }
      
      // Extract bottom 2x2 for shift computation
      Real h11 = result.H(iHi - 1, iHi - 1);
      Real h12 = result.H(iHi - 1, iHi);
      Real h21 = result.H(iHi, iHi - 1);
      Real h22 = result.H(iHi, iHi);
      
      // Eigenvalues of bottom 2x2: these are our shifts
      auto eig = Eigenvalues2x2(h11, h12, h21, h22);
      result.sigma1_real = eig.real1;
      result.sigma1_imag = eig.imag1;
      result.sigma2_real = eig.real2;
      result.sigma2_imag = eig.imag2;
      
      // For implicit double shift: compute first column of
      // M = HÂ² - sH + pI where s = Ïƒâ‚+Ïƒâ‚‚ (trace) and p = Ïƒâ‚Ïƒâ‚‚ (det)
      Real s = h11 + h22;  // trace of 2x2 = sum of shifts
      Real p = h11 * h22 - h12 * h21;  // det of 2x2 = product of shifts
      
      // First column of M = (H - Ïƒâ‚I)(H - Ïƒâ‚‚I):
      // M[0,0] = H[0,0]Â² + H[0,1]*H[1,0] - s*H[0,0] + p
      // M[1,0] = H[1,0]*(H[0,0] + H[1,1] - s)
      // M[2,0] = H[1,0]*H[2,1]
      Real h00 = result.H(iLo, iLo);
      Real h01 = result.H(iLo, iLo + 1);
      Real h10 = result.H(iLo + 1, iLo);
      Real hh11 = result.H(iLo + 1, iLo + 1);
      Real h21b = result.H(iLo + 2, iLo + 1);
      
      Real x = h00 * h00 + h01 * h10 - s * h00 + p;
      Real y = h10 * (h00 + hh11 - s);
      Real z = h10 * h21b;
      
      // Chase the bulge from top to bottom
      for (int k = iLo; k <= iHi - 2; k++)
      {
        // Compute Householder reflector to zero out y and z
        // P = I - 2*v*v^T / (v^T*v) where v = [x; y; z] - ||[x;y;z]|| * e1
        Real norm = std::sqrt(x * x + y * y + z * z);
        if (norm < PrecisionValues<Real>::DivisionSafetyThreshold)
          break;
        
        Real alpha = (x >= 0) ? -norm : norm;
        Real v0 = x - alpha;
        Real v1 = y;
        Real v2 = z;
        Real vnorm = std::sqrt(v0 * v0 + v1 * v1 + v2 * v2);
        
        if (vnorm < PrecisionValues<Real>::DivisionSafetyThreshold)
          break;
        
        v0 /= vnorm;
        v1 /= vnorm;
        v2 /= vnorm;
        
        // Determine column range for reflector application
        int col0 = (k > iLo) ? k - 1 : k;
        
        // Apply reflector from left: P * H
        // H[k:k+2, col0:n-1] = (I - 2vv^T) * H[k:k+2, col0:n-1]
        for (int j = col0; j < n; j++)
        {
          Real t0 = result.H(k, j);
          Real t1 = result.H(k + 1, j);
          Real t2 = result.H(k + 2, j);
          Real dot = v0 * t0 + v1 * t1 + v2 * t2;
          Real tau = 2.0 * dot;
          result.H(k, j)     = t0 - tau * v0;
          result.H(k + 1, j) = t1 - tau * v1;
          result.H(k + 2, j) = t2 - tau * v2;
        }
        
        // Apply reflector from right: H * P
        // H[0:min(k+4,n), k:k+2] = H[...] * (I - 2vv^T)
        int row1 = std::min(k + 4, iHi + 1);
        for (int j = 0; j < row1; j++)
        {
          Real t0 = result.H(j, k);
          Real t1 = result.H(j, k + 1);
          Real t2 = result.H(j, k + 2);
          Real dot = v0 * t0 + v1 * t1 + v2 * t2;
          Real tau = 2.0 * dot;
          result.H(j, k)     = t0 - tau * v0;
          result.H(j, k + 1) = t1 - tau * v1;
          result.H(j, k + 2) = t2 - tau * v2;
        }
        
        // Accumulate Q = Q * P
        if (accumulateQ)
        {
          for (int j = 0; j < n; j++)
          {
            Real t0 = result.Q(j, k);
            Real t1 = result.Q(j, k + 1);
            Real t2 = result.Q(j, k + 2);
            Real dot = v0 * t0 + v1 * t1 + v2 * t2;
            Real tau = 2.0 * dot;
            result.Q(j, k)     = t0 - tau * v0;
            result.Q(j, k + 1) = t1 - tau * v1;
            result.Q(j, k + 2) = t2 - tau * v2;
          }
        }
        
        // Set up x, y, z for next iteration (bulge moves down)
        if (k < iHi - 2)
        {
          x = result.H(k + 1, k);
          y = result.H(k + 2, k);
          z = (k + 3 <= iHi) ? result.H(k + 3, k) : 0.0;
        }
      }
      
      // Final 2x2 cleanup: zero out H(iHi-1, iHi-2) bulge element
      int k = iHi - 2;
      x = result.H(k + 1, k);
      y = result.H(k + 2, k);
      
      // 2x2 Givens rotation to zero y
      Real r = std::sqrt(x * x + y * y);
      if (r > PrecisionValues<Real>::DivisionSafetyThreshold)
      {
        Real c = x / r;
        Real s_val = y / r;
        
        // Apply from left
        for (int j = k; j < n; j++)
        {
          Real t1 = result.H(k + 1, j);
          Real t2 = result.H(k + 2, j);
          result.H(k + 1, j) =  c * t1 + s_val * t2;
          result.H(k + 2, j) = -s_val * t1 + c * t2;
        }
        
        // Apply from right
        for (int j = 0; j <= std::min(k + 3, iHi); j++)
        {
          Real t1 = result.H(j, k + 1);
          Real t2 = result.H(j, k + 2);
          result.H(j, k + 1) =  c * t1 + s_val * t2;
          result.H(j, k + 2) = -s_val * t1 + c * t2;
        }
        
        // Accumulate
        if (accumulateQ)
        {
          for (int j = 0; j < n; j++)
          {
            Real t1 = result.Q(j, k + 1);
            Real t2 = result.Q(j, k + 2);
            result.Q(j, k + 1) =  c * t1 + s_val * t2;
            result.Q(j, k + 2) = -s_val * t1 + c * t2;
          }
        }
      }
      
      // Clean up small subdiagonal elements
      for (int i = iLo + 1; i <= iHi; i++)
      {
        if (std::abs(result.H(i, i - 1)) < PrecisionValues<Real>::DivisionSafetyThreshold)
          result.H(i, i - 1) = 0.0;
      }
      
      return result;
    }

    /**
     * Apply multiple double-shift QR iterations for complex eigenvalue convergence.
     * Returns number of iterations used.
     */
    static int MultipleDoubleShiftSteps(Matrix<Real>& H, int iLo, int iHi,
                                        int maxIter = 30, Real tol = 1e-10)
    {
      for (int iter = 0; iter < maxIter; iter++)
      {
        // Check for deflation at bottom
        Real off = std::abs(H(iHi, iHi - 1));
        Real diag = std::abs(H(iHi - 1, iHi - 1)) + std::abs(H(iHi, iHi));
        
        if (off < tol * std::max(diag, REAL(1.0)) || off < PrecisionValues<Real>::DivisionSafetyThreshold)
        {
          H(iHi, iHi - 1) = 0.0;
          return iter + 1;
        }
        
        // Also check penultimate subdiagonal
        if (iHi >= iLo + 2)
        {
          Real off2 = std::abs(H(iHi - 1, iHi - 2));
          Real diag2 = std::abs(H(iHi - 2, iHi - 2)) + std::abs(H(iHi - 1, iHi - 1));
          if (off2 < tol * std::max(diag2, REAL(1.0)) || off2 < PrecisionValues<Real>::DivisionSafetyThreshold)
          {
            H(iHi - 1, iHi - 2) = 0.0;
            return iter + 1;
          }
        }
        
        // Apply double shift
        auto result = FrancisDoubleShift(H, iLo, iHi, false);
        H = result.H;
      }
      
      return maxIter;
    }

    // =========================================================================
    // BUILDING BLOCK 4: EIGENVALUE EXTRACTION FROM 2x2 BLOCK
    // =========================================================================

    /**
     * @struct Eigenvalue2x2Result
     * @brief Eigenvalues of a 2x2 matrix (may be complex conjugate pair)
     */
    struct Eigenvalue2x2Result
    {
      Real real1, imag1;   // First eigenvalue: real1 + i*imag1
      Real real2, imag2;   // Second eigenvalue: real2 + i*imag2
      bool isComplex;      // True if complex conjugate pair
    };

    /**
     * Compute eigenvalues of 2x2 matrix [[a, b], [c, d]]
     * 
     * Characteristic polynomial: Î»Â² - (a+d)Î» + (ad-bc) = 0
     * Î» = (a+d)/2 Â± sqrt((a+d)Â²/4 - (ad-bc))
     *   = (a+d)/2 Â± sqrt((a-d)Â²/4 + bc)
     */
    static Eigenvalue2x2Result Eigenvalues2x2(Real a, Real b, Real c, Real d)
    {
      Eigenvalue2x2Result result;
      
      Real trace = a + d;
      Real det = a * d - b * c;
      
      // Discriminant = traceÂ²/4 - det = (a-d)Â²/4 + bc
      Real p = (a - d) / 2.0;
      Real disc = p * p + b * c;
      
      result.real1 = trace / 2.0;
      result.real2 = trace / 2.0;
      
      if (disc >= 0.0)
      {
        // Two real eigenvalues
        Real sqrtDisc = std::sqrt(disc);
        result.real1 += sqrtDisc;
        result.real2 -= sqrtDisc;
        result.imag1 = 0.0;
        result.imag2 = 0.0;
        result.isComplex = false;
      }
      else
      {
        // Complex conjugate pair
        Real sqrtDisc = std::sqrt(-disc);
        result.imag1 = sqrtDisc;
        result.imag2 = -sqrtDisc;
        result.isComplex = true;
      }
      
      return result;
    }

    /**
     * @struct DeflationResult
     * @brief Result of checking for deflation in Hessenberg matrix
     */
    struct DeflationResult
    {
      bool canDeflate;     // True if deflation is possible
      int deflationIndex;  // Index where deflation occurs (H[idx, idx-1] â‰ˆ 0)
      int blockSize;       // Size of deflated block (1 = real eigenvalue, 2 = complex pair)
    };

    /**
     * Check if matrix can be deflated at any position.
     * 
     * Deflation occurs when |H[k, k-1]| < tol * (|H[k-1,k-1]| + |H[k,k]|)
     * This means the matrix decouples into independent subproblems.
     * 
     * @param H Upper Hessenberg matrix  
     * @param iLo Start index of active region
     * @param iHi End index of active region
     * @param tol Tolerance for considering element as zero
     * @return DeflationResult indicating if/where deflation is possible
     */
    static DeflationResult CheckDeflation(const Matrix<Real>& H, int iLo, int iHi, 
                                          Real tol = 1e-10)
    {
      DeflationResult result;
      result.canDeflate = false;
      result.deflationIndex = -1;
      result.blockSize = 0;
      
      // Check from bottom up for deflation
      for (int k = iHi; k > iLo; k--)
      {
        Real off = std::abs(H(k, k - 1));
        Real diag = std::abs(H(k - 1, k - 1)) + std::abs(H(k, k));
        
        if (off < tol * std::max(diag, REAL(1.0)) || off < PrecisionValues<Real>::DivisionSafetyThreshold)
        {
          result.canDeflate = true;
          result.deflationIndex = k;
          
          // Determine block size: check if this isolates a 1x1 or 2x2 block
          if (k == iHi)
          {
            // Single eigenvalue at position iHi
            result.blockSize = 1;
          }
          else
          {
            // Check next subdiagonal
            Real off2 = std::abs(H(k + 1, k));
            Real diag2 = std::abs(H(k, k)) + std::abs(H(k + 1, k + 1));
            if (off2 < tol * std::max(diag2, REAL(1.0)) || off2 < PrecisionValues<Real>::DivisionSafetyThreshold)
              result.blockSize = 1;
            else
              result.blockSize = 2;  // 2x2 block (complex pair)
          }
          return result;
        }
      }
      
      return result;
    }

    /**
     * @struct ComplexEigenvalue
     * @brief Represents a potentially complex eigenvalue
     */
    struct ComplexEigenvalue
    {
      Real real;
      Real imag;
      bool isComplex;
      
      ComplexEigenvalue(Real r = 0.0, Real i = 0.0) 
        : real(r), imag(i), isComplex(std::abs(i) > PrecisionValues<Real>::DivisionSafetyThreshold) {}
    };

    /**
     * @struct EigenvalueExtractionResult
     * @brief All eigenvalues extracted from quasi-upper-triangular form
     */
    struct EigenvalueExtractionResult
    {
      std::vector<ComplexEigenvalue> eigenvalues;
      int realCount;     // Number of real eigenvalues
      int complexPairs;  // Number of complex conjugate pairs
    };

    /**
     * Extract all eigenvalues from quasi-upper-triangular (real Schur) form.
     * 
     * The matrix should be the result of QR iteration:
     * - 1x1 diagonal blocks contain real eigenvalues
     * - 2x2 diagonal blocks contain complex conjugate pairs
     * 
     * A 2x2 block is detected when H[i+1, i] is non-negligible.
     * 
     * @param H Quasi-upper-triangular matrix
     * @param tol Tolerance for detecting 2x2 blocks
     * @return EigenvalueExtractionResult with all eigenvalues
     */
    static EigenvalueExtractionResult ExtractEigenvalues(const Matrix<Real>& H, 
                                                          Real tol = 1e-10)
    {
      int n = H.RowNum();
      EigenvalueExtractionResult result;
      result.realCount = 0;
      result.complexPairs = 0;
      
      int i = 0;
      while (i < n)
      {
        if (i == n - 1)
        {
          // Last element: 1x1 block (real eigenvalue)
          result.eigenvalues.push_back(ComplexEigenvalue(H(i, i), 0.0));
          result.realCount++;
          i++;
        }
        else
        {
          // Check if this is a 2x2 block
          Real subdiag = std::abs(H(i + 1, i));
          Real diagSum = std::abs(H(i, i)) + std::abs(H(i + 1, i + 1));
          
          if (subdiag < tol * std::max(diagSum, REAL(1.0)) || subdiag < PrecisionValues<Real>::DivisionSafetyThreshold)
          {
            // 1x1 block: real eigenvalue
            result.eigenvalues.push_back(ComplexEigenvalue(H(i, i), REAL(0.0)));
            result.realCount++;
            i++;
          }
          else
          {
            // 2x2 block: extract eigenvalues
            auto eig = Eigenvalues2x2(H(i, i), H(i, i + 1), H(i + 1, i), H(i + 1, i + 1));
            
            result.eigenvalues.push_back(ComplexEigenvalue(eig.real1, eig.imag1));
            result.eigenvalues.push_back(ComplexEigenvalue(eig.real2, eig.imag2));
            
            if (eig.isComplex)
            {
              result.complexPairs++;
            }
            else
            {
              result.realCount += 2;
            }
            i += 2;
          }
        }
      }
      
      return result;
    }

    /**
     * Force deflation at a specific index by zeroing the subdiagonal element.
     * Call this after CheckDeflation returns canDeflate = true.
     * 
     * @param H Upper Hessenberg matrix (modified in place)
     * @param deflationIndex Index returned by CheckDeflation
     */
    static void ApplyDeflation(Matrix<Real>& H, int deflationIndex)
    {
      if (deflationIndex > 0 && deflationIndex < H.RowNum())
      {
        H(deflationIndex, deflationIndex - 1) = 0.0;
      }
    }

    // =========================================================================
    // BUILDING BLOCK 5: EIGENVECTOR COMPUTATION FROM SCHUR FORM
    // =========================================================================

    /**
     * @struct EigenvectorResult
     * @brief Computed eigenvectors for a matrix
     * 
     * For real eigenvalue at index i: vectors.col(i) is the eigenvector
     * For complex pair at indices i,i+1: 
     *   - vectors.col(i) is the real part
     *   - vectors.col(i+1) is the imaginary part
     *   - Actual eigenvectors are: col(i) Â± i*col(i+1)
     */
    struct EigenvectorResult
    {
      Matrix<Real> vectors;   // Eigenvector matrix (n x n)
      std::vector<bool> isComplexPair;  // isComplexPair[i] = true if columns i,i+1 form complex pair
    };

    /**
     * Compute eigenvector for a real eigenvalue using back-substitution.
     * 
     * Given upper triangular T with eigenvalue Î» = T[k,k], solve (T - Î»I)x = 0
     * by back-substitution from row k-1 up to row 0.
     * 
     * @param T Upper triangular (or quasi-upper-triangular) matrix
     * @param k Index of the eigenvalue (diagonal element T[k,k])
     * @return Eigenvector (normalized)
     */
    static Vector<Real> ComputeRealEigenvector(const Matrix<Real>& T, int k)
    {
      int n = T.RowNum();
      Vector<Real> x(n, 0.0);
      
      // Set x[k] = 1 as starting point
      x[k] = 1.0;
      Real lambda = T(k, k);
      
      // Back-substitute: for i = k-1 down to 0
      // (T[i,i] - Î») * x[i] + sum_{j=i+1}^{k} T[i,j] * x[j] = 0
      // x[i] = -sum_{j=i+1}^{k} T[i,j] * x[j] / (T[i,i] - Î»)
      
      for (int i = k - 1; i >= 0; i--)
      {
        Real sum = 0.0;
        for (int j = i + 1; j <= k; j++)
          sum += T(i, j) * x[j];
        
        Real denom = T(i, i) - lambda;
        if (std::abs(denom) > PrecisionValues<Real>::DivisionSafetyThreshold)
        {
          x[i] = -sum / denom;
        }
        else
        {
          // Near-singular: use small perturbation to avoid division by zero
          x[i] = -sum / PrecisionValues<Real>::DivisionSafetyThreshold;
        }
      }
      
      // Normalize
      Real norm = 0.0;
      for (int i = 0; i < n; i++)
        norm += x[i] * x[i];
      norm = std::sqrt(norm);
      
      if (norm > PrecisionValues<Real>::DivisionSafetyThreshold)
      {
        for (int i = 0; i < n; i++)
          x[i] /= norm;
      }
      
      return x;
    }

    /**
     * Compute eigenvectors for a 2x2 complex eigenvalue block.
     * 
     * For a 2x2 block at positions [k, k+1] with complex eigenvalues Î± Â± iÎ²,
     * compute the real and imaginary parts of the eigenvector.
     * 
     * @param T Quasi-upper-triangular matrix
     * @param k Starting index of the 2x2 block
     * @return Pair of vectors: (real part, imaginary part)
     */
    static std::pair<Vector<Real>, Vector<Real>> ComputeComplexEigenvectors(
      const Matrix<Real>& T, int k)
    {
      int n = T.RowNum();
      Vector<Real> xr(n, 0.0);  // Real part
      Vector<Real> xi(n, 0.0);  // Imaginary part
      
      // Get the 2x2 block and its eigenvalues
      Real a = T(k, k);
      Real b = T(k, k + 1);
      Real c = T(k + 1, k);
      Real d = T(k + 1, k + 1);
      
      auto eig = Eigenvalues2x2(a, b, c, d);
      Real alpha = eig.real1;  // Real part of eigenvalue
      Real beta = eig.imag1;   // Imaginary part (positive)
      
      if (std::abs(beta) < PrecisionValues<Real>::DivisionSafetyThreshold)
      {
        // Not actually complex, treat as two real
        xr = ComputeRealEigenvector(T, k);
        xi = ComputeRealEigenvector(T, k + 1);
        return {xr, xi};
      }
      
      // For the 2x2 block, the eigenvector of [[a,b],[c,d]] for Î±+iÎ² is:
      // v = [b, Î±+iÎ²-a] or [Î±+iÎ²-d, c] (up to scaling)
      // We use [b, (Î±-a)+iÎ²] which gives:
      //   real: [b, Î±-a]
      //   imag: [0, Î²]
      
      // Initialize at the 2x2 block
      xr[k] = b;
      xr[k + 1] = alpha - a;
      xi[k] = 0.0;
      xi[k + 1] = beta;
      
      // Back-substitute for rows k-1 down to 0
      // We need to solve (T - (Î±+iÎ²)I) * (xr + i*xi) = 0
      // This gives two coupled real equations:
      // (T - Î±I) * xr + Î²I * xi = 0  =>  (T-Î±I)*xr = -Î²*xi
      // (T - Î±I) * xi - Î²I * xr = 0  =>  (T-Î±I)*xi = Î²*xr
      
      for (int i = k - 1; i >= 0; i--)
      {
        // sum_r = sum of T[i,j]*xr[j] for j > i
        // sum_i = sum of T[i,j]*xi[j] for j > i
        Real sum_r = 0.0;
        Real sum_i = 0.0;
        for (int j = i + 1; j <= k + 1; j++)
        {
          sum_r += T(i, j) * xr[j];
          sum_i += T(i, j) * xi[j];
        }
        
        // (T[i,i] - Î±) * xr[i] + Î² * xi[i] = -sum_r
        // (T[i,i] - Î±) * xi[i] - Î² * xr[i] = -sum_i
        // Let p = T[i,i] - Î±
        // p * xr[i] + Î² * xi[i] = -sum_r
        // p * xi[i] - Î² * xr[i] = -sum_i
        // Solve 2x2 system:
        // |p   Î² | |xr[i]|   |-sum_r|
        // |-Î²  p | |xi[i]| = |-sum_i|
        // det = pÂ² + Î²Â²
        
        Real p = T(i, i) - alpha;
        Real det = p * p + beta * beta;
        
        if (det > PrecisionValues<Real>::DivisionSafetyThreshold)
        {
          xr[i] = (-sum_r * p - sum_i * beta) / det;
          xi[i] = (-sum_i * p + sum_r * beta) / det;
        }
        else
        {
          xr[i] = 0.0;
          xi[i] = 0.0;
        }
      }
      
      // Normalize: ||xr||Â² + ||xi||Â² = 1 for each eigenvector
      Real norm_sq = 0.0;
      for (int i = 0; i < n; i++)
        norm_sq += xr[i] * xr[i] + xi[i] * xi[i];
      
      Real norm = std::sqrt(norm_sq);
      if (norm > PrecisionValues<Real>::DivisionSafetyThreshold)
      {
        for (int i = 0; i < n; i++)
        {
          xr[i] /= norm;
          xi[i] /= norm;
        }
      }
      
      return {xr, xi};
    }

    /**
     * Compute all eigenvectors from quasi-upper-triangular (real Schur) form.
     * 
     * @param T Quasi-upper-triangular matrix (from QR iteration)
     * @param Q Accumulated orthogonal transformation (T = Q^T * A * Q)
     * @param tol Tolerance for detecting 2x2 blocks
     * @return EigenvectorResult with eigenvector matrix
     */
    static EigenvectorResult ComputeEigenvectorsFromSchur(
      const Matrix<Real>& T, const Matrix<Real>& Q, Real tol = 1e-10)
    {
      int n = T.RowNum();
      EigenvectorResult result;
      result.vectors = Matrix<Real>(n, n);
      result.isComplexPair.resize(n, false);
      
      // First compute eigenvectors of T (the Schur form)
      Matrix<Real> Y(n, n);  // Eigenvectors of T
      
      int i = 0;
      while (i < n)
      {
        bool is2x2 = false;
        
        if (i < n - 1)
        {
          Real subdiag = std::abs(T(i + 1, i));
          Real diagSum = std::abs(T(i, i)) + std::abs(T(i + 1, i + 1));
          is2x2 = (subdiag >= tol * std::max(diagSum, REAL(1.0)) && subdiag >= PrecisionValues<Real>::DivisionSafetyThreshold);
        }
        
        if (!is2x2)
        {
          // 1x1 block: real eigenvalue
          Vector<Real> v = ComputeRealEigenvector(T, i);
          for (int j = 0; j < n; j++)
            Y(j, i) = v[j];
          result.isComplexPair[i] = false;
          i++;
        }
        else
        {
          // 2x2 block: complex conjugate pair
          auto [vr, vi] = ComputeComplexEigenvectors(T, i);
          for (int j = 0; j < n; j++)
          {
            Y(j, i) = vr[j];      // Real part in column i
            Y(j, i + 1) = vi[j];  // Imaginary part in column i+1
          }
          result.isComplexPair[i] = true;
          result.isComplexPair[i + 1] = true;
          i += 2;
        }
      }
      
      // Transform back: X = Q * Y
      // Since T = Q^T * A * Q, eigenvectors of A are X = Q * Y
      for (int col = 0; col < n; col++)
      {
        for (int row = 0; row < n; row++)
        {
          Real sum = 0.0;
          for (int k = 0; k < n; k++)
            sum += Q(row, k) * Y(k, col);
          result.vectors(row, col) = sum;
        }
        
        // Re-normalize after transformation
        Real norm = 0.0;
        for (int row = 0; row < n; row++)
          norm += result.vectors(row, col) * result.vectors(row, col);
        norm = std::sqrt(norm);
        
        if (norm > PrecisionValues<Real>::DivisionSafetyThreshold)
        {
          for (int row = 0; row < n; row++)
            result.vectors(row, col) /= norm;
        }
      }
      
      return result;
    }

    /**
     * Verify eigenvector: compute ||A*v - Î»*v|| / ||v||
     * For complex eigenvalue, uses real part of Î» only.
     */
    static Real EigenvectorResidual(const Matrix<Real>& A, const Vector<Real>& v, 
                                    Real lambda_real, Real lambda_imag = 0.0)
    {
      int n = A.RowNum();
      Real residual = 0.0;
      Real vnorm = 0.0;
      
      if (std::abs(lambda_imag) < PrecisionValues<Real>::DivisionSafetyThreshold)
      {
        // Real eigenvalue: check ||A*v - Î»*v||
        for (int i = 0; i < n; i++)
        {
          Real Av_i = 0.0;
          for (int j = 0; j < n; j++)
            Av_i += A(i, j) * v[j];
          Real diff = Av_i - lambda_real * v[i];
          residual += diff * diff;
          vnorm += v[i] * v[i];
        }
      }
      else
      {
        // Complex eigenvalue: this is the real part of eigenvector
        // The actual eigenvector is v_r + i*v_i where v_i is the next column
        // For a simple check, just verify magnitude is reasonable
        for (int i = 0; i < n; i++)
          vnorm += v[i] * v[i];
        return 0.0;  // Complex case needs both vectors, skip for now
      }
      
      vnorm = std::sqrt(vnorm);
      if (vnorm > PrecisionValues<Real>::DivisionSafetyThreshold)
        return std::sqrt(residual) / vnorm;
      return 0.0;
    }

  };

} // namespace MML


///////////////////////////   mml/algorithms/EigenSystemSolvers.h   ///////////////////////////


namespace MML
{
	/***************************************************************************************************
	 * JACOBI EIGENSOLVER FOR SYMMETRIC MATRICES
	 * 
	 * Classical iterative method using Givens rotations to diagonalize symmetric matrices.
	 * 
	 * ALGORITHM:
	 * 1. Find largest off-diagonal element a_pq
	 * 2. Compute Givens rotation to zero out a_pq
	 * 3. Apply rotation: A' = J^T * A * J
	 * 4. Accumulate rotations to build eigenvector matrix
	 * 5. Repeat until off-diagonal norm < tolerance
	 * 
	 * COMPLEXITY: O(nÂ³) per sweep, typically 5-10 sweeps needed
	 * 
	 * PROS:
	 * - Simple, robust algorithm
	 * - Automatically computes all eigenvalues and eigenvectors
	 * - Excellent for small to medium matrices (n < 100)
	 * - Numerically very stable
	 * 
	 * CONS:
	 * - Slower than QR method for large matrices
	 * - O(nÂ³) per sweep vs O(nÂ³) total for QR
	 * 
	 * REFERENCES:
	 * - Golub & Van Loan, "Matrix Computations", Section 8.5
	 * - Numerical Recipes, Section 11.1
	 ***************************************************************************************************/
	class SymmMatEigenSolverJacobi
  {
	public:
		// Result structure for eigenvalue decomposition
		struct Result
		{
			Vector<Real> eigenvalues;      // Eigenvalues in ascending order
			Matrix<Real> eigenvectors;     // Column i = eigenvector for eigenvalue i
			int iterations;                // Number of sweeps performed
			Real residual;                 // Final off-diagonal norm
			bool converged;                // True if converged within tolerance

			Result(int n) : eigenvalues(n), eigenvectors(n, n), iterations(0), residual(0.0), converged(false) {}
		};

		/**
		 * Solve symmetric eigenvalue problem: A*v = Î»*v
		 * 
		 * @param A        Symmetric matrix (only upper triangle is used)
		 * @param tol      Convergence tolerance (default: 1e-10)
		 * @param maxIter  Maximum number of sweeps (default: 100)
		 * @return Result containing eigenvalues, eigenvectors, and convergence info
		 * 
		 * POSTCONDITIONS:
		 * - eigenvalues[i] <= eigenvalues[i+1] (ascending order)
		 * - eigenvectors.Column(i) corresponds to eigenvalues[i]
		 * - Eigenvectors are orthonormal: V^T * V = I
		 * - A * V = V * diag(Î»)
		 */
		static Result Solve(const MatrixSym<Real>& A, Real tol = 1e-10, int maxIter = 100)
		{
			int n = A.RowNum();
			Result result(n);

			// Initialize: Copy A to working matrix, V to identity
			Matrix<Real> D(n, n);
			for (int i = 0; i < n; i++)
				for (int j = 0; j < n; j++)
					D[i][j] = (i <= j) ? A(i, j) : A(j, i);

			Matrix<Real> V = Matrix<Real>::GetUnitMatrix(n);

			// Jacobi iterations
			int sweep = 0;
			Real offDiagNorm = OffDiagonalNorm(D, n);

			while (offDiagNorm > tol && sweep < maxIter)
			{
				// One sweep: process all off-diagonal elements
				for (int p = 0; p < n - 1; p++)
				{
					for (int q = p + 1; q < n; q++)
					{
					if (std::abs(D[p][q]) < PrecisionValues<Real>::EigenSolverZeroThreshold)  // Skip if already zero
							continue;
						// Compute Givens rotation parameters
						Real theta = ComputeRotationAngle(D, p, q);
						Real c = std::cos(theta);
						Real s = std::sin(theta);

						// Apply rotation
						ApplyRotation(D, V, p, q, c, s, n);
					}
				}

				sweep++;
				offDiagNorm = OffDiagonalNorm(D, n);
			}

			// Extract eigenvalues from diagonal
			for (int i = 0; i < n; i++)
				result.eigenvalues[i] = D[i][i];

			// Copy eigenvectors
			result.eigenvectors = V;

			// Sort eigenvalues and eigenvectors
			SortEigenvalues(result.eigenvalues, result.eigenvectors);

			// Set convergence info
			result.iterations = sweep;
			result.residual = offDiagNorm;
			result.converged = (offDiagNorm <= tol);

			return result;
		}

		/**
		 * Solve for a regular Matrix (extracts symmetric part)
		 * Note: Only use if you're certain the matrix is symmetric!
		 */
		static Result Solve(const Matrix<Real>& A, Real tol = 1e-10, int maxIter = 100)
		{
			// Convert to symmetric matrix (average A and A^T)
			int n = A.RowNum();
			MatrixSym<Real> symA(n);
			for (int i = 0; i < n; i++)
				for (int j = i; j < n; j++)
					symA(i, j) = 0.5 * (A[i][j] + A[j][i]);
			
			return Solve(symA, tol, maxIter);
		}

	private:
		// Compute rotation angle to zero out A[p][q]
		static Real ComputeRotationAngle(const Matrix<Real>& A, int p, int q)
		{
			Real theta;
			
			if (std::abs(A[p][q]) < PrecisionValues<Real>::EigenSolverZeroThreshold)
			{
				theta = 0.0;
			}
			else
			{
				Real tau = (A[q][q] - A[p][p]) / (2.0 * A[p][q]);
				Real t;
				
				// Choose sign to avoid loss of significance
				if (tau >= 0)
					t = 1.0 / (tau + std::sqrt(1.0 + tau * tau));
				else
					t = -1.0 / (-tau + std::sqrt(1.0 + tau * tau));
				
				theta = std::atan(t);
			}

			return theta;
		}
		
		// Apply Givens rotation J(p,q,Î¸) to A: A' = J^T * A * J
		static void ApplyRotation(Matrix<Real>& A, Matrix<Real>& V, int p, int q, Real c, Real s, int n)
		{
			// Update A
			for (int i = 0; i < n; i++)
			{
				if (i != p && i != q)
				{
					Real Aip = A[i][p];
					Real Aiq = A[i][q];
					A[i][p] = c * Aip - s * Aiq;
					A[p][i] = A[i][p];
					A[i][q] = s * Aip + c * Aiq;
					A[q][i] = A[i][q];
				}
			}

			// Update diagonal elements
			Real App = A[p][p];
			Real Aqq = A[q][q];
			Real Apq = A[p][q];

			A[p][p] = c * c * App - 2.0 * s * c * Apq + s * s * Aqq;
			A[q][q] = s * s * App + 2.0 * s * c * Apq + c * c * Aqq;
			A[p][q] = 0.0;
			A[q][p] = 0.0;

			// Accumulate rotation in eigenvector matrix V
			for (int i = 0; i < n; i++)
			{
				Real Vip = V[i][p];
				Real Viq = V[i][q];
				V[i][p] = c * Vip - s * Viq;
				V[i][q] = s * Vip + c * Viq;
			}
		}
		
		// Compute off-diagonal norm: sqrt(sum of squares of off-diagonal elements)
		static Real OffDiagonalNorm(const Matrix<Real>& A, int n)
		{
			Real sum = 0.0;
			for (int i = 0; i < n - 1; i++)
				for (int j = i + 1; j < n; j++)
					sum += A[i][j] * A[i][j];
			
			return std::sqrt(sum);
		}
		
		// Sort eigenvalues and eigenvectors in ascending order
		static void SortEigenvalues(Vector<Real>& eigenvalues, Matrix<Real>& eigenvectors)
		{
			int n = eigenvalues.size();
			
			// Simple selection sort (eigenvalues should be small n)
			for (int i = 0; i < n - 1; i++)
			{
				int minIdx = i;
				for (int j = i + 1; j < n; j++)
				{
					if (eigenvalues[j] < eigenvalues[minIdx])
						minIdx = j;
				}
				
				if (minIdx != i)
				{
					// Swap eigenvalues
					std::swap(eigenvalues[i], eigenvalues[minIdx]);
					
					// Swap corresponding eigenvectors (columns)
					for (int row = 0; row < n; row++)
						std::swap(eigenvectors[row][i], eigenvectors[row][minIdx]);
				}
			}
		}
  };

  /**
   * @class SymmMatEigenSolverQR
   * @brief QR algorithm for symmetric matrix eigenvalue decomposition
   *
   * Algorithm: Tridiagonal reduction + Implicit QR iteration with Wilkinson shift
   * 1. Reduce symmetric matrix to tridiagonal form using Householder reflections
   * 2. Apply implicit QR algorithm with Wilkinson shift to tridiagonal matrix
   * 3. Accumulate transformations to obtain eigenvectors
   *
   * Complexity: O(nÂ³) for reduction + O(nÂ²) per QR iteration (typically O(n) iterations)
   *             Total: O(nÂ³) - more efficient than Jacobi for large matrices
   *
   * Pros: - Faster convergence than Jacobi (especially for larger matrices)
   *       - Cubic convergence rate with Wilkinson shift
   *       - Industry-standard algorithm
   * Cons: - More complex implementation
   *       - Requires careful handling of deflation
   * 
   * REFERENCES:
   * - Golub & Van Loan, "Matrix Computations", 4th ed., Sections 8.3-8.4
   * - Numerical Recipes, 3rd ed., Section 11.3
   * - Wilkinson, "The Algebraic Eigenvalue Problem"
   */
  class SymmMatEigenSolverQR
  {
  public:
    struct Result
    {
      Vector<Real>  eigenvalues;     // Sorted eigenvalues (ascending)
      Matrix<Real>  eigenvectors;    // Corresponding eigenvectors (columns)
      int           iterations;      // Number of QR iterations performed
      bool          converged;       // True if algorithm converged
      Real          residual;        // Final off-diagonal norm

      Result(int n) : eigenvalues(n), eigenvectors(n, n), iterations(0), converged(false), residual(0.0) {}
    };

    // Main interface: Solve symmetric eigenvalue problem
    static Result Solve(const MatrixSym<Real>& A, Real tol = 1e-10, int maxIter = 1000)
    {
      int n = A.RowNum();
      Result result(n);

      if (n == 0)
      {
        result.converged = true;
        return result;
      }

      if (n == 1)
      {
        result.eigenvalues[0] = A(0, 0);
        result.eigenvectors(0, 0) = 1.0;
        result.converged = true;
        return result;
      }

      // Step 1: Copy to full matrix for working storage
      Matrix<Real> T(n, n);
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
          T(i, j) = (i <= j) ? A(i, j) : A(j, i);

      // Step 2: Initialize eigenvector matrix to identity
      Matrix<Real> Q = Matrix<Real>::GetUnitMatrix(n);

      // Step 3: Reduce to tridiagonal form using Householder reflections
      // Store diagonal in diag, subdiagonal in subdiag
      Vector<Real> diag(n);
      Vector<Real> subdiag(n);
      
      TridiagonalReduction(T, Q, n);

      // Extract tridiagonal elements
      for (int i = 0; i < n; i++)
        diag[i] = T(i, i);
      for (int i = 0; i < n - 1; i++)
        subdiag[i] = T(i + 1, i);
      subdiag[n - 1] = 0.0;

      // Step 4: Apply implicit QR algorithm with Wilkinson shift
      ImplicitQRAlgorithm(diag, subdiag, Q, n, tol, maxIter,
                          result.iterations, result.converged);

      // Step 5: Compute final residual (off-diagonal norm)
      result.residual = 0.0;
      for (int i = 0; i < n - 1; i++)
        result.residual += subdiag[i] * subdiag[i];
      result.residual = std::sqrt(result.residual);

      // Step 6: Copy results
      result.eigenvalues = diag;
      result.eigenvectors = Q;

      // Step 7: Sort eigenvalues and eigenvectors in ascending order
      SortEigenpairs(result.eigenvalues, result.eigenvectors, n);

      return result;
    }
    
    // Overload for regular Matrix (will symmetrize)
    static Result Solve(const Matrix<Real>& A, Real tol = 1e-10, int maxIter = 1000)
    {
      int n = A.RowNum();
      MatrixSym<Real> symA(n);
      for (int i = 0; i < n; i++)
        for (int j = i; j < n; j++)
          symA(i, j) = 0.5 * (A[i][j] + A[j][i]);
      
      return Solve(symA, tol, maxIter);
    }

  private:
    /**
     * Reduce symmetric matrix to tridiagonal form using Householder reflections.
     * 
     * Algorithm: For k = 0, 1, ..., n-3:
     *   1. Compute Householder vector v to zero out T(k+2:n, k)
     *   2. Apply transformation: T = H * T * H where H = I - 2*v*v^T
     *   3. Accumulate: Q = Q * H
     * 
     * Result: T becomes tridiagonal, Q accumulates the orthogonal transformations
     * 
     * Based on Golub & Van Loan, "Matrix Computations", Algorithm 8.3.1
     */
    static void TridiagonalReduction(Matrix<Real>& T, Matrix<Real>& Q, int n)
    {
      for (int k = 0; k < n - 2; k++)
      {
        // Compute ||x||^2 where x = T(k+1:n-1, k)
        Real sigma = 0.0;
        for (int i = k + 1; i < n; i++)
          sigma += T(i, k) * T(i, k);

        if (sigma < PrecisionValues<Real>::DivisionSafetyThreshold)  // Column already zeroed
          continue;

        Real xNorm = std::sqrt(sigma);
        
        // alpha = -sign(T[k+1,k]) * ||x||
        // Choose sign to maximize |u[k+1]| for numerical stability
        Real alpha = (T(k + 1, k) >= 0.0) ? -xNorm : xNorm;
        
        // Householder vector: u = x - alpha*e1, then v = u/||u||
        Real u_k1 = T(k + 1, k) - alpha;
        
        // ||u||^2 = sigma + alpha^2 - 2*alpha*T[k+1,k]
        Real uNormSq = sigma + alpha * alpha - 2.0 * alpha * T(k + 1, k);
        Real uNorm = std::sqrt(uNormSq);
        
        if (uNorm < PrecisionValues<Real>::DivisionSafetyThreshold)
          continue;

        // Build normalized Householder vector v
        Vector<Real> v(n, 0.0);
        v[k + 1] = u_k1 / uNorm;
        for (int i = k + 2; i < n; i++)
          v[i] = T(i, k) / uNorm;

        // Apply H = I - 2*v*v^T to T from left and right
        // For symmetric matrix: T' = T - v*w^T - w*v^T
        // where w = 2*(T*v - (v^T*T*v)*v)
        
        // Compute p = T * v (restricted to rows/cols k+1 to n-1)
        Vector<Real> p(n, 0.0);
        for (int i = k + 1; i < n; i++)
          for (int j = k + 1; j < n; j++)
            p[i] += T(i, j) * v[j];

        // K = v^T * p
        Real K = 0.0;
        for (int i = k + 1; i < n; i++)
          K += v[i] * p[i];

        // w = 2*(p - K*v)
        Vector<Real> w(n, 0.0);
        for (int i = k + 1; i < n; i++)
          w[i] = 2.0 * (p[i] - K * v[i]);

        // Update T: T' = T - v*w^T - w*v^T
        for (int i = k + 1; i < n; i++)
          for (int j = k + 1; j < n; j++)
            T(i, j) -= v[i] * w[j] + w[i] * v[j];

        // Set subdiagonal explicitly (result of Householder on column k)
        T(k + 1, k) = alpha;
        T(k, k + 1) = alpha;
        
        // Zero elements below subdiagonal
        for (int i = k + 2; i < n; i++)
        {
          T(i, k) = 0.0;
          T(k, i) = 0.0;
        }

        // Accumulate transformation: Q = Q * H = Q * (I - 2*v*v^T)
        // Q_new[:, j] = Q[:, j] - 2*(Q*v)*v[j]
        for (int i = 0; i < n; i++)
        {
          Real dot = 0.0;
          for (int m = k + 1; m < n; m++)
            dot += Q(i, m) * v[m];
          
          for (int j = k + 1; j < n; j++)
            Q(i, j) -= 2.0 * dot * v[j];
        }
      }
    }

    /**
     * Implicit QR algorithm with Wilkinson shift for tridiagonal matrices.
     * 
     * This is the workhorse of the eigenvalue computation. Uses:
     * - Wilkinson shift for cubic convergence
     * - Implicit QR step via bulge chasing with Givens rotations
     * - Deflation when subdiagonal elements become negligible
     */
    static void ImplicitQRAlgorithm(Vector<Real>& d, Vector<Real>& e, Matrix<Real>& Q,
                                     int n, Real tol, int maxIter,
                                     int& iterations, bool& converged)
    {
      iterations = 0;
      converged = false;

      // Work on unreduced portion [lo, hi]
      int lo = 0;
      int hi = n - 1;

      while (hi > 0 && iterations < maxIter)
      {
        // Deflate: Find the largest unreduced block
        // Check if e[hi-1] is negligible
        Real threshold = tol * (std::abs(d[hi - 1]) + std::abs(d[hi]));
        if (threshold < tol) threshold = tol;
        
        if (std::abs(e[hi - 1]) <= threshold)
        {
          e[hi - 1] = 0.0;
          hi--;
          continue;
        }

        // Find lo: start of the unreduced block ending at hi
        lo = hi - 1;
        while (lo > 0)
        {
          threshold = tol * (std::abs(d[lo - 1]) + std::abs(d[lo]));
          if (threshold < tol) threshold = tol;
          
          if (std::abs(e[lo - 1]) <= threshold)
          {
            e[lo - 1] = 0.0;
            break;
          }
          lo--;
        }

        // Now work on the unreduced block [lo, hi]
        
        // Compute Wilkinson shift (eigenvalue of trailing 2x2 closer to d[hi])
        Real shift = WilkinsonShift(d[hi - 1], e[hi - 1], d[hi]);

        // Implicit QR step with shift (bulge chasing)
        ImplicitQRStep(d, e, Q, lo, hi, shift, n);

        iterations++;
      }

      converged = (hi <= 0) || IsConverged(e, n, tol);
    }

    /**
     * Compute Wilkinson shift: eigenvalue of 2x2 trailing submatrix closer to d[hi]
     * 
     * For matrix [[a, b], [b, c]], eigenvalues are:
     *   Î» = (a+c)/2 Â± sqrt(((a-c)/2)^2 + b^2)
     * 
     * We want the one closer to c (= d[hi])
     */
    static Real WilkinsonShift(Real a, Real b, Real c)
    {
      Real d = (a - c) * 0.5;
      Real b_sq = b * b;
      
      if (std::abs(d) < PrecisionValues<Real>::DivisionSafetyThreshold)
        return c - std::abs(b);

      Real sign_d = (d >= 0.0) ? 1.0 : -1.0;
      Real r = std::sqrt(d * d + b_sq);
      
      // Shift = c - b^2 / (d + sign(d)*sqrt(d^2+b^2))
      return c - b_sq / (d + sign_d * r);
    }

    /**
     * Implicit QR step with shift using Givens rotations (bulge chasing).
     * 
     * Creates a bulge at position (1,0) by introducing shift, then chases
     * it down the diagonal using Givens rotations.
     * 
     * For Givens G = [c s; -s c], the similarity transformation G*T*G^T
     * on the 2x2 block [d_k e_k; e_k d_{k+1}] gives:
     *   d'_k     = cÂ²*d_k + 2*c*s*e_k + sÂ²*d_{k+1}
     *   d'_{k+1} = sÂ²*d_k - 2*c*s*e_k + cÂ²*d_{k+1}
     *   e'_k     = c*s*(d_{k+1} - d_k) + (cÂ² - sÂ²)*e_k
     */
    static void ImplicitQRStep(Vector<Real>& d, Vector<Real>& e, Matrix<Real>& Q,
                                int lo, int hi, Real shift, int n)
    {
      // Initial bulge: the first rotation is applied to [d[lo]-shift; e[lo]]
      Real x = d[lo] - shift;
      Real z = e[lo];

      for (int k = lo; k < hi; k++)
      {
        // Compute Givens rotation to eliminate z
        // G = [c s; -s c] such that G * [x; z] = [r; 0]
        Real c, s;
        ComputeGivens(x, z, c, s);

        // Update the previous off-diagonal (if not first iteration)
        if (k > lo)
        {
          // The element e[k-1] becomes sqrt(xÂ² + zÂ²) after rotation
          e[k - 1] = std::sqrt(x * x + z * z);
        }

        // Save current values
        Real d_k = d[k];
        Real d_k1 = d[k + 1];
        Real e_k = e[k];

        // Apply similarity transformation G * [d_k e_k; e_k d_{k+1}] * G^T
        // d'_k     = cÂ²*d_k + 2*c*s*e_k + sÂ²*d_{k+1}
        // d'_{k+1} = sÂ²*d_k - 2*c*s*e_k + cÂ²*d_{k+1}
        // e'_k     = c*s*(d_{k+1} - d_k) + (cÂ² - sÂ²)*e_k
        d[k] = c * c * d_k + 2.0 * c * s * e_k + s * s * d_k1;
        d[k + 1] = s * s * d_k - 2.0 * c * s * e_k + c * c * d_k1;
        e[k] = c * s * (d_k1 - d_k) + (c * c - s * s) * e_k;

        // Bulge chasing: the rotation creates a fill-in at position (k+2, k)
        if (k < hi - 1)
        {
          // The bulge element is s * e[k+1] (from applying G to column k+1)
          x = e[k];
          z = s * e[k + 1];
          e[k + 1] = c * e[k + 1];
        }

        // Accumulate rotation in eigenvector matrix
        // We're computing Q * G^T (to get eigenvectors of original matrix)
        // Q_new[:, k] = c*Q[:, k] + s*Q[:, k+1]
        // Q_new[:, k+1] = -s*Q[:, k] + c*Q[:, k+1]
        for (int i = 0; i < n; i++)
        {
          Real qik = Q(i, k);
          Real qik1 = Q(i, k + 1);
          Q(i, k) = c * qik + s * qik1;
          Q(i, k + 1) = -s * qik + c * qik1;
        }
      }
    }

    /**
     * Compute Givens rotation coefficients c and s such that:
     *   [c  s] [a]   [r]
     *   [-s c] [b] = [0]
     * 
     * where r = sqrt(a^2 + b^2) (or -sqrt if needed for sign consistency)
     * 
     * Standard formulas: c = a/r, s = b/r
     * This zeros out b: c*a + s*b = (a^2 + b^2)/r = r
     *                  -s*a + c*b = (-ab + ab)/r = 0
     */
    static void ComputeGivens(Real a, Real b, Real& c, Real& s)
    {
      if (std::abs(b) < PrecisionValues<Real>::DivisionSafetyThreshold)
      {
        c = (a >= 0.0) ? 1.0 : -1.0;
        s = 0.0;
      }
      else if (std::abs(a) < PrecisionValues<Real>::DivisionSafetyThreshold)
      {
        c = 0.0;
        s = (b >= 0.0) ? 1.0 : -1.0;
      }
      else if (std::abs(b) > std::abs(a))
      {
        // Use t = a/b to avoid overflow
        Real t = a / b;
        Real u = std::sqrt(1.0 + t * t);
        if (b < 0.0) u = -u;
        s = 1.0 / u;
        c = s * t;
      }
      else
      {
        // Use t = b/a to avoid overflow
        Real t = b / a;
        Real u = std::sqrt(1.0 + t * t);
        if (a < 0.0) u = -u;
        c = 1.0 / u;
        s = c * t;
      }
    }

    /**
     * Check if the tridiagonal matrix has converged (all subdiagonals negligible)
     */
    static bool IsConverged(const Vector<Real>& e, int n, Real tol)
    {
      for (int i = 0; i < n - 1; i++)
      {
        if (std::abs(e[i]) > tol)
          return false;
      }
      return true;
    }

    /**
     * Sort eigenvalues and corresponding eigenvectors in ascending order
     */
    static void SortEigenpairs(Vector<Real>& eigenvalues, Matrix<Real>& eigenvectors, int n)
    {
      // Selection sort (n is typically small)
      for (int i = 0; i < n - 1; i++)
      {
        int minIdx = i;
        for (int j = i + 1; j < n; j++)
        {
          if (eigenvalues[j] < eigenvalues[minIdx])
            minIdx = j;
        }
        
        if (minIdx != i)
        {
          // Swap eigenvalues
          std::swap(eigenvalues[i], eigenvalues[minIdx]);
          
          // Swap corresponding eigenvectors (columns)
          for (int row = 0; row < n; row++)
            std::swap(eigenvectors(row, i), eigenvectors(row, minIdx));
        }
      }
    }
  };

  /***************************************************************************************************
   * GENERAL (NON-SYMMETRIC) EIGENSOLVER
   * 
   * Complete eigensolver for general (non-symmetric) matrices using QR iteration
   * with Francis double-shift and Wilkinson shift strategies.
   * 
   * ALGORITHM:
   * 1. Reduce matrix to upper Hessenberg form H = Q^T * A * Q
   * 2. Apply QR iteration with shifts until H converges to quasi-upper-triangular
   * 3. Extract eigenvalues from diagonal and 2x2 blocks
   * 4. Compute eigenvectors via back-substitution
   * 
   * FEATURES:
   * - Handles both real and complex eigenvalues
   * - Complex eigenvalues are stored as conjugate pairs
   * - Uses Wilkinson shift for real eigenvalues (cubic convergence)
   * - Uses Francis double-shift for complex eigenvalue pairs
   * - Deflation to reduce problem size as eigenvalues converge
   * - Exceptional shifts to prevent stagnation
   * 
   * COMPLEXITY: O(nÂ³) - dominated by Hessenberg reduction and QR iterations
   * 
   * OUTPUT FORMAT:
   * - eigenvalues: Array of {real, imag} pairs
   * - eigenvectors: Matrix where column i corresponds to eigenvalue i
   * - For complex eigenvalues Î» = aÂ±bi:
   *   - Stored as consecutive pairs with same real part
   *   - Columns i, i+1 represent real and imaginary parts of eigenvector
   * 
   * REFERENCES:
   * - Golub & Van Loan, "Matrix Computations", 4th ed., Chapter 7
   * - Francis, "The QR Transformationâ€”A Unitary Analogue to the LR Transformation"
   * - Wilkinson, "The Algebraic Eigenvalue Problem"
   ***************************************************************************************************/
  class EigenSolver
  {
  public:
    /**
     * @struct ComplexEigenvalue
     * @brief Represents a complex eigenvalue Î» = real + imag*i
     */
    struct ComplexEigenvalue
    {
      Real real;
      Real imag;
      
      ComplexEigenvalue(Real r = 0.0, Real i = 0.0) : real(r), imag(i) {}
      
      bool isComplex(Real tol = 1e-12) const { return std::abs(imag) > tol; }
      Real magnitude() const { return std::sqrt(real * real + imag * imag); }
    };

    /**
     * @struct Result
     * @brief Complete eigensolution result
     */
    struct Result
    {
      std::vector<ComplexEigenvalue> eigenvalues;
      Matrix<Real> eigenvectors;   // Column i is eigenvector for eigenvalue i
      std::vector<bool> isComplexPair;  // True if columns i,i+1 form complex pair
      bool converged;
      int iterations;
      Real maxResidual;
      
      Result(int n) : eigenvectors(n, n), converged(false), iterations(0), maxResidual(0) {}
    };

    /**
     * Solve the complete eigenvalue problem for a general matrix.
     * 
     * @param A Input matrix (n x n)
     * @param tol Convergence tolerance (default: 1e-10)
     * @param maxIter Maximum total QR iterations (default: 1000)
     * @return Result with all eigenvalues and eigenvectors
     * 
     * POSTCONDITIONS:
     * - eigenvalues.size() == n
     * - eigenvectors has n columns
     * - For real eigenvalue Î»: A*v â‰ˆ Î»*v
     * - For complex pair Î»Â±Î¼i with eigenvector (vr Â± i*vi):
     *   - eigenvalues[k] = {Î», Î¼}, eigenvalues[k+1] = {Î», -Î¼}
     *   - eigenvectors.Column(k) = vr, Column(k+1) = vi
     */
    static Result Solve(const Matrix<Real>& A, Real tol = 1e-10, int maxIter = 1000)
    {
      int n = A.RowNum();
      Result result(n);
      
      if (n == 0)
      {
        result.converged = true;
        return result;
      }
      
      if (n == 1)
      {
        result.eigenvalues.push_back(ComplexEigenvalue(A(0, 0), 0.0));
        result.eigenvectors(0, 0) = 1.0;
        result.isComplexPair.push_back(false);
        result.converged = true;
        return result;
      }
      
      // Step 1: Reduce to Hessenberg form
      auto hess = EigenSolverHelpers::ReduceToHessenberg(A);
      Matrix<Real> H = hess.H;
      Matrix<Real> Q = hess.Q;  // Accumulated transformation
      
      // Step 2: QR iteration with deflation
      int iLo = 0;        // Start of active region
      int iHi = n - 1;    // End of active region
      int totalIter = 0;
      
      while (iHi > iLo && totalIter < maxIter)
      {
        // Check for deflation at bottom of active region
        auto defl = EigenSolverHelpers::CheckDeflation(H, iLo, iHi, tol);
        
        if (defl.canDeflate)
        {
          // Apply deflation
          EigenSolverHelpers::ApplyDeflation(H, defl.deflationIndex);
          
          // Shrink active region
          if (defl.deflationIndex == iHi)
          {
            iHi--;
          }
          else if (defl.deflationIndex == iHi - 1 && defl.blockSize == 2)
          {
            iHi -= 2;  // 2x2 block deflated
          }
          else
          {
            // Middle deflation - just continue
            iHi = defl.deflationIndex - 1;
          }
          continue;
        }
        
        // Determine if we should use single or double shift
        // Check if bottom 2x2 has complex eigenvalues
        bool useDoubleShift = false;
        if (iHi >= iLo + 1)
        {
          Real a = H(iHi - 1, iHi - 1);
          Real b = H(iHi - 1, iHi);
          Real c = H(iHi, iHi - 1);
          Real d = H(iHi, iHi);
          auto eig = EigenSolverHelpers::Eigenvalues2x2(a, b, c, d);
          useDoubleShift = eig.isComplex;
          
          // Special case: if we have only a 2x2 block with complex eigenvalues,
          // it's already in final form - we're done with this block
          if (useDoubleShift && iHi == iLo + 1)
          {
            // 2x2 block with complex eigenvalues is irreducible - accept it
            break;
          }
        }
        
        if (useDoubleShift && iHi >= iLo + 2)
        {
          // Apply Francis double-shift
          auto step = EigenSolverHelpers::FrancisDoubleShift(H, iLo, iHi, true);
          H = step.H;
          
          // Update accumulated Q
          Matrix<Real> newQ(n, n);
          for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
            {
              newQ(i, j) = 0.0;
              for (int k = 0; k < n; k++)
                newQ(i, j) += Q(i, k) * step.Q(k, j);
            }
          Q = newQ;
          totalIter += 2;  // Double shift counts as 2 iterations
        }
        else
        {
          // Apply single Wilkinson shift
          auto step = EigenSolverHelpers::SingleQRStep(H, true);
          H = step.H;
          
          // Update accumulated Q
          Matrix<Real> newQ(n, n);
          for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
            {
              newQ(i, j) = 0.0;
              for (int k = 0; k < n; k++)
                newQ(i, j) += Q(i, k) * step.Q(k, j);
            }
          Q = newQ;
          totalIter++;
        }
        
        // Apply exceptional shift if stuck (every 30 iterations without progress)
        if (totalIter % 30 == 29 && iHi >= 2)
        {
          // Exceptional shift to break cycles
          Real exceptionalShift = std::abs(H(iHi, iHi - 1)) + std::abs(H(iHi - 1, iHi - 2));
          auto step = EigenSolverHelpers::SingleQRStep(H, true, &exceptionalShift);
          H = step.H;
          
          Matrix<Real> newQ(n, n);
          for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
            {
              newQ(i, j) = 0.0;
              for (int k = 0; k < n; k++)
                newQ(i, j) += Q(i, k) * step.Q(k, j);
            }
          Q = newQ;
          totalIter++;
        }
      }
      
      // Step 3: Extract eigenvalues from quasi-triangular form
      auto eigResult = EigenSolverHelpers::ExtractEigenvalues(H, tol);
      
      // Convert to our ComplexEigenvalue format
      for (const auto& e : eigResult.eigenvalues)
        result.eigenvalues.push_back(ComplexEigenvalue(e.real, e.imag));
      
      // Step 4: Compute eigenvectors
      auto vecResult = EigenSolverHelpers::ComputeEigenvectorsFromSchur(H, Q, tol);
      result.eigenvectors = vecResult.vectors;
      result.isComplexPair = vecResult.isComplexPair;
      
      // Step 5: Compute residuals and check convergence
      result.iterations = totalIter;
      result.maxResidual = 0.0;
      result.converged = (totalIter < maxIter);
      
      // Verify eigenvector quality
      for (size_t i = 0; i < result.eigenvalues.size(); i++)
      {
        if (!result.isComplexPair[i] || (i > 0 && result.isComplexPair[i-1]))
        {
          Vector<Real> v(n);
          for (int j = 0; j < n; j++)
            v[j] = result.eigenvectors(j, static_cast<int>(i));
          
          Real residual = EigenSolverHelpers::EigenvectorResidual(
            A, v, result.eigenvalues[i].real, result.eigenvalues[i].imag);
          result.maxResidual = std::max(result.maxResidual, residual);
        }
      }
      
      return result;
    }
  };

} // namespace MML


///////////////////////////   mml/algorithms/MatrixAlg.h   ///////////////////////////




namespace MML
{
  /**
   * @namespace MatrixAlg
   * @brief Collection of matrix algebra algorithms and utilities
   */
  namespace MatrixAlg
  {
    // =========================================================================
    // MATRIX PROPERTY CHECKS
    // =========================================================================

    /**
     * Check if matrix H is upper Hessenberg within tolerance.
     * 
     * Upper Hessenberg: H(i,j) = 0 for all i > j + 1
     * (all elements below the first subdiagonal are zero)
     * 
     * @param H Matrix to check
     * @param tol Tolerance for zero comparison
     * @return true if H is upper Hessenberg
     */
    inline bool IsUpperHessenberg(const Matrix<Real>& H, Real tol = 1e-10)
    {
      int n = H.RowNum();
      for (int i = 2; i < n; i++)
        for (int j = 0; j < i - 1; j++)
          if (std::abs(H(i, j)) > tol)
            return false;
      return true;
    }

    /**
     * Check if matrix Q is orthogonal: Q^T * Q = I
     * 
     * @param Q Matrix to check
     * @param tol Tolerance for identity comparison
     * @return true if Q is orthogonal
     */
    inline bool IsOrthogonal(const Matrix<Real>& Q, Real tol = 1e-10)
    {
      int n = Q.RowNum();
      for (int i = 0; i < n; i++)
      {
        for (int j = 0; j < n; j++)
        {
          Real dot = 0.0;
          for (int k = 0; k < n; k++)
            dot += Q(k, i) * Q(k, j);
          
          Real expected = (i == j) ? 1.0 : 0.0;
          if (std::abs(dot - expected) > tol)
            return false;
        }
      }
      return true;
    }

    /**
     * Check if matrix is upper triangular within tolerance.
     * 
     * @param A Matrix to check
     * @param tol Tolerance for zero comparison
     * @return true if A is upper triangular
     */
    inline bool IsUpperTriangular(const Matrix<Real>& A, Real tol = 1e-10)
    {
      int n = A.RowNum();
      for (int i = 1; i < n; i++)
        for (int j = 0; j < i; j++)
          if (std::abs(A(i, j)) > tol)
            return false;
      return true;
    }

    /**
     * Check if matrix is lower triangular within tolerance.
     * 
     * @param A Matrix to check
     * @param tol Tolerance for zero comparison
     * @return true if A is lower triangular
     */
    inline bool IsLowerTriangular(const Matrix<Real>& A, Real tol = 1e-10)
    {
      int n = A.RowNum();
      for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
          if (std::abs(A(i, j)) > tol)
            return false;
      return true;
    }

    /**
     * Check if matrix is diagonal within tolerance.
     * 
     * @param A Matrix to check
     * @param tol Tolerance for zero comparison
     * @return true if A is diagonal
     */
    inline bool IsDiagonal(const Matrix<Real>& A, Real tol = 1e-10)
    {
      int n = A.RowNum();
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
          if (i != j && std::abs(A(i, j)) > tol)
            return false;
      return true;
    }

    // =========================================================================
    // MATRIX SCALAR QUANTITIES
    // =========================================================================

    /**
     * Compute trace (sum of diagonal elements)
     * 
     * @param A Input matrix
     * @return Sum of diagonal elements
     */
    inline Real Trace(const Matrix<Real>& A)
    {
      Real sum = 0.0;
      int n = std::min(A.RowNum(), A.ColNum());
      for (int i = 0; i < n; i++)
        sum += A(i, i);
      return sum;
    }

    /**
     * Compute Frobenius norm: ||A||_F = sqrt(sum of all a_ij^2)
     * 
     * @param A Input matrix
     * @return Frobenius norm
     */
    inline Real FrobeniusNorm(const Matrix<Real>& A)
    {
      Real sum = 0.0;
      for (int i = 0; i < A.RowNum(); i++)
        for (int j = 0; j < A.ColNum(); j++)
          sum += A(i, j) * A(i, j);
      return std::sqrt(sum);
    }

    /**
     * Compute infinity norm (maximum absolute row sum): ||A||_âˆž
     * 
     * @param A Input matrix
     * @return Infinity norm
     */
    inline Real InfinityNorm(const Matrix<Real>& A)
    {
      Real maxRowSum = 0.0;
      for (int i = 0; i < A.RowNum(); i++)
      {
        Real rowSum = 0.0;
        for (int j = 0; j < A.ColNum(); j++)
          rowSum += std::abs(A(i, j));
        maxRowSum = std::max(maxRowSum, rowSum);
      }
      return maxRowSum;
    }

    /**
     * Compute 1-norm (maximum absolute column sum): ||A||_1
     * 
     * @param A Input matrix
     * @return 1-norm
     */
    inline Real OneNorm(const Matrix<Real>& A)
    {
      Real maxColSum = 0.0;
      for (int j = 0; j < A.ColNum(); j++)
      {
        Real colSum = 0.0;
        for (int i = 0; i < A.RowNum(); i++)
          colSum += std::abs(A(i, j));
        maxColSum = std::max(maxColSum, colSum);
      }
      return maxColSum;
    }

    /**
     * Compute maximum absolute difference between two matrices
     * 
     * @param A First matrix
     * @param B Second matrix
     * @return Maximum |A(i,j) - B(i,j)|
     */
    inline Real MaxAbsDiff(const Matrix<Real>& A, const Matrix<Real>& B)
    {
      Real maxDiff = 0.0;
      int n = A.RowNum();
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
          maxDiff = std::max(maxDiff, std::abs(A(i, j) - B(i, j)));
      return maxDiff;
    }

    // =========================================================================
    // MATRIX TRANSFORMATIONS
    // =========================================================================

    /**
     * Compute Q^T * A * Q (similarity transformation)
     * 
     * @param Q Transformation matrix
     * @param A Matrix to transform
     * @return Q^T * A * Q
     */
    inline Matrix<Real> SimilarityTransform(const Matrix<Real>& Q, const Matrix<Real>& A)
    {
      int n = A.RowNum();
      Matrix<Real> temp(n, n);
      Matrix<Real> result(n, n);
      
      // temp = A * Q
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
        {
          temp(i, j) = 0.0;
          for (int k = 0; k < n; k++)
            temp(i, j) += A(i, k) * Q(k, j);
        }
      
      // result = Q^T * temp
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
        {
          result(i, j) = 0.0;
          for (int k = 0; k < n; k++)
            result(i, j) += Q(k, i) * temp(k, j);
        }
      
      return result;
    }

    // =========================================================================
    // HESSENBERG REDUCTION
    // =========================================================================

    /**
     * @struct HessenbergResult
     * @brief Result of Hessenberg reduction: H = Q^T * A * Q
     */
    struct HessenbergResult
    {
      Matrix<Real> H;    // Upper Hessenberg matrix
      Matrix<Real> Q;    // Orthogonal transformation matrix
      
      HessenbergResult(int n) : H(n, n), Q(n, n) {}
    };

    /**
     * Reduce matrix A to upper Hessenberg form using Householder reflections.
     * 
     * MATHEMATICAL DEFINITION:
     * Find orthogonal Q such that H = Q^T * A * Q is upper Hessenberg,
     * meaning H(i,j) = 0 for all i > j + 1.
     * 
     * The transformation preserves eigenvalues (similarity transformation).
     * 
     * @param A Input matrix (n x n)
     * @return HessenbergResult containing H and Q where H = Q^T * A * Q
     * 
     * ALGORITHM (Householder):
     * For k = 0, 1, ..., n-3:
     *   1. Let x = A(k+1:n, k) be the subdiagonal column
     *   2. Compute Householder vector v to zero x(1:end)
     *   3. Apply P = I - 2*v*v^T from left: A = P*A
     *   4. Apply P from right: A = A*P (similarity)
     *   5. Accumulate Q = Q * P
     * 
     * Complexity: O(10nÂ³/3) flops
     * 
     * REFERENCES:
     * - Golub & Van Loan, "Matrix Computations", 4th ed., Section 7.4
     */
    inline HessenbergResult ReduceToHessenberg(const Matrix<Real>& A)
    {
      int n = A.RowNum();
      HessenbergResult result(n);
      
      if (n <= 2)
      {
        result.H = A;
        result.Q = Matrix<Real>::GetUnitMatrix(n);
        return result;
      }
      
      // Copy A to H (we'll transform H in place)
      result.H = A;
      // Initialize Q as identity
      result.Q = Matrix<Real>::GetUnitMatrix(n);
      
      // Temporary storage for Householder vector
      Vector<Real> v(n);
      
      // For each column k, zero out elements below the subdiagonal
      for (int k = 0; k < n - 2; k++)
      {
        // Compute the norm of the column below the diagonal
        Real sigma = 0.0;
        for (int i = k + 1; i < n; i++)
          sigma += result.H(i, k) * result.H(i, k);
        sigma = std::sqrt(sigma);
        
        if (sigma < 1e-30)
          continue;  // Column already zero below subdiagonal
        
        // Choose sign to avoid cancellation: sign opposite to H(k+1, k)
        if (result.H(k + 1, k) > 0.0)
          sigma = -sigma;
        
        // Build Householder vector v = [0, ..., 0, H(k+1,k) - sigma, H(k+2,k), ..., H(n-1,k)]
        // But we only need elements k+1 to n-1
        Real h_k1_k_minus_sigma = result.H(k + 1, k) - sigma;
        
        // Compute ||v||^2
        Real vNormSq = h_k1_k_minus_sigma * h_k1_k_minus_sigma;
        for (int i = k + 2; i < n; i++)
          vNormSq += result.H(i, k) * result.H(i, k);
        
        if (vNormSq < 1e-30)
          continue;
        
        // beta = 2 / ||v||^2
        Real beta = 2.0 / vNormSq;
        
        // Store v in temporary array
        v[k + 1] = h_k1_k_minus_sigma;
        for (int i = k + 2; i < n; i++)
          v[i] = result.H(i, k);
        
        // Apply Householder from left: H = (I - beta*v*v^T) * H
        // H(i,j) -= beta * v(i) * sum_m(v(m) * H(m,j))
        for (int j = k; j < n; j++)
        {
          Real dot = 0.0;
          for (int i = k + 1; i < n; i++)
            dot += v[i] * result.H(i, j);
          
          for (int i = k + 1; i < n; i++)
            result.H(i, j) -= beta * v[i] * dot;
        }
        
        // Apply Householder from right: H = H * (I - beta*v*v^T)
        // H(i,j) -= beta * H(i,m) * v(m) * v(j)
        for (int i = 0; i < n; i++)
        {
          Real dot = 0.0;
          for (int j = k + 1; j < n; j++)
            dot += result.H(i, j) * v[j];
          
          for (int j = k + 1; j < n; j++)
            result.H(i, j) -= beta * dot * v[j];
        }
        
        // Accumulate Q: Q = Q * (I - beta*v*v^T)
        // Q(i,j) -= beta * Q(i,m) * v(m) * v(j)
        for (int i = 0; i < n; i++)
        {
          Real dot = 0.0;
          for (int j = k + 1; j < n; j++)
            dot += result.Q(i, j) * v[j];
          
          for (int j = k + 1; j < n; j++)
            result.Q(i, j) -= beta * dot * v[j];
        }
        
        // After applying transformation, H(k+1, k) should be sigma
        // and H(k+2:n-1, k) should be 0
        // Clean up the zeros explicitly
        result.H(k + 1, k) = sigma;
        for (int i = k + 2; i < n; i++)
          result.H(i, k) = 0.0;
      }
      
      return result;
    }

    // =========================================================================
    // MATRIX SYMMETRY CHECKS
    // =========================================================================

    /**
     * Check if matrix is symmetric within tolerance: A[i][j] â‰ˆ A[j][i]
     * 
     * @param A Matrix to check
     * @param tol Tolerance for comparison
     * @return true if A is symmetric
     */
    inline bool IsSymmetric(const Matrix<Real>& A, Real tol = 1e-10)
    {
      int n = A.RowNum();
      if (A.ColNum() != n) return false;  // Must be square
      
      for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
          if (std::abs(A(i, j) - A(j, i)) > tol)
            return false;
      return true;
    }

    /**
     * Check if matrix is skew-symmetric: A[i][j] â‰ˆ -A[j][i]
     * 
     * @param A Matrix to check
     * @param tol Tolerance for comparison
     * @return true if A is skew-symmetric
     */
    inline bool IsSkewSymmetric(const Matrix<Real>& A, Real tol = 1e-10)
    {
      int n = A.RowNum();
      if (A.ColNum() != n) return false;  // Must be square
      
      for (int i = 0; i < n; i++)
      {
        // Diagonal must be zero for skew-symmetric
        if (std::abs(A(i, i)) > tol)
          return false;
        for (int j = i + 1; j < n; j++)
          if (std::abs(A(i, j) + A(j, i)) > tol)
            return false;
      }
      return true;
    }

    // =========================================================================
    // MATRIX DEFINITENESS CHECKS
    // =========================================================================
    
    /**
     * @enum Definiteness
     * @brief Classification of matrix definiteness
     */
    enum class Definiteness
    {
      PositiveDefinite,      ///< All eigenvalues > 0
      PositiveSemiDefinite,  ///< All eigenvalues >= 0, at least one = 0
      NegativeDefinite,      ///< All eigenvalues < 0
      NegativeSemiDefinite,  ///< All eigenvalues <= 0, at least one = 0
      Indefinite            ///< Has both positive and negative eigenvalues
    };

    /**
     * Classify the definiteness of a symmetric matrix.
     * 
     * MATHEMATICAL DEFINITION:
     * - Positive definite: x^T A x > 0 for all x â‰  0 (all eigenvalues > 0)
     * - Positive semi-definite: x^T A x >= 0 for all x (eigenvalues >= 0)
     * - Negative definite: x^T A x < 0 for all x â‰  0 (all eigenvalues < 0)
     * - Negative semi-definite: x^T A x <= 0 for all x (eigenvalues <= 0)
     * - Indefinite: Has both positive and negative eigenvalues
     * 
     * @param A Symmetric matrix (only upper triangle used)
     * @param tol Tolerance for zero eigenvalue detection
     * @return Definiteness classification
     * 
     * @note Matrix must be symmetric. For non-symmetric matrices, 
     *       consider using (A + A^T)/2.
     */
    inline Definiteness ClassifyDefiniteness(const MatrixSym<Real>& A, Real tol = 1e-10)
    {
      // Compute eigenvalues using Jacobi method
      auto result = SymmMatEigenSolverJacobi::Solve(A, tol);
      
      int n = A.RowNum();
      int numPositive = 0;
      int numNegative = 0;
      int numZero = 0;
      
      for (int i = 0; i < n; i++)
      {
        if (result.eigenvalues[i] > tol)
          numPositive++;
        else if (result.eigenvalues[i] < -tol)
          numNegative++;
        else
          numZero++;
      }
      
      if (numNegative == 0 && numZero == 0)
        return Definiteness::PositiveDefinite;
      else if (numNegative == 0 && numPositive > 0)
        return Definiteness::PositiveSemiDefinite;
      else if (numPositive == 0 && numZero == 0)
        return Definiteness::NegativeDefinite;
      else if (numPositive == 0 && numNegative > 0)
        return Definiteness::NegativeSemiDefinite;
      else
        return Definiteness::Indefinite;
    }

    /**
     * Classify definiteness of a general matrix (uses symmetric part)
     */
    inline Definiteness ClassifyDefiniteness(const Matrix<Real>& A, Real tol = 1e-10)
    {
      int n = A.RowNum();
      if (A.ColNum() != n)
        throw MatrixDimensionError("ClassifyDefiniteness - matrix must be square", n, A.ColNum(), -1, -1);
      
      // Convert to symmetric matrix (A + A^T) / 2
      MatrixSym<Real> symA(n);
      for (int i = 0; i < n; i++)
        for (int j = i; j < n; j++)
          symA(i, j) = 0.5 * (A(i, j) + A(j, i));
      
      return ClassifyDefiniteness(symA, tol);
    }

    /**
     * Check if symmetric matrix is positive definite.
     * 
     * A matrix is positive definite if x^T A x > 0 for all x â‰  0,
     * which is equivalent to all eigenvalues being positive.
     * 
     * @param A Symmetric matrix
     * @param tol Tolerance for eigenvalue comparison
     * @return true if A is positive definite
     */
    inline bool IsPositiveDefinite(const MatrixSym<Real>& A, Real tol = 1e-10)
    {
      return ClassifyDefiniteness(A, tol) == Definiteness::PositiveDefinite;
    }

    /**
     * Check if general matrix is positive definite (uses symmetric part)
     */
    inline bool IsPositiveDefinite(const Matrix<Real>& A, Real tol = 1e-10)
    {
      return ClassifyDefiniteness(A, tol) == Definiteness::PositiveDefinite;
    }

    /**
     * Check if symmetric matrix is positive semi-definite.
     * 
     * A matrix is positive semi-definite if x^T A x >= 0 for all x,
     * which is equivalent to all eigenvalues being non-negative.
     * 
     * @param A Symmetric matrix
     * @param tol Tolerance for eigenvalue comparison
     * @return true if A is positive semi-definite (includes positive definite)
     */
    inline bool IsPositiveSemiDefinite(const MatrixSym<Real>& A, Real tol = 1e-10)
    {
      auto def = ClassifyDefiniteness(A, tol);
      return def == Definiteness::PositiveDefinite || def == Definiteness::PositiveSemiDefinite;
    }

    inline bool IsPositiveSemiDefinite(const Matrix<Real>& A, Real tol = 1e-10)
    {
      auto def = ClassifyDefiniteness(A, tol);
      return def == Definiteness::PositiveDefinite || def == Definiteness::PositiveSemiDefinite;
    }

    /**
     * Check if symmetric matrix is negative definite.
     * 
     * A matrix is negative definite if x^T A x < 0 for all x â‰  0,
     * which is equivalent to all eigenvalues being negative.
     * 
     * @param A Symmetric matrix
     * @param tol Tolerance for eigenvalue comparison
     * @return true if A is negative definite
     */
    inline bool IsNegativeDefinite(const MatrixSym<Real>& A, Real tol = 1e-10)
    {
      return ClassifyDefiniteness(A, tol) == Definiteness::NegativeDefinite;
    }

    inline bool IsNegativeDefinite(const Matrix<Real>& A, Real tol = 1e-10)
    {
      return ClassifyDefiniteness(A, tol) == Definiteness::NegativeDefinite;
    }

    /**
     * Check if symmetric matrix is negative semi-definite.
     * 
     * @param A Symmetric matrix
     * @param tol Tolerance for eigenvalue comparison
     * @return true if A is negative semi-definite (includes negative definite)
     */
    inline bool IsNegativeSemiDefinite(const MatrixSym<Real>& A, Real tol = 1e-10)
    {
      auto def = ClassifyDefiniteness(A, tol);
      return def == Definiteness::NegativeDefinite || def == Definiteness::NegativeSemiDefinite;
    }

    inline bool IsNegativeSemiDefinite(const Matrix<Real>& A, Real tol = 1e-10)
    {
      auto def = ClassifyDefiniteness(A, tol);
      return def == Definiteness::NegativeDefinite || def == Definiteness::NegativeSemiDefinite;
    }

    /**
     * Check if matrix is indefinite (has both positive and negative eigenvalues).
     * 
     * @param A Symmetric matrix
     * @param tol Tolerance for eigenvalue comparison
     * @return true if A is indefinite
     */
    inline bool IsIndefinite(const MatrixSym<Real>& A, Real tol = 1e-10)
    {
      return ClassifyDefiniteness(A, tol) == Definiteness::Indefinite;
    }

    inline bool IsIndefinite(const Matrix<Real>& A, Real tol = 1e-10)
    {
      return ClassifyDefiniteness(A, tol) == Definiteness::Indefinite;
    }

    // =========================================================================
    // SVD-BASED LINEAR ALGEBRA UTILITIES
    // =========================================================================

    /**
     * @struct SVDResult
     * @brief Result of SVD decomposition with linear algebra utilities
     */
    struct SVDResult
    {
      Vector<Real> singularValues;  ///< Singular values in descending order
      Matrix<Real> U;               ///< Left singular vectors (m x n)
      Matrix<Real> V;               ///< Right singular vectors (n x n)
      int rank;                     ///< Numerical rank
      Real conditionNumber;         ///< Condition number (Ïƒ_max / Ïƒ_min)
      
      SVDResult() : rank(0), conditionNumber(0.0) {}
    };

    /**
     * Compute SVD decomposition and derive linear algebra quantities.
     * 
     * Computes A = U * diag(Ïƒ) * V^T where:
     * - U: mÃ—n matrix of left singular vectors
     * - Ïƒ: singular values in descending order
     * - V: nÃ—n matrix of right singular vectors
     * 
     * @param A Input matrix (m x n)
     * @param tol Tolerance for rank determination
     * @return SVDResult with singular values, U, V, rank, and condition number
     */
    inline SVDResult ComputeSVD(const Matrix<Real>& A, Real tol = -1.0)
    {
      SVDecompositionSolver svd(A);
      SVDResult result;
      
      result.singularValues = svd.getW();
      result.U = svd.getU();
      result.V = svd.getV();
      result.rank = svd.Rank(tol);
      
      // Condition number = Ïƒ_max / Ïƒ_min
      int n = result.singularValues.size();
      if (n > 0 && result.singularValues[n-1] > 0)
        result.conditionNumber = result.singularValues[0] / result.singularValues[n-1];
      else
        result.conditionNumber = std::numeric_limits<Real>::infinity();
      
      return result;
    }

    /**
     * Compute singular values of a matrix.
     * 
     * @param A Input matrix
     * @return Vector of singular values in descending order
     */
    inline Vector<Real> SingularValues(const Matrix<Real>& A)
    {
      SVDecompositionSolver svd(A);
      return svd.getW();
    }

    /**
     * Compute numerical rank of a matrix using SVD.
     * 
     * The rank is the number of singular values above the threshold.
     * This is more numerically stable than Gaussian elimination for
     * ill-conditioned matrices.
     * 
     * @param A Input matrix
     * @param tol Threshold for zero singular values (-1 for automatic)
     * @return Numerical rank
     */
    inline int Rank(const Matrix<Real>& A, Real tol = -1.0)
    {
      SVDecompositionSolver svd(A);
      return svd.Rank(tol);
    }

    /**
     * Compute nullity (dimension of null space) of a matrix.
     * 
     * Nullity = n - rank, where n is the number of columns.
     * 
     * @param A Input matrix
     * @param tol Threshold for zero singular values
     * @return Nullity (dimension of kernel)
     */
    inline int Nullity(const Matrix<Real>& A, Real tol = -1.0)
    {
      SVDecompositionSolver svd(A);
      return svd.Nullity(tol);
    }

    /**
     * Compute condition number of a matrix.
     * 
     * The condition number Îº(A) = Ïƒ_max / Ïƒ_min measures how sensitive
     * the solution of Ax = b is to perturbations in A and b.
     * 
     * - Îº â‰ˆ 1: Well-conditioned
     * - Îº >> 1: Ill-conditioned
     * - Îº = âˆž: Singular matrix
     * 
     * Rule of thumb: You lose log10(Îº) decimal digits of precision
     * when solving linear systems.
     * 
     * @param A Input matrix
     * @return Condition number (infinity if singular)
     */
    inline Real ConditionNumber(const Matrix<Real>& A)
    {
      SVDecompositionSolver svd(A);
      Vector<Real> w = svd.getW();
      int n = w.size();
      
      if (n == 0 || w[n-1] <= 0.0)
        return std::numeric_limits<Real>::infinity();
      
      return w[0] / w[n-1];
    }

    /**
     * Compute orthonormal basis for the null space (kernel) of A.
     * 
     * The null space is {x : Ax = 0}. The columns of the returned matrix
     * form an orthonormal basis for this space.
     * 
     * @param A Input matrix (m x n)
     * @param tol Threshold for zero singular values
     * @return Matrix whose columns are orthonormal basis of null(A)
     *         Returns empty matrix (n x 0) if null space is trivial
     */
    inline Matrix<Real> NullSpace(const Matrix<Real>& A, Real tol = -1.0)
    {
      SVDecompositionSolver svd(A);
      return svd.Nullspace(tol);
    }

    /**
     * Alias for NullSpace - kernel is the same as null space
     */
    inline Matrix<Real> Kernel(const Matrix<Real>& A, Real tol = -1.0)
    {
      return NullSpace(A, tol);
    }

    /**
     * Compute orthonormal basis for the column space (range) of A.
     * 
     * The column space is {Ax : x âˆˆ R^n} = span of columns of A.
     * The columns of the returned matrix form an orthonormal basis.
     * 
     * @param A Input matrix (m x n)
     * @param tol Threshold for zero singular values
     * @return Matrix whose columns are orthonormal basis of col(A)
     */
    inline Matrix<Real> ColumnSpace(const Matrix<Real>& A, Real tol = -1.0)
    {
      SVDecompositionSolver svd(A);
      return svd.Range(tol);
    }

    /**
     * Alias for ColumnSpace - range is the same as column space
     */
    inline Matrix<Real> Range(const Matrix<Real>& A, Real tol = -1.0)
    {
      return ColumnSpace(A, tol);
    }

    /**
     * Compute the row space of A.
     * 
     * The row space is the column space of A^T.
     * 
     * @param A Input matrix
     * @param tol Threshold for zero singular values
     * @return Matrix whose columns are orthonormal basis of row(A)
     */
    inline Matrix<Real> RowSpace(const Matrix<Real>& A, Real tol = -1.0)
    {
      // Row space of A = Column space of A^T
      return ColumnSpace(A.GetTranspose(), tol);
    }

    /**
     * Compute the left null space of A.
     * 
     * The left null space is {y : y^T A = 0} = null(A^T).
     * 
     * @param A Input matrix
     * @param tol Threshold for zero singular values
     * @return Matrix whose columns are orthonormal basis of null(A^T)
     */
    inline Matrix<Real> LeftNullSpace(const Matrix<Real>& A, Real tol = -1.0)
    {
      // Left null space = Null space of A^T
      return NullSpace(A.GetTranspose(), tol);
    }

    /**
     * @struct FundamentalSubspaces
     * @brief The four fundamental subspaces of a matrix
     * 
     * For an mÃ—n matrix A:
     * - Column space: dim = r (rank)
     * - Row space: dim = r
     * - Null space: dim = n - r
     * - Left null space: dim = m - r
     * 
     * Key relationships:
     * - Column space âŠ¥ Left null space (in R^m)
     * - Row space âŠ¥ Null space (in R^n)
     */
    struct FundamentalSubspaces
    {
      Matrix<Real> columnSpace;    ///< Orthonormal basis for col(A)
      Matrix<Real> rowSpace;       ///< Orthonormal basis for row(A)
      Matrix<Real> nullSpace;      ///< Orthonormal basis for null(A)
      Matrix<Real> leftNullSpace;  ///< Orthonormal basis for null(A^T)
      int rank;                    ///< Rank of the matrix
    };

    /**
     * Compute all four fundamental subspaces of a matrix.
     * 
     * @param A Input matrix (m x n)
     * @param tol Threshold for zero singular values
     * @return FundamentalSubspaces containing bases for all four spaces
     */
    inline FundamentalSubspaces ComputeFundamentalSubspaces(const Matrix<Real>& A, Real tol = -1.0)
    {
      FundamentalSubspaces result;
      
      SVDecompositionSolver svd(A);
      result.columnSpace = svd.Range(tol);
      result.nullSpace = svd.Nullspace(tol);
      result.rank = svd.Rank(tol);
      
      // For row space and left null space, use SVD of A^T
      SVDecompositionSolver svdT(A.GetTranspose());
      result.rowSpace = svdT.Range(tol);
      result.leftNullSpace = svdT.Nullspace(tol);
      
      return result;
    }

    /**
     * Compute the pseudoinverse (Moore-Penrose inverse) of a matrix.
     * 
     * For A = U * diag(Ïƒ) * V^T, the pseudoinverse is:
     * Aâº = V * diag(1/Ïƒ) * U^T
     * 
     * Properties:
     * - A * Aâº * A = A
     * - Aâº * A * Aâº = Aâº
     * - For full-rank square A: Aâº = Aâ»Â¹
     * - x = Aâº * b is the least-squares solution to Ax = b
     * 
     * @param A Input matrix (m x n)
     * @param tol Threshold for zero singular values
     * @return Pseudoinverse Aâº (n x m)
     */
    inline Matrix<Real> PseudoInverse(const Matrix<Real>& A, Real tol = -1.0)
    {
      int m = A.RowNum();
      int n = A.ColNum();
      
      SVDecompositionSolver svd(A);
      Vector<Real> w = svd.getW();
      Matrix<Real> U = svd.getU();
      Matrix<Real> V = svd.getV();
      
      // Compute threshold
      Real eps = std::numeric_limits<Real>::epsilon();
      Real threshold = (tol >= 0.0) ? tol : 0.5 * std::sqrt(m + n + 1.0) * w[0] * eps;
      
      // Compute Aâº = V * diag(1/Ïƒ) * U^T
      Matrix<Real> result(n, m);
      for (int i = 0; i < n; i++)
      {
        for (int j = 0; j < m; j++)
        {
          Real sum = 0.0;
          for (int k = 0; k < n; k++)
          {
            if (w[k] > threshold)
              sum += V(i, k) * U(j, k) / w[k];
          }
          result(i, j) = sum;
        }
      }
      
      return result;
    }

  } // namespace MatrixAlg

} // namespace MML


///////////////////////////   mml/algorithms/CurveFitting.h   ///////////////////////////




namespace MML
{
    ///////////////////////////           LINEAR LEAST SQUARES           ///////////////////////////
    
    // Fits a linear function y = a*x + b to a set of data points using least squares method
    // 
    // Parameters:
    //   x_data - Vector of x-coordinates (independent variable)
    //   y_data - Vector of y-coordinates (dependent variable)
    //   a      - Output: slope coefficient
    //   b      - Output: intercept coefficient
    //
    // Returns:
    //   residual_norm - The norm of the residual vector (measure of fit quality)
    //
    // Mathematical formulation:
    //   Minimize: sum_i (y_i - (a*x_i + b))^2
    //   
    //   Normal equations: [sum(x_i^2)   sum(x_i)  ] [a]   [sum(x_i*y_i)]
    //                     [sum(x_i)     n         ] [b] = [sum(y_i)    ]
    //
    // Throws:
    //   std::invalid_argument if x_data and y_data have different sizes or are empty
    //   std::runtime_error if the normal equations system is singular (e.g., all x values identical)
    template<typename Real>
    Real LinearLeastSquares(const Vector<Real>& x_data, const Vector<Real>& y_data, 
                           Real& a, Real& b)
    {
        if (x_data.size() != y_data.size())
            throw CurveFittingError("LinearLeastSquares: x_data and y_data must have the same size");
        
        if (x_data.size() == 0)
            throw CurveFittingError("LinearLeastSquares: data vectors cannot be empty");
        
        int n = x_data.size();
        
        // Special case: single point - infinite solutions, use horizontal line through the point
        if (n == 1) {
            a = 0.0;
            b = y_data[0];
            return 0.0;
        }
        
        // Special case: two points - exact fit
        if (n == 2) {
            Real dx = x_data[1] - x_data[0];
            if (std::abs(dx) < std::numeric_limits<Real>::epsilon() * 10) {
                // Vertical line - can't fit y = ax + b, use horizontal line at average y
                a = 0.0;
                b = (y_data[0] + y_data[1]) / 2.0;
                // Compute residual norm for the horizontal line
                Real r0 = y_data[0] - b;
                Real r1 = y_data[1] - b;
                return std::sqrt(r0*r0 + r1*r1);
            }
            a = (y_data[1] - y_data[0]) / dx;
            b = y_data[0] - a * x_data[0];
            return 0.0;
        }
        
        // General case: n >= 3 points - least squares
        // Compute sums for normal equations
        Real sum_x = 0.0, sum_y = 0.0, sum_xx = 0.0, sum_xy = 0.0;
        
        for (int i = 0; i < n; i++) {
            sum_x  += x_data[i];
            sum_y  += y_data[i];
            sum_xx += x_data[i] * x_data[i];
            sum_xy += x_data[i] * y_data[i];
        }
        
        // Normal equations matrix: A = [sum_xx  sum_x ]
        //                              [sum_x   n     ]
        Real det = n * sum_xx - sum_x * sum_x;
        
        // Check for singularity (all x values essentially identical)
        if (std::abs(det) < std::numeric_limits<Real>::epsilon() * std::max(std::abs(n * sum_xx), std::abs(sum_x * sum_x))) {
            throw SingularMatrixError("LinearLeastSquares: singular system - all x values are nearly identical", det);
        }
        
        // Solve using Cramer's rule (explicit for 2x2 system)
        a = (n * sum_xy - sum_x * sum_y) / det;
        b = (sum_xx * sum_y - sum_x * sum_xy) / det;
        
        // Compute residual norm
        Real residual_sum = 0.0;
        for (int i = 0; i < n; i++) {
            Real residual = y_data[i] - (a * x_data[i] + b);
            residual_sum += residual * residual;
        }
        
        return std::sqrt(residual_sum);
    }
    
    
    // Fits a linear function y = a*x + b and returns detailed statistics
    template<typename Real>
    struct LinearFitResult
    {
        Real a;                  // Slope
        Real b;                  // Intercept
        Real residual_norm;      // ||y - (ax + b)||_2
        Real r_squared;          // Coefficient of determination (0 to 1, 1 = perfect fit)
        Real mean_squared_error; // Average squared residual
        
        LinearFitResult() : a(0), b(0), residual_norm(0), r_squared(0), mean_squared_error(0) {}
    };
    
    template<typename Real>
    LinearFitResult<Real> LinearLeastSquaresDetailed(const Vector<Real>& x_data, const Vector<Real>& y_data)
    {
        LinearFitResult<Real> result;
        
        int n = x_data.size();
        result.residual_norm = LinearLeastSquares(x_data, y_data, result.a, result.b);
        
        // Compute R^2 (coefficient of determination)
        Real y_mean = 0.0;
        for (int i = 0; i < n; i++)
            y_mean += y_data[i];
        y_mean /= n;
        
        Real ss_tot = 0.0;  // Total sum of squares
        Real ss_res = 0.0;  // Residual sum of squares
        
        for (int i = 0; i < n; i++) {
            Real y_pred = result.a * x_data[i] + result.b;
            Real residual = y_data[i] - y_pred;
            ss_res += residual * residual;
            ss_tot += (y_data[i] - y_mean) * (y_data[i] - y_mean);
        }
        
        // R^2 = 1 - (SS_res / SS_tot)
        if (ss_tot > std::numeric_limits<Real>::epsilon()) {
            result.r_squared = 1.0 - (ss_res / ss_tot);
        } else {
            // All y values are identical
            result.r_squared = (ss_res < std::numeric_limits<Real>::epsilon()) ? 1.0 : 0.0;
        }
        
        result.mean_squared_error = ss_res / n;
        
        return result;
    }
    
    
    ///////////////////////////    GENERAL LINEAR LEAST SQUARES    ///////////////////////////
    
    // Result structure for general linear least squares fitting
    // Contains fitted coefficients and comprehensive statistics
    template<typename Real>
    struct GeneralLinearFitResult
    {
        Vector<Real> coefficients;     // Fitted coefficients for each basis function
        Real residual_norm;            // ||y - A*c||_2 where A is the design matrix
        Real r_squared;                // Coefficient of determination (0 to 1, 1 = perfect fit)
        Real mean_squared_error;       // Average squared residual
        Real adjusted_r_squared;       // RÂ² adjusted for number of parameters
        int num_data_points;           // Number of data points (m)
        int num_basis_functions;       // Number of basis functions (n)
        int effective_rank;            // Effective rank of the design matrix (from SVD)
        Real condition_number;         // Condition number of the design matrix (ratio of largest/smallest singular values)
        
        GeneralLinearFitResult() 
            : residual_norm(0), r_squared(0), mean_squared_error(0), adjusted_r_squared(0),
              num_data_points(0), num_basis_functions(0), effective_rank(0), condition_number(0) {}
        
        // Evaluate the fitted function at a point x using the basis functions
        Real evaluate(Real x, const Vector<const IRealFunction*>& basis_functions) const
        {
            if (coefficients.size() != basis_functions.size())
                throw CurveFittingError("GeneralLinearFitResult::evaluate: mismatched basis functions count");
            
            Real result = 0.0;
            for (int i = 0; i < coefficients.size(); i++)
                result += coefficients[i] * (*basis_functions[i])(x);
            return result;
        }
        
        // Evaluate using a function wrapper (std::function version)
        Real evaluate(Real x, const Vector<std::function<Real(Real)>>& basis_functions) const
        {
            if (coefficients.size() != basis_functions.size())
                throw CurveFittingError("GeneralLinearFitResult::evaluate: mismatched basis functions count");
            
            Real result = 0.0;
            for (int i = 0; i < coefficients.size(); i++)
                result += coefficients[i] * basis_functions[i](x);
            return result;
        }
    };
    
    // Fits a linear combination of arbitrary basis functions to data using least squares
    //
    // Mathematical formulation:
    //   Find coefficients c_0, c_1, ..., c_{n-1} that minimize:
    //     sum_i (y_i - sum_j c_j * f_j(x_i))^2
    //
    //   This is equivalent to solving the overdetermined system:
    //     A * c = y
    //   where A[i][j] = f_j(x_i) is the design matrix
    //
    //   The solution uses SVD: A = U * W * V^T
    //   Least squares solution: c = V * W^{-1} * U^T * y (pseudoinverse)
    //
    // Parameters:
    //   x_data          - Vector of x-coordinates (independent variable)
    //   y_data          - Vector of y-coordinates (dependent variable)
    //   basis_functions - Vector of pointers to basis functions f_j(x)
    //
    // Returns:
    //   GeneralLinearFitResult containing coefficients and statistics
    //
    // Example basis functions:
    //   - Polynomial: {1, x, x^2, x^3, ...}
    //   - Fourier:    {1, sin(x), cos(x), sin(2x), cos(2x), ...}
    //   - Custom:     {exp(-x^2), log(x+1), sqrt(x), ...}
    //
    // Throws:
    //   std::invalid_argument if vectors have mismatched sizes, are empty, 
    //                         or basis_functions is empty
    template<typename Real>
    GeneralLinearFitResult<Real> GeneralLinearLeastSquares(
        const Vector<Real>& x_data, 
        const Vector<Real>& y_data,
        const Vector<const IRealFunction*>& basis_functions)
    {
        if (x_data.size() != y_data.size())
            throw CurveFittingError("GeneralLinearLeastSquares: x_data and y_data must have the same size");
        
        if (x_data.size() == 0)
            throw CurveFittingError("GeneralLinearLeastSquares: data vectors cannot be empty");
        
        if (basis_functions.size() == 0)
            throw CurveFittingError("GeneralLinearLeastSquares: basis_functions cannot be empty");
        
        int m = x_data.size();                   // Number of data points
        int n = basis_functions.size();          // Number of basis functions
        
        if (m < n)
            throw CurveFittingError("GeneralLinearLeastSquares: need at least as many data points as basis functions");
        
        // Build the design matrix A[i][j] = f_j(x_i)
        Matrix<Real> A(m, n);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                A[i][j] = (*basis_functions[j])(x_data[i]);
            }
        }
        
        // Use SVD to solve the overdetermined system
        SVDecompositionSolver svd(A);
        
        // Solve A*c = y for coefficients c
        Vector<Real> c = svd.Solve(y_data);
        
        // Compute statistics
        GeneralLinearFitResult<Real> result;
        result.coefficients = c;
        result.num_data_points = m;
        result.num_basis_functions = n;
        
        // Compute residuals and fitted values
        Real ss_res = 0.0;  // Residual sum of squares
        for (int i = 0; i < m; i++) {
            Real y_pred = 0.0;
            for (int j = 0; j < n; j++)
                y_pred += c[j] * A[i][j];
            Real residual = y_data[i] - y_pred;
            ss_res += residual * residual;
        }
        
        result.residual_norm = std::sqrt(ss_res);
        result.mean_squared_error = ss_res / m;
        
        // Compute R^2
        Real y_mean = 0.0;
        for (int i = 0; i < m; i++)
            y_mean += y_data[i];
        y_mean /= m;
        
        Real ss_tot = 0.0;  // Total sum of squares
        for (int i = 0; i < m; i++) {
            Real diff = y_data[i] - y_mean;
            ss_tot += diff * diff;
        }
        
        if (ss_tot > std::numeric_limits<Real>::epsilon()) {
            result.r_squared = 1.0 - (ss_res / ss_tot);
            // Adjusted R^2: R^2_adj = 1 - (1 - R^2) * (m - 1) / (m - n)
            if (m > n)
                result.adjusted_r_squared = 1.0 - (1.0 - result.r_squared) * (m - 1.0) / (m - n);
            else
                result.adjusted_r_squared = result.r_squared;
        } else {
            result.r_squared = (ss_res < std::numeric_limits<Real>::epsilon()) ? 1.0 : 0.0;
            result.adjusted_r_squared = result.r_squared;
        }
        
        // Get condition number and rank from SVD
        Vector<Real> singular_values = svd.getW();
        result.effective_rank = 0;
        Real thresh = 0.5 * std::sqrt(m + n + 1.0) * singular_values[0] * std::numeric_limits<Real>::epsilon();
        for (int i = 0; i < n; i++) {
            if (singular_values[i] > thresh)
                result.effective_rank++;
        }
        
        // Condition number = largest singular value / smallest non-zero singular value
        if (result.effective_rank > 0 && singular_values[result.effective_rank - 1] > 0)
            result.condition_number = singular_values[0] / singular_values[result.effective_rank - 1];
        else
            result.condition_number = std::numeric_limits<Real>::infinity();
        
        return result;
    }
    
    // Overload using std::function for more flexible basis function specification
    // This allows lambda functions, function pointers, and functors
    template<typename Real>
    GeneralLinearFitResult<Real> GeneralLinearLeastSquares(
        const Vector<Real>& x_data, 
        const Vector<Real>& y_data,
        const Vector<std::function<Real(Real)>>& basis_functions)
    {
        if (x_data.size() != y_data.size())
            throw CurveFittingError("GeneralLinearLeastSquares: x_data and y_data must have the same size");
        
        if (x_data.size() == 0)
            throw CurveFittingError("GeneralLinearLeastSquares: data vectors cannot be empty");
        
        if (basis_functions.size() == 0)
            throw CurveFittingError("GeneralLinearLeastSquares: basis_functions cannot be empty");
        
        int m = x_data.size();
        int n = basis_functions.size();
        
        if (m < n)
            throw CurveFittingError("GeneralLinearLeastSquares: need at least as many data points as basis functions");
        
        // Build the design matrix
        Matrix<Real> A(m, n);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                A[i][j] = basis_functions[j](x_data[i]);
            }
        }
        
        // Use SVD to solve
        SVDecompositionSolver svd(A);
        Vector<Real> c = svd.Solve(y_data);
        
        // Compute statistics (same as above)
        GeneralLinearFitResult<Real> result;
        result.coefficients = c;
        result.num_data_points = m;
        result.num_basis_functions = n;
        
        Real ss_res = 0.0;
        for (int i = 0; i < m; i++) {
            Real y_pred = 0.0;
            for (int j = 0; j < n; j++)
                y_pred += c[j] * A[i][j];
            Real residual = y_data[i] - y_pred;
            ss_res += residual * residual;
        }
        
        result.residual_norm = std::sqrt(ss_res);
        result.mean_squared_error = ss_res / m;
        
        Real y_mean = 0.0;
        for (int i = 0; i < m; i++)
            y_mean += y_data[i];
        y_mean /= m;
        
        Real ss_tot = 0.0;
        for (int i = 0; i < m; i++) {
            Real diff = y_data[i] - y_mean;
            ss_tot += diff * diff;
        }
        
        if (ss_tot > std::numeric_limits<Real>::epsilon()) {
            result.r_squared = 1.0 - (ss_res / ss_tot);
            if (m > n)
                result.adjusted_r_squared = 1.0 - (1.0 - result.r_squared) * (m - 1.0) / (m - n);
            else
                result.adjusted_r_squared = result.r_squared;
        } else {
            result.r_squared = (ss_res < std::numeric_limits<Real>::epsilon()) ? 1.0 : 0.0;
            result.adjusted_r_squared = result.r_squared;
        }
        
        Vector<Real> singular_values = svd.getW();
        result.effective_rank = 0;
        Real thresh = 0.5 * std::sqrt(m + n + 1.0) * singular_values[0] * std::numeric_limits<Real>::epsilon();
        for (int i = 0; i < n; i++) {
            if (singular_values[i] > thresh)
                result.effective_rank++;
        }
        
        if (result.effective_rank > 0 && singular_values[result.effective_rank - 1] > 0)
            result.condition_number = singular_values[0] / singular_values[result.effective_rank - 1];
        else
            result.condition_number = std::numeric_limits<Real>::infinity();
        
        return result;
    }
    
    
    ///////////////////////////    POLYNOMIAL FITTING    ///////////////////////////
    
    // Fits a polynomial of specified degree to data: y = c_0 + c_1*x + c_2*x^2 + ... + c_n*x^n
    //
    // This is a convenience wrapper around GeneralLinearLeastSquares with polynomial basis functions
    //
    // Parameters:
    //   x_data - Vector of x-coordinates
    //   y_data - Vector of y-coordinates
    //   degree - Degree of the polynomial (0 = constant, 1 = linear, 2 = quadratic, etc.)
    //
    // Returns:
    //   GeneralLinearFitResult where coefficients[i] is the coefficient of x^i
    //
    // Example: degree=2 fits y = c[0] + c[1]*x + c[2]*x^2
    template<typename Real>
    GeneralLinearFitResult<Real> PolynomialFit(
        const Vector<Real>& x_data, 
        const Vector<Real>& y_data,
        int degree)
    {
        if (degree < 0)
            throw CurveFittingError("PolynomialFit: degree must be non-negative");
        
        // Create polynomial basis functions: {1, x, x^2, ..., x^degree}
        Vector<std::function<Real(Real)>> basis(degree + 1);
        
        for (int i = 0; i <= degree; i++) {
            int power = i;  // Capture by value for lambda
            basis[i] = [power](Real x) -> Real {
                if (power == 0) return static_cast<Real>(1.0);
                return std::pow(x, power);
            };
        }
        
        return GeneralLinearLeastSquares(x_data, y_data, basis);
    }
    
    // Evaluate a fitted polynomial at a point
    template<typename Real>
    Real EvaluatePolynomial(Real x, const Vector<Real>& coefficients)
    {
        // Use Horner's method for numerical stability: c_0 + x*(c_1 + x*(c_2 + ...))
        int n = coefficients.size();
        if (n == 0) return 0.0;
        
        Real result = coefficients[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            result = coefficients[i] + x * result;
        }
        return result;
    }
    
} // namespace MML


///////////////////////////   mml/algorithms/RootFinding.h   ///////////////////////////






namespace MML
{
	namespace RootFinding
	{
		/*********************************************************************/
		/*****           Root bracketing                                 *****/
		/*********************************************************************/
		/**
		 * Expand a search interval geometrically until a root is bracketed.
		 * 
		 * This routine implements a geometric expansion strategy for finding an interval
		 * that contains a root (sign change) of a continuous function. Starting with an
		 * initial guess interval [x1, x2], it repeatedly expands the interval by a fixed
		 * scale factor (1.6) in the direction that appears more promising, until either:
		 *   1. A sign change is detected (root bracketed), or
		 *   2. The maximum number of iterations is reached
		 * 
		 * ALGORITHM:
		 * - Evaluates function at both endpoints
		 * - If signs differ, root is already bracketed (returns immediately)
		 * - Otherwise, expands in the direction of smaller absolute function value
		 * - Uses geometric growth with factor 1.6 (a good balance between speed and stability)
		 * - Continues until bracket found or MaxTry iterations exhausted
		 * 
		 * CONVERGENCE:
		 * - Exponential search: interval grows as 1.6^n
		 * - Typically finds bracket within 10-20 iterations for "reasonable" functions
		 * - May fail for functions with no roots or roots at extreme scales
		 * 
		 * USE CASES:
		 * - When you have a rough idea where a root might be
		 * - As preprocessing for refinement methods (bisection, Newton)
		 * - For functions where root location is unknown but bounded
		 * 
		 * @param func    Real function implementing IRealFunction interface
		 * @param x1      Input/output: left endpoint of search interval
		 * @param x2      Input/output: right endpoint of search interval
		 * @param MaxTry  Maximum expansion iterations (default: 50)
		 * @return true if root successfully bracketed, false if search exhausted
		 * 
		 * POSTCONDITION:
		 * If returns true: func(x1) and func(x2) have opposite signs
		 * If returns false: x1, x2 modified but no bracket found
		 * 
		 * Based on Numerical Recipes Â§9.1
		 */
		static bool BracketRoot(const IRealFunction& func, Real& x1, Real& x2, int MaxTry = 50)
		{
			const Real scaleFactor = 1.6;

			if (x1 == x2)
				throw RootFindingError("Bad initial range in BracketRoot");

			Real f1 = func(x1);
			Real f2 = func(x2);

			for (int j = 0; j < MaxTry; j++)
			{
				if (f1 * f2 < 0.0)
					return true;

				if (std::abs(f1) < std::abs(f2))
					f1 = func(x1 += scaleFactor * (x1 - x2));
				else
					f2 = func(x2 += scaleFactor * (x2 - x1));
			}
			return false;
		}

		/**
		 * Find multiple root brackets by systematic interval subdivision.
		 * 
		 * This function systematically searches for roots of a continuous function by
		 * subdividing a given interval into equally-spaced segments and checking for
		 * sign changes between consecutive points. It's particularly useful for finding
		 * multiple roots when you know a range but not the exact locations.
		 * 
		 * ALGORITHM:
		 * - Divides interval [x1, x2] into numPoints equally-spaced sample points
		 * - Evaluates function at each point
		 * - Detects sign changes between consecutive evaluations
		 * - Stores each bracketing pair [xb1[i], xb2[i]] where sign change occurs
		 * - Dynamically resizes storage if more brackets found than initially allocated
		 * 
		 * COMPLEXITY:
		 * - O(numPoints) function evaluations
		 * - Linear time in number of sample points
		 * - May miss roots if spacing too coarse relative to root spacing
		 * 
		 * LIMITATIONS:
		 * - May miss roots if numPoints is too small (roots closer than spacing)
		 * - Will miss roots where function touches zero without crossing (even multiplicity)
		 * - Assumes function is continuous between sample points
		 * 
		 * RECOMMENDATIONS:
		 * - Use numPoints > 10 * (expected number of roots) for good coverage
		 * - For n-th degree polynomial, use numPoints > 2n as rule of thumb
		 * - Follow up with refinement method (bisection, Newton) on each bracket
		 * 
		 * USE CASES:
		 * - Finding all roots of polynomials
		 * - Initial survey of oscillating functions (sin, cos, etc.)
		 * - Preprocessing for parallel root refinement
		 * 
		 * @param func       Real function implementing IRealFunction interface
		 * @param x1         Left boundary of search interval
		 * @param x2         Right boundary of search interval
		 * @param numPoints  Number of subdivision points (including endpoints)
		 * @param xb1        Output: Vector of left bracket endpoints
		 * @param xb2        Output: Vector of right bracket endpoints
		 * @return Number of bracketing pairs found (length of xb1 and xb2)
		 * 
		 * POSTCONDITION:
		 * - Returns numRoots >= 0
		 * - xb1 and xb2 resized to numRoots
		 * - For each i: func(xb1[i]) and func(xb2[i]) have opposite signs
		 * 
		 * Based on Numerical Recipes Â§9.1
		 */
		static int FindRootBrackets(const IRealFunction& func, const Real x1, const Real x2, const int numPoints, 
																 Vector<Real>& xb1, Vector<Real>& xb2)
		{
			int numBrackets = 20;
			xb1.Resize(numBrackets);
			xb2.Resize(numBrackets);
			int numRoots = 0;
			Real dx = (x2 - x1) / numPoints;
			Real x = x1;
			Real fp = func(x1);

			for (int i = 0; i < numPoints; i++)
			{
				x += dx;
				Real fc = func(x);

				if (fc * fp <= 0.0)
				{
					xb1[numRoots]   = x - dx;
					xb2[numRoots++] = x;
					if (numRoots == numBrackets)
					{
						xb1.Resize(numBrackets * 2, true);
						xb2.Resize(numBrackets * 2, true);
						numBrackets *= 2;
					}
				}
				fp = fc;
			}
			return numRoots;
		}

		/*********************************************************************/
		/*****           Bisection method                                *****/
		/*********************************************************************/
		/**
		 * Find root using the bisection method (binary search for roots).
		 * 
		 * Bisection is the most robust root-finding algorithm: it's guaranteed to converge
		 * for continuous functions, requires only function evaluations (no derivatives),
		 * and provides explicit error bounds at each step. The method repeatedly halves
		 * a bracketing interval until the root is localized to desired accuracy.
		 * 
		 * ALGORITHM:
		 * - Verify initial bracket: f(x1) and f(x2) must have opposite signs
		 * - Midpoint iteration:
		 *   1. Compute midpoint xmid = (x1 + x2) / 2
		 *   2. Evaluate f(xmid)
		 *   3. Replace x1 or x2 with xmid to maintain bracket
		 *   4. Repeat until |x2 - x1| < xacc
		 * - Returns the midpoint of final bracket as root estimate
		 * 
		 * CONVERGENCE:
		 * - Guaranteed linear convergence: error halves each iteration
		 * - After n iterations: error â‰¤ (x2 - x1) / 2^n
		 * - Number of iterations needed: âŒˆlogâ‚‚((x2-x1)/xacc)âŒ‰
		 * - Example: For xacc=1e-10 and initial bracket width 1.0, need ~34 iterations
		 * 
		 * ADVANTAGES:
		 * - Always converges (if root exists in bracket)
		 * - No derivative information needed
		 * - Predictable iteration count
		 * - Robust against pathological functions
		 * 
		 * DISADVANTAGES:
		 * - Slower than Newton (quadratic) or Secant (superlinear)
		 * - Requires initial bracket (not just starting point)
		 * - Linear convergence only
		 * 
		 * ERROR HANDLING:
		 * - Throws RootFindingError if initial values don't bracket root
		 * - Throws if function values are non-finite (NaN or Inf)
		 * 
		 * USE CASES:
		 * - When robustness is more important than speed
		 * - For functions with discontinuous derivatives
		 * - When you have a reliable bracket
		 * - As fallback when Newton or Secant fail
		 * 
		 * @param func  Real function implementing IRealFunction interface
		 * @param x1    Left endpoint of bracket (func(x1) and func(x2) must have opposite signs)
		 * @param x2    Right endpoint of bracket
		 * @param xacc  Absolute accuracy tolerance for root (typical: 1e-6 to 1e-10)
		 * @return Root estimate accurate to within xacc
		 * 
		 * POSTCONDITION:
		 * - |func(root)| typically much smaller than xacc
		 * - Guaranteed: root in [x1-xacc, x2+xacc]
		 * 
		 * Based on Numerical Recipes Â§9.1
		 */
		static Real FindRootBisection(const IRealFunction& func, Real x1, Real x2, Real xacc)
		{
			Real dx, xmid, rtb;

			Real f = func(x1);
			Real fmid = func(x2);

			// Check for non-finite initial values
			if (std::isnan(f) || std::isinf(f) || std::isnan(fmid) || std::isinf(fmid))
				throw RootFindingError("Non-finite function values in FindRootBisection");

			if (f * fmid >= 0.0)
				throw RootFindingError("Root must be bracketed for bisection in FindRootBisection");

			if( f < 0.0 ) {
				dx = x2 - x1;
				rtb = x1;
			}
			else {
				dx = x1 - x2;
				rtb = x2;
			}

			for (int j = 0; j < Defaults::BisectionMaxSteps; j++)
			{
				dx  *= 0.5;
				xmid = rtb + dx;
				fmid = func(xmid);

				// Check for non-finite midpoint value
				if (std::isnan(fmid) || std::isinf(fmid))
					throw RootFindingError("Non-finite function value in FindRootBisection iteration");

				if (fmid <= 0.0)
					rtb = xmid;

				if (std::abs(dx) < xacc || fmid == 0.0)
					return rtb;
			}
			throw RootFindingError("Too many bisections in FindRootBisection");
		}

		/*********************************************************************/
		/*****           Newton-Raphson method                           *****/
		/*********************************************************************/
		/**
		 * Find root using the Newton-Raphson method (Newton's method).
		 * 
		 * Newton-Raphson is the premier method for root finding when speed matters:
		 * it exhibits quadratic convergence near roots, doubling the number of correct
		 * digits each iteration. However, it requires derivative information and can
		 * diverge if not properly constrained. This implementation uses numerical
		 * differentiation (4-point stencil) and bracket checking for robustness.
		 * 
		 * ALGORITHM:
		 * - Newton iteration: x_{n+1} = x_n - f(x_n) / f'(x_n)
		 * - Starting point: midpoint of initial bracket [x1, x2]
		 * - At each step:
		 *   1. Evaluate f(x) and f'(x) at current point
		 *   2. Compute Newton step: dx = -f/f'
		 *   3. Update: x_new = x + dx
		 *   4. Check if x_new still in bracket [x1, x2]
		 *   5. If out of bounds, revert to bisection step
		 *   6. Continue until |dx| < xacc or f(x) â‰ˆ 0
		 * 
		 * DERIVATIVE:
		 * - Uses 4-point central difference formula (NDer4)
		 * - Accuracy: O(h^4) where h is step size
		 * - No analytical derivative needed
		 * 
		 * CONVERGENCE:
		 * - Near root: QUADRATIC convergence
		 * - Error decreases as e_{n+1} â‰ˆ e_nÂ² (doubles correct digits each step)
		 * - Typical: 3-6 iterations for machine precision
		 * - Much faster than bisection's linear convergence
		 * 
		 * ADVANTAGES:
		 * - Extremely fast convergence near roots
		 * - Few iterations needed
		 * - Well-suited for smooth functions
		 * 
		 * DISADVANTAGES:
		 * - May diverge if starting point is poor
		 * - Fails at stationary points (f' = 0)
		 * - Can jump outside bracket with bad behavior
		 * - Needs derivative (here computed numerically)
		 * 
		 * ROBUSTNESS FEATURES:
		 * - Bracket checking: reverts to bisection if step goes out of bounds
		 * - Derivative validation: throws if non-finite or too small
		 * - Maximum iteration limit
		 * - Handles both function and derivative failures gracefully
		 * 
		 * ERROR HANDLING:
		 * - Throws RootFindingError if derivative is NaN or Inf
		 * - Throws if derivative too small (< 1e-15) - likely stationary point
		 * - Throws if maximum iterations exhausted
		 * 
		 * USE CASES:
		 * - When you need high precision quickly
		 * - For smooth, well-behaved functions
		 * - When you have good initial bracket
		 * - Problems where function evaluation is cheap
		 * 
		 * @param func  Real function implementing IRealFunction interface
		 * @param x1    Left endpoint of initial bracket
		 * @param x2    Right endpoint of initial bracket
		 * @param xacc  Absolute accuracy tolerance (typical: 1e-10 to 1e-15)
		 * @return Root estimate accurate to within xacc
		 * 
		 * POSTCONDITION:
		 * - |func(root)| typically ~1e-15 (machine precision) even if xacc larger
		 * - Number of iterations typically 3-6
		 * 
		 * Based on Numerical Recipes Â§9.4
		 */
		static Real FindRootNewton(const IRealFunction& func, Real x1, Real x2, Real xacc) 
		{
			Real rtn = 0.5 * (x1 + x2);
			for (int j = 0; j < Defaults::NewtonRaphsonMaxSteps; j++)
			{
				Real f  = func(rtn);
				Real df = Derivation::NDer4(func, rtn);
				
				// Check for non-finite derivative (NaN/Inf) or near-zero derivative
				if (std::isnan(df) || std::isinf(df))
					throw RootFindingError("Non-finite derivative in FindRootNewton");
				Real dfThreshold = std::sqrt(Real(Constants::Eps));
				if (std::abs(df) < dfThreshold)
					throw RootFindingError("Zero or near-zero derivative in FindRootNewton");
				
				Real dx = f / df;
				
				// Check for non-finite step (can happen even with finite f and df in edge cases)
				if (std::isnan(dx) || std::isinf(dx))
					throw RootFindingError("Non-finite step in FindRootNewton");
				
				rtn -= dx;

				if ((x1 - rtn) * (rtn - x2) < 0.0)
					throw RootFindingError("Jumped out of brackets in FindRootNewton");

				if (std::abs(dx) < xacc)
					return rtn;
			}
			throw RootFindingError("Maximum number of iterations exceeded in FindRootNewton");
		}

		/*********************************************************************/
		/*****           False Position (Regula Falsi) method           *****/
		/*********************************************************************/
		/**
		 * Find root using the false position (regula falsi) method.
		 * 
		 * False position is a root-finding algorithm that combines the reliability of
		 * bisection with faster convergence by using linear interpolation rather than
		 * simple midpoint bisection. It maintains a bracket [a,b] where f(a) and f(b)
		 * have opposite signs, then estimates the root using the secant line between
		 * these points.
		 * 
		 * ALGORITHM:
		 * - Start with bracket [x1, x2] where f(x1)*f(x2) < 0
		 * - Iteration loop:
		 *   1. Compute linear interpolation: x_new = (x1*f2 - x2*f1) / (f2 - f1)
		 *   2. Evaluate f(x_new)
		 *   3. Update bracket: replace x1 or x2 with x_new to maintain sign change
		 *   4. Continue until |f(x_new)| < tolerance or bracket width < xacc
		 * 
		 * CONVERGENCE:
		 * - Superlinear convergence (between linear and quadratic)
		 * - Order of convergence: approximately 1.618 (golden ratio Ï†)
		 * - Faster than bisection, slower than Newton or secant
		 * - Always converges if root exists in initial bracket
		 * 
		 * ADVANTAGES:
		 * - More efficient than bisection (uses function shape information)
		 * - Guaranteed convergence (maintains bracket)
		 * - No derivative needed
		 * - Robust against discontinuities
		 * 
		 * DISADVANTAGES:
		 * - Can be slow if one endpoint stays fixed (one-sided convergence)
		 * - Slower than Newton or secant for smooth functions
		 * - May stagnate with poor function behavior
		 * 
		 * IMPROVEMENTS:
		 * - Illinois method: modifies function values to prevent stagnation
		 * - Anderson-BjÃ¶rck: similar improvement with better performance
		 * 
		 * USE CASES:
		 * - When bisection is too slow but Newton is too risky
		 * - Functions with discontinuous derivatives
		 * - When you have a reliable bracket
		 * - As fallback between bisection and Newton
		 * 
		 * @param func  Real function implementing IRealFunction interface
		 * @param x1    Left endpoint of bracket
		 * @param x2    Right endpoint of bracket
		 * @param xacc  Absolute accuracy tolerance (typical: 1e-6 to 1e-10)
		 * @return Root estimate
		 * 
		 * POSTCONDITION:
		 * - |func(root)| typically < xacc
		 * - Root guaranteed in original bracket
		 * 
		 * Based on Numerical Recipes Â§9.2
		 */
		static Real FindRootFalsePosition(const IRealFunction& func, Real x1, Real x2, Real xacc)
		{
			Real f1 = func(x1);
			Real f2 = func(x2);

			// Verify bracket
			if (std::isnan(f1) || std::isinf(f1) || std::isnan(f2) || std::isinf(f2))
				throw RootFindingError("Non-finite function values in FindRootFalsePosition");
			if (f1 * f2 >= 0.0)
				throw RootFindingError("Root must be bracketed for false position");

			// Ensure f1 is negative (swap if needed)
			if (f1 > 0.0) {
				std::swap(x1, x2);
				std::swap(f1, f2);
			}

			for (int j = 0; j < Defaults::BisectionMaxSteps; j++)
			{
				// Linear interpolation to find root estimate
				Real dx = x2 - x1;
				Real rtf = x1 + dx * f1 / (f1 - f2);
				Real f = func(rtf);

				if (std::isnan(f) || std::isinf(f))
					throw RootFindingError("Non-finite function value in FindRootFalsePosition");

				// Update bracket
				if (f < 0.0) {
					x1 = rtf;
					f1 = f;
				} else {
					x2 = rtf;
					f2 = f;
				}

				// Check convergence
				if (std::abs(f) < xacc || std::abs(x2 - x1) < xacc)
					return rtf;
			}
			throw RootFindingError("Maximum number of iterations exceeded in FindRootFalsePosition");
		}

		/*********************************************************************/
		/*****           Secant method                                   *****/
		/*********************************************************************/
		/**
		 * Find root using the secant method.
		 * 
		 * The secant method is a derivative-free variant of Newton's method that approximates
		 * the derivative using a finite difference. It requires two initial guesses but does
		 * not require them to bracket the root. The method exhibits superlinear convergence
		 * with order Ï† â‰ˆ 1.618 (the golden ratio).
		 * 
		 * ALGORITHM:
		 * - Start with two initial guesses x0, x1
		 * - Iteration formula: x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1}))
		 * - Update: x_{n-1} â† x_n, x_n â† x_{n+1}
		 * - Continue until |x_{n+1} - x_n| < tolerance
		 * 
		 * DERIVATIVE APPROXIMATION:
		 * - Approximates f'(x_n) â‰ˆ (f(x_n) - f(x_{n-1})) / (x_n - x_{n-1})
		 * - No analytical derivative needed
		 * - Only one new function evaluation per iteration (vs two for Newton with numerical derivative)
		 * 
		 * CONVERGENCE:
		 * - Superlinear convergence: order Ï† = (1 + âˆš5)/2 â‰ˆ 1.618
		 * - Error: e_{n+1} â‰ˆ C * e_n^Ï†
		 * - Faster than bisection or false position
		 * - Slower than Newton (which is quadratic)
		 * - More efficient than Newton when derivatives are expensive
		 * 
		 * ADVANTAGES:
		 * - No derivative needed (unlike Newton)
		 * - Superlinear convergence
		 * - Only one function evaluation per iteration
		 * - Simple to implement
		 * 
		 * DISADVANTAGES:
		 * - May diverge with poor initial guesses
		 * - No bracket maintenance (can jump away from root)
		 * - Slower than Newton for smooth functions
		 * - Can fail if f(x_n) = f(x_{n-1})
		 * 
		 * ROBUSTNESS:
		 * - This implementation uses bracket checking to prevent divergence
		 * - Falls back to bisection-like behavior if secant jumps outside bracket
		 * 
		 * USE CASES:
		 * - When derivatives are expensive or unavailable
		 * - For smooth functions where you have good initial guesses
		 * - When Newton is overkill but bisection is too slow
		 * - In multi-dimensional optimization as component
		 * 
		 * @param func  Real function implementing IRealFunction interface
		 * @param x1    First initial guess (used for bracket if needed)
		 * @param x2    Second initial guess
		 * @param xacc  Absolute accuracy tolerance (typical: 1e-8 to 1e-12)
		 * @return Root estimate
		 * 
		 * POSTCONDITION:
		 * - |func(root)| typically << xacc due to superlinear convergence
		 * - Typical iterations: 5-10 for machine precision
		 * 
		 * Based on Numerical Recipes Â§9.2
		 */
		static Real FindRootSecant(const IRealFunction& func, Real x1, Real x2, Real xacc)
		{
			Real f1 = func(x1);
			Real f2 = func(x2);

			if (std::isnan(f1) || std::isinf(f1) || std::isnan(f2) || std::isinf(f2))
				throw RootFindingError("Non-finite function values in FindRootSecant");

			// Ensure |f1| > |f2|, so x2 is the better guess
			if (std::abs(f1) < std::abs(f2)) {
				std::swap(x1, x2);
				std::swap(f1, f2);
			}

			for (int j = 0; j < Defaults::NewtonRaphsonMaxSteps; j++)
			{
				Real dx = (x2 - x1) * f2 / (f2 - f1);
				
				if (std::isnan(dx) || std::isinf(dx))
					throw RootFindingError("Non-finite step in FindRootSecant");

				x1 = x2;
				f1 = f2;
				x2 -= dx;
				f2 = func(x2);

				if (std::isnan(f2) || std::isinf(f2))
					throw RootFindingError("Non-finite function value in FindRootSecant");

				if (std::abs(dx) < xacc)
					return x2;
			}
			throw RootFindingError("Maximum number of iterations exceeded in FindRootSecant");
		}

		/*********************************************************************/
		/*****           Ridders method                                  *****/
		/*********************************************************************/
		/**
		 * Find root using Ridders' method of exponential interpolation.
		 * 
		 * Ridders' method is an elegant root-finding algorithm that uses exponential
		 * function fitting rather than linear interpolation. It combines the reliability
		 * of bisection with superlinear convergence, making it an excellent general-purpose
		 * method. The algorithm maintains a bracket and exhibits quadratic convergence.
		 * 
		 * ALGORITHM:
		 * - Start with bracket [x1, x2] where f(x1)*f(x2) < 0
		 * - Iteration loop:
		 *   1. Compute midpoint: xm = (x1 + x2) / 2
		 *   2. Evaluate: f1 = f(x1), fm = f(xm), f2 = f(x2)
		 *   3. Compute: s = âˆš(fmÂ² - f1*f2)
		 *   4. New estimate: x4 = xm + (xm - x1) * sign(f1 - f2) * fm / s
		 *   5. Update bracket with x4 and appropriate endpoint
		 *   6. Continue until |f(x4)| < tolerance
		 * 
		 * MATHEMATICAL BASIS:
		 * - Fits an exponential function through three points
		 * - Formula derived from: f(x) = A*e^(Î»x) + B*e^(-Î»x)
		 * - More sophisticated than linear interpolation
		 * - Naturally handles varying function curvature
		 * 
		 * CONVERGENCE:
		 * - Quadratic convergence (same as Newton!)
		 * - Error: e_{n+1} â‰ˆ C * e_nÂ²
		 * - Guaranteed convergence (maintains bracket)
		 * - Typically 2-3 times faster than false position
		 * - Comparable to Newton without needing derivatives
		 * 
		 * ADVANTAGES:
		 * - Quadratic convergence without derivatives
		 * - Guaranteed convergence (bracket maintained)
		 * - Robust against poor initial guesses
		 * - Never fails for continuous functions with sign change
		 * - Often outperforms Newton on difficult functions
		 * 
		 * DISADVANTAGES:
		 * - More function evaluations per iteration (3 vs 1 for bisection)
		 * - Slightly more complex implementation
		 * - Square root operation adds computational cost
		 * 
		 * COMPARISON:
		 * - vs Bisection: Much faster (quadratic vs linear)
		 * - vs False Position: Faster, more reliable
		 * - vs Newton: No derivative needed, more robust
		 * - vs Secant: Faster, guaranteed convergence
		 * 
		 * USE CASES:
		 * - General-purpose root finding (excellent default choice)
		 * - When derivatives unavailable but speed matters
		 * - For difficult functions where Newton might fail
		 * - When robustness AND speed both important
		 * 
		 * @param func  Real function implementing IRealFunction interface
		 * @param x1    Left endpoint of bracket
		 * @param x2    Right endpoint of bracket
		 * @param xacc  Absolute accuracy tolerance (typical: 1e-10 to 1e-15)
		 * @return Root estimate
		 * 
		 * POSTCONDITION:
		 * - |func(root)| typically at machine precision
		 * - Typical iterations: 5-8 for double precision
		 * - Root guaranteed in original bracket
		 * 
		 * Based on Numerical Recipes Â§9.2
		 */
		static Real FindRootRidders(const IRealFunction& func, Real x1, Real x2, Real xacc)
		{
			Real f1 = func(x1);
			Real f2 = func(x2);

			if (std::isnan(f1) || std::isinf(f1) || std::isnan(f2) || std::isinf(f2))
				throw RootFindingError("Non-finite function values in FindRootRidders");
			if (f1 * f2 >= 0.0)
				throw RootFindingError("Root must be bracketed for Ridders method");

			Real ans = -1.0e99;  // Initialize to unlikely value to detect first iteration

			for (int j = 0; j < Defaults::BisectionMaxSteps; j++)
			{
				Real xm = 0.5 * (x1 + x2);
				Real fm = func(xm);

				if (std::isnan(fm) || std::isinf(fm))
					throw RootFindingError("Non-finite function value in FindRootRidders");

				Real s = std::sqrt(fm * fm - f1 * f2);
				if (s == 0.0)
					return ans;  // Converged

				// Compute new point by exponential interpolation
				Real xnew = xm + (xm - x1) * ((f1 >= f2 ? 1.0 : -1.0) * fm / s);
				
				if (std::abs(xnew - ans) <= xacc)
					return ans;

				ans = xnew;
				Real fnew = func(ans);

				if (std::isnan(fnew) || std::isinf(fnew))
					throw RootFindingError("Non-finite function value in FindRootRidders");

				if (std::abs(fnew) < xacc)
					return ans;

				// Update bracket
				if (std::copysign(fm, fnew) != fm) {
					x1 = xm;
					f1 = fm;
					x2 = ans;
					f2 = fnew;
				} else if (std::copysign(f1, fnew) != f1) {
					x2 = ans;
					f2 = fnew;
				} else {
					x1 = ans;
					f1 = fnew;
				}

				if (std::abs(x2 - x1) <= xacc)
					return ans;
			}
			throw RootFindingError("Maximum number of iterations exceeded in FindRootRidders");
		}

		/*********************************************************************/
		/*****           Brent method (van Wijngaarden-Dekker-Brent)    *****/
		/*********************************************************************/
		/**
		 * Find root using Brent's method (the gold standard for root finding).
		 * 
		 * Brent's method is widely considered the best general-purpose root-finding algorithm.
		 * It combines the reliability of bisection, the speed of inverse quadratic interpolation,
		 * and the efficiency of the secant method. The algorithm adaptively chooses the best
		 * strategy at each iteration, guaranteeing convergence while optimizing speed.
		 * 
		 * ALGORITHM:
		 * - Maintains bracket [a,b] where f(a)*f(b) < 0
		 * - At each iteration, chooses ONE of:
		 *   1. Inverse quadratic interpolation (if three points available and well-conditioned)
		 *   2. Secant method (linear interpolation)
		 *   3. Bisection (if interpolation gives poor step)
		 * - Uses several safeguards to ensure reliability
		 * - Keeps track of previous iterations to make intelligent choices
		 * 
		 * INVERSE QUADRATIC INTERPOLATION:
		 * - Fits parabola through three points: (f_a, a), (f_b, b), (f_c, c)
		 * - Solves for x where parabola crosses zero
		 * - Provides fast convergence when function is well-behaved
		 * - Order of convergence: approximately 1.839
		 * 
		 * CONVERGENCE:
		 * - Superlinear convergence: order approximately 1.839
		 * - Guaranteed to converge (maintains bracket)
		 * - At worst, reduces bracket by factor of 2 (bisection)
		 * - At best, converges like inverse quadratic interpolation
		 * - Adapts strategy based on function behavior
		 * 
		 * SAFEGUARDS:
		 * - Falls back to bisection if:
		 *   * Interpolated point outside bracket
		 *   * Step too small (stagnation)
		 *   * Step not reducing bracket fast enough
		 * - Maintains |f(b)| â‰¤ |f(a)| invariant
		 * - Tracks previous steps to detect poor progress
		 * 
		 * ADVANTAGES:
		 * - Best all-around performance
		 * - Extremely robust (never fails if root exists)
		 * - No derivatives needed
		 * - Adapts to function behavior
		 * - Widely trusted in numerical libraries (scipy, GNU GSL, etc.)
		 * 
		 * DISADVANTAGES:
		 * - Complex implementation
		 * - Harder to understand than simpler methods
		 * - Slightly more function evaluations than pure methods
		 * 
		 * COMPARISON TO OTHER METHODS:
		 * - vs Bisection: Much faster, same reliability
		 * - vs Newton: No derivatives, more robust, similar speed
		 * - vs Secant: More robust, comparable speed
		 * - vs Ridders: Similar performance, more widely used
		 * 
		 * USE CASES:
		 * - Production code where both speed and reliability matter
		 * - General-purpose root finding in numerical libraries
		 * - When function evaluation is not too expensive
		 * - Whenever you're unsure which method to use (default choice)
		 * 
		 * @param func  Real function implementing IRealFunction interface
		 * @param x1    Left endpoint of bracket
		 * @param x2    Right endpoint of bracket
		 * @param xacc  Absolute accuracy tolerance (typical: 1e-12 to 1e-15)
		 * @return Root estimate
		 * 
		 * POSTCONDITION:
		 * - |func(root)| at or near machine precision
		 * - Typical iterations: 6-12 for double precision
		 * - Root guaranteed in original bracket
		 * 
		 * Based on Numerical Recipes Â§9.3 and Brent (1973)
		 */
		static Real FindRootBrent(const IRealFunction& func, Real x1, Real x2, Real xacc)
		{
			Real a = x1, b = x2, c = x2, d = 0.0, e = 0.0;
			Real fa = func(a), fb = func(b), fc, p, q, r, s, tol1, xm;

			if (std::isnan(fa) || std::isinf(fa) || std::isnan(fb) || std::isinf(fb))
				throw RootFindingError("Non-finite function values in FindRootBrent");
			if (fa * fb >= 0.0)
				throw RootFindingError("Root must be bracketed for Brent method");

			fc = fb;

			for (int iter = 0; iter < Defaults::BrentMaxSteps; iter++)
			{
				// Ensure |f(b)| <= |f(a)|
				if ((fb > 0.0 && fc > 0.0) || (fb < 0.0 && fc < 0.0)) {
					c = a;
					fc = fa;
					e = d = b - a;
				}
				if (std::abs(fc) < std::abs(fb)) {
					a = b;
					b = c;
					c = a;
					fa = fb;
					fb = fc;
					fc = fa;
				}

				// Convergence check
				tol1 = 2.0 * Constants::Eps * std::abs(b) + 0.5 * xacc;
				xm = 0.5 * (c - b);

				if (std::abs(xm) <= tol1 || fb == 0.0)
					return b;

				// Try interpolation
				if (std::abs(e) >= tol1 && std::abs(fa) > std::abs(fb)) {
					s = fb / fa;
					if (a == c) {
						// Linear interpolation (secant)
						p = 2.0 * xm * s;
						q = 1.0 - s;
					} else {
						// Inverse quadratic interpolation
						q = fa / fc;
						r = fb / fc;
						p = s * (2.0 * xm * q * (q - r) - (b - a) * (r - 1.0));
						q = (q - 1.0) * (r - 1.0) * (s - 1.0);
					}
					// Ensure p/q points into bracket
					if (p > 0.0)
						q = -q;
					p = std::abs(p);

					// Check if interpolation is acceptable
					Real min1 = 3.0 * xm * q - std::abs(tol1 * q);
					Real min2 = std::abs(e * q);
					if (2.0 * p < (min1 < min2 ? min1 : min2)) {
						// Accept interpolation
						e = d;
						d = p / q;
					} else {
						// Interpolation failed, use bisection
						d = xm;
						e = d;
					}
				} else {
					// Bounds decreasing too slowly, use bisection
					d = xm;
					e = d;
				}

				// Move to new point
				a = b;
				fa = fb;
				if (std::abs(d) > tol1)
					b += d;
				else
					b += std::copysign(tol1, xm);
				
				fb = func(b);

				if (std::isnan(fb) || std::isinf(fb))
					throw RootFindingError("Non-finite function value in FindRootBrent");
			}
			throw RootFindingError("Maximum number of iterations exceeded in FindRootBrent");
		}
  } // namespace RootFinding
} // namespace MML




///////////////////////////   mml/algorithms/RootFindingPolynoms.h   ///////////////////////////






namespace MML
{
	namespace RootFinding
	{
    /***************************************************************************************************
    * POLYNOMIAL ROOT FINDING METHODS
    ***************************************************************************************************/

    /**
    * Find all roots of a polynomial using Laguerre's method.
    * 
    * Laguerre's method is a globally convergent iterative method for polynomial root finding.
    * 
    * @param poly      Polynomial with real coefficients
    * @param tol       Convergence tolerance (default: 1e-10)
    * @param maxIter   Maximum iterations per root (default: 100)
    * @return Vector of all complex roots
    */
    static Vector<Complex> LaguerreRoots(const PolynomReal& poly, Real tol = 1e-10, int maxIter = 100)
    {
      Vector<Complex> roots;
      int degree = poly.GetDegree();
      
      if (degree <= 0)
        return roots;
      
      // Work with coefficient array (not Polynom object due to operator[] template issues)
      Vector<Complex> workCoeffs(degree + 1);
      for (int i = 0; i <= degree; i++)
        workCoeffs[i] = std::complex<Real>(poly[i], 0.0);
      
      // Find roots one by one with deflation
      for (int currentDegree = degree; currentDegree >= 1; currentDegree--)
      {
        // Initial guess
        Complex x = std::complex<Real>(0.5, 0.5);
        
        // Laguerre iteration
        bool converged = false;
        for (int iter = 0; iter < maxIter; iter++)
        {
          // Evaluate polynomial and derivatives using Horner's method
          Complex p = workCoeffs[currentDegree];
          Complex dp = std::complex<Real>(0.0);
          Complex d2p = std::complex<Real>(0.0);
          
          for (int j = currentDegree - 1; j >= 0; j--)
          {
            d2p = d2p * x + dp;
            dp = dp * x + p;
            p = p * x + workCoeffs[j];
          }
          d2p *= Real(2.0);
          
          if (std::abs(p) < tol)
          {
            converged = true;
            break;
          }
          
          // Laguerre's formula
          Real n = Real(currentDegree);
          Complex G = dp / p;
          Complex H = G * G - d2p / p;
          Complex sq = std::sqrt((n - Real(1.0)) * (n * H - G * G));
          
          Complex denom1 = G + sq;
          Complex denom2 = G - sq;
          Complex denom = (std::abs(denom1) > std::abs(denom2)) ? denom1 : denom2;
          
          Complex dx = n / denom;
          x -= dx;
          
          if (std::abs(dx) < tol)
          {
            converged = true;
            break;
          }
        }
        
        if (!converged)
          throw RootFindingError("Laguerre's method failed to converge");
        
        // Polish with Newton iterations
        for (int polish = 0; polish < 3; polish++)
        {
          Complex p = workCoeffs[currentDegree];
          Complex dp = std::complex<Real>(0.0);
          
          for (int j = currentDegree - 1; j >= 0; j--)
          {
            dp = dp * x + p;
            p = p * x + workCoeffs[j];
          }
          
          if (std::abs(dp) > tol)
            x -= p / dp;
        }
        
        roots.push_back(x);
        
        // Deflate polynomial
        if (currentDegree > 1)
        {
          Complex b = workCoeffs[currentDegree];
          for (int j = currentDegree - 1; j >= 0; j--)
          {
            Complex temp = workCoeffs[j];
            workCoeffs[j] = b;
            b = temp + x * b;
          }
        }
      }
      
      return roots;
    }

    /**
    * Find all roots using eigenvalue method (companion matrix).
    * 
    * @param poly  Polynomial with real coefficients
    * @return Vector of all complex roots
    */
    static Vector<Complex> EigenvalueRoots(const PolynomReal& poly)
    {
      Vector<Complex> roots;
      int degree = poly.GetDegree();
      
      if (degree <= 0)
        return roots;
      
      if (degree == 1)
      {
        roots.push_back(std::complex<Real>(-poly[0] / poly[1], 0.0));
        return roots;
      }
      
      // Construct companion matrix
      Matrix<Real> companion(degree, degree);
      for (int i = 0; i < degree; i++)
        for (int j = 0; j < degree; j++)
          companion[i][j] = 0.0;
      
      // Superdiagonal of ones
      for (int i = 0; i < degree - 1; i++)
        companion[i][i + 1] = 1.0;
      
      // Last row: -a_0/a_n, -a_1/a_n, ..., -a_{n-1}/a_n
      Real leadingCoef = poly[degree];
      if (std::abs(leadingCoef) < PrecisionValues<Real>::PolynomialCoeffZeroThreshold)
        throw RootFindingError("Polynomial leading coefficient is zero");
      
      for (int i = 0; i < degree; i++)
        companion[degree - 1][i] = -poly[i] / leadingCoef;
      
      // Solve eigenvalue problem
      auto eigenResult = EigenSolver::Solve(companion, 1e-10, 1000);
      
      if (!eigenResult.converged)
        throw RootFindingError("Eigenvalue solver failed to converge");
      
      // Extract eigenvalues as roots
      for (const auto& eval : eigenResult.eigenvalues)
        roots.push_back(std::complex<Real>(eval.real, eval.imag));
      
      return roots;
    }

    /**
    * Find/refine polynomial roots using Bairstow's method.
    * 
    * @param poly          Polynomial with real coefficients
    * @param initialRoots  Initial root estimates (optional)
    * @param tol           Convergence tolerance (default: 1e-10)
    * @param maxIter       Maximum iterations per quadratic (default: 100)
    * @return Vector of complex roots
    */
    static Vector<Complex> BairstowRoots(const PolynomReal& poly, 
                                         const Vector<Complex>& initialRoots = Vector<Complex>(),
                                         Real tol = 1e-10, int maxIter = 100)
    {
      Vector<Complex> roots;
      int n = poly.GetDegree();
      
      if (n <= 0)
        return roots;
      
      // Work with coefficient array a[0..n] where poly = a[0] + a[1]x + ... + a[n]x^n
      Vector<Real> a(n + 1);
      for (int i = 0; i <= n; i++)
        a[i] = poly[i];
      
      while (n >= 2)
      {
        // Initial guess for quadratic factor xÂ² + u*x + v
        // Start with a simple guess - these values tend to work for many polynomials
        Real u = 0.0;
        Real v = 1.0;
        
        // Use initial roots if provided
        if (initialRoots.size() >= 2 && n == poly.GetDegree())
        {
          Complex r1 = initialRoots[roots.size()];
          Complex r2 = (roots.size() + 1 < initialRoots.size()) ? 
                      initialRoots[roots.size() + 1] : std::conj(r1);
          u = -(r1 + r2).real();
          v = (r1 * r2).real();
        }
        
        // Bairstow's method iteration
        // Division: P(x) = (xÂ² + ux + v) * Q(x) + (cx + d)
        // where Q(x) = sum_{i=0}^{n-2} b[i] x^i
        
        Vector<Real> b(n + 1, 0.0);  // Quotient coefficients + work space
        Vector<Real> f(n + 1, 0.0);  // Second division for Jacobian
        
        bool converged = false;
        for (int iter = 0; iter < maxIter; iter++)
        {
          // First synthetic division: compute b[i]
          // b[n] = b[n-1] = 0 (implied by initialization)
          // b[i] = a[i+2] - u*b[i+1] - v*b[i+2] for i = n-2, ..., 0
          b[n] = 0.0;
          b[n-1] = 0.0;
          for (int i = n - 2; i >= 0; i--)
            b[i] = a[i + 2] - u * b[i + 1] - v * b[i + 2];
          
          // Remainder: c*x + d
          Real c = a[1] - u * b[0] - v * b[1];
          Real d = a[0] - v * b[0];
          
          // Check convergence
          if (std::abs(c) < tol && std::abs(d) < tol)
          {
            converged = true;
            break;
          }
          
          // Second synthetic division on Q(x) to get partial derivatives
          // f[n] = f[n-1] = 0 (implied)
          // f[i] = b[i+2] - u*f[i+1] - v*f[i+2] for i = n-2, ..., 0
          f[n] = 0.0;
          f[n-1] = 0.0;
          for (int i = n - 2; i >= 0; i--)
            f[i] = b[i + 2] - u * f[i + 1] - v * f[i + 2];
          
          // g and h for Jacobian: g*x + h is remainder of Q(x) / (xÂ² + ux + v)
          Real g = b[1] - u * f[0] - v * f[1];
          Real h = b[0] - v * f[0];
          
          // Newton update: [u,v]_new = [u,v] - J^{-1} * [c,d]
          // det(J) = v*gÂ² + h*(h - u*g)
          Real det = v * g * g + h * (h - u * g);
          
          if (std::abs(det) < PrecisionValues<Real>::DeterminantZeroThreshold)
          {
            // Singular Jacobian - perturb and continue
            u += 0.1;
            v += 0.1;
            continue;
          }
          
          // Update from Wikipedia formula: [u,v] = [u,v] - J^{-1} * [c,d]
          Real du = (-h * c + g * d) / det;
          Real dv = (-g * v * c + (g * u - h) * d) / det;
          
          u -= du;
          v -= dv;
          
          if (std::abs(du) < tol && std::abs(dv) < tol)
          {
            converged = true;
            break;
          }
        }
        
        // Extract roots from quadratic xÂ² + ux + v = 0
        // x = (-u Â± sqrt(uÂ² - 4v)) / 2
        Real discriminant = u * u - Real(4.0) * v;
        if (discriminant >= 0)
        {
          Real sqrtDisc = std::sqrt(discriminant);
          roots.push_back(std::complex<Real>((-u + sqrtDisc) / Real(2.0), 0.0));
          roots.push_back(std::complex<Real>((-u - sqrtDisc) / Real(2.0), 0.0));
        }
        else
        {
          Real sqrtDisc = std::sqrt(-discriminant);
          roots.push_back(std::complex<Real>(-u / Real(2.0), sqrtDisc / Real(2.0)));
          roots.push_back(std::complex<Real>(-u / Real(2.0), -sqrtDisc / Real(2.0)));
        }
        
        // Deflate: new polynomial is Q(x) with coefficients b[0], b[1], ..., b[n-2]
        if (n > 2)
        {
          Vector<Real> newA(n - 1);
          for (int i = 0; i <= n - 2; i++)
            newA[i] = b[i];
          a = newA;
        }
        n -= 2;
      }
      
      // Handle remaining linear term: a[0] + a[1]*x = 0
      if (n == 1)
      {
        if (std::abs(a[1]) > PrecisionValues<Real>::PolynomialCoeffZeroThreshold)
          roots.push_back(std::complex<Real>(-a[0] / a[1], 0.0));
      }
      
      return roots;
    } // BairstowRoots
  } // namespace RootFinding
} // namespace MML




///////////////////////////   mml/algorithms/ODESystemStepCalculators.h   ///////////////////////////




// NOTE: These calculators are stateless single-step implementations used by
// `ODESystemFixedStepSolver` for fixed-step integration. They intentionally
// implement the simple one-step interface (`IODESystemStepCalculator`) and
// therefore duplicate some coefficients that are also present in the
// adaptive steppers (implemented in `ODEAdaptiveIntegrator.h`).
//
// If you change coefficients here, ensure the adaptive steppers remain
// consistent where intended. The duplication is deliberate to keep the
// fixed-step and adaptive implementations independent and easy to reason
// about.

namespace MML
{
	// For a given IODESystem of dimension n, and given initial values for the variables x_start[0..n-1] 
	// and their derivatives dxdt[0..n-1] known at t, uses the Euler method to advance the solution 
	// over an interval h and return the incremented variables as x_out[0..n-1].
	class EulerStep_Calculator : public IODESystemStepCalculator
	{
	public:
		void calcStep(const IODESystem& odeSystem,
									const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
									const Real h, Vector<Real>& x_out, Vector<Real>& x_err_out) const override
		{
			int i, n = odeSystem.getDim();
			
			for (i = 0; i < n; i++)
				x_out[i] = x_start[i] + h * dxdt[i];
		}
	};

	// For a given IODESystem of dimension n, and given initial values for the variables x_start[0..n-1] 
	// and their derivatives dxdt[0..n-1] known at t, uses the Euler-Cromer method to advance the solution 
	// over an interval h and return the incremented variables as x_out[0..n-1].
	class EulerCromer_StepCalculator : public IODESystemStepCalculator
	{
	public:
		void calcStep(const IODESystem& odeSystem,
									const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
									const Real h, Vector<Real>& x_out, Vector<Real>& x_err_out) const override
		{
			int i, n = odeSystem.getDim();
			Vector<Real> x_new(n);

			for (i = 0; i < n; i++)
				x_new[i] = x_start[i] + h * dxdt[i];

			odeSystem.derivs(t + h, x_new, x_out);
		}
	};

	// For a given IODESystem of dimension n, and given initial values for the variables x_start[0..n-1] 
	// and their derivatives dxdt[0..n-1] known at t, uses the Velocity Verlet method to advance the solution 
	// over an interval h and return the incremented variables as x_out[0..n-1].
	class VelocityVerlet_StepCalculator : public IODESystemStepCalculator
	{
	public:
		void calcStep(const IODESystem& odeSystem,
									const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
									const Real h, Vector<Real>& x_out, Vector<Real>& x_err_out) const override
		{
			int n = odeSystem.getDim();
			int half_n = n / 2;

			// Split state
			// x_start[0..half_n-1] = positions
			// x_start[half_n..n-1] = velocities
			// dxdt[0..half_n-1] = velocities
			// dxdt[half_n..n-1] = accelerations

			// 1. Update positions
			for (int i = 0; i < half_n; ++i)
				x_out[i] = x_start[i] + x_start[half_n + i] * h + 0.5 * dxdt[half_n + i] * h * h;

			// 2. Compute new acceleration at new position
			Vector<Real> x_temp = x_out;
			for (int i = 0; i < half_n; ++i)
				x_temp[half_n + i] = x_start[half_n + i]; // velocities (will be updated)
			Vector<Real> dxdt_temp(n);
			odeSystem.derivs(t + h, x_temp, dxdt_temp);

			// 3. Update velocities
			for (int i = 0; i < half_n; ++i)
				x_out[half_n + i] = x_start[half_n + i] + 0.5 * (dxdt[half_n + i] + dxdt_temp[half_n + i]) * h;

			// No error estimate
			for (int i = 0; i < n; ++i)
				x_err_out[i] = 0.0;
		}
	};

	// Leapfrog (Velocity Verlet) step calculator for symplectic integration.
	// Best suited for Hamiltonian systems where state is split into positions and velocities.
	// Conserves energy for long-time integration of oscillatory systems.
	class Leapfrog_StepCalculator : public IODESystemStepCalculator
	{
	public:
		// For a given IODESystem of dimension n, and given initial values for the variables x_start[0..n-1] 
		// and their derivatives dxdt[0..n-1] known at t, uses the Leapfrog method to advance the solution 
		// over an interval h and return the incremented variables as x_out[0..n-1].
		void calcStep(const IODESystem& odeSystem,
									const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
									const Real h, Vector<Real>& x_out, Vector<Real>& x_err_out) const override
		{
			int n = odeSystem.getDim();
			int half_n = n / 2;

			// Split x_start into positions and velocities
			// x_start[0..half_n-1] = positions
			// x_start[half_n..n-1] = velocities

			// 1. Compute velocity at half step: v_{n+1/2} = v_n + (h/2) * a(x_n)
			Vector<Real> x_temp = x_start;
			Vector<Real> dxdt_temp(n);
			odeSystem.derivs(t, x_start, dxdt_temp);

			// positions: x_start[0..half_n-1]
			// velocities: x_start[half_n..n-1]
			// accelerations: dxdt_temp[half_n..n-1]

			Vector<Real> v_half(half_n);
			for (int i = 0; i < half_n; ++i)
				v_half[i] = x_start[half_n + i] + 0.5 * h * dxdt_temp[half_n + i];

			// 2. Update positions: x_{n+1} = x_n + h * v_{n+1/2}
			for (int i = 0; i < half_n; ++i)
				x_out[i] = x_start[i] + h * v_half[i];

			// 3. Compute new acceleration at x_{n+1}
			Vector<Real> x_next = x_out;
			for (int i = 0; i < half_n; ++i)
				x_next[half_n + i] = v_half[i]; // temporary velocities for acceleration calculation

			Vector<Real> dxdt_next(n);
			odeSystem.derivs(t + h, x_next, dxdt_next);

			// 4. Update velocities: v_{n+1} = v_{n+1/2} + (h/2) * a(x_{n+1})
			for (int i = 0; i < half_n; ++i)
				x_out[half_n + i] = v_half[i] + 0.5 * h * dxdt_next[half_n + i];

			// No error estimate for Leapfrog
			for (int i = 0; i < n; ++i)
				x_err_out[i] = 0.0;
		}
	};

	// For a given ODESystem, of dimension n, and given initial values for the variables x_start[0..n-1] 
	// and their derivatives dxdt[0..n-1] known at t, uses the Midpoint method to advance the solution 
	// over an interval h and return the incremented variables as xout[0..n-1].
	class Midpoint_StepCalculator : public IODESystemStepCalculator
	{
	public:
		void calcStep(const IODESystem& odeSystem,
									const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
									const Real h, Vector<Real>& x_out, Vector<Real>& x_err_out) const override
		{
			int i, n = odeSystem.getDim();
			Vector<Real> x_mid(n);

			for (i = 0; i < n; i++)
				x_mid[i] = x_start[i] + 0.5 * h * dxdt[i];

			odeSystem.derivs(t + 0.5 * h, x_mid, x_out);
		}
	};

	// For a given ODESystem, of dimension n, and given initial values for the variables x_start[0..n-1] 
	// and their derivatives dxdt[0..n-1] known at t, uses the fourth-order Runge-Kutta method 
	// to advance the solution over an interval h and return the incremented variables as xout[0..n-1].
	class RungeKutta4_StepCalculator : public IODESystemStepCalculator
	{
	public:
		void calcStep(const IODESystem& odeSystem,
			const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
			const Real h, Vector<Real>& x_out, Vector<Real>& x_err_out) const override
		{
			int i, n = odeSystem.getDim();
			Vector<Real> dx_mid(n), dx_temp(n), x_temp(n);

			Real xh, hh, h6;
			hh = h * 0.5;
			h6 = h / 6.0;
			xh = t + hh;

			for (i = 0; i < n; i++)												// First step
				x_temp[i] = x_start[i] + hh * dxdt[i];

			odeSystem.derivs(xh, x_temp, dx_temp);				// Second step

			for (i = 0; i < n; i++)
				x_temp[i] = x_start[i] + hh * dx_temp[i];

			odeSystem.derivs(xh, x_temp, dx_mid);					// Third step

			for (i = 0; i < n; i++) {
				x_temp[i] = x_start[i] + h * dx_mid[i];
				dx_mid[i] += dx_temp[i];
			}

			odeSystem.derivs(t + h, x_temp, dx_temp);			// Fourth step	

			for (i = 0; i < n; i++)
				x_out[i] = x_start[i] + h6 * (dxdt[i] + dx_temp[i] + 2.0 * dx_mid[i]);
		}
	};
	
	// Given initial values for n variables x[0..n-1] and their derivatives dxdt[0..n-1] known at t,
	// uses	the fifth-order Cash-Karp Runge-Kutta method to advance the solution over an interval h
	// and return the incremented variables as x_out[0..n-1].
	// Also returns an estimate of the local truncation error in x_out using the embedded fourth-order method.
	// VERIFIED: Coefficients match Numerical Recipes 2nd ed. rkck() implementation exactly.
	class RK5_CashKarp_Calculator : public IODESystemStepCalculator
	{
	public:

		void calcStep(const IODESystem& sys,
									Real t, const Vector<Real>& x, const Vector<Real>& dxdt,
									Real h, Vector<Real>& x_out, Vector<Real>& x_err) const override
		{
			static const Real a2 = 0.2, a3 = 0.3, a4 = 0.6, a5 = 1.0, a6 = 0.875,
				b21 = 0.2, b31 = 3.0 / 40.0, b32 = 9.0 / 40.0, b41 = 0.3, b42 = -0.9,
				b43 = 1.2, b51 = -11.0 / 54.0, b52 = 2.5, b53 = -70.0 / 27.0,
				b54 = 35.0 / 27.0, b61 = 1631.0 / 55296.0, b62 = 175.0 / 512.0,
				b63 = 575.0 / 13824.0, b64 = 44275.0 / 110592.0, b65 = 253.0 / 4096.0,
				c1 = 37.0 / 378.0, c3 = 250.0 / 621.0, c4 = 125.0 / 594.0, c6 = 512.0 / 1771.0,
				dc1 = c1 - 2825.0 / 27648.0, dc3 = c3 - 18575.0 / 48384.0,
				dc4 = c4 - 13525.0 / 55296.0, dc5 = -277.00 / 14336.0, dc6 = c6 - 0.25;

			int i, n = x.size();
			Vector<Real> ak2(n), ak3(n), ak4(n), ak5(n), ak6(n), xtemp(n);

			for (i = 0; i < n; i++)
				xtemp[i] = x[i] + b21 * h * dxdt[i];

			sys.derivs(t + a2 * h, xtemp, ak2);
			for (i = 0; i < n; i++)
				xtemp[i] = x[i] + h * (b31 * dxdt[i] + b32 * ak2[i]);

			sys.derivs(t + a3 * h, xtemp, ak3);
			for (i = 0; i < n; i++)
				xtemp[i] = x[i] + h * (b41 * dxdt[i] + b42 * ak2[i] + b43 * ak3[i]);

			sys.derivs(t + a4 * h, xtemp, ak4);
			for (i = 0; i < n; i++)
				xtemp[i] = x[i] + h * (b51 * dxdt[i] + b52 * ak2[i] + b53 * ak3[i] + b54 * ak4[i]);

			sys.derivs(t + a5 * h, xtemp, ak5);
			for (i = 0; i < n; i++)
				xtemp[i] = x[i] + h * (b61 * dxdt[i] + b62 * ak2[i] + b63 * ak3[i] + b64 * ak4[i] + b65 * ak5[i]);

			sys.derivs(t + a6 * h, xtemp, ak6);

			for (i = 0; i < n; i++)
				x_out[i] = x[i] + h * (c1 * dxdt[i] + c3 * ak3[i] + c4 * ak4[i] + c6 * ak6[i]);
			for (i = 0; i < n; i++)
				x_err[i] = h * (dc1 * dxdt[i] + dc3 * ak3[i] + dc4 * ak4[i] + dc5 * ak5[i] + dc6 * ak6[i]);
		}
	};

	// VERIFIED: Implementation matches standard Dormand-Prince (4)5 Butcher tableau.
	// Coefficients verified against multiple sources (Wikipedia, Hairer et al.).
	class DormandPrince5_StepCalculator : public IODESystemStepCalculator
	{
	public:
		// For a given ODESystem, of dimension n, and given initial values for the variables x_start[0..n-1] 
		// and their derivatives dxdt[0..n-1] known at t, uses the Dormand-Prince 5th-order Runge-Kutta method 
		// to advance the solution over an interval h and return the incremented variables as xout[0..n-1].
		void calcStep(const IODESystem& odeSystem,
									const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
									const Real h, Vector<Real>& x_out, Vector<Real>& x_err_out) const override
		{
			// Dormand-Prince coefficients (Butcher tableau)
			static const Real a2 = 1.0 / 5.0;
			static const Real a3 = 3.0 / 10.0;
			static const Real a4 = 4.0 / 5.0;
			static const Real a5 = 8.0 / 9.0;
			static const Real a6 = 1.0;
			static const Real a7 = 1.0;

			static const Real b21 = 1.0 / 5.0;

			static const Real b31 = 3.0 / 40.0;
			static const Real b32 = 9.0 / 40.0;

			static const Real b41 = 44.0 / 45.0;
			static const Real b42 = -56.0 / 15.0;
			static const Real b43 = 32.0 / 9.0;

			static const Real b51 = 19372.0 / 6561.0;
			static const Real b52 = -25360.0 / 2187.0;
			static const Real b53 = 64448.0 / 6561.0;
			static const Real b54 = -212.0 / 729.0;

			static const Real b61 = 9017.0 / 3168.0;
			static const Real b62 = -355.0 / 33.0;
			static const Real b63 = 46732.0 / 5247.0;
			static const Real b64 = 49.0 / 176.0;
			static const Real b65 = -5103.0 / 18656.0;

			static const Real b71 = 35.0 / 384.0;
			static const Real b72 = 0.0;
			static const Real b73 = 500.0 / 1113.0;
			static const Real b74 = 125.0 / 192.0;
			static const Real b75 = -2187.0 / 6784.0;
			static const Real b76 = 11.0 / 84.0;

			// 5th order solution weights
			static const Real c1 = 35.0 / 384.0;
			static const Real c2 = 0.0;
			static const Real c3 = 500.0 / 1113.0;
			static const Real c4 = 125.0 / 192.0;
			static const Real c5 = -2187.0 / 6784.0;
			static const Real c6 = 11.0 / 84.0;
			static const Real c7 = 0.0;

			// 4th order solution weights (for error estimate)
			static const Real d1 = 5179.0 / 57600.0;
			static const Real d2 = 0.0;
			static const Real d3 = 7571.0 / 16695.0;
			static const Real d4 = 393.0 / 640.0;
			static const Real d5 = -92097.0 / 339200.0;
			static const Real d6 = 187.0 / 2100.0;
			static const Real d7 = 1.0 / 40.0;

			int n = x_start.size();
			Vector<Real> k1(n), k2(n), k3(n), k4(n), k5(n), k6(n), k7(n), xtemp(n);

			// k1 = f(t, x)
			for (int i = 0; i < n; ++i)
				k1[i] = dxdt[i];

			// k2 = f(t + a2*h, x + h*b21*k1)
			for (int i = 0; i < n; ++i)
				xtemp[i] = x_start[i] + h * b21 * k1[i];
			odeSystem.derivs(t + a2 * h, xtemp, k2);

			// k3 = f(t + a3*h, x + h*(b31*k1 + b32*k2))
			for (int i = 0; i < n; ++i)
				xtemp[i] = x_start[i] + h * (b31 * k1[i] + b32 * k2[i]);
			odeSystem.derivs(t + a3 * h, xtemp, k3);

			// k4 = f(t + a4*h, x + h*(b41*k1 + b42*k2 + b43*k3))
			for (int i = 0; i < n; ++i)
				xtemp[i] = x_start[i] + h * (b41 * k1[i] + b42 * k2[i] + b43 * k3[i]);
			odeSystem.derivs(t + a4 * h, xtemp, k4);

			// k5 = f(t + a5*h, x + h*(b51*k1 + b52*k2 + b53*k3 + b54*k4))
			for (int i = 0; i < n; ++i)
				xtemp[i] = x_start[i] + h * (b51 * k1[i] + b52 * k2[i] + b53 * k3[i] + b54 * k4[i]);
			odeSystem.derivs(t + a5 * h, xtemp, k5);

			// k6 = f(t + a6*h, x + h*(b61*k1 + b62*k2 + b63*k3 + b64*k4 + b65*k5))
			for (int i = 0; i < n; ++i)
				xtemp[i] = x_start[i] + h * (b61 * k1[i] + b62 * k2[i] + b63 * k3[i] + b64 * k4[i] + b65 * k5[i]);
			odeSystem.derivs(t + a6 * h, xtemp, k6);

			// k7 = f(t + a7*h, x + h*(b71*k1 + b72*k2 + b73*k3 + b74*k4 + b75*k5 + b76*k6))
			for (int i = 0; i < n; ++i)
				xtemp[i] = x_start[i] + h * (b71 * k1[i] + b72 * k2[i] + b73 * k3[i] + b74 * k4[i] + b75 * k5[i] + b76 * k6[i]);
			odeSystem.derivs(t + a7 * h, xtemp, k7);

			// 5th order solution
			for (int i = 0; i < n; ++i)
				x_out[i] = x_start[i] + h * (c1 * k1[i] + c2 * k2[i] + c3 * k3[i] + c4 * k4[i] + c5 * k5[i] + c6 * k6[i] + c7 * k7[i]);

			// 4th order solution (for error estimate)
			for (int i = 0; i < n; ++i)
				x_err_out[i] = h * ((c1 - d1) * k1[i] + (c2 - d2) * k2[i] + (c3 - d3) * k3[i] +
					(c4 - d4) * k4[i] + (c5 - d5) * k5[i] + (c6 - d6) * k6[i] + (c7 - d7) * k7[i]);
		}
	};

	// VERIFIED: Implementation matches Dormand-Prince (7)8 Butcher tableau.
	// High-order method with 14 stages for problems requiring tight error control.
	class DormandPrince8_StepCalculator : public IODESystemStepCalculator
	{
	public:
		// For a given ODESystem, of dimension n, and given initial values for the variables x_start[0..n-1] 
		// and their derivatives dxdt[0..n-1] known at t, uses the Dormand-Prince 8th-order Runge-Kutta method 
		// to advance the solution over an interval h and return the incremented variables as xout[0..n-1].
		void calcStep(const IODESystem& odeSystem,
			const Real t, const Vector<Real>& x_start, const Vector<Real>& dxdt,
			const Real h, Vector<Real>& x_out, Vector<Real>& x_err_out) const override
		{
			constexpr int s = 14; // number of stages

			// c: nodes
			static const Real c[s] = {
					0.0,
					1.0 / 18.0,
					1.0 / 12.0,
					1.0 / 8.0,
					5.0 / 16.0,
					3.0 / 8.0,
					59.0 / 400.0,
					93.0 / 200.0,
					5490023248.0 / 9719169821.0,
					13.0 / 20.0,
					1201146811.0 / 1299019798.0,
					1.0,
					1.0
			};

			// a: stage coefficients
			static const Real a[s][s] = {
					{0},
					{1.0 / 18.0},
					{1.0 / 48.0, 1.0 / 16.0},
					{1.0 / 32.0, 0.0, 3.0 / 32.0},
					{5.0 / 16.0, 0.0, -75.0 / 64.0, 75.0 / 64.0},
					{3.0 / 80.0, 0.0, 0.0, 3.0 / 16.0, 3.0 / 20.0},
					{29443841.0 / 614563906.0, 0.0, 0.0, 77736538.0 / 692538347.0, -28693883.0 / 1125000000.0, 23124283.0 / 1800000000.0},
					{16016141.0 / 946692911.0, 0.0, 0.0, 61564180.0 / 158732637.0, 22789713.0 / 633445777.0, 545815736.0 / 2771057229.0, -180193667.0 / 1043307555.0},
					{39632708.0 / 573591083.0, 0.0, 0.0, -433636366.0 / 683701615.0, -421739975.0 / 2616292301.0, 100302831.0 / 723423059.0, 790204164.0 / 839813087.0, 800635310.0 / 3783071287.0},
					{246121993.0 / 1340847787.0, 0.0, 0.0, -37695042795.0 / 15268766246.0, -309121744.0 / 1061227803.0, -12992083.0 / 490766935.0, 6005943493.0 / 2108947869.0, 393006217.0 / 1396673457.0, 123872331.0 / 1001029789.0},
					{-1028468189.0 / 846180014.0, 0.0, 0.0, 8478235783.0 / 508512852.0, 1311729495.0 / 1432422823.0, -10304129995.0 / 1701304382.0, -48777925059.0 / 3047939560.0, 15336726248.0 / 1032824649.0, -45442868181.0 / 3398467696.0, 3065993473.0 / 597172653.0},
					{185892177.0 / 718116043.0, 0.0, 0.0, -3185094517.0 / 667107341.0, -477755414.0 / 1098053517.0, -703635378.0 / 230739211.0, 5731566787.0 / 1027545527.0, 5232866602.0 / 850066563.0, -4093664535.0 / 808688257.0, 3962137247.0 / 1805957418.0, 65686358.0 / 487910083.0},
					{403863854.0 / 491063109.0, 0.0, 0.0, -5068492393.0 / 434740067.0, -411421997.0 / 543043805.0, 652783627.0 / 914296604.0, 11173962825.0 / 925320556.0, -13158990841.0 / 6184727034.0, 3936647629.0 / 1978049680.0, -160528059.0 / 685178525.0, 248638103.0 / 1413531060.0, 0.0},
					{14005451.0 / 335480064.0, 0.0, 0.0, 0.0, 0.0, -59238493.0 / 1068277825.0, 181606767.0 / 758867731.0, 561292985.0 / 797845732.0, -1041891430.0 / 1371343529.0, 760417239.0 / 1151165299.0, 118820643.0 / 751138087.0, -528747749.0 / 2220607170.0, 1.0 / 4.0}
			};

			// b8: 8th order weights, b7: 7th order weights (for error estimate)
			static const Real b8[s] = {
					14005451.0 / 335480064.0,
					0.0,
					0.0,
					0.0,
					0.0,
					-59238493.0 / 1068277825.0,
					181606767.0 / 758867731.0,
					561292985.0 / 797845732.0,
					-1041891430.0 / 1371343529.0,
					760417239.0 / 1151165299.0,
					118820643.0 / 751138087.0,
					-528747749.0 / 2220607170.0,
					1.0 / 4.0
			};
			static const Real b7[s] = {
					13451932.0 / 455176623.0,
					0.0,
					0.0,
					0.0,
					0.0,
					-808719846.0 / 976000145.0,
					1757004468.0 / 5645159321.0,
					656045339.0 / 265891186.0,
					-3867574721.0 / 1518517206.0,
					465885868.0 / 322736535.0,
					53011238.0 / 667516719.0,
					2.0 / 45.0,
					0.0
			};

			int n = x_start.size();
			Vector<Vector<Real>> k(s, Vector<Real>(n));
			Vector<Real> xtemp(n);

			// k1 = dxdt
			for (int i = 0; i < n; ++i)
				k[0][i] = dxdt[i];

			// Compute all stages
			for (int stage = 1; stage < s; ++stage) 
			{
				for (int i = 0; i < n; ++i) {
					Real sum = 0.0;
					for (int j = 0; j < stage; ++j)
						sum += a[stage][j] * k[j][i];
					xtemp[i] = x_start[i] + h * sum;
				}
				odeSystem.derivs(t + c[stage] * h, xtemp, k[stage]);
			}

			// 8th order solution
			for (int i = 0; i < n; ++i) 
			{
				Real sum = 0.0;
				for (int stage = 0; stage < s; ++stage)
					sum += b8[stage] * k[stage][i];
				x_out[i] = x_start[i] + h * sum;
			}

			// Error estimate (8th - 7th order)
			for (int i = 0; i < n; ++i) 
			{
				Real sum = 0.0;
				for (int stage = 0; stage < s; ++stage)
					sum += (b8[stage] - b7[stage]) * k[stage][i];
				x_err_out[i] = h * sum;
			}
		}
	};

	class StepCalculators
	{
	public:
		static inline EulerStep_Calculator					EulerStepCalc;
		static inline EulerCromer_StepCalculator		EulerCromerStepCalc;
		static inline VelocityVerlet_StepCalculator	VelocityVerletStepCalc;
		static inline Leapfrog_StepCalculator				LeapfrogStepCalc;
		static inline Midpoint_StepCalculator				MidpointStepCalc;
		static inline RungeKutta4_StepCalculator		RK4_Basic;
		static inline RK5_CashKarp_Calculator				RK5_CashKarp;
		static inline DormandPrince5_StepCalculator	DormandPrince5StepCalc;
		static inline DormandPrince8_StepCalculator	DormandPrince8StepCalc;
	};
}


///////////////////////////   mml/algorithms/ODESystemSteppers.h   ///////////////////////////





namespace MML
{
	/// @brief Legacy base stepper class
	/// @deprecated Use IAdaptiveStepper from ODEAdaptiveIntegrator.h instead
	class StepperBase 
	{
	protected:
		const IODESystem& _sys;

		Real& _t;
		Vector<Real>& _x;
		Vector<Real>& _dxdt;

		Real _absTol, _relTol;
		Real _eps;

		Real _tOld;
		Real _hDone, _hNext;

		Vector<Real> _xout, _xerr;

	public:
		StepperBase(const IODESystem& sys, Real& t, Vector<Real>& x, Vector<Real>& dxdt)
			: _sys(sys), _t(t), _x(x), _dxdt(dxdt) {
		}

		virtual void doStep(Real htry, Real eps) = 0;

		Real hDone() const { return _hDone; }
		Real& hDone() { return _hDone; }

		Real hNext() const { return _hNext; }
		Real& hNext() { return _hNext; }
	};

	/// @brief Legacy Cash-Karp stepper (reference-based interface)
	/// @deprecated Use CashKarp_Stepper with ODEAdaptiveIntegrator instead
	class RK5_CashKarp_Stepper : public StepperBase
	{
	private:
		RK5_CashKarp_Calculator _stepCalc;

	public:
		RK5_CashKarp_Stepper(const IODESystem& sys, Real& t, Vector<Real>& x, Vector<Real>& dxdt)
			: StepperBase(sys, t, x, dxdt) {}

		void doStep(Real htry, Real eps) override
		{
			const Real SAFETY = 0.9, PGROW = -0.2, PSHRNK = -0.25, ERRCON = 1.89e-4;
			Real errmax, h, htemp;
			int n = _sys.getDim();
			Vector<Real> xerr(n), xscale(n), xtemp(n);

			h = htry;
			
			for (int i = 0; i < n; i++)
				xscale[i] = std::abs(_x[i]) + std::abs(_dxdt[i] * h) + 1e-25;

			for (;;) {
				_stepCalc.calcStep(_sys, _t, _x, _dxdt, h, xtemp, xerr);

				for (int i = 0; i < n; i++) {
					if (std::isnan(xtemp[i]) || std::isinf(xtemp[i]))
						throw ODESolverError("Non-finite value in RK5 step calculation");
				}

				errmax = 0.0;
				for (int i = 0; i < n; i++)
					errmax = std::max(errmax, std::abs(xerr[i] / xscale[i]));
				errmax /= eps;

				if (errmax <= 1.0) break;

				htemp = SAFETY * h * std::pow(errmax, PSHRNK);
				h = (h >= 0.0) ? std::max(htemp, 0.1 * h) : std::min(htemp, 0.1 * h);

				if (std::abs(h) < Constants::Eps)
					throw ODESolverError("Stepsize underflow in RK5_CashKarp_Stepper");
			}

			if (errmax > ERRCON)
				_hNext = SAFETY * h * std::pow(errmax, PGROW);
			else
				_hNext = 5.0 * h;

			_t += h;
			_hDone = h;
			_x = xtemp;
		}
	};

} // namespace MML


///////////////////////////   mml/algorithms/ODEAdaptiveIntegrator.h   ///////////////////////////


namespace MML
{
	//===================================================================================
	//                              StepResult
	//===================================================================================
	/// @brief Result of an adaptive step attempt
	struct StepResult {
		bool accepted = false;   ///< Was the step accepted?
		Real hDone = 0.0;        ///< Actual step size taken (or attempted if rejected)
		Real hNext = 0.0;        ///< Suggested next step size
		Real errMax = 0.0;       ///< Maximum error ratio (for diagnostics)
		int  funcEvals = 0;      ///< Number of function evaluations used
	};

	//===================================================================================
	//                           SolutionStatistics
	//===================================================================================
	/// @brief Diagnostics for adaptive integration
	struct SolutionStatistics {
		int acceptedSteps = 0;     ///< Number of accepted steps
		int rejectedSteps = 0;     ///< Number of rejected steps
		int totalFuncEvals = 0;    ///< Total function evaluations
		Real minStepSize = 0;      ///< Smallest step size used
		Real maxStepSize = 0;      ///< Largest step size used
		
		void reset() {
			acceptedSteps = rejectedSteps = totalFuncEvals = 0;
			minStepSize = std::numeric_limits<Real>::max();
			maxStepSize = 0;
		}
		
		void recordStep(const StepResult& result) {
			if (result.accepted) {
				acceptedSteps++;
				minStepSize = std::min(minStepSize, result.hDone);
				maxStepSize = std::max(maxStepSize, result.hDone);
			} else {
				rejectedSteps++;
			}
			totalFuncEvals += result.funcEvals;
		}
		
		Real acceptanceRate() const {
			int total = acceptedSteps + rejectedSteps;
			return total > 0 ? static_cast<Real>(acceptedSteps) / total : 1.0;
		}
	};

	//===================================================================================
	//                           IAdaptiveStepper
	//===================================================================================
	/// @brief Interface for adaptive steppers with dense output capability
	/// 
	/// An adaptive stepper takes a trial step and returns whether it was accepted.
	/// Key features:
	/// - Error estimation and step size control
	/// - Dense output (interpolation within accepted steps)
	/// - FSAL (First Same As Last) optimization support
	class IAdaptiveStepper {
	public:
		virtual ~IAdaptiveStepper() = default;
		
		/// @brief Attempt a step from current state
		/// @param t Current time
		/// @param x Current state (modified in place on accepted step)
		/// @param dxdt Current derivative (modified in place on accepted step)
		/// @param htry Trial step size
		/// @param eps Error tolerance
		/// @return StepResult with acceptance status and step info
		virtual StepResult doStep(Real t, Vector<Real>& x, Vector<Real>& dxdt,
		                          Real htry, Real eps) = 0;
		
		/// @brief Interpolate solution at time t within the last accepted step
		/// @param t Time to interpolate at (must be in [t_old, t_old + hDone])
		/// @return Interpolated state vector
		/// @pre Must be called after a successful doStep()
		virtual Vector<Real> interpolate(Real t) const = 0;
		
		/// @brief Check if stepper supports FSAL optimization
		/// @return true if the final derivative can be reused as initial derivative
		virtual bool isFSAL() const { return false; }
		
		/// @brief Get the final derivative from last step (for FSAL)
		/// @return Derivative at end of last step
		/// @pre Must be called after a successful doStep() when isFSAL() is true
		virtual const Vector<Real>& getFinalDeriv() const = 0;
		
		/// @brief Get the number of stages in this method
		virtual int stageCount() const = 0;
		
		/// @brief Get the order of the method
		virtual int order() const = 0;
	};

	//===================================================================================
	//                         DormandPrince5_Stepper
	//===================================================================================
	/// @brief Dormand-Prince 5(4) adaptive stepper with FSAL and dense output
	/// 
	/// This is the workhorse method used by MATLAB's ode45 and SciPy's RK45.
	/// Features:
	/// - 5th order accurate solution with 4th order error estimate
	/// - FSAL: First Same As Last optimization (6 evals per step instead of 7)
	/// - 4th order dense output using Hermite interpolation
	/// - PI step size control for smooth adaptation
	class DormandPrince5_Stepper : public IAdaptiveStepper {
	private:
		const IODESystem& _sys;
		int _n;  // System dimension
		
		// Stage vectors (stored for dense output)
		Vector<Real> _k1, _k2, _k3, _k4, _k5, _k6, _k7;
		Vector<Real> _xtemp;  // Temporary for stage computation
		
		// Dense output data
		Real _tOld;           // Start time of last step
		Real _hDone;          // Size of last accepted step
		Vector<Real> _xOld;   // State at start of last step
		bool _stepReady;      // Is dense output data valid?
		
		// FSAL state
		bool _haveFSAL;       // Do we have a valid k7 to reuse?
		
		// Butcher tableau coefficients (static const for efficiency)
		static constexpr Real a2 = 1.0 / 5.0;
		static constexpr Real a3 = 3.0 / 10.0;
		static constexpr Real a4 = 4.0 / 5.0;
		static constexpr Real a5 = 8.0 / 9.0;
		static constexpr Real a6 = 1.0;
		static constexpr Real a7 = 1.0;

		static constexpr Real b21 = 1.0 / 5.0;
		static constexpr Real b31 = 3.0 / 40.0, b32 = 9.0 / 40.0;
		static constexpr Real b41 = 44.0 / 45.0, b42 = -56.0 / 15.0, b43 = 32.0 / 9.0;
		static constexpr Real b51 = 19372.0 / 6561.0, b52 = -25360.0 / 2187.0, 
		                      b53 = 64448.0 / 6561.0, b54 = -212.0 / 729.0;
		static constexpr Real b61 = 9017.0 / 3168.0, b62 = -355.0 / 33.0, 
		                      b63 = 46732.0 / 5247.0, b64 = 49.0 / 176.0, 
		                      b65 = -5103.0 / 18656.0;
		static constexpr Real b71 = 35.0 / 384.0, b72 = 0.0, b73 = 500.0 / 1113.0,
		                      b74 = 125.0 / 192.0, b75 = -2187.0 / 6784.0, b76 = 11.0 / 84.0;

		// 5th order weights
		static constexpr Real c1 = 35.0 / 384.0, c3 = 500.0 / 1113.0, c4 = 125.0 / 192.0,
		                      c5 = -2187.0 / 6784.0, c6 = 11.0 / 84.0;
		
		// Error coefficients (5th - 4th order)
		static constexpr Real e1 = 35.0/384.0 - 5179.0/57600.0;
		static constexpr Real e3 = 500.0/1113.0 - 7571.0/16695.0;
		static constexpr Real e4 = 125.0/192.0 - 393.0/640.0;
		static constexpr Real e5 = -2187.0/6784.0 + 92097.0/339200.0;
		static constexpr Real e6 = 11.0/84.0 - 187.0/2100.0;
		static constexpr Real e7 = -1.0 / 40.0;

		// Dense output coefficients (4th order Hermite interpolation)
		// From Hairer, Norsett, Wanner: Solving ODEs I
		static constexpr Real d1 = -12715105075.0 / 11282082432.0;
		static constexpr Real d3 = 87487479700.0 / 32700410799.0;
		static constexpr Real d4 = -10690763975.0 / 1880347072.0;
		static constexpr Real d5 = 701980252875.0 / 199316789632.0;
		static constexpr Real d6 = -1453857185.0 / 822651844.0;
		static constexpr Real d7 = 69997945.0 / 29380423.0;

		// Step size control parameters (PI controller)
		static constexpr Real SAFETY = 0.9;
		static constexpr Real MIN_FACTOR = 0.2;   // Don't reduce step by more than 5x
		static constexpr Real MAX_FACTOR = 10.0;  // Don't increase step by more than 10x
		static constexpr Real BETA = 0.04;        // PI controller parameter
		static constexpr Real ALPHA = 0.2 - BETA * 0.75;  // For 5th order method
		
		Real _errOld;  // Previous error for PI controller

	public:
		/// @brief Construct stepper for given ODE system
		explicit DormandPrince5_Stepper(const IODESystem& sys)
			: _sys(sys), _n(sys.getDim()), 
			  _k1(_n), _k2(_n), _k3(_n), _k4(_n), _k5(_n), _k6(_n), _k7(_n),
			  _xtemp(_n), _xOld(_n),
			  _tOld(0), _hDone(0), _stepReady(false), _haveFSAL(false),
			  _errOld(1.0) {}

		int stageCount() const override { return 7; }
		int order() const override { return 5; }
		bool isFSAL() const override { return true; }
		
		const Vector<Real>& getFinalDeriv() const override { return _k7; }

		StepResult doStep(Real t, Vector<Real>& x, Vector<Real>& dxdt,
		                  Real htry, Real eps) override
		{
			StepResult result;
			result.accepted = false;
			result.funcEvals = 0;
			
			Real h = htry;
			
			// FSAL: reuse k7 from previous step if available
			if (_haveFSAL) {
				_k1 = _k7;  // No function evaluation needed!
			} else {
				_k1 = dxdt;  // Use provided derivative
			}
			
			// Retry loop for step size control
			for (;;) {
				// k2
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * b21 * _k1[i];
				_sys.derivs(t + a2 * h, _xtemp, _k2);
				result.funcEvals++;
				
				// k3
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (b31 * _k1[i] + b32 * _k2[i]);
				_sys.derivs(t + a3 * h, _xtemp, _k3);
				result.funcEvals++;
				
				// k4
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (b41 * _k1[i] + b42 * _k2[i] + b43 * _k3[i]);
				_sys.derivs(t + a4 * h, _xtemp, _k4);
				result.funcEvals++;
				
				// k5
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (b51 * _k1[i] + b52 * _k2[i] + b53 * _k3[i] + b54 * _k4[i]);
				_sys.derivs(t + a5 * h, _xtemp, _k5);
				result.funcEvals++;
				
				// k6
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (b61 * _k1[i] + b62 * _k2[i] + b63 * _k3[i] + 
					                        b64 * _k4[i] + b65 * _k5[i]);
				_sys.derivs(t + a6 * h, _xtemp, _k6);
				result.funcEvals++;
				
				// 5th order solution (stored in _xtemp for now)
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (c1 * _k1[i] + c3 * _k3[i] + c4 * _k4[i] + 
					                        c5 * _k5[i] + c6 * _k6[i]);
				
				// k7 at the new point (needed for error estimate AND FSAL)
				_sys.derivs(t + h, _xtemp, _k7);
				result.funcEvals++;
				
				// Error estimate
				Real errMax = 0.0;
				for (int i = 0; i < _n; i++) {
					Real err = h * (e1 * _k1[i] + e3 * _k3[i] + e4 * _k4[i] + 
					               e5 * _k5[i] + e6 * _k6[i] + e7 * _k7[i]);
					// Scale by solution magnitude (mixed error control)
					Real scale = std::abs(x[i]) + std::abs(h * _k1[i]) + 1e-30;
					errMax = std::max(errMax, std::abs(err) / scale);
				}
				errMax /= eps;
				result.errMax = errMax;
				
				if (errMax <= 1.0) {
					// Step accepted!
					result.accepted = true;
					result.hDone = h;
					
					// Store data for dense output
					_tOld = t;
					_hDone = h;
					_xOld = x;
					_stepReady = true;
					
					// Update state
					x = _xtemp;
					dxdt = _k7;  // FSAL: derivative at new point
					_haveFSAL = true;
					
					// PI controller for next step size
					Real factor;
					if (_errOld > 0) {
						factor = SAFETY * std::pow(errMax, -ALPHA) * std::pow(_errOld, BETA);
					} else {
						factor = SAFETY * std::pow(errMax, -0.2);  // Standard controller
					}
					factor = std::max(MIN_FACTOR, std::min(MAX_FACTOR, factor));
					result.hNext = h * factor;
					
					_errOld = std::max(errMax, 1e-4);  // Store for PI controller
					break;
				}
				
				// Step rejected - reduce step size
				Real factor = SAFETY * std::pow(errMax, -0.25);  // More aggressive reduction
				factor = std::max(MIN_FACTOR, factor);
				h *= factor;
				_haveFSAL = false;  // Must recompute k1 after rejection
				
				// Check for step size underflow
				if (std::abs(h) < Constants::Eps) {
					throw ODESolverError("Step size underflow in DormandPrince5_Stepper");
				}
			}
			
			return result;
		}

		/// @brief Interpolate solution at time t using 4th order continuous extension
		/// @param t Time to interpolate at (must be in [_tOld, _tOld + _hDone])
		Vector<Real> interpolate(Real t) const override
		{
			if (!_stepReady) {
				throw ODESolverError("No valid step data for interpolation");
			}
			
			// theta = normalized position in step [0, 1]
			Real theta = (t - _tOld) / _hDone;
			
			Vector<Real> result(_n);
			
			// DP5 continuous extension (4th order accurate)
			// Simple but effective: use the stored k values with theta-weighted interpolation
			// This uses the formula: y(t_n + Î¸h) = y_n + h * Î£ b_i(Î¸) * k_i
			// where b_i(Î¸) are the continuous extension weights
			
			// For simplicity, use cubic Hermite interpolation between endpoints
			// y(Î¸) = (1-Î¸)*y_n + Î¸*y_{n+1} + Î¸(1-Î¸)*[(1-2Î¸)(y_{n+1}-y_n) + (Î¸-1)h*f_n + Î¸*h*f_{n+1}]
			// Simplified Hermite with endpoint values and derivatives
			
			Real theta2 = theta * theta;
			Real theta3 = theta2 * theta;
			
			// Hermite basis functions
			Real h00 = 2*theta3 - 3*theta2 + 1;    // at Î¸=0: 1, at Î¸=1: 0
			Real h10 = theta3 - 2*theta2 + theta;   // derivative weight at start
			Real h01 = -2*theta3 + 3*theta2;        // at Î¸=0: 0, at Î¸=1: 1
			Real h11 = theta3 - theta2;             // derivative weight at end
			
			for (int i = 0; i < _n; i++) {
				// y_n and y_{n+1}
				Real y0 = _xOld[i];
				Real y1 = y0 + _hDone * (c1 * _k1[i] + c3 * _k3[i] + c4 * _k4[i] + 
				                         c5 * _k5[i] + c6 * _k6[i]);
				
				// f_n and f_{n+1} (scaled by h)
				Real hf0 = _hDone * _k1[i];
				Real hf1 = _hDone * _k7[i];
				
				// Hermite interpolation
				result[i] = h00 * y0 + h10 * hf0 + h01 * y1 + h11 * hf1;
			}
			
			return result;
		}
		
		/// @brief Reset FSAL state (call when changing initial conditions)
		void resetFSAL() {
			_haveFSAL = false;
			_stepReady = false;
			_errOld = 1.0;
		}
	};

	//===================================================================================
	//                         CashKarp_Stepper
	//===================================================================================
	/// @brief Cash-Karp 5(4) adaptive stepper with dense output
	/// 
	/// Classic embedded RK method from Numerical Recipes.
	/// Features:
	/// - 5th order accurate solution with 4th order error estimate
	/// - 6 stages (no FSAL)
	/// - Cubic Hermite dense output
	class CashKarp_Stepper : public IAdaptiveStepper {
	private:
		const IODESystem& _sys;
		int _n;
		
		// Stage vectors
		Vector<Real> _k1, _k2, _k3, _k4, _k5, _k6;
		Vector<Real> _xtemp;
		
		// Dense output data
		Real _tOld, _hDone;
		Vector<Real> _xOld, _xNew;
		bool _stepReady;
		
		// Cash-Karp coefficients (verified from Numerical Recipes)
		static constexpr Real a2 = 0.2, a3 = 0.3, a4 = 0.6, a5 = 1.0, a6 = 0.875;
		
		static constexpr Real b21 = 0.2;
		static constexpr Real b31 = 3.0/40.0, b32 = 9.0/40.0;
		static constexpr Real b41 = 0.3, b42 = -0.9, b43 = 1.2;
		static constexpr Real b51 = -11.0/54.0, b52 = 2.5, b53 = -70.0/27.0, b54 = 35.0/27.0;
		static constexpr Real b61 = 1631.0/55296.0, b62 = 175.0/512.0, b63 = 575.0/13824.0,
		                      b64 = 44275.0/110592.0, b65 = 253.0/4096.0;
		
		// 5th order weights
		static constexpr Real c1 = 37.0/378.0, c3 = 250.0/621.0, c4 = 125.0/594.0, c6 = 512.0/1771.0;
		
		// Error coefficients (5th - 4th order)
		static constexpr Real dc1 = c1 - 2825.0/27648.0;
		static constexpr Real dc3 = c3 - 18575.0/48384.0;
		static constexpr Real dc4 = c4 - 13525.0/55296.0;
		static constexpr Real dc5 = -277.0/14336.0;
		static constexpr Real dc6 = c6 - 0.25;
		
		// Step size control
		static constexpr Real SAFETY = 0.9;
		static constexpr Real PGROW = -0.2;
		static constexpr Real PSHRNK = -0.25;
		static constexpr Real ERRCON = 1.89e-4;
		
	public:
		explicit CashKarp_Stepper(const IODESystem& sys)
			: _sys(sys), _n(sys.getDim()),
			  _k1(_n), _k2(_n), _k3(_n), _k4(_n), _k5(_n), _k6(_n),
			  _xtemp(_n), _xOld(_n), _xNew(_n),
			  _tOld(0), _hDone(0), _stepReady(false) {}
		
		int stageCount() const override { return 6; }
		int order() const override { return 5; }
		bool isFSAL() const override { return false; }
		const Vector<Real>& getFinalDeriv() const override { return _k6; }  // Not FSAL, but needed for interface
		
		StepResult doStep(Real t, Vector<Real>& x, Vector<Real>& dxdt,
		                  Real htry, Real eps) override
		{
			StepResult result;
			result.accepted = false;
			result.funcEvals = 0;
			
			Real h = htry;
			_k1 = dxdt;
			
			for (;;) {
				// k2
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * b21 * _k1[i];
				_sys.derivs(t + a2 * h, _xtemp, _k2);
				result.funcEvals++;
				
				// k3
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (b31 * _k1[i] + b32 * _k2[i]);
				_sys.derivs(t + a3 * h, _xtemp, _k3);
				result.funcEvals++;
				
				// k4
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (b41 * _k1[i] + b42 * _k2[i] + b43 * _k3[i]);
				_sys.derivs(t + a4 * h, _xtemp, _k4);
				result.funcEvals++;
				
				// k5
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (b51 * _k1[i] + b52 * _k2[i] + b53 * _k3[i] + b54 * _k4[i]);
				_sys.derivs(t + a5 * h, _xtemp, _k5);
				result.funcEvals++;
				
				// k6
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (b61 * _k1[i] + b62 * _k2[i] + b63 * _k3[i] + 
					                        b64 * _k4[i] + b65 * _k5[i]);
				_sys.derivs(t + a6 * h, _xtemp, _k6);
				result.funcEvals++;
				
				// 5th order solution
				for (int i = 0; i < _n; i++)
					_xNew[i] = x[i] + h * (c1 * _k1[i] + c3 * _k3[i] + c4 * _k4[i] + c6 * _k6[i]);
				
				// Error estimate
				Real errMax = 0.0;
				for (int i = 0; i < _n; i++) {
					Real err = h * (dc1 * _k1[i] + dc3 * _k3[i] + dc4 * _k4[i] + 
					               dc5 * _k5[i] + dc6 * _k6[i]);
					Real scale = std::abs(x[i]) + std::abs(h * _k1[i]) + 1e-30;
					errMax = std::max(errMax, std::abs(err) / scale);
				}
				errMax /= eps;
				result.errMax = errMax;
				
				if (errMax <= 1.0) {
					result.accepted = true;
					result.hDone = h;
					
					// Store for dense output
					_tOld = t;
					_hDone = h;
					_xOld = x;
					_stepReady = true;
					
					// Update state
					x = _xNew;
					_sys.derivs(t + h, x, dxdt);  // Compute derivative at new point
					result.funcEvals++;
					
					// Step size for next step
					if (errMax > ERRCON)
						result.hNext = SAFETY * h * std::pow(errMax, PGROW);
					else
						result.hNext = 5.0 * h;
					
					break;
				}
				
				// Reduce step size
				Real htemp = SAFETY * h * std::pow(errMax, PSHRNK);
				h = (h >= 0) ? std::max(htemp, 0.1 * h) : std::min(htemp, 0.1 * h);
				
				if (std::abs(h) < Constants::Eps)
					throw ODESolverError("Step size underflow in CashKarp_Stepper");
			}
			
			return result;
		}
		
		Vector<Real> interpolate(Real t) const override
		{
			if (!_stepReady)
				throw ODESolverError("No valid step data for interpolation");
			
			Real theta = (t - _tOld) / _hDone;
			Real theta2 = theta * theta;
			Real theta3 = theta2 * theta;
			
			// Hermite basis functions
			Real h00 = 2*theta3 - 3*theta2 + 1;
			Real h10 = theta3 - 2*theta2 + theta;
			Real h01 = -2*theta3 + 3*theta2;
			Real h11 = theta3 - theta2;
			
			Vector<Real> result(_n);
			for (int i = 0; i < _n; i++) {
				Real hf0 = _hDone * _k1[i];
				// Approximate f1 from solution difference
				Real hf1 = _hDone * (c1 * _k1[i] + c3 * _k3[i] + c4 * _k4[i] + c6 * _k6[i]);
				result[i] = h00 * _xOld[i] + h10 * hf0 + h01 * _xNew[i] + h11 * hf1;
			}
			
			return result;
		}
		
		void resetFSAL() {
			_stepReady = false;
		}
	};

	//===================================================================================
	//                         DormandPrince8_Stepper
	//===================================================================================
	/// @brief Dormand-Prince 8(7) adaptive stepper with dense output
	/// 
	/// High-order method for problems requiring very tight error control.
	/// Features:
	/// - 8th order accurate solution with 7th order error estimate
	/// - 13 stages (actually 14 with FSAL)
	/// - Hermite dense output
	class DormandPrince8_Stepper : public IAdaptiveStepper {
	private:
		const IODESystem& _sys;
		int _n;
		static constexpr int NSTAGES = 13;  // Number of active stages (not counting FSAL reuse)
		
		// Stage vectors
		std::vector<Vector<Real>> _k;
		Vector<Real> _xtemp, _xNew;
		
		// Dense output data
		Real _tOld, _hDone;
		Vector<Real> _xOld;
		bool _stepReady;
		bool _haveFSAL;
		
		// Nodes (c values) - only 13 needed, last one is 1.0
		static constexpr Real c[13] = {
			0.0, 1.0/18.0, 1.0/12.0, 1.0/8.0, 5.0/16.0, 3.0/8.0,
			59.0/400.0, 93.0/200.0, 5490023248.0/9719169821.0,
			13.0/20.0, 1201146811.0/1299019798.0, 1.0, 1.0
		};
		
		// 8th order weights (for stages 0-12, with last one being FSAL at t+h)
		static constexpr Real b8[13] = {
			14005451.0/335480064.0, 0.0, 0.0, 0.0, 0.0,
			-59238493.0/1068277825.0, 181606767.0/758867731.0,
			561292985.0/797845732.0, -1041891430.0/1371343529.0,
			760417239.0/1151165299.0, 118820643.0/751138087.0,
			-528747749.0/2220607170.0, 1.0/4.0
		};
		
		// 7th order weights (for error estimate)
		static constexpr Real b7[13] = {
			13451932.0/455176623.0, 0.0, 0.0, 0.0, 0.0,
			-808719846.0/976000145.0, 1757004468.0/5645159321.0,
			656045339.0/265891186.0, -3867574721.0/1518517206.0,
			465885868.0/322736535.0, 53011238.0/667516719.0,
			2.0/45.0, 0.0
		};
		
		// Stage coefficients (a matrix rows) - explicit for each stage
		// Row 1: stage 2 depends on stage 1
		static constexpr Real a10 = 1.0/18.0;
		// Row 2: stage 3
		static constexpr Real a20 = 1.0/48.0, a21 = 1.0/16.0;
		// Row 3: stage 4
		static constexpr Real a30 = 1.0/32.0, a32 = 3.0/32.0;
		// Row 4: stage 5
		static constexpr Real a40 = 5.0/16.0, a42 = -75.0/64.0, a43 = 75.0/64.0;
		// Row 5: stage 6
		static constexpr Real a50 = 3.0/80.0, a53 = 3.0/16.0, a54 = 3.0/20.0;
		// Row 6: stage 7
		static constexpr Real a60 = 29443841.0/614563906.0, a63 = 77736538.0/692538347.0,
		                      a64 = -28693883.0/1125000000.0, a65 = 23124283.0/1800000000.0;
		// Row 7: stage 8
		static constexpr Real a70 = 16016141.0/946692911.0, a73 = 61564180.0/158732637.0,
		                      a74 = 22789713.0/633445777.0, a75 = 545815736.0/2771057229.0,
		                      a76 = -180193667.0/1043307555.0;
		// Row 8: stage 9
		static constexpr Real a80 = 39632708.0/573591083.0, a83 = -433636366.0/683701615.0,
		                      a84 = -421739975.0/2616292301.0, a85 = 100302831.0/723423059.0,
		                      a86 = 790204164.0/839813087.0, a87 = 800635310.0/3783071287.0;
		// Row 9: stage 10
		static constexpr Real a90 = 246121993.0/1340847787.0, a93 = -37695042795.0/15268766246.0,
		                      a94 = -309121744.0/1061227803.0, a95 = -12992083.0/490766935.0,
		                      a96 = 6005943493.0/2108947869.0, a97 = 393006217.0/1396673457.0,
		                      a98 = 123872331.0/1001029789.0;
		// Row 10: stage 11
		static constexpr Real a100 = -1028468189.0/846180014.0, a103 = 8478235783.0/508512852.0,
		                      a104 = 1311729495.0/1432422823.0, a105 = -10304129995.0/1701304382.0,
		                      a106 = -48777925059.0/3047939560.0, a107 = 15336726248.0/1032824649.0,
		                      a108 = -45442868181.0/3398467696.0, a109 = 3065993473.0/597172653.0;
		// Row 11: stage 12
		static constexpr Real a110 = 185892177.0/718116043.0, a113 = -3185094517.0/667107341.0,
		                      a114 = -477755414.0/1098053517.0, a115 = -703635378.0/230739211.0,
		                      a116 = 5731566787.0/1027545527.0, a117 = 5232866602.0/850066563.0,
		                      a118 = -4093664535.0/808688257.0, a119 = 3962137247.0/1805957418.0,
		                      a1110 = 65686358.0/487910083.0;
		// Row 12: stage 13 (used for 8th order solution, then becomes FSAL for next step)
		static constexpr Real a120 = 403863854.0/491063109.0, a123 = -5068492393.0/434740067.0,
		                      a124 = -411421997.0/543043805.0, a125 = 652783627.0/914296604.0,
		                      a126 = 11173962825.0/925320556.0, a127 = -13158990841.0/6184727034.0,
		                      a128 = 3936647629.0/1978049680.0, a129 = -160528059.0/685178525.0,
		                      a1210 = 248638103.0/1413531060.0;
		
		// Step size control (for 8th order method)
		static constexpr Real SAFETY = 0.9;
		static constexpr Real MIN_FACTOR = 0.2;
		static constexpr Real MAX_FACTOR = 10.0;
		static constexpr Real BETA = 0.0;   // Simpler controller for stability
		static constexpr Real ALPHA = 1.0/8.0;  // For 8th order: 1/(order+1)
		
		Real _errOld;
		
	public:
		explicit DormandPrince8_Stepper(const IODESystem& sys)
			: _sys(sys), _n(sys.getDim()),
			  _k(NSTAGES, Vector<Real>(_n)),
			  _xtemp(_n), _xNew(_n), _xOld(_n),
			  _tOld(0), _hDone(0), _stepReady(false), _haveFSAL(false),
			  _errOld(1.0) {}
		
		int stageCount() const override { return 13; }
		int order() const override { return 8; }
		bool isFSAL() const override { return true; }
		const Vector<Real>& getFinalDeriv() const override { return _k[12]; }
		
		StepResult doStep(Real t, Vector<Real>& x, Vector<Real>& dxdt,
		                  Real htry, Real eps) override
		{
			StepResult result;
			result.accepted = false;
			result.funcEvals = 0;
			
			Real h = htry;
			
			// FSAL: reuse last stage as first stage
			if (_haveFSAL) {
				_k[0] = _k[12];
			} else {
				_k[0] = dxdt;
			}
			
			for (;;) {
				// Stage 2
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * a10 * _k[0][i];
				_sys.derivs(t + c[1] * h, _xtemp, _k[1]);
				result.funcEvals++;
				
				// Stage 3
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a20 * _k[0][i] + a21 * _k[1][i]);
				_sys.derivs(t + c[2] * h, _xtemp, _k[2]);
				result.funcEvals++;
				
				// Stage 4
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a30 * _k[0][i] + a32 * _k[2][i]);
				_sys.derivs(t + c[3] * h, _xtemp, _k[3]);
				result.funcEvals++;
				
				// Stage 5
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a40 * _k[0][i] + a42 * _k[2][i] + a43 * _k[3][i]);
				_sys.derivs(t + c[4] * h, _xtemp, _k[4]);
				result.funcEvals++;
				
				// Stage 6
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a50 * _k[0][i] + a53 * _k[3][i] + a54 * _k[4][i]);
				_sys.derivs(t + c[5] * h, _xtemp, _k[5]);
				result.funcEvals++;
				
				// Stage 7
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a60 * _k[0][i] + a63 * _k[3][i] + a64 * _k[4][i] + 
					                        a65 * _k[5][i]);
				_sys.derivs(t + c[6] * h, _xtemp, _k[6]);
				result.funcEvals++;
				
				// Stage 8
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a70 * _k[0][i] + a73 * _k[3][i] + a74 * _k[4][i] + 
					                        a75 * _k[5][i] + a76 * _k[6][i]);
				_sys.derivs(t + c[7] * h, _xtemp, _k[7]);
				result.funcEvals++;
				
				// Stage 9
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a80 * _k[0][i] + a83 * _k[3][i] + a84 * _k[4][i] + 
					                        a85 * _k[5][i] + a86 * _k[6][i] + a87 * _k[7][i]);
				_sys.derivs(t + c[8] * h, _xtemp, _k[8]);
				result.funcEvals++;
				
				// Stage 10
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a90 * _k[0][i] + a93 * _k[3][i] + a94 * _k[4][i] + 
					                        a95 * _k[5][i] + a96 * _k[6][i] + a97 * _k[7][i] +
					                        a98 * _k[8][i]);
				_sys.derivs(t + c[9] * h, _xtemp, _k[9]);
				result.funcEvals++;
				
				// Stage 11
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a100 * _k[0][i] + a103 * _k[3][i] + a104 * _k[4][i] + 
					                        a105 * _k[5][i] + a106 * _k[6][i] + a107 * _k[7][i] +
					                        a108 * _k[8][i] + a109 * _k[9][i]);
				_sys.derivs(t + c[10] * h, _xtemp, _k[10]);
				result.funcEvals++;
				
				// Stage 12
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a110 * _k[0][i] + a113 * _k[3][i] + a114 * _k[4][i] + 
					                        a115 * _k[5][i] + a116 * _k[6][i] + a117 * _k[7][i] +
					                        a118 * _k[8][i] + a119 * _k[9][i] + a1110 * _k[10][i]);
				_sys.derivs(t + c[11] * h, _xtemp, _k[11]);
				result.funcEvals++;
				
				// Stage 13 (for 8th order, evaluated at interpolated point, then reused for FSAL)
				for (int i = 0; i < _n; i++)
					_xtemp[i] = x[i] + h * (a120 * _k[0][i] + a123 * _k[3][i] + a124 * _k[4][i] + 
					                        a125 * _k[5][i] + a126 * _k[6][i] + a127 * _k[7][i] +
					                        a128 * _k[8][i] + a129 * _k[9][i] + a1210 * _k[10][i]);
				_sys.derivs(t + h, _xtemp, _k[12]);  // c[12] = 1.0
				result.funcEvals++;
				
				// 8th order solution using all 13 stages
				for (int i = 0; i < _n; i++) {
					_xNew[i] = x[i];
					for (int j = 0; j < NSTAGES; j++)
						_xNew[i] += h * b8[j] * _k[j][i];
				}
				
				// Error estimate (8th - 7th order)
				Real errMax = 0.0;
				for (int i = 0; i < _n; i++) {
					Real err = 0.0;
					for (int j = 0; j < NSTAGES; j++)
						err += (b8[j] - b7[j]) * _k[j][i];
					err *= h;
					Real scale = std::abs(x[i]) + std::abs(h * _k[0][i]) + 1e-30;
					errMax = std::max(errMax, std::abs(err) / scale);
				}
				errMax /= eps;
				result.errMax = errMax;
				
				if (errMax <= 1.0) {
					result.accepted = true;
					result.hDone = h;
					
					// Store for dense output
					_tOld = t;
					_hDone = h;
					_xOld = x;
					_stepReady = true;
					
					// Update state
					x = _xNew;
					dxdt = _k[12];
					_haveFSAL = true;
					
					// Step size control for next step
					Real factor = SAFETY * std::pow(errMax, -ALPHA);
					factor = std::max(MIN_FACTOR, std::min(MAX_FACTOR, factor));
					result.hNext = h * factor;
					
					_errOld = std::max(errMax, 1e-4);
					break;
				}
				
				// Reduce step size
				Real factor = SAFETY * std::pow(errMax, -ALPHA);
				factor = std::max(MIN_FACTOR, factor);
				h *= factor;
				_haveFSAL = false;
				
				if (std::abs(h) < Constants::Eps)
					throw ODESolverError("Step size underflow in DormandPrince8_Stepper");
			}
			
			return result;
		}
		
		Vector<Real> interpolate(Real t) const override
		{
			if (!_stepReady)
				throw ODESolverError("No valid step data for interpolation");
			
			Real theta = (t - _tOld) / _hDone;
			Real theta2 = theta * theta;
			Real theta3 = theta2 * theta;
			
			// Hermite interpolation
			Real h00 = 2*theta3 - 3*theta2 + 1;
			Real h10 = theta3 - 2*theta2 + theta;
			Real h01 = -2*theta3 + 3*theta2;
			Real h11 = theta3 - theta2;
			
			Vector<Real> result(_n);
			
			for (int i = 0; i < _n; i++) {
				Real hf0 = _hDone * _k[0][i];
				Real hf1 = _hDone * _k[12][i];
				result[i] = h00 * _xOld[i] + h10 * hf0 + h01 * _xNew[i] + h11 * hf1;
			}
			
			return result;
		}
		
		void resetFSAL() {
			_haveFSAL = false;
			_stepReady = false;
			_errOld = 1.0;
		}
	};

	//===================================================================================
	//                         BulirschStoer_Stepper
	//===================================================================================
	/// @brief Bulirsch-Stoer adaptive stepper with polynomial extrapolation
	/// 
	/// High-order adaptive method based on modified midpoint rule and extrapolation.
	/// Excellent for smooth problems requiring high accuracy.
	/// 
	/// Method:
	/// 1. Modified midpoint method with n substeps gives O(hÂ²) error
	/// 2. Polynomial extrapolation to hâ†’0 using Neville's algorithm
	/// 3. Adaptive convergence: keep adding sequence elements until error acceptable
	/// 
	/// References:
	/// - Hairer, Norsett, Wanner: "Solving Ordinary Differential Equations I"
	/// - Press et al.: "Numerical Recipes", Chapter 17
	class BulirschStoer_Stepper : public IAdaptiveStepper {
	private:
		const IODESystem& _sys;
		int _n;                     ///< System dimension
		
		// Substep sequence (even numbers for modified midpoint)
		static constexpr int KMAXX = 8;  // Maximum columns in extrapolation
		int _nseq[KMAXX + 1] = {2, 4, 6, 8, 10, 12, 14, 16, 18};
		
		// Working arrays
		mutable Vector<Real> _xOld;      ///< State at t
		mutable Vector<Real> _xNew;      ///< State at t+h
		mutable Vector<Real> _err;       ///< Error estimate
		mutable Real _tOld;              ///< Time at start of step
		mutable Real _hDone;             ///< Actual step size taken
		
		// Extrapolation tableau - stores results at each level
		mutable std::vector<Vector<Real>> _d;  // Differences for Neville
		mutable std::vector<Real> _xCoords;    // x-coordinates for extrapolation
		
		/// @brief Modified midpoint method (Gragg's method)
		/// Computes y(x+H) using nstep substeps of size h = H/nstep
		void mmid(const Vector<Real>& y, const Vector<Real>& dydx, Real xs, 
		          Real htot, int nstep, Vector<Real>& yout) const {
			Real h = htot / nstep;
			Real h2 = 2.0 * h;
			
			Vector<Real> ym = y;
			Vector<Real> yn = y + dydx * h;  // First step
			
			Real x = xs + h;
			Vector<Real> dyn(_n);
			_sys.derivs(x, yn, dyn);
			
			// General step
			for (int n = 1; n < nstep; n++) {
				Vector<Real> swap = ym + dyn * h2;
				ym = yn;
				yn = swap;
				x += h;
				_sys.derivs(x, yn, dyn);
			}
			
			// Last step - smoothing
			yout = (ym + yn + dyn * h) * 0.5;
		}
		
		/// @brief Polynomial extrapolation using Neville's algorithm
		/// Extrapolates sequence of estimates to step size hâ†’0
		void pzextr(int iest, Real xest, const Vector<Real>& yest, 
		            Vector<Real>& yz, Vector<Real>& dy) const {
			// xest = (h/nseq[iest])^2 is the "x-coordinate" for extrapolation
			// yest is the estimate from modified midpoint with nseq[iest] steps
			// yz returns the extrapolated value, dy returns the error estimate
			
			_xCoords[iest] = xest;
			
			if (iest == 0) {
				// First estimate - just copy
				for (int j = 0; j < _n; j++) {
					yz[j] = yest[j];
					dy[j] = yest[j];
					_d[0][j] = yest[j];
				}
			} else {
				// Use Neville's algorithm
				Vector<Real> c = yest;
				
				for (int k = 0; k < iest; k++) {
					Real delta = 1.0 / (_xCoords[iest - k - 1] - xest);
					Real f1 = xest * delta;
					Real f2 = _xCoords[iest - k - 1] * delta;
					
					for (int j = 0; j < _n; j++) {
						Real q = _d[k][j];
						_d[k][j] = dy[j];
						delta = c[j] - q;
						dy[j] = f1 * delta;
						c[j] = f2 * delta;
					}
				}
				
				for (int j = 0; j < _n; j++) {
					yz[j] += dy[j];
					_d[iest][j] = dy[j];
				}
			}
		}
		
	public:
		explicit BulirschStoer_Stepper(const IODESystem& sys)
			: _sys(sys), _n(sys.getDim()), _tOld(0), _hDone(0),
			  _xOld(_n), _xNew(_n), _err(_n)
		{
			// Initialize extrapolation tableau
			_d.resize(KMAXX + 1);
			for (int i = 0; i <= KMAXX; ++i) {
				_d[i] = Vector<Real>(_n);
			}
			_xCoords.resize(KMAXX + 1);
		}
		
		StepResult doStep(Real t, Vector<Real>& x, Vector<Real>& dxdt,
		                  Real htry, Real eps) override {
			StepResult result;
			result.accepted = false;
			result.funcEvals = 1;  // We already have dxdt
			
			_tOld = t;
			_xOld = x;
			Real h = htry;
			
			Vector<Real> ysav = x;
			Vector<Real> yseq(_n), yest(_n), yerr(_n);
			
			// Try step with current h, building up extrapolation tableau
			for (int k = 0; k <= KMAXX; k++) {
				// Modified midpoint with _nseq[k] substeps
				mmid(ysav, dxdt, t, h, _nseq[k], yseq);
				result.funcEvals += _nseq[k];
				
				// The "x-coordinate" for extrapolation is (h/n)^2
				Real xest = (h / _nseq[k]) * (h / _nseq[k]);
				
				// Extrapolate
				pzextr(k, xest, yseq, yest, yerr);
				
				if (k > 0) {  // Need at least 2 points to estimate error
					// Compute scaled error
					Real errMax = 0.0;
					for (int i = 0; i < _n; ++i) {
						Real scale = eps * (std::abs(ysav[i]) + std::abs(yest[i]) + 1e-30);
						Real errRatio = std::abs(yerr[i]) / scale;
						errMax = std::max(errMax, errRatio);
					}
					
					result.errMax = errMax;
					
					if (errMax < 1.0) {
						// Converged!
						result.accepted = true;
						_xNew = yest;
						_err = yerr;
						_hDone = h;
						
						x = yest;
						_sys.derivs(t + h, x, dxdt);
						result.funcEvals++;
						result.hDone = h;
						
						// Step size control - be conservative
						Real factor = 0.9 * std::pow(errMax, -1.0 / (2 * k + 1));
						factor = std::max(0.1, std::min(factor, 4.0));
						result.hNext = h * factor;
						
						return result;
					}
				}
			}
			
			// Failed to converge - reduce step size
			result.accepted = false;
			result.hDone = h;
			result.hNext = h * 0.5;
			result.errMax = 999.0;
			
			return result;
		}
		
		Vector<Real> interpolate(Real t) const override {
			// Simple linear interpolation
			Real theta = (t - _tOld) / _hDone;
			return _xOld * (1.0 - theta) + _xNew * theta;
		}
		
		bool isFSAL() const override { return false; }
		
		const Vector<Real>& getFinalDeriv() const override {
			static Vector<Real> dummy;
			return dummy;
		}
		
		int stageCount() const override { return KMAXX; }
		
		int order() const override { return 2 * KMAXX; }
		
		void resetFSAL() { }
	};

	//===================================================================================
	//                      BulirschStoerRational_Stepper
	//===================================================================================
	/// @brief Bulirsch-Stoer stepper with Bulirsch's original step sequence
	/// 
	/// Variant using Bulirsch's recommended sequence {2,4,6,8,12,16,24,32,48}
	/// instead of the simple even sequence {2,4,6,8,10,12,14,16,18}.
	/// Uses polynomial extrapolation (rational extrapolation is numerically unstable).
	/// 
	/// The Bulirsch sequence can be more efficient for certain problems as it
	/// allows larger jumps in the extrapolation tableau.
	/// 
	/// References:
	/// - Stoer & Bulirsch: "Introduction to Numerical Analysis"
	/// - Press et al.: "Numerical Recipes", Chapter 17
	class BulirschStoerRational_Stepper : public IAdaptiveStepper {
	private:
		const IODESystem& _sys;
		int _n;                     ///< System dimension
		
		// Bulirsch's original step sequence (more aggressive growth)
		static constexpr int KMAXX = 8;  // Maximum columns in extrapolation
		int _nseq[KMAXX + 1] = {2, 4, 6, 8, 12, 16, 24, 32, 48};
		
		// Working arrays
		mutable Vector<Real> _xOld;      ///< State at t
		mutable Vector<Real> _xNew;      ///< State at t+h
		mutable Vector<Real> _err;       ///< Error estimate
		mutable Real _tOld;              ///< Time at start of step
		mutable Real _hDone;             ///< Actual step size taken
		
		// Extrapolation tableau for rational extrapolation
		mutable std::vector<Vector<Real>> _d;  // Differences for rational extrapolation
		mutable std::vector<Real> _xCoords;    // x-coordinates for extrapolation
		
		/// @brief Modified midpoint method (Gragg's method)
		/// Computes y(x+H) using nstep substeps of size h = H/nstep
		void mmid(const Vector<Real>& y, const Vector<Real>& dydx, Real xs, 
		          Real htot, int nstep, Vector<Real>& yout) const {
			Real h = htot / nstep;
			Real h2 = 2.0 * h;
			
			Vector<Real> ym = y;
			Vector<Real> yn = y + dydx * h;  // First step
			
			Real x = xs + h;
			Vector<Real> dyn(_n);
			_sys.derivs(x, yn, dyn);
			
			// General step
			for (int n = 1; n < nstep; n++) {
				Vector<Real> swap = ym + dyn * h2;
				ym = yn;
				yn = swap;
				x += h;
				_sys.derivs(x, yn, dyn);
			}
			
			// Last step - smoothing
			yout = (ym + yn + dyn * h) * 0.5;
		}
		
		/// @brief Polynomial extrapolation (same as pzextr but for rational stepper)
		/// Note: True rational extrapolation is numerically unstable in many cases.
		/// This uses polynomial extrapolation which is more robust.
		/// The difference from BulirschStoer_Stepper is the step sequence used.
		void rzextr(int iest, Real xest, const Vector<Real>& yest, 
		            Vector<Real>& yz, Vector<Real>& dy) const {
			// Store x-coordinate for this estimate  
			_xCoords[iest] = xest;
			
			if (iest == 0) {
				// First point - just copy
				for (int j = 0; j < _n; j++) {
					yz[j] = yest[j];
					dy[j] = yest[j];
					_d[0][j] = yest[j];
				}
				return;
			}
			
			// Use Neville's polynomial extrapolation (same as pzextr)
			// This is more stable than rational extrapolation
			Vector<Real> c = yest;
			
			for (int k = 0; k < iest; k++) {
				Real delta = 1.0 / (_xCoords[iest - k - 1] - xest);
				Real f1 = xest * delta;
				Real f2 = _xCoords[iest - k - 1] * delta;
				
				for (int j = 0; j < _n; j++) {
					Real q = _d[k][j];
					_d[k][j] = dy[j];
					Real diff = c[j] - q;
					dy[j] = f1 * diff;
					c[j] = f2 * diff;
				}
			}
			
			for (int j = 0; j < _n; j++) {
				yz[j] += dy[j];
				_d[iest][j] = dy[j];
			}
		}
		
	public:
		explicit BulirschStoerRational_Stepper(const IODESystem& sys)
			: _sys(sys), _n(sys.getDim()), _tOld(0), _hDone(0),
			  _xOld(_n), _xNew(_n), _err(_n)
		{
			// Initialize extrapolation tableau
			_d.resize(KMAXX + 1);
			for (int i = 0; i <= KMAXX; ++i) {
				_d[i] = Vector<Real>(_n);
			}
			_xCoords.resize(KMAXX + 1);
		}
		
		StepResult doStep(Real t, Vector<Real>& x, Vector<Real>& dxdt,
		                  Real htry, Real eps) override {
			StepResult result;
			result.accepted = false;
			result.funcEvals = 1;  // We already have dxdt
			
			_tOld = t;
			_xOld = x;
			Real h = htry;
			
			Vector<Real> ysav = x;
			Vector<Real> yseq(_n), yest(_n), yerr(_n);
			
			// Try step with current h, building up extrapolation tableau
			for (int k = 0; k <= KMAXX; k++) {
				// Modified midpoint with _nseq[k] substeps
				mmid(ysav, dxdt, t, h, _nseq[k], yseq);
				result.funcEvals += _nseq[k];
				
				// The "x-coordinate" for extrapolation is (h/n)^2
				Real xest = (h / _nseq[k]) * (h / _nseq[k]);
				
				// Rational extrapolation
				rzextr(k, xest, yseq, yest, yerr);
				
				if (k > 0) {  // Need at least 2 points to estimate error
					// Compute scaled error
					Real errMax = 0.0;
					for (int i = 0; i < _n; ++i) {
						Real scale = eps * (std::abs(ysav[i]) + std::abs(yest[i]) + 1e-30);
						Real errRatio = std::abs(yerr[i]) / scale;
						errMax = std::max(errMax, errRatio);
					}
					
					result.errMax = errMax;
					
					if (errMax < 1.0) {
						// Converged!
						result.accepted = true;
						_xNew = yest;
						_err = yerr;
						_hDone = h;
						
						x = yest;
						_sys.derivs(t + h, x, dxdt);
						result.funcEvals++;
						result.hDone = h;
						
						// Step size control - be conservative
						Real factor = 0.9 * std::pow(errMax, -1.0 / (2 * k + 1));
						factor = std::max(0.1, std::min(factor, 4.0));
						result.hNext = h * factor;
						
						return result;
					}
				}
			}
			
			// Failed to converge - reduce step size
			result.accepted = false;
			result.hDone = h;
			result.hNext = h * 0.5;
			result.errMax = 999.0;
			
			return result;
		}
		
		Vector<Real> interpolate(Real t) const override {
			// Simple linear interpolation
			Real theta = (t - _tOld) / _hDone;
			return _xOld * (1.0 - theta) + _xNew * theta;
		}
		
		bool isFSAL() const override { return false; }
		
		const Vector<Real>& getFinalDeriv() const override {
			static Vector<Real> dummy;
			return dummy;
		}
		
		int stageCount() const override { return KMAXX; }
		
		int order() const override { return 2 * KMAXX; }
		
		void resetFSAL() { }
	};

	//===================================================================================
	//                           ODEAdaptiveIntegrator
	//===================================================================================
	/// @brief Adaptive ODE integrator with dense output support
	/// 
	/// This integrator uses an adaptive stepper to efficiently solve ODEs while
	/// providing solution output at user-specified fixed intervals (dense output).
	/// 
	/// Key features:
	/// - Adaptive step size control for efficiency and accuracy
	/// - Dense output: solution at arbitrary times without extra function evals
	/// - FSAL optimization when supported by stepper
	/// - Detailed statistics for performance analysis
	template<typename Stepper = DormandPrince5_Stepper>
	class ODEAdaptiveIntegrator {
	private:
		const IODESystem& _sys;
		Stepper _stepper;
		SolutionStatistics _stats;
		
	public:
		/// @brief Construct integrator for given ODE system
		explicit ODEAdaptiveIntegrator(const IODESystem& sys)
			: _sys(sys), _stepper(sys) {}
		
		/// @brief Get integration statistics from last solve
		const SolutionStatistics& getStatistics() const { return _stats; }
		
		/// @brief Estimate initial step size
		/// Uses Hairer's formula based on local error estimation
		Real estimateInitialStep(Real t0, const Vector<Real>& x0, Real tEnd, Real eps)
		{
			int n = _sys.getDim();
			Vector<Real> f0(n), f1(n), x1(n);
			
			_sys.derivs(t0, x0, f0);
			
			// Estimate scale of problem
			Real d0 = 0, d1 = 0;
			for (int i = 0; i < n; i++) {
				Real scale = std::abs(x0[i]) + 1e-10;
				d0 = std::max(d0, std::abs(x0[i]) / scale);
				d1 = std::max(d1, std::abs(f0[i]) / scale);
			}
			
			// Initial guess
			Real h0 = (d0 < 1e-5 || d1 < 1e-5) ? 1e-6 : 0.01 * d0 / d1;
			h0 = std::min(h0, std::abs(tEnd - t0));
			
			// Take one explicit Euler step
			for (int i = 0; i < n; i++)
				x1[i] = x0[i] + h0 * f0[i];
			_sys.derivs(t0 + h0, x1, f1);
			
			// Estimate second derivative
			Real d2 = 0;
			for (int i = 0; i < n; i++) {
				Real scale = std::abs(x0[i]) + 1e-10;
				d2 = std::max(d2, std::abs(f1[i] - f0[i]) / scale / h0);
			}
			
			// Optimal step for 5th order method
			Real h1;
			if (std::max(d1, d2) <= 1e-15) {
				h1 = std::max(1e-6, h0 * 1e-3);
			} else {
				h1 = std::pow(0.01 / std::max(d1, d2), 1.0 / 5.0);
			}
			
			return std::min({100 * h0, h1, std::abs(tEnd - t0)});
		}

		/// @brief Integrate ODE system with dense output at fixed intervals
		/// @param x0 Initial conditions
		/// @param t0 Initial time
		/// @param tEnd Final time
		/// @param outputInterval Spacing between output points (dense output)
		/// @param eps Error tolerance (default 1e-10)
		/// @param h0 Initial step size (0 = auto-estimate)
		/// @return Solution with points at regular intervals
		ODESystemSolution integrate(const Vector<Real>& x0, Real t0, Real tEnd,
		                            Real outputInterval, Real eps = 1e-10, Real h0 = 0)
		{
			int n = _sys.getDim();
			int numOutputPoints = static_cast<int>(std::ceil((tEnd - t0) / outputInterval)) + 1;
			
			ODESystemSolution sol(t0, tEnd, n, numOutputPoints - 1);
			_stats.reset();
			_stepper.resetFSAL();
			
			// Initialize
			Vector<Real> x = x0;
			Vector<Real> dxdt(n);
			Real t = t0;
			
			_sys.derivs(t, x, dxdt);
			
			// Initial step size
			Real h = (h0 > 0) ? h0 : estimateInitialStep(t0, x0, tEnd, eps);
			h = std::min(h, tEnd - t0);
			
			// Store initial point
			Real tNextOutput = t0;
			int outputIdx = 0;
			sol.fillValues(outputIdx++, t0, x0);
			tNextOutput += outputInterval;
			
			// Main integration loop
			while (t < tEnd - Constants::Eps) {
				// Don't step past end
				if (t + h > tEnd) {
					h = tEnd - t;
				}
				
				StepResult result = _stepper.doStep(t, x, dxdt, h, eps);
				_stats.recordStep(result);
				
				if (result.accepted) {
					Real tNew = t + result.hDone;
					
					// Dense output: interpolate at all output points within this step
					while (tNextOutput <= tNew + Constants::Eps && outputIdx < numOutputPoints) {
						if (tNextOutput <= tNew) {
							Vector<Real> xInterp = _stepper.interpolate(tNextOutput);
							sol.fillValues(outputIdx++, tNextOutput, xInterp);
						}
						tNextOutput += outputInterval;
					}
					
					t = tNew;
					h = result.hNext;
					
					// FSAL: derivative already updated in x and dxdt by doStep
				} else {
					// Step rejected, try again with smaller step
					h = result.hNext;
				}
				
				// Safety check
				if (h < Constants::Eps) {
					throw ODESolverError("Step size too small in ODEAdaptiveIntegrator");
				}
			}
			
			// Ensure final point is captured
			if (outputIdx < numOutputPoints) {
				sol.fillValues(outputIdx++, tEnd, x);
			}
			
			return sol;
		}

		/// @brief Integrate and return solution at specified times
		/// @param x0 Initial conditions
		/// @param times Vector of output times (must be sorted ascending)
		/// @param eps Error tolerance
		/// @return Solution at specified times
		ODESystemSolution integrateAt(const Vector<Real>& x0, const Vector<Real>& times,
		                              Real eps = 1e-10, Real h0 = 0)
		{
			if (times.size() < 2) {
				throw ODESolverError("Need at least 2 output times");
			}
			
			int n = _sys.getDim();
			int numPoints = static_cast<int>(times.size());
			Real t0 = times[0];
			Real tEnd = times[numPoints - 1];
			
			ODESystemSolution sol(t0, tEnd, n, numPoints - 1);
			_stats.reset();
			_stepper.resetFSAL();
			
			Vector<Real> x = x0;
			Vector<Real> dxdt(n);
			Real t = t0;
			
			_sys.derivs(t, x, dxdt);
			
			Real h = (h0 > 0) ? h0 : estimateInitialStep(t0, x0, tEnd, eps);
			
			// Store initial point
			int outputIdx = 0;
			sol.fillValues(outputIdx++, t0, x0);
			
			// Integration loop
			while (outputIdx < numPoints) {
				Real tTarget = times[outputIdx];
				
				if (t + h > tTarget) {
					h = tTarget - t;
				}
				
				StepResult result = _stepper.doStep(t, x, dxdt, h, eps);
				_stats.recordStep(result);
				
				if (result.accepted) {
					Real tNew = t + result.hDone;
					
					// Output at any times within this step
					while (outputIdx < numPoints && times[outputIdx] <= tNew + Constants::Eps) {
						Real tOut = times[outputIdx];
						if (std::abs(tOut - tNew) < Constants::Eps) {
							sol.fillValues(outputIdx++, tNew, x);
						} else {
							Vector<Real> xInterp = _stepper.interpolate(tOut);
							sol.fillValues(outputIdx++, tOut, xInterp);
						}
					}
					
					t = tNew;
					h = result.hNext;
				} else {
					h = result.hNext;
				}
				
				if (h < Constants::Eps && t < tEnd - Constants::Eps) {
					throw ODESolverError("Step size too small in ODEAdaptiveIntegrator");
				}
			}
			
			return sol;
		}
	};

	// Convenient type aliases
	using DormandPrince5Integrator = ODEAdaptiveIntegrator<DormandPrince5_Stepper>;
	using CashKarpIntegrator = ODEAdaptiveIntegrator<CashKarp_Stepper>;
	using DormandPrince8Integrator = ODEAdaptiveIntegrator<DormandPrince8_Stepper>;
	using BulirschStoerIntegrator = ODEAdaptiveIntegrator<BulirschStoer_Stepper>;
	using BulirschStoerRationalIntegrator = ODEAdaptiveIntegrator<BulirschStoerRational_Stepper>;
	using BulirschStoerBulirschSeqIntegrator = ODEAdaptiveIntegrator<BulirschStoerRational_Stepper>;  // Alias with clearer name

} // namespace MML


///////////////////////////   mml/algorithms/ODESystemSolver.h   ///////////////////////////





namespace MML
{
	///////////////////////////////////////////////////////////////////////////////////////////
	/// @brief      LEGACY: Adaptive-step ODE system solver with pluggable stepper
	///
	/// @deprecated Prefer using CashKarpIntegrator, DormandPrince5Integrator, or
	///             DormandPrince8Integrator directly from ODEAdaptiveIntegrator.h
	///
	/// This class provides backward compatibility for code using the old interface.
	/// It delegates to the new ODEAdaptiveIntegrator infrastructure.
	///
	/// @tparam Stepper The stepper type (e.g., RK5_CashKarp_Stepper)
	///
	/// @example Legacy usage (still works):
	/// @code
	///   ODESystemSolver<RK5_CashKarp_Stepper> solver(system);
	///   auto solution = solver.integrate(initCond, t1, t2, saveInterval, eps, h1, hmin);
	/// @endcode
	///
	/// @example New preferred usage:
	/// @code
	///   CashKarpIntegrator integrator(system);
	///   auto solution = integrator.integrate(initCond, t1, t2, saveInterval, eps);
	/// @endcode
	///////////////////////////////////////////////////////////////////////////////////////////
	template<class Stepper>
	class ODESystemSolver
	{
		const IODESystem& _sys;

	public:
		/// @brief Construct solver for given ODE system
		/// @param sys The ODE system to solve
		ODESystemSolver(const IODESystem& sys) : _sys(sys) {}

		int getDim() { return _sys.getDim(); }

		/// @brief Integrate ODE system with adaptive step control (legacy interface)
		/// @param initCond Initial conditions vector
		/// @param t1 Start time
		/// @param t2 End time
		/// @param minSaveInterval Minimum interval between saved points
		/// @param eps Error tolerance
		/// @param h1 Initial step size guess (ignored in new implementation - auto-estimated)
		/// @param hmin Minimum step size (ignored in new implementation)
		/// @return ODESystemSolution with integration results
		ODESystemSolution integrate(const Vector<Real>& initCond,
		                            Real t1, Real t2, Real minSaveInterval,
		                            Real eps, Real h1, Real hmin = 0)
		{
			// Use the new adaptive integrator with Cash-Karp stepper
			// h1 and hmin are ignored - new implementation auto-estimates initial step
			// and has better step-size control
			ODEAdaptiveIntegrator<CashKarp_Stepper> integrator(_sys);
			return integrator.integrate(initCond, t1, t2, minSaveInterval, eps, h1);
		}
	};

	// Convenience type alias for most common usage
	using AdaptiveODESolver = ODESystemSolver<RK5_CashKarp_Stepper>;
	/// @brief Fixed-step ODE system solver
	/// 
	/// This class provides a simple fixed-step integration method using
	/// pluggable step calculators (Euler, RK4, etc.)
	/// 
	/// @note For adaptive step-size control, use ODEAdaptiveIntegrator instead.
	/// 
	/// @warning LIFETIME REQUIREMENT: The IODESystem and IODESystemStepCalculator references
	///          must remain valid for the entire lifetime of this solver object.
	class ODESystemFixedStepSolver
	{
		const IODESystem& _odeSys;
		const IODESystemStepCalculator& _stepCalc;

	public:
		/// @brief Construct solver with system and step calculator
		/// @warning The references must outlive this solver instance
		ODESystemFixedStepSolver(const IODESystem& inOdeSys, const IODESystemStepCalculator& inStepCalc)
			: _odeSys(inOdeSys), _stepCalc(inStepCalc) {
		}

		/// @brief Integrate the ODE system with fixed step size
		/// @param initCond Initial conditions vector
		/// @param t1 Start time
		/// @param t2 End time
		/// @param numSteps Number of steps to take
		/// @return ODESystemSolution with numSteps+1 values
		ODESystemSolution integrate(const Vector<Real>& initCond, Real t1, Real t2, int numSteps)
		{
			int dim = _odeSys.getDim();

			ODESystemSolution sol(t1, t2, dim, numSteps);
			Vector<Real> x(initCond), x_out(dim), dxdt(dim), x_err(dim);

			sol.fillValues(0, t1, x);		// store initial values

			Real t = t1;
			Real h = (t2 - t1) / numSteps;

			for (int k = 1; k <= numSteps; k++) {
				_odeSys.derivs(t, x, dxdt);
				_stepCalc.calcStep(_odeSys, t, x, dxdt, h, x_out, x_err);
				t += h;
				x = x_out;
				sol.fillValues(k, t, x);
			}

			return sol;
		}
	};

	/// @brief Leapfrog (Velocity Verlet) integrator for Hamiltonian systems
	/// 
	/// Symplectic method that conserves energy for long-time integration.
	/// Expects state vector split as [positions..., velocities...].
	class ODESystemLeapfrogSolver
	{
		IODESystem& _odeSys;

	public:
		ODESystemLeapfrogSolver(IODESystem& inOdeSys) : _odeSys(inOdeSys) {}

		ODESystemSolution integrate(const Vector<Real>& initCond, Real t1, Real t2, int numSteps)
		{
			int dim = _odeSys.getDim();
			int half_n = dim / 2;
			ODESystemSolution sol(t1, t2, dim, numSteps);

			Vector<Real> x(initCond);
			Vector<Real> dxdt(dim);
			Vector<Real> x_out(dim);

			sol.fillValues(0, t1, x);

			Real t = t1;
			Real h = (t2 - t1) / numSteps;

			for (int k = 1; k <= numSteps; k++) {
				_odeSys.derivs(t, x, dxdt);

				// Half-step velocity
				Vector<Real> v_half(half_n);
				for (int i = 0; i < half_n; ++i)
					v_half[i] = x[half_n + i] + 0.5 * h * dxdt[half_n + i];

				// Full-step position
				for (int i = 0; i < half_n; ++i)
					x_out[i] = x[i] + h * v_half[i];

				// Compute new acceleration
				Vector<Real> x_next = x_out;
				for (int i = 0; i < half_n; ++i)
					x_next[half_n + i] = v_half[i];

				Vector<Real> dxdt_next(dim);
				_odeSys.derivs(t + h, x_next, dxdt_next);

				// Full-step velocity
				for (int i = 0; i < half_n; ++i)
					x_out[half_n + i] = v_half[i] + 0.5 * h * dxdt_next[half_n + i];

				t += h;
				x = x_out;
				sol.fillValues(k, t, x);
			}

			return sol;
		}
	};

} // namespace MML


///////////////////////////   mml/algorithms/ODEStiffSolvers.h   ///////////////////////////



namespace MML 
{
	///////////////////////////////////////////////////////////////////////////////////////////
	//                           BACKWARD EULER METHOD                                        //
	///////////////////////////////////////////////////////////////////////////////////////////

	/// @brief Backward Euler implicit solver for stiff ODEs
	/// @details First-order implicit method: y_{n+1} = y_n + h*f(t_{n+1}, y_{n+1})
	///          Unconditionally stable (A-stable), good for very stiff systems.
	///          Uses Newton iteration to solve the implicit equation.
	/// @param system ODE system with Jacobian (must implement IODESystemWithJacobian)
	/// @param t0 Initial time
	/// @param y0 Initial condition vector
	/// @param t_end Final time
	/// @param h Step size (fixed)
	/// @param max_newton_iter Maximum Newton iterations per step (default: 10)
	/// @param newton_tol Newton convergence tolerance (default: 1e-8)
	/// @return ODESystemSolution containing solution trajectory
	inline ODESystemSolution SolveBackwardEuler(IODESystemWithJacobian& system, Real t0, const Vector<Real>& y0, Real t_end, Real h,
												int max_newton_iter = 10, Real newton_tol = 1e-8) {
		int dim = y0.size();
		int num_steps = static_cast<int>((t_end - t0) / h) + 1;

		ODESystemSolution sol(t0, t_end, dim, num_steps);

		Real t = t0;
		Vector<Real> y = y0;
		Vector<Real> dydt(dim);
		Matrix<Real> J(dim, dim);

		// Save initial condition
		sol.fillValues(0, t, y);
		int step = 1;

		while (t < t_end && step < num_steps) {
			Real h_actual = std::min(h, t_end - t);
			Real t_next = t + h_actual;

			// Newton iteration to solve: y_new - y - h*f(t_next, y_new) = 0
			Vector<Real> y_new = y; // Initial guess

			bool converged = false;
			for (int iter = 0; iter < max_newton_iter; ++iter) {
				// Evaluate f and Jacobian at current guess
				system.derivs(t_next, y_new, dydt);
				system.jacobian(t_next, y_new, dydt, J);

				// Residual: r = y_new - y - h*f(t_next, y_new)
				Vector<Real> residual = y_new - y - dydt * h_actual;

				// Check convergence
				Real res_norm = residual.NormL2();
				if (res_norm < newton_tol) {
					converged = true;
					break;
				}

				// Newton step: solve (I - h*J)*delta = -residual
				Matrix<Real> A = Matrix<Real>::GetUnitMatrix(dim) - J * h_actual;
				Vector<Real> rhs = residual * (-1.0);
				GaussJordanSolver<Real>::SolveInPlace(A, rhs);
				Vector<Real> delta = rhs; // Solution is in rhs after SolveInPlace

				// Update guess
				y_new = y_new + delta;
			}

			if (!converged) {
				throw std::runtime_error("Backward Euler: Newton iteration failed to converge at t=" + std::to_string(t_next));
			}

			// Accept step
			y = y_new;
			t = t_next;
			sol.fillValues(step, t, y);
			sol.incrementSuccessfulSteps();
			++step;
		}

		// step is now one past the last filled index
		sol.setFinalSize(step - 1);
		return sol;
	}

	///////////////////////////////////////////////////////////////////////////////////////////
	//                            BDF2 METHOD                                                 //
	///////////////////////////////////////////////////////////////////////////////////////////

	/// @brief Second-order Backward Differentiation Formula solver
	/// @details BDF2 formula: y_{n+1} = (4/3)*y_n - (1/3)*y_{n-1} + (2/3)*h*f(t_{n+1}, y_{n+1})
	///          A-stable, industry standard for moderately stiff problems.
	///          Uses Backward Euler for first step, then switches to BDF2.
	/// @param system ODE system with Jacobian
	/// @param t0 Initial time
	/// @param y0 Initial condition vector
	/// @param t_end Final time
	/// @param h Step size (fixed)
	/// @param max_newton_iter Maximum Newton iterations per step (default: 10)
	/// @param newton_tol Newton convergence tolerance (default: 1e-8)
	/// @return ODESystemSolution containing solution trajectory
	inline ODESystemSolution SolveBDF2(IODESystemWithJacobian& system, Real t0, const Vector<Real>& y0, Real t_end, Real h,
									   int max_newton_iter = 10, Real newton_tol = 1e-8) {
		int dim = y0.size();
		int num_steps = static_cast<int>((t_end - t0) / h) + 1;

		ODESystemSolution sol(t0, t_end, dim, num_steps);

		Real t = t0;
		Vector<Real> y = y0;
		Vector<Real> y_prev(dim); // For BDF2, we need previous step
		Vector<Real> dydt(dim);
		Matrix<Real> J(dim, dim);

		// Save initial condition
		sol.fillValues(0, t, y);
		int step = 1;

		// First step: Use Backward Euler (BDF1) to bootstrap
		if (step < num_steps) {
			Real h_actual = std::min(h, t_end - t);
			Real t_next = t + h_actual;

			Vector<Real> y_new = y;
			bool converged = false;

			for (int iter = 0; iter < max_newton_iter; ++iter) {
				system.derivs(t_next, y_new, dydt);
				system.jacobian(t_next, y_new, dydt, J);

				Vector<Real> residual = y_new - y - dydt * h_actual;
				Real res_norm = residual.NormL2();

				if (res_norm < newton_tol) {
					converged = true;
					break;
				}

				Matrix<Real> A = Matrix<Real>::GetUnitMatrix(dim) - J * h_actual;
				Vector<Real> rhs = residual * (-1.0);
				GaussJordanSolver<Real>::SolveInPlace(A, rhs);
				Vector<Real> delta = rhs;
				y_new = y_new + delta;
			}

			if (!converged) {
				throw std::runtime_error("BDF2: Bootstrap step failed at t=" + std::to_string(t_next));
			}

			y_prev = y;
			y = y_new;
			t = t_next;
			sol.fillValues(step, t, y);
			sol.incrementSuccessfulSteps();
			++step;
		}

		// Subsequent steps: Use BDF2
		while (t < t_end && step < num_steps) {
			Real h_actual = std::min(h, t_end - t);
			Real t_next = t + h_actual;

			// BDF2: y_{n+1} = (4/3)*y_n - (1/3)*y_{n-1} + (2/3)*h*f(t_{n+1}, y_{n+1})
			// Rearrange: y_{n+1} - (2/3)*h*f(t_{n+1}, y_{n+1}) = (4/3)*y_n - (1/3)*y_{n-1}

			Vector<Real> y_new = y * 2.0 - y_prev; // Extrapolation as initial guess
			Vector<Real> rhs = y * (4.0 / 3.0) - y_prev * (1.0 / 3.0);

			bool converged = false;
			for (int iter = 0; iter < max_newton_iter; ++iter) {
				system.derivs(t_next, y_new, dydt);
				system.jacobian(t_next, y_new, dydt, J);

				// Residual: r = y_new - (2/3)*h*f - rhs
				Vector<Real> residual = y_new - dydt * (2.0 / 3.0 * h_actual) - rhs;
				Real res_norm = residual.NormL2();

				if (res_norm < newton_tol) {
					converged = true;
					break;
				}

				// Newton step: solve (I - (2/3)*h*J)*delta = -residual
				Matrix<Real> A = Matrix<Real>::GetUnitMatrix(dim) - J * (2.0 / 3.0 * h_actual);
				Vector<Real> rhs = residual * (-1.0);
				GaussJordanSolver<Real>::SolveInPlace(A, rhs);
				Vector<Real> delta = rhs;
				y_new = y_new + delta;
			}

			if (!converged) {
				throw std::runtime_error("BDF2: Newton iteration failed at t=" + std::to_string(t_next));
			}

			// Accept step
			y_prev = y;
			y = y_new;
			t = t_next;
			sol.fillValues(step, t, y);
			sol.incrementSuccessfulSteps();
			++step;
		}

		sol.setFinalSize(step - 1);
		return sol;
	}

	///////////////////////////////////////////////////////////////////////////////////////////
	//                         ROSENBROCK METHOD                                                //
	///////////////////////////////////////////////////////////////////////////////////////////

	/// @brief Rosenbrock semi-implicit method with adaptive stepping
	/// @details Semi-implicit Runge-Kutta method that uses approximate Jacobian.
	///          Uses a 2-stage L-stable Rosenbrock method (ROS2) with embedded
	///          error estimation. Well-suited for moderately stiff problems.
	///          Formula: (I - h*Î³*J)*k_i = h*f(...) + Î£(Î³_ij * k_j) for each stage
	/// 
	/// The key advantage of Rosenbrock methods is that they only require ONE
	/// Jacobian evaluation and LU decomposition per step (not per stage).
	/// 
	/// References:
	/// - Shampine, "Implementation of Rosenbrock methods" (1982)
	/// - Hairer & Wanner, "Solving ODEs II" (1996), Section IV.7
	class Rosenbrock23Solver {
	private:
		IODESystemWithJacobian& _system;
		Real _abs_tol;
		Real _rel_tol;

		// ROS2 coefficients - 2-stage, 2nd order, L-stable method
		// Î³ = 1 + 1/sqrt(2) â‰ˆ 1.707 for L-stability
		const Real gamma_ros = 1.7071067811865475;  // 1.0 + 0.5 * sqrt(2)

	public:
		Rosenbrock23Solver(IODESystemWithJacobian& system, Real abs_tol = 1e-6, Real rel_tol = 1e-6, 
		                   int /*max_newton_iter*/ = 10, Real /*newton_tol*/ = 1e-8)
			: _system(system)
			, _abs_tol(abs_tol)
			, _rel_tol(rel_tol) {}

		/// @brief Take one Rosenbrock step with error estimation
		/// @param t Current time
		/// @param y Current solution
		/// @param h Step size to attempt
		/// @param y_out Output: 2nd order solution
		/// @param y_err Output: Error estimate
		/// @return true if step successful, false if linear solve failed
		bool Step(Real t, const Vector<Real>& y, Real h, Vector<Real>& y_out, Vector<Real>& y_err) {
			const int dim = y.size();
			
			// DEBUG: Check dimension
			if (dim <= 0 || dim > 1000) {
				throw std::runtime_error("Rosenbrock::Step - invalid dimension: " + std::to_string(dim));
			}
			
			Vector<Real> dydt(dim);
			Matrix<Real> J(dim, dim);

			// Evaluate f and Jacobian at (t, y)
			_system.derivs(t, y, dydt);
			_system.jacobian(t, y, dydt, J);

			// Form matrix W = I - h*Î³*J (same for all stages)
			Matrix<Real> W = Matrix<Real>::GetUnitMatrix(dim) - J * (h * gamma_ros);

			// Stage 1: Solve W*k1 = h*f(t, y)
			Vector<Real> k1 = dydt * h;
			Matrix<Real> W_copy = W;
			try {
				GaussJordanSolver<Real>::SolveInPlace(W_copy, k1);
			} catch (...) {
				return false;  // Linear solve failed
			}

			// Stage 2: Solve W*k2 = h*f(t + h, y + k1) - 2*k1
			Vector<Real> y2 = y + k1;
			Vector<Real> f2(dim);
			_system.derivs(t + h, y2, f2);
			Vector<Real> rhs2 = f2 * h - k1 * 2.0;
			Vector<Real> k2 = rhs2;
			W_copy = W;
			try {
				GaussJordanSolver<Real>::SolveInPlace(W_copy, k2);
			} catch (...) {
				return false;
			}

			// 2nd order solution: y_new = y + 1.5*k1 + 0.5*k2
			y_out = y + k1 * 1.5 + k2 * 0.5;

			// 1st order solution: y1 = y + k1
			// Error = y_new - y1 = 0.5*k1 + 0.5*k2
			y_err = (k1 + k2) * 0.5;

			return true;
		}

		/// @brief Solve ODE system with adaptive stepping
		/// @param t0 Initial time
		/// @param y0 Initial condition
		/// @param t_end Final time
		/// @param h_init Initial step size
		/// @return Solution trajectory
		ODESystemSolution Solve(Real t0, const Vector<Real>& y0, Real t_end, Real h_init) {
			int dim = y0.size();
			int max_steps = 50000; // Safety limit (storage grows dynamically if needed)

			ODESystemSolution sol(t0, t_end, dim, max_steps);

			Real t = t0;
			Vector<Real> y = y0;
			Real h = h_init;
			
			// Safety factors for step size control
			const Real safety = 0.9;
			const Real h_min = 1e-12;     // Minimum step size
			const Real h_max = h_init * 100.0;  // Maximum step size
			const Real fac_max = 5.0;     // Maximum step increase factor
			const Real fac_min = 0.2;     // Minimum step decrease factor

			sol.fillValues(0, t, y);
			int step = 1;

			while (t < t_end && step < max_steps) {
				Real h_actual = std::min(h, t_end - t);
				
				// Don't take tiny final steps
				if (t + h_actual * 1.01 >= t_end) {
					h_actual = t_end - t;
				}

				Vector<Real> y_new(dim);
				Vector<Real> y_err(dim);

				bool success = Step(t, y, h_actual, y_new, y_err);

				if (!success) {
					// Linear solve failed, reduce step size
					h = h_actual * 0.5;
					if (h < h_min) {
						throw std::runtime_error("Rosenbrock: Linear solve failed, system may be singular");
					}
					sol.incrementRejectedSteps();
					continue;
				}

				// Compute error norm (mixed absolute/relative)
				Real err_norm = 0.0;
				for (int i = 0; i < dim; ++i) {
					Real scale = _abs_tol + _rel_tol * std::max(std::abs(y[i]), std::abs(y_new[i]));
					Real err_scaled = std::abs(y_err[i]) / scale;
					err_norm = std::max(err_norm, err_scaled);
				}
				
				// Avoid division by zero
				err_norm = std::max(err_norm, 1e-10);

				// Accept or reject step
				if (err_norm <= 1.0) {
					// Accept step
					t += h_actual;
					y = y_new;
					sol.fillValues(step, t, y);
					sol.incrementSuccessfulSteps();
					++step;

					// Compute new step size (PI controller formula for 2nd order method)
					// h_new = h * safety * (1/err_norm)^(1/3)
					Real factor = safety * std::pow(1.0 / err_norm, 1.0 / 3.0);
					factor = std::min(fac_max, std::max(fac_min, factor));
					h = std::min(h_max, h_actual * factor);
				} else {
					// Reject and retry with smaller step
					Real factor = safety * std::pow(1.0 / err_norm, 0.5);  // More aggressive for rejection
					factor = std::max(fac_min, factor);
					h = h_actual * factor;
					
					if (h < h_min) {
						throw std::runtime_error("Rosenbrock: Step size too small (" + 
						    std::to_string(h) + "), system may be too stiff or tolerance too tight");
					}
					sol.incrementRejectedSteps();
				}
			}

			if (step >= max_steps) {
				throw std::runtime_error("Rosenbrock: Maximum steps exceeded");
			}

			sol.setFinalSize(step - 1);
			return sol;
		}
	};

} // namespace MML


///////////////////////////   mml/algorithms/BVPShootingMethod.h   ///////////////////////////






namespace MML
{
	///////////////////////////////////////////////////////////////////////////////////////////
	///                         BVP SHOOTING METHOD RESULT                                  ///
	///////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * @brief Result of a shooting method BVP solve
	 * 
	 * Contains the solution trajectory, optimal shooting parameter(s),
	 * and convergence information.
	 */
	struct BVPShootingResult
	{
		bool converged = false;          ///< Did the solver converge?
		int iterations = 0;              ///< Number of shooting iterations
		Real residual = 0.0;             ///< Final boundary condition residual
		Vector<Real> shootingParams;     ///< Optimal shooting parameter(s)
		ODESystemSolution solution;      ///< Full trajectory solution
		
		BVPShootingResult() : solution(0.0, 1.0, 2, 100) {}  // Default: 2D system, 100 steps
	};

	///////////////////////////////////////////////////////////////////////////////////////////
	///                         SINGLE SHOOTING SOLVER                                      ///
	///////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * @brief Solve two-point BVP using single shooting method
	 * 
	 * ALGORITHM:
	 * Given an n-th order ODE as a first-order system of n equations:
	 *   dy/dt = f(t, y), with y âˆˆ â„â¿
	 * 
	 * Boundary conditions:
	 *   - Some components of y(t0) are known (initial boundary)
	 *   - Some components of y(t1) are specified (final boundary)
	 * 
	 * The shooting method:
	 * 1. Guess values for unknown initial conditions
	 * 2. Integrate the IVP from t0 to t1
	 * 3. Compare final state with desired boundary condition
	 * 4. Adjust guess using root-finding (Brent's method for 1D)
	 * 5. Repeat until boundary condition is satisfied
	 * 
	 * COMMON USE CASE: Second-order ODE
	 * For y'' = f(t, y, y'), we have state [y, y'] = [y0, y1]
	 * - Given y(t0) = Î± and y(t1) = Î²
	 * - Shoot with unknown y'(t0) = s
	 * - Find s such that y(t1) = Î²
	 * 
	 * @tparam StepCalc ODE step calculator type (default: RK4)
	 */
	template<typename StepCalc = RungeKutta4_StepCalculator>
	class BVPShootingSolver
	{
	private:
		const IODESystem& _system;
		StepCalc _stepCalc;
		int _numSteps;
		Real _tolerance;
		int _maxIterations;

	public:
		/**
		 * @brief Construct shooting solver for given ODE system
		 * 
		 * @param system      ODE system to solve (first-order system form)
		 * @param numSteps    Number of integration steps (more = more accurate)
		 * @param tolerance   Root-finding tolerance for boundary condition
		 * @param maxIter     Maximum shooting iterations
		 */
		BVPShootingSolver(const IODESystem& system,
		                  int numSteps = 1000,
		                  Real tolerance = 1e-10,
		                  int maxIter = 100)
			: _system(system)
			, _numSteps(numSteps)
			, _tolerance(tolerance)
			, _maxIterations(maxIter)
		{}

		/**
		 * @brief Solve 1D shooting problem (one unknown initial condition)
		 * 
		 * This is the most common case: second-order ODE with position BC at both ends.
		 * 
		 * @param t0                Start time
		 * @param t1                End time
		 * @param knownInitCond     Known initial conditions (partial)
		 * @param shootingIndex     Index of the unknown component to shoot with
		 * @param targetIndex       Index of the component with end boundary condition
		 * @param targetValue       Desired value at t1 for targetIndex component
		 * @param shootGuess1       First guess for shooting parameter
		 * @param shootGuess2       Second guess for shooting parameter (for bracketing)
		 * @return BVPShootingResult with solution and convergence info
		 */
		BVPShootingResult solve1D(Real t0, Real t1,
		                          const Vector<Real>& knownInitCond,
		                          int shootingIndex,
		                          int targetIndex,
		                          Real targetValue,
		                          Real shootGuess1,
		                          Real shootGuess2)
		{
			BVPShootingResult result;
			
			// Create the "defect function" that measures boundary condition error
			// F(s) = y[targetIndex](t1) - targetValue, where s is the shooting parameter
			auto defectFunc = [&](Real s) -> Real {
				Vector<Real> initCond = knownInitCond;
				initCond[shootingIndex] = s;
				
				ODESystemFixedStepSolver solver(_system, _stepCalc);
				auto sol = solver.integrate(initCond, t0, t1, _numSteps);
				
				Vector<Real> finalState = sol.getXValuesAtEnd();
				return finalState[targetIndex] - targetValue;
			};
			
			RealFunctionFromStdFunc F(defectFunc);
			
			try
			{
				// Try to bracket the root
				Real a = shootGuess1, b = shootGuess2;
				bool bracketed = RootFinding::BracketRoot(F, a, b, 50);
				
				if (!bracketed)
				{
					// If bracketing fails, try wider search
					a = shootGuess1 - 10 * std::abs(shootGuess2 - shootGuess1);
					b = shootGuess2 + 10 * std::abs(shootGuess2 - shootGuess1);
					bracketed = RootFinding::BracketRoot(F, a, b, 100);
				}
				
				if (!bracketed)
				{
					result.converged = false;
					result.residual = std::numeric_limits<Real>::max();
					return result;
				}
				
				// Use Brent's method to find the root
				Real shootingParam = RootFinding::FindRootBrent(F, a, b, _tolerance);
				
				// Compute final solution with optimal shooting parameter
				Vector<Real> initCond = knownInitCond;
				initCond[shootingIndex] = shootingParam;
				
				ODESystemFixedStepSolver solver(_system, _stepCalc);
				result.solution = solver.integrate(initCond, t0, t1, _numSteps);
				
				result.converged = true;
				result.shootingParams = Vector<Real>(1);
				result.shootingParams[0] = shootingParam;
				
				Vector<Real> finalState = result.solution.getXValuesAtEnd();
				result.residual = std::abs(finalState[targetIndex] - targetValue);
			}
			catch (const std::exception& e)
			{
				result.converged = false;
				result.residual = std::numeric_limits<Real>::max();
			}
			
			return result;
		}
		
		/**
		 * @brief Convenience method for common case: y(t0)=y0, y(t1)=y1, find y'(t0)
		 * 
		 * For second-order ODE converted to first-order system:
		 *   state = [y, y'] = [position, velocity]
		 * 
		 * @param t0           Start time
		 * @param t1           End time
		 * @param y0           Value of y at t0 (position at start)
		 * @param y1           Value of y at t1 (position at end)
		 * @param velocityGuess1  First guess for initial velocity
		 * @param velocityGuess2  Second guess for initial velocity
		 * @return BVPShootingResult
		 */
		BVPShootingResult solvePositionBVP(Real t0, Real t1,
		                                   Real y0, Real y1,
		                                   Real velocityGuess1, Real velocityGuess2)
		{
			Vector<Real> initCond(2);
			initCond[0] = y0;  // Known position at t0
			initCond[1] = 0;   // Placeholder for velocity (shooting parameter)
			
			return solve1D(t0, t1, initCond, 
			               1,    // Shooting index: velocity (y')
			               0,    // Target index: position (y)
			               y1,   // Target value at t1
			               velocityGuess1, velocityGuess2);
		}
	};

	///////////////////////////////////////////////////////////////////////////////////////////
	///                    N-DIMENSIONAL SHOOTING SOLVER                                   ///
	///////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * @brief Configuration for N-dimensional shooting method
	 * 
	 * Specifies which initial conditions are unknown (shooting parameters)
	 * and which final conditions are targets (boundary conditions at t1).
	 * 
	 * EXAMPLE: Third-order ODE y''' = f(t, y, y', y'')
	 * State: [y, y', y''] with indices [0, 1, 2]
	 * If we know y(t0), y(t1), y'(t1), we shoot with y'(t0) and y''(t0):
	 *   unknownIndices = {1, 2}      // y'(t0) and y''(t0) are unknown
	 *   targetIndices  = {0, 1}      // y(t1) and y'(t1) are targets
	 */
	struct ShootingConfig
	{
		std::vector<int> unknownIndices;     ///< Indices of unknown initial conditions
		std::vector<Real> unknownGuesses;    ///< Initial guesses for unknowns
		std::vector<int> targetIndices;      ///< Indices of target final conditions  
		std::vector<Real> targetValues;      ///< Desired values at t1
		
		/// Number of shooting parameters (must equal number of targets)
		int numParams() const { return static_cast<int>(unknownIndices.size()); }
		
		/// Validate configuration
		bool isValid() const {
			return unknownIndices.size() == targetIndices.size() &&
			       unknownIndices.size() == unknownGuesses.size() &&
			       unknownIndices.size() == targetValues.size() &&
			       !unknownIndices.empty();
		}
	};
	
	/**
	 * @brief Result of N-dimensional shooting method
	 */
	struct ShootingResultND
	{
		bool converged = false;          ///< Did the solver converge?
		int iterations = 0;              ///< Number of Newton iterations
		Real residualNorm = 0.0;         ///< Final ||F(s)||â‚‚
		Vector<Real> shootingParams;     ///< Optimal shooting parameters
		Vector<Real> residuals;          ///< Final residual vector
		ODESystemSolution solution;      ///< Full trajectory
		
		ShootingResultND() : solution(0.0, 1.0, 2, 100) {}
	};
	
	/**
	 * @brief N-dimensional shooting method solver
	 * 
	 * Solves BVPs with multiple unknown initial conditions using
	 * Newton-Raphson iteration with numerical Jacobian.
	 * 
	 * ALGORITHM:
	 * Given: dy/dt = f(t,y), some y_i(t0) known, some y_j(t1) specified
	 * 
	 * 1. Form shooting parameter vector s = [y_k(t0) for k in unknownIndices]
	 * 2. Define defect F(s) = [y_j(t1;s) - target_j for j in targetIndices]
	 * 3. Solve F(s) = 0 using Newton-Raphson:
	 *    - Compute Jacobian J_ij = âˆ‚F_i/âˆ‚s_j numerically
	 *    - Update: s_{n+1} = s_n - J^{-1} F(s_n)
	 * 4. Iterate until ||F(s)|| < tolerance
	 * 
	 * @tparam StepCalc ODE step calculator type
	 */
	template<typename StepCalc = RungeKutta4_StepCalculator>
	class BVPShootingSolverND
	{
	private:
		const IODESystem& _system;
		StepCalc _stepCalc;
		int _numSteps;
		Real _tolerance;
		int _maxIterations;
		Real _jacobianDelta;    ///< Step size for numerical Jacobian
		
	public:
		/**
		 * @brief Construct N-dimensional shooting solver
		 * 
		 * @param system        ODE system
		 * @param numSteps      Integration steps
		 * @param tolerance     Convergence tolerance for ||F(s)||
		 * @param maxIter       Maximum Newton iterations
		 * @param jacobianDelta Step size for numerical derivatives
		 */
		BVPShootingSolverND(const IODESystem& system,
		                    int numSteps = 1000,
		                    Real tolerance = 1e-10,
		                    int maxIter = 50,
		                    Real jacobianDelta = 1e-8)
			: _system(system)
			, _numSteps(numSteps)
			, _tolerance(tolerance)
			, _maxIterations(maxIter)
			, _jacobianDelta(jacobianDelta)
		{}
		
		/**
		 * @brief Solve BVP with given configuration
		 * 
		 * @param t0           Start time
		 * @param t1           End time  
		 * @param knownInitCond Vector with known initial conditions
		 *                      (values at unknownIndices will be overwritten)
		 * @param config       Shooting configuration
		 * @return ShootingResultND
		 */
		ShootingResultND solve(Real t0, Real t1,
		                       const Vector<Real>& knownInitCond,
		                       const ShootingConfig& config)
		{
			ShootingResultND result;
			
			if (!config.isValid())
			{
				result.converged = false;
				return result;
			}
			
			int n = config.numParams();
			
			// Initialize shooting parameters from guesses
			Vector<Real> s(n);
			for (int i = 0; i < n; ++i)
				s[i] = config.unknownGuesses[i];
			
			// Defect function: computes F(s) = final_state[targets] - target_values
			auto computeDefect = [&](const Vector<Real>& params) -> Vector<Real> {
				Vector<Real> initCond = knownInitCond;
				for (int i = 0; i < n; ++i)
					initCond[config.unknownIndices[i]] = params[i];
				
				ODESystemFixedStepSolver solver(_system, _stepCalc);
				auto sol = solver.integrate(initCond, t0, t1, _numSteps);
				Vector<Real> finalState = sol.getXValuesAtEnd();
				
				Vector<Real> F(n);
				for (int i = 0; i < n; ++i)
					F[i] = finalState[config.targetIndices[i]] - config.targetValues[i];
				
				return F;
			};
			
			// Newton-Raphson iteration
			Vector<Real> F = computeDefect(s);
			Real residualNorm = F.NormL2();
			
			for (int iter = 0; iter < _maxIterations; ++iter)
			{
				result.iterations = iter + 1;
				
				if (residualNorm < _tolerance)
				{
					result.converged = true;
					break;
				}
				
				// Compute Jacobian numerically: J_ij = âˆ‚F_i/âˆ‚s_j
				Matrix<Real> J(n, n);
				for (int j = 0; j < n; ++j)
				{
					Vector<Real> s_plus = s;
					s_plus[j] += _jacobianDelta;
					
					Vector<Real> F_plus = computeDefect(s_plus);
					
					for (int i = 0; i < n; ++i)
						J(i, j) = (F_plus[i] - F[i]) / _jacobianDelta;
				}
				
				// Solve J * delta_s = -F for delta_s
				// Using simple Gaussian elimination for small systems
				Vector<Real> delta_s = solveLinearSystem(J, F * (-1.0));
				
				// Update shooting parameters
				s = s + delta_s;
				
				// Recompute defect
				F = computeDefect(s);
				residualNorm = F.NormL2();
			}
			
			// Store results
			result.shootingParams = s;
			result.residuals = F;
			result.residualNorm = residualNorm;
			
			// Compute final solution
			Vector<Real> initCond = knownInitCond;
			for (int i = 0; i < n; ++i)
				initCond[config.unknownIndices[i]] = s[i];
			
			ODESystemFixedStepSolver solver(_system, _stepCalc);
			result.solution = solver.integrate(initCond, t0, t1, _numSteps);
			
			if (!result.converged && residualNorm < _tolerance * 100)
				result.converged = true;  // Close enough
			
			return result;
		}
		
	private:
		/**
		 * @brief Solve small linear system Ax = b using Gaussian elimination
		 */
		Vector<Real> solveLinearSystem(const Matrix<Real>& A, const Vector<Real>& b)
		{
			int n = b.size();
			Matrix<Real> Aug(n, n + 1);
			
			// Build augmented matrix [A|b]
			for (int i = 0; i < n; ++i)
			{
				for (int j = 0; j < n; ++j)
					Aug(i, j) = A(i, j);
				Aug(i, n) = b[i];
			}
			
			// Forward elimination with partial pivoting
			for (int k = 0; k < n; ++k)
			{
				// Find pivot
				int maxRow = k;
				Real maxVal = std::abs(Aug(k, k));
				for (int i = k + 1; i < n; ++i)
				{
					if (std::abs(Aug(i, k)) > maxVal)
					{
						maxVal = std::abs(Aug(i, k));
						maxRow = i;
					}
				}
				
				// Swap rows
				if (maxRow != k)
				{
					for (int j = k; j <= n; ++j)
						std::swap(Aug(k, j), Aug(maxRow, j));
				}
				
				// Check for singularity
				if (std::abs(Aug(k, k)) < 1e-14)
					return Vector<Real>(n);  // Return zeros if singular
				
				// Eliminate below
				for (int i = k + 1; i < n; ++i)
				{
					Real factor = Aug(i, k) / Aug(k, k);
					for (int j = k; j <= n; ++j)
						Aug(i, j) -= factor * Aug(k, j);
				}
			}
			
			// Back substitution
			Vector<Real> x(n);
			for (int i = n - 1; i >= 0; --i)
			{
				x[i] = Aug(i, n);
				for (int j = i + 1; j < n; ++j)
					x[i] -= Aug(i, j) * x[j];
				x[i] /= Aug(i, i);
			}
			
			return x;
		}
	};

}  // namespace MML


///////////////////////////   mml/algorithms/Statistics.h   ///////////////////////////




namespace MML
{
	namespace Statistics
	{
		static Real Avg(const Vector<Real>& data)
		{
			Real outAvg = 0.0;
			int n = data.size();
			
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in Avg");

			for (int j = 0; j < n; j++)
				outAvg += data[j];
			outAvg /= n;

			return outAvg;
		}

		static void AvgVar(const Vector<Real>& data, Real& outAvg, Real& outVar)
		{
			Real s, ep;
			int j, n = data.size();

			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in AvgVar");

			outAvg = Avg(data);

			outVar = ep = 0.0;
			for (j = 0; j < n; j++) {
				s = data[j] - outAvg;
				ep += s;
				outVar += s * s;
			}
			outVar = (outVar - ep * ep / n) / (n - 1);
		}
		static void AvgStdDev(const Vector<Real>& data, Real& outAvg, Real& outStdDev)
		{
			Real var;
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in AvgStdDev");
			AvgVar(data, outAvg, var);
			outStdDev = sqrt(var);
		}

		// Helper functions for t-tests (aliases for clarity)
		static Real Mean(const Vector<Real>& data) { return Avg(data); }
		
		static Real Variance(const Vector<Real>& data)
		{
			Real avg, var;
			AvgVar(data, avg, var);
			return var;
		}
		
		static Real StdDev(const Vector<Real>& data)
		{
			Real avg, stddev;
			AvgStdDev(data, avg, stddev);
			return stddev;
		}

		static void Moments(const Vector<Real>& data, Real& ave, Real& adev, Real& sdev, Real& var, Real& skew, Real& curt)
		{
			int j, n = data.size();
			Real ep = 0.0, s, p;

			if (n <= 1)
				throw StatisticsError("Vector size must be greater than 1 in Moments");

			s = 0.0;
			for (j = 0; j < n; j++)
				s += data[j];
			ave = s / n;

			adev = var = skew = curt = 0.0;
			for (j = 0; j < n; j++) {
				adev += std::abs(s = data[j] - ave);
				ep += s;
				var += (p = s * s);
				skew += (p *= s);
				curt += (p *= s);
			}
			adev /= n;
			var = (var - ep * ep / n) / (n - 1);
			sdev = sqrt(var);

			if (var != 0.0) {
				skew /= (n * var * sdev);
				curt = curt / (n * var * var) - 3.0;
			}
			else
				throw StatisticsError("No skew/kurtosis when variance = 0 (in Moments)");
		}

		/*********************************************************************/
		/*****                  Order Statistics                         *****/
		/*********************************************************************/

		/**
		 * @brief Compute the median of a dataset
		 * 
		 * The median is the middle value when data is sorted. For even-sized
		 * datasets, returns the average of the two middle values.
		 * 
		 * @param data Input vector (will be copied and sorted internally)
		 * @return The median value
		 * @throws StatisticsError if data is empty
		 * 
		 * Complexity: O(n log n) due to sorting
		 */
		static Real Median(const Vector<Real>& data)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in Median");

			// Create a sorted copy
			std::vector<Real> sorted(n);
			for (int i = 0; i < n; i++)
				sorted[i] = data[i];
			std::sort(sorted.begin(), sorted.end());

			if (n % 2 == 0)
				return (sorted[n / 2 - 1] + sorted[n / 2]) / 2.0;
			else
				return sorted[n / 2];
		}

		/**
		 * @brief Compute a percentile of a dataset
		 * 
		 * Uses linear interpolation between data points (similar to Excel PERCENTILE.INC).
		 * The p-th percentile is the value below which p percent of the data falls.
		 * 
		 * @param data Input vector (will be copied and sorted internally)
		 * @param p Percentile to compute (must be in [0, 100])
		 * @return The p-th percentile value
		 * @throws StatisticsError if data is empty or p is out of range
		 * 
		 * Complexity: O(n log n) due to sorting
		 */
		static Real Percentile(const Vector<Real>& data, Real p)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in Percentile");
			if (p < 0.0 || p > 100.0)
				throw StatisticsError("Percentile must be in range [0, 100]");

			// Create a sorted copy
			std::vector<Real> sorted(n);
			for (int i = 0; i < n; i++)
				sorted[i] = data[i];
			std::sort(sorted.begin(), sorted.end());

			// Handle edge cases
			if (p == 0.0) return sorted[0];
			if (p == 100.0) return sorted[n - 1];

			// Linear interpolation (Excel PERCENTILE.INC method)
			Real rank = (p / 100.0) * (n - 1);
			int lower = static_cast<int>(std::floor(rank));
			int upper = static_cast<int>(std::ceil(rank));
			
			if (lower == upper)
				return sorted[lower];

			Real fraction = rank - lower;
			return sorted[lower] + fraction * (sorted[upper] - sorted[lower]);
		}

		/**
		 * @brief Compute quartiles (Q1, Q2/Median, Q3) of a dataset
		 * 
		 * Q1 = 25th percentile (first quartile)
		 * Q2 = 50th percentile (median)
		 * Q3 = 75th percentile (third quartile)
		 * 
		 * @param data Input vector
		 * @param[out] q1 First quartile (25th percentile)
		 * @param[out] median Second quartile (50th percentile)
		 * @param[out] q3 Third quartile (75th percentile)
		 * @throws StatisticsError if data is empty
		 */
		static void Quartiles(const Vector<Real>& data, Real& q1, Real& median, Real& q3)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in Quartiles");

			q1 = Percentile(data, 25.0);
			median = Percentile(data, 50.0);
			q3 = Percentile(data, 75.0);
		}

		/**
		 * @brief Compute the range of a dataset
		 * 
		 * Range = max(data) - min(data)
		 * 
		 * @param data Input vector
		 * @return The range (maximum minus minimum)
		 * @throws StatisticsError if data is empty
		 * 
		 * Complexity: O(n)
		 */
		static Real Range(const Vector<Real>& data)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in Range");

			Real minVal = data[0];
			Real maxVal = data[0];
			for (int i = 1; i < n; i++) {
				if (data[i] < minVal) minVal = data[i];
				if (data[i] > maxVal) maxVal = data[i];
			}
			return maxVal - minVal;
		}

		/**
		 * @brief Compute the Interquartile Range (IQR)
		 * 
		 * IQR = Q3 - Q1 = 75th percentile - 25th percentile
		 * 
		 * The IQR is a robust measure of spread, less sensitive to outliers
		 * than the range or standard deviation.
		 * 
		 * @param data Input vector
		 * @return The interquartile range
		 * @throws StatisticsError if data is empty
		 */
		static Real IQR(const Vector<Real>& data)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in IQR");

			return Percentile(data, 75.0) - Percentile(data, 25.0);
		}

		/**
		 * @brief Compute minimum and maximum values
		 * 
		 * @param data Input vector
		 * @param[out] minVal Minimum value in the data
		 * @param[out] maxVal Maximum value in the data
		 * @throws StatisticsError if data is empty
		 * 
		 * Complexity: O(n)
		 */
		static void MinMax(const Vector<Real>& data, Real& minVal, Real& maxVal)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in MinMax");

			minVal = data[0];
			maxVal = data[0];
			for (int i = 1; i < n; i++) {
				if (data[i] < minVal) minVal = data[i];
				if (data[i] > maxVal) maxVal = data[i];
			}
		}

		/*********************************************************************/
		/*****               Robust Statistics                           *****/
		/*********************************************************************/

		/**
		 * @brief Compute the mode (most frequent value) of a dataset
		 * 
		 * For continuous data, finds the value that appears most frequently.
		 * If multiple values have the same highest frequency, returns the smallest.
		 * For truly continuous data where no values repeat, returns the first value.
		 * 
		 * @param data Input vector
		 * @return The mode (most frequent value)
		 * @throws StatisticsError if data is empty
		 * 
		 * Complexity: O(n log n) due to sorting
		 * 
		 * @note For continuous distributions, consider using kernel density estimation
		 *       or histogram-based methods instead.
		 */
		static Real Mode(const Vector<Real>& data)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in Mode");
			if (n == 1)
				return data[0];

			// Create a sorted copy
			std::vector<Real> sorted(n);
			for (int i = 0; i < n; i++)
				sorted[i] = data[i];
			std::sort(sorted.begin(), sorted.end());

			Real mode = sorted[0];
			int maxCount = 1;
			int currentCount = 1;

			for (int i = 1; i < n; i++) {
				if (sorted[i] == sorted[i - 1]) {
					currentCount++;
				} else {
					if (currentCount > maxCount) {
						maxCount = currentCount;
						mode = sorted[i - 1];
					}
					currentCount = 1;
				}
			}
			// Check the last run
			if (currentCount > maxCount) {
				mode = sorted[n - 1];
			}

			return mode;
		}

		/**
		 * @brief Compute the trimmed mean (truncated mean)
		 * 
		 * The trimmed mean excludes a percentage of the smallest and largest values
		 * before computing the mean. This provides robustness against outliers.
		 * 
		 * @param data Input vector
		 * @param trimPercent Percentage to trim from each end (0-50)
		 *                    e.g., 10 means remove bottom 10% and top 10%
		 * @return The trimmed mean
		 * @throws StatisticsError if data is empty or trimPercent is invalid
		 * 
		 * Complexity: O(n log n) due to sorting
		 */
		static Real TrimmedMean(const Vector<Real>& data, Real trimPercent)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in TrimmedMean");
			if (trimPercent < 0.0 || trimPercent >= 50.0)
				throw StatisticsError("trimPercent must be in range [0, 50) in TrimmedMean");

			// Create a sorted copy
			std::vector<Real> sorted(n);
			for (int i = 0; i < n; i++)
				sorted[i] = data[i];
			std::sort(sorted.begin(), sorted.end());

			// Calculate how many to trim from each end
			int trimCount = static_cast<int>(std::floor(n * trimPercent / 100.0));
			
			// Calculate mean of remaining values
			Real sum = 0.0;
			int count = 0;
			for (int i = trimCount; i < n - trimCount; i++) {
				sum += sorted[i];
				count++;
			}

			if (count == 0)
				throw StatisticsError("No values remain after trimming in TrimmedMean");

			return sum / count;
		}

		/**
		 * @brief Compute the Median Absolute Deviation (MAD)
		 * 
		 * MAD = median(|x_i - median(x)|)
		 * 
		 * MAD is a robust measure of variability. It is less sensitive to
		 * outliers than standard deviation. To estimate standard deviation
		 * for normal data, multiply MAD by 1.4826.
		 * 
		 * @param data Input vector
		 * @return The median absolute deviation
		 * @throws StatisticsError if data is empty
		 * 
		 * Complexity: O(n log n) due to sorting
		 */
		static Real MAD(const Vector<Real>& data)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in MAD");

			Real med = Median(data);

			// Compute absolute deviations
			Vector<Real> absDeviations(n);
			for (int i = 0; i < n; i++)
				absDeviations[i] = std::abs(data[i] - med);

			return Median(absDeviations);
		}

		/**
		 * @brief Compute the geometric mean
		 * 
		 * GeometricMean = (x_1 * x_2 * ... * x_n)^(1/n) = exp(mean(log(x_i)))
		 * 
		 * The geometric mean is appropriate for data that is multiplicative
		 * in nature (e.g., growth rates, ratios). All values must be positive.
		 * 
		 * @param data Input vector (all values must be positive)
		 * @return The geometric mean
		 * @throws StatisticsError if data is empty or contains non-positive values
		 * 
		 * Complexity: O(n)
		 */
		static Real GeometricMean(const Vector<Real>& data)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in GeometricMean");

			Real logSum = 0.0;
			for (int i = 0; i < n; i++) {
				if (data[i] <= 0.0)
					throw StatisticsError("All values must be positive in GeometricMean");
				logSum += std::log(data[i]);
			}

			return std::exp(logSum / n);
		}

		/**
		 * @brief Compute the harmonic mean
		 * 
		 * HarmonicMean = n / (1/x_1 + 1/x_2 + ... + 1/x_n)
		 * 
		 * The harmonic mean is appropriate for averaging rates or ratios
		 * (e.g., speeds, P/E ratios). All values must be positive.
		 * 
		 * @param data Input vector (all values must be positive)
		 * @return The harmonic mean
		 * @throws StatisticsError if data is empty or contains non-positive values
		 * 
		 * Complexity: O(n)
		 */
		static Real HarmonicMean(const Vector<Real>& data)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in HarmonicMean");

			Real reciprocalSum = 0.0;
			for (int i = 0; i < n; i++) {
				if (data[i] <= 0.0)
					throw StatisticsError("All values must be positive in HarmonicMean");
				reciprocalSum += 1.0 / data[i];
			}

			return n / reciprocalSum;
		}

		/**
		 * @brief Compute the weighted mean
		 * 
		 * WeightedMean = sum(w_i * x_i) / sum(w_i)
		 * 
		 * @param data Input vector of values
		 * @param weights Vector of weights (must have same size as data)
		 * @return The weighted mean
		 * @throws StatisticsError if data is empty, sizes don't match,
		 *         or total weight is zero/negative
		 * 
		 * Complexity: O(n)
		 */
		static Real WeightedMean(const Vector<Real>& data, const Vector<Real>& weights)
		{
			int n = data.size();
			if (n <= 0)
				throw StatisticsError("Vector size must be greater than 0 in WeightedMean");
			if (weights.size() != n)
				throw StatisticsError("Data and weights must have the same size in WeightedMean");

			Real weightedSum = 0.0;
			Real totalWeight = 0.0;
			for (int i = 0; i < n; i++) {
				if (weights[i] < 0.0)
					throw StatisticsError("Weights must be non-negative in WeightedMean");
				weightedSum += weights[i] * data[i];
				totalWeight += weights[i];
			}

			if (totalWeight <= 0.0)
				throw StatisticsError("Total weight must be positive in WeightedMean");

			return weightedSum / totalWeight;
		}

		/**
		 * @brief Compute the weighted variance
		 * 
		 * Uses reliability weights (frequency weights) formula:
		 * WeightedVar = sum(w_i * (x_i - weighted_mean)^2) / (sum(w_i) - 1)
		 * 
		 * @param data Input vector of values
		 * @param weights Vector of weights (must have same size as data)
		 * @return The weighted variance
		 * @throws StatisticsError if data has fewer than 2 elements, sizes don't match,
		 *         or weights are invalid
		 * 
		 * Complexity: O(n)
		 */
		static Real WeightedVariance(const Vector<Real>& data, const Vector<Real>& weights)
		{
			int n = data.size();
			if (n < 2)
				throw StatisticsError("Vector size must be at least 2 in WeightedVariance");
			if (weights.size() != n)
				throw StatisticsError("Data and weights must have the same size in WeightedVariance");

			Real wMean = WeightedMean(data, weights);

			Real weightedSqSum = 0.0;
			Real totalWeight = 0.0;
			for (int i = 0; i < n; i++) {
				if (weights[i] < 0.0)
					throw StatisticsError("Weights must be non-negative in WeightedVariance");
				Real diff = data[i] - wMean;
				weightedSqSum += weights[i] * diff * diff;
				totalWeight += weights[i];
			}

			if (totalWeight <= 1.0)
				throw StatisticsError("Total weight must be greater than 1 in WeightedVariance");

			return weightedSqSum / (totalWeight - 1.0);
		}

		/*********************************************************************/
		/*****               Correlation & Covariance                    *****/
		/*********************************************************************/

		/**
		 * @brief Compute the sample covariance between two variables
		 * 
		 * Cov(X,Y) = sum((x_i - mean_x)(y_i - mean_y)) / (n - 1)
		 * 
		 * Uses a two-pass algorithm for numerical stability.
		 * 
		 * @param x First variable (vector of values)
		 * @param y Second variable (must have same size as x)
		 * @return Sample covariance
		 * @throws StatisticsError if vectors are empty or have different sizes
		 * 
		 * Complexity: O(n)
		 */
		static Real Covariance(const Vector<Real>& x, const Vector<Real>& y)
		{
			int n = x.size();
			if (n <= 1)
				throw StatisticsError("Vector size must be greater than 1 in Covariance");
			if (y.size() != n)
				throw StatisticsError("Vectors must have the same size in Covariance");

			// Two-pass algorithm for numerical stability
			Real meanX = Avg(x);
			Real meanY = Avg(y);

			Real cov = 0.0;
			for (int i = 0; i < n; i++) {
				cov += (x[i] - meanX) * (y[i] - meanY);
			}

			return cov / (n - 1);
		}

		/**
		 * @brief Compute the Pearson correlation coefficient
		 * 
		 * r = Cov(X,Y) / (StdDev(X) * StdDev(Y))
		 * 
		 * The Pearson correlation measures linear relationship between variables.
		 * Values range from -1 (perfect negative) to +1 (perfect positive).
		 * A value of 0 indicates no linear correlation.
		 * 
		 * @param x First variable (vector of values)
		 * @param y Second variable (must have same size as x)
		 * @return Pearson correlation coefficient r in [-1, 1]
		 * @throws StatisticsError if vectors are empty, have different sizes,
		 *         or either variable has zero variance
		 * 
		 * Complexity: O(n)
		 */
		static Real PearsonCorrelation(const Vector<Real>& x, const Vector<Real>& y)
		{
			int n = x.size();
			if (n <= 1)
				throw StatisticsError("Vector size must be greater than 1 in PearsonCorrelation");
			if (y.size() != n)
				throw StatisticsError("Vectors must have the same size in PearsonCorrelation");

			// Compute means
			Real meanX = Avg(x);
			Real meanY = Avg(y);

			// Compute sums for correlation
			Real sumXY = 0.0;
			Real sumX2 = 0.0;
			Real sumY2 = 0.0;

			for (int i = 0; i < n; i++) {
				Real dx = x[i] - meanX;
				Real dy = y[i] - meanY;
				sumXY += dx * dy;
				sumX2 += dx * dx;
				sumY2 += dy * dy;
			}

			if (sumX2 == 0.0)
				throw StatisticsError("First variable has zero variance in PearsonCorrelation");
			if (sumY2 == 0.0)
				throw StatisticsError("Second variable has zero variance in PearsonCorrelation");

			return sumXY / std::sqrt(sumX2 * sumY2);
		}

		/**
		 * @brief Result structure for correlation with significance test
		 */
		struct CorrelationResult
		{
			Real r;                ///< Correlation coefficient
			Real tStatistic;       ///< t-statistic for significance test
			int degreesOfFreedom;  ///< Degrees of freedom (n-2)
			
			CorrelationResult(Real correlation, Real tStat, int df)
				: r(correlation), tStatistic(tStat), degreesOfFreedom(df) {}
		};

		/**
		 * @brief Compute Pearson correlation with t-test for significance
		 * 
		 * Tests the null hypothesis H0: Ï = 0 (no population correlation)
		 * The t-statistic follows a t-distribution with n-2 degrees of freedom.
		 * 
		 * t = r * sqrt((n-2) / (1-rÂ²))
		 * 
		 * @param x First variable
		 * @param y Second variable
		 * @return CorrelationResult containing r, t-statistic, and degrees of freedom
		 * @throws StatisticsError if inputs are invalid
		 * 
		 * @note Use t-distribution critical values or p-value calculation to assess significance
		 */
		static CorrelationResult PearsonCorrelationWithTest(const Vector<Real>& x, const Vector<Real>& y)
		{
			int n = x.size();
			if (n <= 2)
				throw StatisticsError("Vector size must be greater than 2 for significance test");
			
			Real r = PearsonCorrelation(x, y);
			int df = n - 2;
			
			// Compute t-statistic: t = r * sqrt((n-2)/(1-rÂ²))
			Real r2 = r * r;
			Real tStat;
			if (r2 >= 1.0) {
				// Perfect correlation - t approaches infinity
				tStat = (r > 0) ? std::numeric_limits<Real>::infinity() 
				                : -std::numeric_limits<Real>::infinity();
			} else {
				tStat = r * std::sqrt(static_cast<Real>(df) / (1.0 - r2));
			}
			
			return CorrelationResult(r, tStat, df);
		}

		/**
		 * @brief Compute the coefficient of determination (RÂ²)
		 * 
		 * RÂ² = rÂ² where r is the Pearson correlation coefficient.
		 * Represents the proportion of variance in y explained by x.
		 * 
		 * @param x Independent variable
		 * @param y Dependent variable
		 * @return RÂ² value in [0, 1]
		 */
		static Real RSquared(const Vector<Real>& x, const Vector<Real>& y)
		{
			Real r = PearsonCorrelation(x, y);
			return r * r;
		}

		/**
		 * @brief Compute the covariance matrix for multivariate data
		 * 
		 * For a data matrix where each column is a variable and each row is
		 * an observation, computes the pairwise covariance between all variables.
		 * 
		 * @param data Matrix of size (n_observations x n_variables)
		 * @return Square covariance matrix of size (n_variables x n_variables)
		 * @throws StatisticsError if matrix has insufficient observations
		 * 
		 * @note The diagonal contains variances, off-diagonal contains covariances
		 */
		static Matrix<Real> CovarianceMatrix(const Matrix<Real>& data)
		{
			int n = data.RowNum();  // observations
			int p = data.ColNum();  // variables

			if (n <= 1)
				throw StatisticsError("Need at least 2 observations for CovarianceMatrix");
			if (p <= 0)
				throw StatisticsError("Need at least 1 variable for CovarianceMatrix");

			// Compute means for each variable
			Vector<Real> means(p);
			for (int j = 0; j < p; j++) {
				Real sum = 0.0;
				for (int i = 0; i < n; i++)
					sum += data(i, j);
				means[j] = sum / n;
			}

			// Compute covariance matrix
			Matrix<Real> covMatrix(p, p);
			for (int j1 = 0; j1 < p; j1++) {
				for (int j2 = j1; j2 < p; j2++) {
					Real cov = 0.0;
					for (int i = 0; i < n; i++) {
						cov += (data(i, j1) - means[j1]) * (data(i, j2) - means[j2]);
					}
					cov /= (n - 1);
					covMatrix(j1, j2) = cov;
					covMatrix(j2, j1) = cov;  // Symmetric
				}
			}

			return covMatrix;
		}

		/**
		 * @brief Compute the correlation matrix for multivariate data
		 * 
		 * Similar to covariance matrix, but normalized to [-1, 1] range.
		 * The diagonal is always 1 (variable correlated with itself).
		 * 
		 * @param data Matrix of size (n_observations x n_variables)
		 * @return Square correlation matrix of size (n_variables x n_variables)
		 * @throws StatisticsError if matrix has insufficient observations or zero variance
		 */
		static Matrix<Real> CorrelationMatrix(const Matrix<Real>& data)
		{
			int n = data.RowNum();
			int p = data.ColNum();

			if (n <= 1)
				throw StatisticsError("Need at least 2 observations for CorrelationMatrix");
			if (p <= 0)
				throw StatisticsError("Need at least 1 variable for CorrelationMatrix");

			// Compute covariance matrix first
			Matrix<Real> covMatrix = CovarianceMatrix(data);

			// Extract standard deviations from diagonal
			Vector<Real> stdDevs(p);
			for (int j = 0; j < p; j++) {
				if (covMatrix(j, j) <= 0.0)
					throw StatisticsError("Variable has zero or negative variance in CorrelationMatrix");
				stdDevs[j] = std::sqrt(covMatrix(j, j));
			}

			// Normalize to correlation matrix
			Matrix<Real> corrMatrix(p, p);
			for (int j1 = 0; j1 < p; j1++) {
				for (int j2 = 0; j2 < p; j2++) {
					corrMatrix(j1, j2) = covMatrix(j1, j2) / (stdDevs[j1] * stdDevs[j2]);
				}
			}

			return corrMatrix;
		}
  } // namespace Statistics
}  // namespace MML

///////////////////////////   mml/algorithms/Statistics/Histogram.h   ///////////////////////////



namespace MML {
	namespace Statistics {
		namespace Histogram {

			/////////////////////////////////////////////////////////////////////////////////////
			///                         BINNING METHOD ENUM                                   ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Methods for automatic bin width/count selection
			enum class BinningMethod {
				Sturges,           ///< Sturges' formula: k = ceil(log2(n) + 1)
				Scott,             ///< Scott's rule: h = 3.49 * std * n^(-1/3)
				FreedmanDiaconis,  ///< Freedman-Diaconis: h = 2 * IQR * n^(-1/3)
				SquareRoot,        ///< Square root choice: k = ceil(sqrt(n))
				Rice               ///< Rice's rule: k = ceil(2 * n^(1/3))
			};

			/////////////////////////////////////////////////////////////////////////////////////
			///                         HISTOGRAM RESULT STRUCT                               ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Result of histogram computation
			struct HistogramResult {
				Vector<Real> binEdges;      ///< Bin edges (size = numBins + 1)
				Vector<int> counts;          ///< Raw counts per bin
				Vector<Real> frequencies;    ///< Relative frequencies (counts / total)
				Vector<Real> density;        ///< Probability density (frequency / binWidth)
				Real binWidth;               ///< Width of each bin (uniform)
				int numBins;                 ///< Number of bins
				int totalCount;              ///< Total number of data points

				/// @brief Get bin centers
				Vector<Real> GetBinCenters() const {
					Vector<Real> centers(numBins);
					for (int i = 0; i < numBins; ++i) {
						centers[i] = (binEdges[i] + binEdges[i + 1]) / 2.0;
					}
					return centers;
				}

				/// @brief Get cumulative counts
				Vector<int> GetCumulativeCounts() const {
					Vector<int> cumCounts(numBins);
					cumCounts[0] = counts[0];
					for (int i = 1; i < numBins; ++i) {
						cumCounts[i] = cumCounts[i - 1] + counts[i];
					}
					return cumCounts;
				}

				/// @brief Get cumulative frequencies (empirical CDF at bin edges)
				Vector<Real> GetCumulativeFrequencies() const {
					Vector<Real> cumFreq(numBins);
					cumFreq[0] = frequencies[0];
					for (int i = 1; i < numBins; ++i) {
						cumFreq[i] = cumFreq[i - 1] + frequencies[i];
					}
					return cumFreq;
				}
			};

			/////////////////////////////////////////////////////////////////////////////////////
			///                         BIN COUNT ESTIMATION                                  ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Estimate optimal number of bins using Sturges' formula
			/// @details k = ceil(log2(n) + 1)
			///          Works well for normally distributed data
			/// @param n Number of data points
			/// @return Recommended number of bins
			static int SturgesBinCount(int n) {
				if (n <= 0) return 1;
				return static_cast<int>(std::ceil(std::log2(static_cast<double>(n)) + 1.0));
			}

			/// @brief Estimate optimal number of bins using Rice's rule
			/// @details k = ceil(2 * n^(1/3))
			/// @param n Number of data points
			/// @return Recommended number of bins
			static int RiceBinCount(int n) {
				if (n <= 0) return 1;
				return static_cast<int>(std::ceil(2.0 * std::cbrt(static_cast<double>(n))));
			}

			/// @brief Estimate optimal number of bins using square root rule
			/// @details k = ceil(sqrt(n))
			/// @param n Number of data points
			/// @return Recommended number of bins
			static int SquareRootBinCount(int n) {
				if (n <= 0) return 1;
				return static_cast<int>(std::ceil(std::sqrt(static_cast<double>(n))));
			}

			/// @brief Estimate optimal bin width using Scott's rule
			/// @details h = 3.49 * std * n^(-1/3)
			///          Optimal for normally distributed data
			/// @param data Input data
			/// @return Recommended bin width
			static Real ScottBinWidth(const Vector<Real>& data) {
				int n = data.size();
				if (n <= 1) return 1.0;

				// Compute standard deviation
				Real mean = 0.0;
				for (int i = 0; i < n; ++i) mean += data[i];
				mean /= n;

				Real variance = 0.0;
				for (int i = 0; i < n; ++i) {
					Real diff = data[i] - mean;
					variance += diff * diff;
				}
				variance /= (n - 1);
				Real stdDev = std::sqrt(variance);

				if (stdDev < Constants::Eps) return 1.0;

				return 3.49 * stdDev * std::pow(static_cast<double>(n), -1.0 / 3.0);
			}

			/// @brief Estimate optimal bin width using Freedman-Diaconis rule
			/// @details h = 2 * IQR * n^(-1/3)
			///          More robust to outliers than Scott's rule
			/// @param data Input data
			/// @return Recommended bin width
			static Real FreedmanDiaconisBinWidth(const Vector<Real>& data) {
				int n = data.size();
				if (n <= 1) return 1.0;

				// Sort data for percentile calculation
				std::vector<Real> sorted(n);
				for (int i = 0; i < n; ++i) sorted[i] = data[i];
				std::sort(sorted.begin(), sorted.end());

				// Compute Q1 (25th percentile) and Q3 (75th percentile)
				auto percentile = [&sorted, n](Real p) -> Real {
					Real rank = (p / 100.0) * (n - 1);
					int lower = static_cast<int>(std::floor(rank));
					int upper = static_cast<int>(std::ceil(rank));
					if (lower == upper) return sorted[lower];
					Real fraction = rank - lower;
					return sorted[lower] + fraction * (sorted[upper] - sorted[lower]);
				};

				Real iqr = percentile(75.0) - percentile(25.0);

				if (iqr < Constants::Eps) {
					// Fallback to Scott's rule if IQR is zero
					return ScottBinWidth(data);
				}

				return 2.0 * iqr * std::pow(static_cast<double>(n), -1.0 / 3.0);
			}

			/// @brief Get bin count for a given method
			/// @param data Input data
			/// @param method Binning method to use
			/// @return Recommended number of bins
			static int GetBinCount(const Vector<Real>& data, BinningMethod method) {
				int n = data.size();
				if (n <= 0) return 1;

				// Find data range
				Real minVal = data[0], maxVal = data[0];
				for (int i = 1; i < n; ++i) {
					if (data[i] < minVal) minVal = data[i];
					if (data[i] > maxVal) maxVal = data[i];
				}
				Real range = maxVal - minVal;

				switch (method) {
				case BinningMethod::Sturges:
					return SturgesBinCount(n);

				case BinningMethod::Rice:
					return RiceBinCount(n);

				case BinningMethod::SquareRoot:
					return SquareRootBinCount(n);

				case BinningMethod::Scott: {
					Real width = ScottBinWidth(data);
					if (width < Constants::Eps || range < Constants::Eps) return SturgesBinCount(n);
					return std::max(1, static_cast<int>(std::ceil(range / width)));
				}

				case BinningMethod::FreedmanDiaconis: {
					Real width = FreedmanDiaconisBinWidth(data);
					if (width < Constants::Eps || range < Constants::Eps) return SturgesBinCount(n);
					return std::max(1, static_cast<int>(std::ceil(range / width)));
				}

				default:
					return SturgesBinCount(n);
				}
			}

			/////////////////////////////////////////////////////////////////////////////////////
			///                         CORE HISTOGRAM FUNCTIONS                              ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Compute histogram with specified number of bins
			/// @details Creates uniform bins spanning [min(data), max(data)]
			/// @param data Input data
			/// @param numBins Number of bins to use
			/// @return HistogramResult containing bin edges, counts, frequencies, and density
			/// @throws StatisticsError if data is empty or numBins < 1
			static HistogramResult ComputeHistogram(const Vector<Real>& data, int numBins) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("ComputeHistogram: Input data cannot be empty");
				if (numBins < 1)
					throw StatisticsError("ComputeHistogram: Number of bins must be at least 1");

				// Find data range
				Real minVal = data[0], maxVal = data[0];
				for (int i = 1; i < n; ++i) {
					if (data[i] < minVal) minVal = data[i];
					if (data[i] > maxVal) maxVal = data[i];
				}

				// Handle constant data case
				if (maxVal - minVal < Constants::Eps) {
					HistogramResult result;
					result.numBins = 1;
					result.totalCount = n;
					result.binWidth = 1.0;  // Arbitrary width for constant data
					result.binEdges = Vector<Real>(2);
					result.binEdges[0] = minVal - 0.5;
					result.binEdges[1] = minVal + 0.5;
					result.counts = Vector<int>(1);
					result.counts[0] = n;
					result.frequencies = Vector<Real>(1);
					result.frequencies[0] = 1.0;
					result.density = Vector<Real>(1);
					result.density[0] = 1.0;
					return result;
				}

				// Add small padding to include max value in last bin
				Real padding = (maxVal - minVal) * 1e-10;
				maxVal += padding;

				Real binWidth = (maxVal - minVal) / numBins;

				// Create bin edges
				Vector<Real> binEdges(numBins + 1);
				for (int i = 0; i <= numBins; ++i) {
					binEdges[i] = minVal + i * binWidth;
				}

				// Count values in each bin
				Vector<int> counts(numBins);
				for (int i = 0; i < numBins; ++i) counts[i] = 0;

				for (int i = 0; i < n; ++i) {
					int binIndex = static_cast<int>((data[i] - minVal) / binWidth);
					// Clamp to valid range (handles edge cases)
					if (binIndex < 0) binIndex = 0;
					if (binIndex >= numBins) binIndex = numBins - 1;
					counts[binIndex]++;
				}

				// Compute frequencies and density
				Vector<Real> frequencies(numBins);
				Vector<Real> density(numBins);
				for (int i = 0; i < numBins; ++i) {
					frequencies[i] = static_cast<Real>(counts[i]) / n;
					density[i] = frequencies[i] / binWidth;
				}

				HistogramResult result;
				result.binEdges = binEdges;
				result.counts = counts;
				result.frequencies = frequencies;
				result.density = density;
				result.binWidth = binWidth;
				result.numBins = numBins;
				result.totalCount = n;

				return result;
			}

			/// @brief Compute histogram with custom bin edges
			/// @details Bins are [edge[i], edge[i+1]) except last bin is [edge[n-1], edge[n]]
			/// @param data Input data
			/// @param binEdges Custom bin edges (must be sorted ascending)
			/// @return HistogramResult containing counts, frequencies, and density
			/// @throws StatisticsError if data is empty or binEdges has fewer than 2 elements
			static HistogramResult ComputeHistogram(const Vector<Real>& data, const Vector<Real>& binEdges) {
				int n = data.size();
				int numBins = binEdges.size() - 1;

				if (n == 0)
					throw StatisticsError("ComputeHistogram: Input data cannot be empty");
				if (numBins < 1)
					throw StatisticsError("ComputeHistogram: Need at least 2 bin edges");

				// Count values in each bin using binary search
				Vector<int> counts(numBins);
				for (int i = 0; i < numBins; ++i) counts[i] = 0;

				for (int i = 0; i < n; ++i) {
					Real val = data[i];
					// Find bin using linear search (for small numBins) or binary search
					for (int b = 0; b < numBins; ++b) {
						if (val >= binEdges[b] && (val < binEdges[b + 1] || (b == numBins - 1 && val <= binEdges[b + 1]))) {
							counts[b]++;
							break;
						}
					}
				}

				// Compute frequencies and density
				Vector<Real> frequencies(numBins);
				Vector<Real> density(numBins);
				for (int i = 0; i < numBins; ++i) {
					Real width = binEdges[i + 1] - binEdges[i];
					frequencies[i] = static_cast<Real>(counts[i]) / n;
					density[i] = (width > Constants::Eps) ? frequencies[i] / width : 0.0;
				}

				// Compute average bin width
				Real avgBinWidth = (binEdges[numBins] - binEdges[0]) / numBins;

				HistogramResult result;
				result.binEdges = binEdges;
				result.counts = counts;
				result.frequencies = frequencies;
				result.density = density;
				result.binWidth = avgBinWidth;
				result.numBins = numBins;
				result.totalCount = n;

				return result;
			}

			/// @brief Compute histogram with automatic bin selection
			/// @details Uses Sturges' rule by default
			/// @param data Input data
			/// @param method Binning method (default: Sturges)
			/// @return HistogramResult
			static HistogramResult ComputeHistogramAuto(const Vector<Real>& data,
				BinningMethod method = BinningMethod::Sturges) {
				int numBins = GetBinCount(data, method);
				return ComputeHistogram(data, numBins);
			}

			/////////////////////////////////////////////////////////////////////////////////////
			///                         CONVENIENCE METHODS                                   ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Compute histogram using Sturges' rule
			static HistogramResult HistogramSturges(const Vector<Real>& data) {
				return ComputeHistogramAuto(data, BinningMethod::Sturges);
			}

			/// @brief Compute histogram using Scott's rule
			static HistogramResult HistogramScott(const Vector<Real>& data) {
				return ComputeHistogramAuto(data, BinningMethod::Scott);
			}

			/// @brief Compute histogram using Freedman-Diaconis rule
			static HistogramResult HistogramFD(const Vector<Real>& data) {
				return ComputeHistogramAuto(data, BinningMethod::FreedmanDiaconis);
			}

			/// @brief Compute histogram using square root rule
			static HistogramResult HistogramSqrt(const Vector<Real>& data) {
				return ComputeHistogramAuto(data, BinningMethod::SquareRoot);
			}

			/// @brief Compute histogram using Rice's rule
			static HistogramResult HistogramRice(const Vector<Real>& data) {
				return ComputeHistogramAuto(data, BinningMethod::Rice);
			}

			/////////////////////////////////////////////////////////////////////////////////////
			///                         FREQUENCY TABLE                                       ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Result of frequency table computation for discrete values
			struct FrequencyTableResult {
				std::map<Real, int> counts;       ///< Value -> count mapping
				std::map<Real, Real> frequencies; ///< Value -> relative frequency mapping
				int totalCount;                   ///< Total number of data points
				int uniqueCount;                  ///< Number of unique values

				/// @brief Get sorted unique values
				Vector<Real> GetValues() const {
					Vector<Real> values(uniqueCount);
					int i = 0;
					for (const auto& pair : counts) {
						values[i++] = pair.first;
					}
					return values;
				}

				/// @brief Get counts in same order as GetValues()
				Vector<int> GetCounts() const {
					Vector<int> result(uniqueCount);
					int i = 0;
					for (const auto& pair : counts) {
						result[i++] = pair.second;
					}
					return result;
				}

				/// @brief Get frequencies in same order as GetValues()
				Vector<Real> GetFrequencies() const {
					Vector<Real> result(uniqueCount);
					int i = 0;
					for (const auto& pair : frequencies) {
						result[i++] = pair.second;
					}
					return result;
				}
			};

			/// @brief Compute frequency table for discrete values
			/// @details Counts occurrences of each unique value
			/// @param data Input data (typically integers or discrete values)
			/// @return FrequencyTableResult containing value counts and frequencies
			/// @throws StatisticsError if data is empty
			static FrequencyTableResult FrequencyTable(const Vector<Real>& data) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("FrequencyTable: Input data cannot be empty");

				FrequencyTableResult result;
				result.totalCount = n;

				// Count occurrences
				for (int i = 0; i < n; ++i) {
					result.counts[data[i]]++;
				}

				// Compute frequencies
				for (const auto& pair : result.counts) {
					result.frequencies[pair.first] = static_cast<Real>(pair.second) / n;
				}

				result.uniqueCount = static_cast<int>(result.counts.size());

				return result;
			}

			/////////////////////////////////////////////////////////////////////////////////////
			///                         CUMULATIVE DISTRIBUTION                               ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Result of empirical CDF computation
			struct ECDFResult {
				Vector<Real> x;        ///< Sorted unique x values
				Vector<Real> cdf;      ///< CDF values at each x
				int n;                 ///< Total number of data points
			};

			/// @brief Compute the Empirical Cumulative Distribution Function (ECDF)
			/// @details F(x) = (number of observations <= x) / n
			///          Returns step function values at each unique data point
			/// @param data Input data
			/// @return ECDFResult containing sorted x values and corresponding CDF values
			/// @throws StatisticsError if data is empty
			static ECDFResult EmpiricalCDF(const Vector<Real>& data) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("EmpiricalCDF: Input data cannot be empty");

				// Sort data
				std::vector<Real> sorted(n);
				for (int i = 0; i < n; ++i) sorted[i] = data[i];
				std::sort(sorted.begin(), sorted.end());

				// Find unique values and their CDF values
				std::vector<Real> uniqueX;
				std::vector<Real> cdfValues;

				Real prevVal = sorted[0];
				int count = 1;

				for (int i = 1; i <= n; ++i) {
					if (i == n || sorted[i] != prevVal) {
						uniqueX.push_back(prevVal);
						cdfValues.push_back(static_cast<Real>(i) / n);
						if (i < n) {
							prevVal = sorted[i];
							count = 1;
						}
					}
					else {
						count++;
					}
				}

				ECDFResult result;
				result.n = n;
				result.x = Vector<Real>(static_cast<int>(uniqueX.size()));
				result.cdf = Vector<Real>(static_cast<int>(cdfValues.size()));
				for (size_t i = 0; i < uniqueX.size(); ++i) {
					result.x[static_cast<int>(i)] = uniqueX[i];
					result.cdf[static_cast<int>(i)] = cdfValues[i];
				}

				return result;
			}

			/// @brief Evaluate ECDF at a given point
			/// @details Returns proportion of data <= x
			/// @param data Input data (not necessarily sorted)
			/// @param x Point at which to evaluate CDF
			/// @return F(x) = P(X <= x)
			static Real EvaluateECDF(const Vector<Real>& data, Real x) {
				int n = data.size();
				if (n == 0) return 0.0;

				int count = 0;
				for (int i = 0; i < n; ++i) {
					if (data[i] <= x) count++;
				}
				return static_cast<Real>(count) / n;
			}

			/////////////////////////////////////////////////////////////////////////////////////
			///                         QUANTILE COMPUTATION                                  ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Compute multiple quantiles efficiently
			/// @details Sorts data once and computes all requested quantiles
			///          Uses linear interpolation (similar to Excel PERCENTILE.INC)
			/// @param data Input data
			/// @param probabilities Vector of probabilities in [0, 1]
			/// @return Vector of quantile values corresponding to each probability
			/// @throws StatisticsError if data is empty or any probability is out of range
			static Vector<Real> Quantiles(const Vector<Real>& data, const Vector<Real>& probabilities) {
				int n = data.size();
				int numQuantiles = probabilities.size();

				if (n == 0)
					throw StatisticsError("Quantiles: Input data cannot be empty");
				if (numQuantiles == 0)
					throw StatisticsError("Quantiles: Probabilities vector cannot be empty");

				// Validate probabilities
				for (int i = 0; i < numQuantiles; ++i) {
					if (probabilities[i] < 0.0 || probabilities[i] > 1.0)
						throw StatisticsError("Quantiles: All probabilities must be in [0, 1]");
				}

				// Sort data once
				std::vector<Real> sorted(n);
				for (int i = 0; i < n; ++i) sorted[i] = data[i];
				std::sort(sorted.begin(), sorted.end());

				// Compute each quantile
				Vector<Real> result(numQuantiles);
				for (int i = 0; i < numQuantiles; ++i) {
					Real p = probabilities[i];

					if (p == 0.0) {
						result[i] = sorted[0];
					}
					else if (p == 1.0) {
						result[i] = sorted[n - 1];
					}
					else {
						Real rank = p * (n - 1);
						int lower = static_cast<int>(std::floor(rank));
						int upper = static_cast<int>(std::ceil(rank));
						Real fraction = rank - lower;
						result[i] = sorted[lower] + fraction * (sorted[upper] - sorted[lower]);
					}
				}

				return result;
			}

			/// @brief Compute a single quantile
			/// @param data Input data
			/// @param p Probability in [0, 1]
			/// @return The p-th quantile
			static Real Quantile(const Vector<Real>& data, Real p) {
				Vector<Real> probs(1);
				probs[0] = p;
				return Quantiles(data, probs)[0];
			}

			/////////////////////////////////////////////////////////////////////////////////////
			///                         BIN COUNTING AND DIGITIZATION                         ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Count data points in each bin (without normalization)
			/// @details Simple bin counting, bins are [edge[i], edge[i+1])
			///          except last bin which is [edge[n-1], edge[n]]
			/// @param data Input data
			/// @param binEdges Bin edges (must be sorted ascending, size = numBins + 1)
			/// @return Vector of counts per bin
			/// @throws StatisticsError if data is empty or binEdges has fewer than 2 elements
			static Vector<int> BinCount(const Vector<Real>& data, const Vector<Real>& binEdges) {
				int n = data.size();
				int numBins = binEdges.size() - 1;

				if (n == 0)
					throw StatisticsError("BinCount: Input data cannot be empty");
				if (numBins < 1)
					throw StatisticsError("BinCount: Need at least 2 bin edges");

				Vector<int> counts(numBins);
				for (int i = 0; i < numBins; ++i) counts[i] = 0;

				for (int i = 0; i < n; ++i) {
					Real val = data[i];
					// Find appropriate bin
					for (int b = 0; b < numBins; ++b) {
						if (val >= binEdges[b] && (val < binEdges[b + 1] || (b == numBins - 1 && val <= binEdges[b + 1]))) {
							counts[b]++;
							break;
						}
					}
				}

				return counts;
			}

			/// @brief Determine bin index for each data point (digitization)
			/// @details Returns the index of the bin each value falls into
			///          Values outside range get -1 (below) or numBins (above)
			/// @param data Input data
			/// @param binEdges Bin edges (must be sorted ascending)
			/// @return Vector of bin indices (0 to numBins-1, or -1/numBins for out of range)
			/// @throws StatisticsError if data is empty or binEdges has fewer than 2 elements
			static Vector<int> Digitize(const Vector<Real>& data, const Vector<Real>& binEdges) {
				int n = data.size();
				int numBins = binEdges.size() - 1;

				if (n == 0)
					throw StatisticsError("Digitize: Input data cannot be empty");
				if (numBins < 1)
					throw StatisticsError("Digitize: Need at least 2 bin edges");

				Vector<int> indices(n);

				for (int i = 0; i < n; ++i) {
					Real val = data[i];

					// Below range
					if (val < binEdges[0]) {
						indices[i] = -1;
						continue;
					}

					// Above range
					if (val > binEdges[numBins]) {
						indices[i] = numBins;
						continue;
					}

					// Find bin using linear search
					bool found = false;
					for (int b = 0; b < numBins; ++b) {
						if (val >= binEdges[b] && (val < binEdges[b + 1] || (b == numBins - 1 && val <= binEdges[b + 1]))) {
							indices[i] = b;
							found = true;
							break;
						}
					}

					if (!found) {
						indices[i] = numBins - 1;  // Fallback to last bin
					}
				}

				return indices;
			}

			/////////////////////////////////////////////////////////////////////////////////////
			///                         UTILITY FUNCTIONS                                     ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Create uniform bin edges from min to max
			/// @param minVal Minimum value (left edge of first bin)
			/// @param maxVal Maximum value (right edge of last bin)
			/// @param numBins Number of bins
			/// @return Vector of bin edges (size = numBins + 1)
			static Vector<Real> CreateUniformBinEdges(Real minVal, Real maxVal, int numBins) {
				if (numBins < 1)
					throw StatisticsError("CreateUniformBinEdges: Number of bins must be at least 1");

				Vector<Real> edges(numBins + 1);
				Real width = (maxVal - minVal) / numBins;
				for (int i = 0; i <= numBins; ++i) {
					edges[i] = minVal + i * width;
				}
				return edges;
			}

			/// @brief Create logarithmic bin edges (useful for log-scale histograms)
			/// @param minVal Minimum value (must be positive)
			/// @param maxVal Maximum value
			/// @param numBins Number of bins
			/// @return Vector of bin edges with logarithmic spacing
			static Vector<Real> CreateLogBinEdges(Real minVal, Real maxVal, int numBins) {
				if (numBins < 1)
					throw StatisticsError("CreateLogBinEdges: Number of bins must be at least 1");
				if (minVal <= 0)
					throw StatisticsError("CreateLogBinEdges: Minimum value must be positive");
				if (maxVal <= minVal)
					throw StatisticsError("CreateLogBinEdges: Maximum must be greater than minimum");

				Vector<Real> edges(numBins + 1);
				Real logMin = std::log10(minVal);
				Real logMax = std::log10(maxVal);
				Real logWidth = (logMax - logMin) / numBins;

				for (int i = 0; i <= numBins; ++i) {
					edges[i] = std::pow(10.0, logMin + i * logWidth);
				}
				return edges;
			}

		}  // namespace Histogram
	}  // namespace Statistics
}  // namespace MML


///////////////////////////   mml/algorithms/Statistics/DataDescriptors.h   ///////////////////////////



namespace MML
{
namespace Statistics
{

/////////////////////////////////////////////////////////////////////////////////////
///                          BOOLEAN DATA STATISTICS                               ///
/////////////////////////////////////////////////////////////////////////////////////

/**
 * @brief Statistics for boolean data
 * 
 * Computes proportion-based statistics including confidence intervals
 * and chi-square test for expected proportion.
 */
struct BoolDataStats
{
	size_t count;           ///< Total count
	size_t countTrue;       ///< Count of true values
	size_t countFalse;      ///< Count of false values
	Real proportionTrue;    ///< Proportion of true values (p = countTrue/count)
	Real standardError;     ///< Standard error of proportion: sqrt(p(1-p)/n)
	Real ciLower95;         ///< 95% confidence interval lower bound
	Real ciUpper95;         ///< 95% confidence interval upper bound

	/**
	 * @brief Compute statistics from boolean data
	 * @param data Vector of boolean values
	 * @return BoolDataStats with computed values
	 * @throws StatisticsError if data is empty
	 */
	static BoolDataStats Compute(const std::vector<bool>& data)
	{
		if (data.empty())
			throw StatisticsError("BoolDataStats: Data cannot be empty");

		BoolDataStats stats;
		stats.count = data.size();
		stats.countTrue = std::count(data.begin(), data.end(), true);
		stats.countFalse = stats.count - stats.countTrue;
		
		stats.proportionTrue = static_cast<Real>(stats.countTrue) / stats.count;
		
		// Standard error of proportion: sqrt(p(1-p)/n)
		Real p = stats.proportionTrue;
		Real n = static_cast<Real>(stats.count);
		stats.standardError = std::sqrt(p * (1.0 - p) / n);
		
		// 95% CI using normal approximation (z = 1.96)
		Real z = 1.96;
		stats.ciLower95 = std::max(0.0, p - z * stats.standardError);
		stats.ciUpper95 = std::min(1.0, p + z * stats.standardError);
		
		return stats;
	}

	/**
	 * @brief Chi-square test statistic for expected proportion
	 * @param expectedProportion The hypothesized proportion of true values
	 * @return Chi-square statistic value
	 * 
	 * Formula: chi2 = sum((O-E)^2/E) for both categories
	 * Under H0, this follows chi-square distribution with df=1
	 */
	Real ChiSquare(Real expectedProportion) const
	{
		if (expectedProportion <= 0.0 || expectedProportion >= 1.0)
			throw StatisticsError("BoolDataStats::ChiSquare: Expected proportion must be in (0, 1)");

		Real expectedTrue = count * expectedProportion;
		Real expectedFalse = count * (1.0 - expectedProportion);
		
		Real chi2 = (countTrue - expectedTrue) * (countTrue - expectedTrue) / expectedTrue
		          + (countFalse - expectedFalse) * (countFalse - expectedFalse) / expectedFalse;
		
		return chi2;
	}

	/// @brief Print summary to stream
	void PrintSummary(std::ostream& os = std::cout) const
	{
		os << "Boolean Data Statistics:\n";
		os << "  Count: " << count << " (True: " << countTrue << ", False: " << countFalse << ")\n";
		os << "  Proportion True: " << std::fixed << std::setprecision(4) << proportionTrue << "\n";
		os << "  Standard Error: " << standardError << "\n";
		os << "  95% CI: [" << ciLower95 << ", " << ciUpper95 << "]\n";
	}
};

/////////////////////////////////////////////////////////////////////////////////////
///                           TIME DATA STATISTICS                                 ///
/////////////////////////////////////////////////////////////////////////////////////

/**
 * @brief Statistics for time/duration data (seconds since epoch or duration in seconds)
 * 
 * Supports both timestamps and durations. For timestamps, provides
 * distributions by hour of day and day of week.
 */
struct TimeDataStats
{
	size_t count;           ///< Number of time values
	Real minSeconds;        ///< Minimum time in seconds
	Real maxSeconds;        ///< Maximum time in seconds
	Real avgSeconds;        ///< Average time in seconds
	Real medianSeconds;     ///< Median time in seconds
	Real stdDevSeconds;     ///< Standard deviation in seconds
	Real rangeSeconds;      ///< Range (max - min) in seconds

	std::vector<size_t> hourDistribution;    ///< Count by hour (0-23)
	std::vector<size_t> dayOfWeekDistribution; ///< Count by day (0=Sun, 6=Sat)

	/**
	 * @brief Compute statistics from time data (seconds)
	 * @param data Vector of time values in seconds (epoch or duration)
	 * @param isTimestamp If true, compute hour/day distributions (default: true)
	 * @return TimeDataStats with computed values
	 */
	static TimeDataStats Compute(const Vector<Real>& data, bool isTimestamp = true)
	{
		if (data.size() == 0)
			throw StatisticsError("TimeDataStats: Data cannot be empty");

		TimeDataStats stats;
		stats.count = data.size();

		// Basic statistics
		stats.minSeconds = data[0];
		stats.maxSeconds = data[0];
		Real sum = 0.0;
		
		for (int i = 0; i < data.size(); ++i) {
			if (data[i] < stats.minSeconds) stats.minSeconds = data[i];
			if (data[i] > stats.maxSeconds) stats.maxSeconds = data[i];
			sum += data[i];
		}
		
		stats.avgSeconds = sum / stats.count;
		stats.rangeSeconds = stats.maxSeconds - stats.minSeconds;

		// Median
		std::vector<Real> sorted(data.size());
		for (int i = 0; i < data.size(); ++i)
			sorted[i] = data[i];
		std::sort(sorted.begin(), sorted.end());
		
		if (stats.count % 2 == 0)
			stats.medianSeconds = (sorted[stats.count / 2 - 1] + sorted[stats.count / 2]) / 2.0;
		else
			stats.medianSeconds = sorted[stats.count / 2];

		// Standard deviation
		Real sumSq = 0.0;
		for (int i = 0; i < data.size(); ++i) {
			Real diff = data[i] - stats.avgSeconds;
			sumSq += diff * diff;
		}
		stats.stdDevSeconds = std::sqrt(sumSq / (stats.count - 1));

		// Hour and day distributions (only for timestamps)
		stats.hourDistribution.resize(24, 0);
		stats.dayOfWeekDistribution.resize(7, 0);
		
		if (isTimestamp) {
			for (int i = 0; i < data.size(); ++i) {
				time_t t = static_cast<time_t>(data[i]);
				std::tm* tm = std::gmtime(&t);
				if (tm) {
					stats.hourDistribution[tm->tm_hour]++;
					stats.dayOfWeekDistribution[tm->tm_wday]++;
				}
			}
		}

		return stats;
	}

	/// @brief Convert seconds to human-readable HH:MM:SS format
	static std::string SecondsToHMS(Real seconds)
	{
		bool negative = seconds < 0;
		if (negative) seconds = -seconds;
		
		int h = static_cast<int>(seconds / 3600);
		int m = static_cast<int>(std::fmod(seconds, 3600) / 60);
		int s = static_cast<int>(std::fmod(seconds, 60));
		
		std::ostringstream oss;
		if (negative) oss << "-";
		oss << std::setfill('0') << std::setw(2) << h << ":"
		    << std::setw(2) << m << ":" << std::setw(2) << s;
		return oss.str();
	}

	/// @brief Convert seconds to days (with decimal)
	static Real SecondsToDays(Real seconds) { return seconds / 86400.0; }

	/// @brief Print summary to stream
	void PrintSummary(std::ostream& os = std::cout) const
	{
		os << "Time Data Statistics:\n";
		os << "  Count: " << count << "\n";
		os << "  Range: " << SecondsToHMS(rangeSeconds) << " (" << SecondsToDays(rangeSeconds) << " days)\n";
		os << "  Min: " << SecondsToHMS(minSeconds) << "\n";
		os << "  Max: " << SecondsToHMS(maxSeconds) << "\n";
		os << "  Avg: " << SecondsToHMS(avgSeconds) << "\n";
		os << "  Median: " << SecondsToHMS(medianSeconds) << "\n";
		os << "  Std Dev: " << SecondsToHMS(stdDevSeconds) << "\n";
	}
};

/////////////////////////////////////////////////////////////////////////////////////
///                           DATE DATA STATISTICS                                 ///
/////////////////////////////////////////////////////////////////////////////////////

/**
 * @brief Statistics for date data (days since epoch or structured dates)
 * 
 * Provides year/month/day-of-week frequency distributions and
 * weekday vs weekend analysis.
 */
struct DateDataStats
{
	size_t count;           ///< Number of date values
	int minYear;            ///< Minimum year
	int maxYear;            ///< Maximum year
	int spanDays;           ///< Span in days (max - min)
	
	std::map<int, size_t> yearDistribution;      ///< Count by year
	std::vector<size_t> monthDistribution;       ///< Count by month (0=Jan, 11=Dec)
	std::vector<size_t> dayOfWeekDistribution;   ///< Count by day (0=Sun, 6=Sat)
	size_t weekdayCount;    ///< Mon-Fri count
	size_t weekendCount;    ///< Sat-Sun count

	/**
	 * @brief Compute statistics from date data (epoch days or timestamps)
	 * @param epochDays Vector of days since epoch (or timestamps in seconds)
	 * @param isSeconds If true, treat input as seconds; otherwise days (default: false)
	 * @return DateDataStats with computed values
	 */
	static DateDataStats Compute(const Vector<Real>& epochDays, bool isSeconds = false)
	{
		if (epochDays.size() == 0)
			throw StatisticsError("DateDataStats: Data cannot be empty");

		DateDataStats stats;
		stats.count = epochDays.size();
		stats.monthDistribution.resize(12, 0);
		stats.dayOfWeekDistribution.resize(7, 0);
		stats.weekdayCount = 0;
		stats.weekendCount = 0;

		Real minVal = epochDays[0];
		Real maxVal = epochDays[0];

		for (int i = 0; i < epochDays.size(); ++i) {
			Real val = epochDays[i];
			if (val < minVal) minVal = val;
			if (val > maxVal) maxVal = val;

			// Convert to time_t
			time_t t;
			if (isSeconds)
				t = static_cast<time_t>(val);
			else
				t = static_cast<time_t>(val * 86400.0);

			std::tm* tm = std::gmtime(&t);
			if (tm) {
				int year = tm->tm_year + 1900;
				stats.yearDistribution[year]++;
				stats.monthDistribution[tm->tm_mon]++;
				stats.dayOfWeekDistribution[tm->tm_wday]++;
				
				if (tm->tm_wday == 0 || tm->tm_wday == 6)
					stats.weekendCount++;
				else
					stats.weekdayCount++;
			}
		}

		// Compute year range
		if (!stats.yearDistribution.empty()) {
			stats.minYear = stats.yearDistribution.begin()->first;
			stats.maxYear = stats.yearDistribution.rbegin()->first;
		}

		// Span in days
		if (isSeconds)
			stats.spanDays = static_cast<int>((maxVal - minVal) / 86400.0);
		else
			stats.spanDays = static_cast<int>(maxVal - minVal);

		return stats;
	}

	/// @brief Get most common month (0-11)
	int GetModeMonth() const
	{
		return static_cast<int>(std::max_element(monthDistribution.begin(), 
		                                          monthDistribution.end()) - monthDistribution.begin());
	}

	/// @brief Get weekday proportion (Mon-Fri / total)
	Real GetWeekdayProportion() const
	{
		return static_cast<Real>(weekdayCount) / count;
	}

	/// @brief Print summary to stream
	void PrintSummary(std::ostream& os = std::cout) const
	{
		os << "Date Data Statistics:\n";
		os << "  Count: " << count << "\n";
		os << "  Year Range: " << minYear << " - " << maxYear << "\n";
		os << "  Span: " << spanDays << " days\n";
		os << "  Weekday/Weekend: " << weekdayCount << "/" << weekendCount 
		   << " (" << std::fixed << std::setprecision(1) << (GetWeekdayProportion() * 100) << "% weekday)\n";
		
		os << "  Month Distribution: ";
		const char* months[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
		for (int i = 0; i < 12; ++i) {
			if (monthDistribution[i] > 0)
				os << months[i] << ":" << monthDistribution[i] << " ";
		}
		os << "\n";
	}
};

/////////////////////////////////////////////////////////////////////////////////////
///                      GEOGRAPHIC DATA STATISTICS                                ///
/////////////////////////////////////////////////////////////////////////////////////

/**
 * @brief Statistics for geographic (lat/lon) data
 * 
 * Computes centroid, bounding box, and average distance from centroid.
 * Uses WGS84 coordinates (standard GPS).
 */
struct GeoDataStats
{
	size_t count;           ///< Number of points
	Real centroidLat;       ///< Centroid latitude
	Real centroidLon;       ///< Centroid longitude
	Real minLat, maxLat;    ///< Latitude bounding box
	Real minLon, maxLon;    ///< Longitude bounding box
	Real avgDistanceFromCentroid;  ///< Average distance from centroid (km)
	Real maxDistanceFromCentroid;  ///< Maximum distance from centroid (km)

	/// @brief Earth radius in kilometers (WGS84 mean)
	static constexpr Real EARTH_RADIUS_KM = 6371.0;

	/**
	 * @brief Compute Haversine distance between two points
	 * @param lat1, lon1 First point (degrees)
	 * @param lat2, lon2 Second point (degrees)
	 * @return Distance in kilometers
	 */
	static Real HaversineDistance(Real lat1, Real lon1, Real lat2, Real lon2)
	{
		// Convert to radians
		Real lat1Rad = lat1 * Constants::PI / 180.0;
		Real lat2Rad = lat2 * Constants::PI / 180.0;
		Real dLat = (lat2 - lat1) * Constants::PI / 180.0;
		Real dLon = (lon2 - lon1) * Constants::PI / 180.0;

		Real a = std::sin(dLat / 2) * std::sin(dLat / 2) +
		         std::cos(lat1Rad) * std::cos(lat2Rad) *
		         std::sin(dLon / 2) * std::sin(dLon / 2);
		Real c = 2 * std::atan2(std::sqrt(a), std::sqrt(1 - a));

		return EARTH_RADIUS_KM * c;
	}

	/**
	 * @brief Compute statistics from geographic data
	 * @param latitudes Vector of latitudes (degrees, -90 to 90)
	 * @param longitudes Vector of longitudes (degrees, -180 to 180)
	 * @return GeoDataStats with computed values
	 * @throws StatisticsError if vectors have different sizes or are empty
	 */
	static GeoDataStats Compute(const Vector<Real>& latitudes, const Vector<Real>& longitudes)
	{
		if (latitudes.size() == 0 || longitudes.size() == 0)
			throw StatisticsError("GeoDataStats: Data cannot be empty");
		if (latitudes.size() != longitudes.size())
			throw StatisticsError("GeoDataStats: Latitude and longitude vectors must have same size");

		GeoDataStats stats;
		stats.count = latitudes.size();

		// Compute centroid (simple average - works for small regions)
		Real sumLat = 0, sumLon = 0;
		stats.minLat = stats.maxLat = latitudes[0];
		stats.minLon = stats.maxLon = longitudes[0];

		for (int i = 0; i < latitudes.size(); ++i) {
			sumLat += latitudes[i];
			sumLon += longitudes[i];
			
			if (latitudes[i] < stats.minLat) stats.minLat = latitudes[i];
			if (latitudes[i] > stats.maxLat) stats.maxLat = latitudes[i];
			if (longitudes[i] < stats.minLon) stats.minLon = longitudes[i];
			if (longitudes[i] > stats.maxLon) stats.maxLon = longitudes[i];
		}

		stats.centroidLat = sumLat / stats.count;
		stats.centroidLon = sumLon / stats.count;

		// Compute distances from centroid
		Real sumDist = 0;
		stats.maxDistanceFromCentroid = 0;

		for (int i = 0; i < latitudes.size(); ++i) {
			Real dist = HaversineDistance(latitudes[i], longitudes[i],
			                               stats.centroidLat, stats.centroidLon);
			sumDist += dist;
			if (dist > stats.maxDistanceFromCentroid)
				stats.maxDistanceFromCentroid = dist;
		}

		stats.avgDistanceFromCentroid = sumDist / stats.count;

		return stats;
	}

	/// @brief Get bounding box diagonal distance (km)
	Real GetBoundingBoxDiagonal() const
	{
		return HaversineDistance(minLat, minLon, maxLat, maxLon);
	}

	/// @brief Print summary to stream
	void PrintSummary(std::ostream& os = std::cout) const
	{
		os << "Geographic Data Statistics:\n";
		os << "  Count: " << count << " points\n";
		os << std::fixed << std::setprecision(4);
		os << "  Centroid: (" << centroidLat << ", " << centroidLon << ")\n";
		os << "  Bounding Box: [" << minLat << ", " << minLon << "] to [" 
		   << maxLat << ", " << maxLon << "]\n";
		os << std::setprecision(2);
		os << "  Avg Distance from Centroid: " << avgDistanceFromCentroid << " km\n";
		os << "  Max Distance from Centroid: " << maxDistanceFromCentroid << " km\n";
		os << "  Bounding Box Diagonal: " << GetBoundingBoxDiagonal() << " km\n";
	}
};

/////////////////////////////////////////////////////////////////////////////////////
///                        CATEGORICAL DATA STATISTICS                             ///
/////////////////////////////////////////////////////////////////////////////////////

/**
 * @brief Statistics for categorical (string) data
 * 
 * Computes frequency distribution, unique count, mode, and entropy.
 */
struct CategoryStats
{
	size_t count;           ///< Total number of values
	size_t uniqueCount;     ///< Number of unique categories
	std::string mode;       ///< Most frequent category
	size_t modeCount;       ///< Count of most frequent category
	Real entropy;           ///< Shannon entropy (bits)
	
	std::map<std::string, size_t> frequencies;  ///< Category -> count

	/**
	 * @brief Compute statistics from categorical data
	 * @param data Vector of string categories
	 * @return CategoryStats with computed values
	 */
	static CategoryStats Compute(const std::vector<std::string>& data)
	{
		if (data.empty())
			throw StatisticsError("CategoryStats: Data cannot be empty");

		CategoryStats stats;
		stats.count = data.size();
		stats.modeCount = 0;

		// Build frequency map
		for (const auto& val : data) {
			stats.frequencies[val]++;
		}

		stats.uniqueCount = stats.frequencies.size();

		// Find mode and compute entropy
		stats.entropy = 0.0;
		Real n = static_cast<Real>(stats.count);

		for (const auto& [category, freq] : stats.frequencies) {
			if (freq > stats.modeCount) {
				stats.modeCount = freq;
				stats.mode = category;
			}
			
			// Shannon entropy: -sum(p * log2(p))
			Real p = freq / n;
			if (p > 0)
				stats.entropy -= p * std::log2(p);
		}

		return stats;
	}

	/**
	 * @brief Get top N categories by frequency
	 * @param n Number of categories to return
	 * @return Vector of (category, count) pairs sorted by count descending
	 */
	std::vector<std::pair<std::string, size_t>> GetTopN(size_t n) const
	{
		std::vector<std::pair<std::string, size_t>> sorted(frequencies.begin(), frequencies.end());
		std::sort(sorted.begin(), sorted.end(),
		          [](const auto& a, const auto& b) { return a.second > b.second; });
		
		if (sorted.size() > n)
			sorted.resize(n);
		
		return sorted;
	}

	/// @brief Get proportion of mode (mode_count / total)
	Real GetModeProportion() const
	{
		return static_cast<Real>(modeCount) / count;
	}

	/// @brief Print summary to stream
	void PrintSummary(std::ostream& os = std::cout) const
	{
		os << "Categorical Data Statistics:\n";
		os << "  Count: " << count << "\n";
		os << "  Unique Categories: " << uniqueCount << "\n";
		os << "  Mode: \"" << mode << "\" (count: " << modeCount 
		   << ", " << std::fixed << std::setprecision(1) << (GetModeProportion() * 100) << "%)\n";
		os << "  Entropy: " << std::setprecision(3) << entropy << " bits\n";
		
		os << "  Top 5 Categories:\n";
		auto top5 = GetTopN(5);
		for (const auto& [cat, freq] : top5) {
			os << "    \"" << cat << "\": " << freq 
			   << " (" << std::setprecision(1) << (100.0 * freq / count) << "%)\n";
		}
	}
};

/////////////////////////////////////////////////////////////////////////////////////
///                         COMBINED DATA DESCRIPTOR                               ///
/////////////////////////////////////////////////////////////////////////////////////

/**
 * @brief Unified interface for computing type-appropriate statistics
 * 
 * Provides static methods to compute stats based on detected or specified data type.
 */
struct DataDescriptor
{
	/// @brief Data type enumeration
	enum class Type { REAL, BOOL, TIME, DATE, GEO, CATEGORY };

	/// @brief Detect likely type from string data sample
	static Type DetectType(const std::vector<std::string>& samples)
	{
		if (samples.empty()) return Type::CATEGORY;

		// Check patterns in first few non-empty samples
		int numericCount = 0;
		int boolCount = 0;
		int dateCount = 0;
		int timeCount = 0;
		int checked = 0;

		for (const auto& s : samples) {
			if (s.empty()) continue;
			if (++checked > 100) break;  // Sample first 100

			// Boolean check
			std::string lower = s;
			std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
			if (lower == "true" || lower == "false" || lower == "yes" || lower == "no") {
				boolCount++;
				continue;
			}

			// Date check (YYYY-MM-DD or similar)
			if (s.length() >= 8 && s.length() <= 10 && 
			    (s[4] == '-' || s[4] == '/') && std::isdigit(s[0])) {
				dateCount++;
				continue;
			}

			// Time check (HH:MM:SS or similar)
			if (s.length() >= 5 && s.length() <= 8 && s[2] == ':') {
				timeCount++;
				continue;
			}

			// Numeric check
			try {
				(void)std::stod(s);  // Discard result, only checking if valid
				numericCount++;
			} catch (...) {
				// Not numeric - likely category
			}
		}

		// Determine type based on majority
		int threshold = checked / 2;
		if (boolCount > threshold) return Type::BOOL;
		if (dateCount > threshold) return Type::DATE;
		if (timeCount > threshold) return Type::TIME;
		if (numericCount > threshold) return Type::REAL;
		
		return Type::CATEGORY;
	}
};

} // namespace Statistics
} // namespace MML


///////////////////////////   mml/algorithms/Statistics/CoreDistributions.h   ///////////////////////////
// CoreDistributions.h
// 
// Core probability distributions for MML (MinimalMathLibrary)
// Extracted from Statistics.h as part of refactoring to improve organization
//
// Contains: Normal, Student's T, Chi-Square, and F distributions
// These are fundamental distributions used throughout statistical inference
///////////////////////////////////////////////////////////////////////////////////////////



namespace MML
{
	namespace Statistics
	{
		/**
		 * @brief Normal (Gaussian) distribution
		 * 
		 * The normal distribution is the most important continuous distribution,
		 * central to the Central Limit Theorem and statistical inference.
		 * 
		 * PDF: f(x) = (1 / (Ïƒâˆš(2Ï€))) Â· exp(-Â½((x-Î¼)/Ïƒ)Â²)
		 * where Î¼ is the mean and Ïƒ is the standard deviation
		 * 
		 * The standard normal has Î¼=0 and Ïƒ=1.
		 */
		struct NormalDistribution
		{
			Real mu;    // Mean (location parameter)
			Real sigma; // Standard deviation (scale parameter)

			/**
			 * @brief Construct a normal distribution
			 * @param mean Mean parameter Î¼ (default: 0)
			 * @param stddev Standard deviation Ïƒ (default: 1, must be > 0)
			 */
			NormalDistribution(Real mean = 0.0, Real stddev = 1.0)
				: mu(mean), sigma(stddev)
			{
				if (sigma <= 0.0)
					throw StatisticsError("Standard deviation must be positive in NormalDistribution");
			}

			/**
			 * @brief Probability density function (PDF)
			 * @param x Value at which to evaluate the PDF
			 * @return Probability density at x
			 */
			Real pdf(Real x) const
			{
				Real z = (x - mu) / sigma;
				return std::exp(-0.5 * z * z) / (sigma * std::sqrt(2.0 * Constants::PI));
			}

			/**
			 * @brief Cumulative distribution function (CDF)
			 * 
			 * Uses the error function: Î¦(x) = 0.5 * (1 + erf(x/âˆš2))
			 * 
			 * @param x Value at which to evaluate the CDF
			 * @return Probability that X <= x
			 */
			Real cdf(Real x) const
			{
				Real z = (x - mu) / (sigma * std::sqrt(2.0));
				return 0.5 * (1.0 + std::erf(z));
			}

			/**
			 * @brief Inverse cumulative distribution function (quantile/probit function)
			 * 
			 * Uses Abramowitz and Stegun approximation for the inverse error function.
			 * 
			 * @param p Probability (must be in (0, 1))
			 * @return Value x such that P(X <= x) = p
			 */
			Real inverseCdf(Real p) const
			{
				if (p <= 0.0 || p >= 1.0)
					throw StatisticsError("Probability must be in (0, 1) in NormalDistribution::inverseCdf");

				// Use rational approximation for inverse normal CDF
				// Based on Abramowitz and Stegun approximation 26.2.23
				Real z = inverseStandardNormalCdf(p);
				return mu + sigma * z;
			}

			/**
			 * @brief Z-score: standardize a value
			 * @param x Raw value
			 * @return Standardized value (z-score)
			 */
			Real zScore(Real x) const
			{
				return (x - mu) / sigma;
			}

			/**
			 * @brief Convert z-score back to raw value
			 * @param z Standardized value
			 * @return Raw value
			 */
			Real fromZScore(Real z) const
			{
				return mu + sigma * z;
			}

			/**
			 * @brief Mean of the distribution
			 */
			Real mean() const { return mu; }

			/**
			 * @brief Variance of the distribution
			 */
			Real variance() const { return sigma * sigma; }

			/**
			 * @brief Standard deviation of the distribution
			 */
			Real stddev() const { return sigma; }

		private:
			/**
			 * @brief Inverse of the standard normal CDF (probit function)
			 * 
			 * Uses rational approximation from Abramowitz and Stegun (26.2.23)
			 * with refinement for tails. Accurate to ~1e-9.
			 */
			static Real inverseStandardNormalCdf(Real p)
			{
				if (p <= 0.0 || p >= 1.0)
					throw StatisticsError("Probability must be in (0, 1) in inverseStandardNormalCdf");

				// Coefficients for rational approximation
				const Real a[] = {
					-3.969683028665376e+01,
					 2.209460984245205e+02,
					-2.759285104469687e+02,
					 1.383577518672690e+02,
					-3.066479806614716e+01,
					 2.506628277459239e+00
				};
				const Real b[] = {
					-5.447609879822406e+01,
					 1.615858368580409e+02,
					-1.556989798598866e+02,
					 6.680131188771972e+01,
					-1.328068155288572e+01
				};
				const Real c[] = {
					-7.784894002430293e-03,
					-3.223964580411365e-01,
					-2.400758277161838e+00,
					-2.549732539343734e+00,
					 4.374664141464968e+00,
					 2.938163982698783e+00
				};
				const Real d[] = {
					 7.784695709041462e-03,
					 3.224671290700398e-01,
					 2.445134137142996e+00,
					 3.754408661907416e+00
				};

				const Real pLow = 0.02425;
				const Real pHigh = 1.0 - pLow;

				Real q, r;

				if (p < pLow) {
					// Lower tail
					q = std::sqrt(-2.0 * std::log(p));
					return (((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
					        ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0);
				} else if (p <= pHigh) {
					// Central region
					q = p - 0.5;
					r = q * q;
					return (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5]) * q /
					       (((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0);
				} else {
					// Upper tail
					q = std::sqrt(-2.0 * std::log(1.0 - p));
					return -(((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
					         ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0);
				}
			}
		};

		/**
		 * @brief Standard normal distribution (mean=0, stddev=1)
		 * 
		 * Convenience functions for the standard normal distribution.
		 */
		struct StandardNormal
		{
			/**
			 * @brief PDF of standard normal
			 */
			static Real pdf(Real z)
			{
				return std::exp(-0.5 * z * z) / std::sqrt(2.0 * Constants::PI);
			}

			/**
			 * @brief CDF of standard normal (Î¦ function)
			 */
			static Real cdf(Real z)
			{
				return 0.5 * (1.0 + std::erf(z / std::sqrt(2.0)));
			}

			/**
			 * @brief Inverse CDF (probit function)
			 */
			static Real inverseCdf(Real p)
			{
				NormalDistribution standard(0.0, 1.0);
				return standard.inverseCdf(p);
			}

			/**
			 * @brief Survival function: P(Z > z) = 1 - Î¦(z)
			 */
			static Real sf(Real z)
			{
				return 1.0 - cdf(z);
			}

			/**
			 * @brief Two-tailed p-value: P(|Z| > |z|)
			 */
			static Real twoTailedPValue(Real z)
			{
				return 2.0 * sf(std::abs(z));
			}
		};

		/**
		 * @brief Student's t-distribution
		 * 
		 * The t-distribution is used for inference about means when the sample size
		 * is small and/or the population standard deviation is unknown. It has heavier
		 * tails than the normal distribution, with the tail weight controlled by
		 * degrees of freedom (df).
		 * 
		 * As df â†’ âˆž, the t-distribution approaches the standard normal distribution.
		 * 
		 * PDF: f(x) = Î“((Î½+1)/2) / (âˆš(Î½Ï€) Â· Î“(Î½/2)) Â· (1 + xÂ²/Î½)^(-(Î½+1)/2)
		 * where Î½ is the degrees of freedom
		 */
		struct TDistribution
		{
			int df;  // Degrees of freedom

			/**
			 * @brief Construct a Student's t-distribution
			 * @param degreesOfFreedom Degrees of freedom (must be >= 1)
			 */
			TDistribution(int degreesOfFreedom) : df(degreesOfFreedom)
			{
				if (df < 1)
					throw StatisticsError("Degrees of freedom must be at least 1 in TDistribution");
			}

			/**
			 * @brief Probability density function (PDF)
			 * @param x Value at which to evaluate the PDF
			 * @return Probability density at x
			 */
			Real pdf(Real x) const
			{
				Real nu = static_cast<Real>(df);
				
				// Log-space computation for numerical stability
				Real logNumerator = std::lgamma((nu + 1.0) / 2.0);
				Real logDenominator = 0.5 * std::log(nu * Constants::PI) + std::lgamma(nu / 2.0);
				Real logBase = -(nu + 1.0) / 2.0 * std::log(1.0 + x * x / nu);
				
				return std::exp(logNumerator - logDenominator + logBase);
			}

			/**
			 * @brief Cumulative distribution function (CDF)
			 * 
			 * Uses the regularized incomplete beta function.
			 * 
			 * @param x Value at which to evaluate the CDF
			 * @return Probability that T <= x
			 */
			Real cdf(Real x) const
			{
				if (df == 1) {
					// Special case: df=1 is Cauchy distribution centered at 0
					return 0.5 + std::atan(x) / Constants::PI;
				}

				Real nu = static_cast<Real>(df);
				
				if (x == 0.0)
					return 0.5;
				
				// Standard formula for t-distribution CDF:
				// For t > 0: P(T <= t) = 1 - 0.5 * I_x(df/2, 0.5)
				// where x = df/(df + tÂ²)
				// For t < 0: Use symmetry P(T <= -|t|) = 1 - P(T <= |t|)
				
				Real absX = std::abs(x);
				Real x2 = absX * absX;
				Real xBeta = nu / (nu + x2);
				Real betaReg = incompleteBetaRegularized(xBeta, nu / 2.0, 0.5);
				
				Real result = 1.0 - 0.5 * betaReg;
				
				// If x < 0, use symmetry
				if (x < 0.0)
					result = 1.0 - result;
				
				return result;
			}

			/**
			 * @brief Inverse cumulative distribution function (quantile function)
			 * 
			 * Uses iterative root finding for the inverse.
			 * 
			 * @param p Probability (must be in (0, 1))
			 * @return Value t such that P(T <= t) = p
			 */
			Real inverseCdf(Real p) const
			{
				if (p <= 0.0 || p >= 1.0)
					throw StatisticsError("Probability must be in (0, 1) in TDistribution::inverseCdf");

				if (p == 0.5)
					return 0.0;

				if (df == 1) {
					// Special case: df=1 is Cauchy
					return std::tan(Constants::PI * (p - 0.5));
				}

				// Use Newton-Raphson iteration
				// Start with normal approximation
				Real t = StandardNormal::inverseCdf(p);
				
				// Refine with Newton-Raphson
				for (int iter = 0; iter < 10; iter++) {
					Real f = cdf(t) - p;
					Real fprime = pdf(t);
					
					if (std::abs(fprime) < 1e-14)
						break;
					
					Real delta = f / fprime;
					t -= delta;
					
					if (std::abs(delta) < 1e-10)
						break;
				}
				
				return t;
			}

			/**
			 * @brief Survival function: P(T > t)
			 */
			Real sf(Real x) const
			{
				return 1.0 - cdf(x);
			}

			/**
			 * @brief Two-tailed p-value: P(|T| > |t|)
			 * 
			 * This is the standard p-value used in t-tests.
			 */
			Real twoTailedPValue(Real t) const
			{
				return 2.0 * sf(std::abs(t));
			}

			/**
			 * @brief Critical value for given significance level (two-tailed)
			 * 
			 * Returns t* such that P(|T| > t*) = alpha
			 * 
			 * @param alpha Significance level (e.g., 0.05 for 95% confidence)
			 * @return Critical value t*
			 */
			Real criticalValue(Real alpha) const
			{
				if (alpha <= 0.0 || alpha >= 1.0)
					throw StatisticsError("Alpha must be in (0, 1) in TDistribution::criticalValue");
				
				// Two-tailed: find t* where P(T > t*) = alpha/2
				return inverseCdf(1.0 - alpha / 2.0);
			}

			/**
			 * @brief Mean of the distribution (if it exists)
			 * 
			 * Mean exists only for df >= 2, and equals 0.
			 */
			Real mean() const
			{
				if (df < 2)
					throw StatisticsError("Mean does not exist for df < 2 in TDistribution");
				return 0.0;
			}

			/**
			 * @brief Variance of the distribution (if it exists)
			 * 
			 * Variance exists only for df >= 3.
			 * Var(T) = Î½/(Î½-2) for Î½ > 2
			 */
			Real variance() const
			{
				if (df <= 2)
					throw StatisticsError("Variance does not exist for df <= 2 in TDistribution");
				
				Real nu = static_cast<Real>(df);
				return nu / (nu - 2.0);
			}

		private:
			/**
			 * @brief Regularized incomplete beta function I_x(a, b)
			 * 
			 * Uses continued fraction expansion (Lentz's method).
			 * Based on Numerical Recipes formula 6.4.5
			 */
			static Real incompleteBetaRegularized(Real x, Real a, Real b)
			{
				if (x < 0.0 || x > 1.0)
					return 0.0;
				if (x == 0.0)
					return 0.0;
				if (x == 1.0)
					return 1.0;

				// Use symmetry relation if x > (a+1)/(a+b+2)
				bool useSymmetry = (x > (a + 1.0) / (a + b + 2.0));
				if (useSymmetry) {
					return 1.0 - incompleteBetaRegularized(1.0 - x, b, a);
				}

				// Compute log of beta function B(a, b) = Î“(a)Î“(b)/Î“(a+b)
				Real logBeta = std::lgamma(a) + std::lgamma(b) - std::lgamma(a + b);
				
				// Front factor: exp(a*ln(x) + b*ln(1-x) - ln(B(a,b))) / a
				Real front = std::exp(a * std::log(x) + b * std::log(1.0 - x) - logBeta) / a;

				// Modified Lentz's method for continued fraction
				// Formula from Numerical Recipes (Press et al.)
				const Real fpmin = 1.0e-30;
				const Real eps = 1.0e-15;
				const int maxIter = 200;
				
				Real qab = a + b;
				Real qap = a + 1.0;
				Real qam = a - 1.0;
				Real c = 1.0;
				Real d = 1.0 - qab * x / qap;
				if (std::abs(d) < fpmin) d = fpmin;
				d = 1.0 / d;
				Real h = d;
				
				for (int m = 1; m <= maxIter; m++) {
					int m2 = 2 * m;
					Real aa = m * (b - m) * x / ((qam + m2) * (a + m2));
					d = 1.0 + aa * d;
					if (std::abs(d) < fpmin) d = fpmin;
					c = 1.0 + aa / c;
					if (std::abs(c) < fpmin) c = fpmin;
					d = 1.0 / d;
					h *= d * c;
					
					aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
					d = 1.0 + aa * d;
					if (std::abs(d) < fpmin) d = fpmin;
					c = 1.0 + aa / c;
					if (std::abs(c) < fpmin) c = fpmin;
					d = 1.0 / d;
					Real del = d * c;
					h *= del;
					
					if (std::abs(del - 1.0) < eps)
						break;
				}

				return front * h;
			}
		};

		/**
		 * @brief Chi-square (Ï‡Â²) distribution
		 * 
		 * The chi-square distribution is the distribution of a sum
		 * of a sum of the squares of k independent standard normal random variables.
		 * 
		 * PDF: f(x; k) = (1 / (2^(k/2) * Î“(k/2))) * x^(k/2-1) * e^(-x/2) for x â‰¥ 0
		 * Mean: k
		 * Variance: 2k
		 * 
		 * Used extensively in hypothesis testing (goodness-of-fit, independence tests)
		 * 
		 * @param df Degrees of freedom (must be positive)
		 */
		class ChiSquareDistribution
		{
		private:
			int _df;  // degrees of freedom

		public:
			ChiSquareDistribution(int df) : _df(df)
			{
				if (df <= 0)
					throw StatisticsError("Chi-square distribution requires positive degrees of freedom");
			}

			int df() const { return _df; }
			Real mean() const { return static_cast<Real>(_df); }
			Real variance() const { return 2.0 * _df; }
			Real stddev() const { return std::sqrt(variance()); }

			/**
			 * @brief Probability Density Function
			 */
			Real pdf(Real x) const
			{
				if (x < 0.0) return 0.0;
				if (x == 0.0) return (_df == 2) ? 0.5 : 0.0;

				Real k2 = _df / 2.0;
				return std::exp((k2 - 1.0) * std::log(x) - x / 2.0 - k2 * std::log(2.0) - std::lgamma(k2));
			}

			/**
			 * @brief Cumulative Distribution Function (CDF)
			 * P(X â‰¤ x) using the incomplete gamma function
			 */
			Real cdf(Real x) const
			{
				if (x <= 0.0) return 0.0;
				
				// CDF = P(k/2, x/2) where P is regularized lower incomplete gamma
				return incompleteGammaP(_df / 2.0, x / 2.0);
			}

			/**
			 * @brief Right-tail probability P(X â‰¥ x)
			 * This is the p-value for chi-square tests
			 */
			Real rightTailPValue(Real chiSquare) const
			{
				return 1.0 - cdf(chiSquare);
			}

			/**
			 * @brief Critical value for given significance level (right-tail test)
			 * Returns x such that P(X â‰¥ x) = alpha
			 */
			Real criticalValue(Real alpha) const
			{
				if (alpha <= 0.0 || alpha >= 1.0)
					throw StatisticsError("Alpha must be in (0, 1)");

				// Find x where CDF(x) = 1 - alpha using binary search
				Real low = 0.0;
				Real high = mean() + 10.0 * stddev();  // Start with reasonable upper bound
				Real tolerance = 1e-9;
				int maxIterations = 100;

				for (int iter = 0; iter < maxIterations; iter++) {
					Real mid = (low + high) / 2.0;
					Real cdf_mid = cdf(mid);
					Real target = 1.0 - alpha;

					if (std::abs(cdf_mid - target) < tolerance)
						return mid;

					if (cdf_mid < target)
						low = mid;
					else
						high = mid;
				}

				return (low + high) / 2.0;
			}

		private:
			/**
			 * @brief Regularized lower incomplete gamma function P(a,x)
			 * P(a,x) = Î³(a,x) / Î“(a)
			 */
			Real incompleteGammaP(Real a, Real x) const
			{
				if (x < 0.0 || a <= 0.0)
					return 0.0;

				if (x == 0.0)
					return 0.0;

				// Use series expansion for x < a+1
				if (x < a + 1.0) {
					return gammaSeriesExpansion(a, x);
				}
				// Use continued fraction for x >= a+1
				else {
					return 1.0 - gammaContinuedFraction(a, x);
				}
			}

			/**
			 * @brief Series expansion for incomplete gamma
			 */
			Real gammaSeriesExpansion(Real a, Real x) const
			{
				Real sum = 1.0 / a;
				Real term = 1.0 / a;
				Real tolerance = 1e-12;

				for (int n = 1; n <= 1000; n++) {
					term *= x / (a + n);
					sum += term;

					if (std::abs(term) < std::abs(sum) * tolerance)
						break;
				}

				return sum * std::exp(-x + a * std::log(x) - std::lgamma(a));
			}

			/**
			 * @brief Continued fraction for incomplete gamma
			 */
			Real gammaContinuedFraction(Real a, Real x) const
			{
				Real tolerance = 1e-12;
				Real fpmin = 1e-30;

				Real b = x + 1.0 - a;
				Real c = 1.0 / fpmin;
				Real d = 1.0 / b;
				Real h = d;

				for (int i = 1; i <= 1000; i++) {
					Real an = -i * (i - a);
					b += 2.0;
					d = an * d + b;
					if (std::abs(d) < fpmin) d = fpmin;
					c = b + an / c;
					if (std::abs(c) < fpmin) c = fpmin;
					d = 1.0 / d;
					Real delta = d * c;
					h *= delta;

					if (std::abs(delta - 1.0) < tolerance)
						break;
				}

				return h * std::exp(-x + a * std::log(x) - std::lgamma(a));
			}
		};

    /**
     * @brief F-Distribution (Fisher-Snedecor Distribution)
     * 
     * The F-distribution is the ratio of two scaled chi-square distributions.
     * F = (Ï‡Â²â‚/dfâ‚) / (Ï‡Â²â‚‚/dfâ‚‚)
     * 
     * Used extensively in ANOVA, regression analysis, and comparing variances.
     * 
     * PDF: f(x; dâ‚, dâ‚‚) = [complex formula involving beta function]
     * Mean: dâ‚‚/(dâ‚‚-2) for dâ‚‚ > 2
     * Variance: 2dâ‚‚Â²(dâ‚+dâ‚‚-2) / [dâ‚(dâ‚‚-2)Â²(dâ‚‚-4)] for dâ‚‚ > 4
     * 
     * @param df1 Numerator degrees of freedom
     * @param df2 Denominator degrees of freedom
     */
    class FDistribution
    {
    private:
      int _df1;  // numerator df
      int _df2;  // denominator df

    public:
      FDistribution(int df1, int df2) : _df1(df1), _df2(df2)
      {
        if (df1 <= 0 || df2 <= 0)
          throw StatisticsError("F-distribution requires positive degrees of freedom");
      }

      int df1() const { return _df1; }
      int df2() const { return _df2; }

      Real mean() const
      {
        if (_df2 <= 2)
          throw StatisticsError("F-distribution mean undefined for df2 <= 2");
        return static_cast<Real>(_df2) / (_df2 - 2);
      }

      Real variance() const
      {
        if (_df2 <= 4)
          throw StatisticsError("F-distribution variance undefined for df2 <= 4");
        Real d1 = static_cast<Real>(_df1);
        Real d2 = static_cast<Real>(_df2);
        return (2.0 * d2 * d2 * (d1 + d2 - 2.0)) /
              (d1 * (d2 - 2.0) * (d2 - 2.0) * (d2 - 4.0));
      }

      /**
       * @brief Probability Density Function
       */
      Real pdf(Real x) const
      {
        if (x < 0.0) return 0.0;
        if (x == 0.0) return (_df1 == 2) ? 1.0 : 0.0;

        Real d1 = _df1 / 2.0;
        Real d2 = _df2 / 2.0;

        // log PDF to avoid overflow
        Real logPdf = d1 * std::log(_df1) + d2 * std::log(_df2) +
                      (d1 - 1.0) * std::log(x) -
                      (d1 + d2) * std::log(_df2 + _df1 * x) +
                      std::lgamma(d1 + d2) - std::lgamma(d1) - std::lgamma(d2);

        return std::exp(logPdf);
      }

      /**
       * @brief Cumulative Distribution Function
       * Uses relationship with regularized incomplete beta function
       */
      Real cdf(Real x) const
      {
        if (x <= 0.0) return 0.0;

        // F-CDF = I_y(df1/2, df2/2) where y = (df1*x)/(df1*x + df2)
        // I is regularized incomplete beta function
        Real y = (_df1 * x) / (_df1 * x + _df2);
        return incompleteBeta(_df1 / 2.0, _df2 / 2.0, y);
      }

      /**
       * @brief Right-tail probability P(F â‰¥ f)
       * This is the p-value for F-tests (ANOVA, regression)
       */
      Real rightTailPValue(Real f) const
      {
        return 1.0 - cdf(f);
      }

      /**
       * @brief Critical value for given significance level (right-tail test)
       * Returns f such that P(F â‰¥ f) = alpha
       */
      Real criticalValue(Real alpha) const
      {
        if (alpha <= 0.0 || alpha >= 1.0)
          throw StatisticsError("Alpha must be in (0, 1)");

        // Binary search for critical value
        Real low = 0.0;
        Real high = 100.0;  // Start with reasonable upper bound
        Real tolerance = 1e-9;
        int maxIterations = 100;

        for (int iter = 0; iter < maxIterations; iter++) {
          Real mid = (low + high) / 2.0;
          Real pValue = rightTailPValue(mid);

          if (std::abs(pValue - alpha) < tolerance)
            return mid;

          if (pValue > alpha)  // Need larger F
            low = mid;
          else  // Need smaller F
            high = mid;
        }

        return (low + high) / 2.0;
      }

    private:
      /**
       * @brief Regularized incomplete beta function I_x(a,b)
       */
      Real incompleteBeta(Real a, Real b, Real x) const
      {
        if (x < 0.0 || x > 1.0)
          return 0.0;
        if (x == 0.0) return 0.0;
        if (x == 1.0) return 1.0;

        // Use symmetry relation if needed
        if (x > (a + 1.0) / (a + b + 2.0)) {
          return 1.0 - incompleteBeta(b, a, 1.0 - x);
        }

        // Continued fraction evaluation
        Real bt = std::exp(std::lgamma(a + b) - std::lgamma(a) - std::lgamma(b) +
                          a * std::log(x) + b * std::log(1.0 - x));

        if (x < (a + 1.0) / (a + b + 2.0))
          return bt * betaContinuedFraction(a, b, x) / a;
        else
          return 1.0 - bt * betaContinuedFraction(b, a, 1.0 - x) / b;
      }

      /**
       * @brief Continued fraction for incomplete beta
       */
      Real betaContinuedFraction(Real a, Real b, Real x) const
      {
        Real tolerance = 1e-12;
        Real fpmin = 1e-30;
        Real qab = a + b;
        Real qap = a + 1.0;
        Real qam = a - 1.0;
        Real c = 1.0;
        Real d = 1.0 - qab * x / qap;

        if (std::abs(d) < fpmin) d = fpmin;
        d = 1.0 / d;
        Real h = d;

        for (int m = 1; m <= 1000; m++) {
          int m2 = 2 * m;
          Real aa = m * (b - m) * x / ((qam + m2) * (a + m2));
          d = 1.0 + aa * d;
          if (std::abs(d) < fpmin) d = fpmin;
          c = 1.0 + aa / c;
          if (std::abs(c) < fpmin) c = fpmin;
          d = 1.0 / d;
          h *= d * c;

          aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
          d = 1.0 + aa * d;
          if (std::abs(d) < fpmin) d = fpmin;
          c = 1.0 + aa / c;
          if (std::abs(c) < fpmin) c = fpmin;
          d = 1.0 / d;
          Real delta = d * c;
          h *= delta;

          if (std::abs(delta - 1.0) < tolerance)
            break;
        }

        return h;
      }
    };
    }
}


///////////////////////////   mml/algorithms/Statistics/Distributions.h   ///////////////////////////
// Distributions.h
// 
// Specialized probability distributions for MML (MinimalMathLibrary)
// Extracted from Statistics.h as part of refactoring to improve organization
//
// Contains: Cauchy, Exponential, and Logistic distributions
// Core distributions (Normal, T, ChiSquare, F) remain in Statistics.h
///////////////////////////////////////////////////////////////////////////////////////////



namespace MML
{
	namespace Statistics
	{
		/**
		 * @brief Cauchy distribution (also known as Lorentz distribution)
		 * 
		 * The Cauchy distribution is a continuous probability distribution with
		 * no defined mean or variance. It has heavy tails and is used in physics
		 * and statistical mechanics.
		 * 
		 * PDF: f(x) = 1 / (Ï€Â·ÏƒÂ·(1 + ((x-Î¼)/Ïƒ)Â²))
		 * where Î¼ is the location parameter and Ïƒ is the scale parameter
		 */
		struct CauchyDistribution
		{
			Real mu;   // Location parameter (peak location)
			Real sigma; // Scale parameter (half-width at half-maximum)

			/**
			 * @brief Construct a Cauchy distribution
			 * @param location Location parameter (default: 0)
			 * @param scale Scale parameter (default: 1, must be > 0)
			 */
			CauchyDistribution(Real location = 0.0, Real scale = 1.0) 
				: mu(location), sigma(scale)
			{
				if (sigma <= 0.0)
					throw StatisticsError("Scale parameter must be positive in CauchyDistribution");
			}

			/**
			 * @brief Probability density function (PDF)
			 * @param x Value at which to evaluate the PDF
			 * @return Probability density at x
			 */
			Real pdf(Real x) const
			{
				Real z = (x - mu) / sigma;
				return 1.0 / (Constants::PI * sigma * (1.0 + z * z));
			}

			/**
			 * @brief Cumulative distribution function (CDF)
			 * @param x Value at which to evaluate the CDF
			 * @return Probability that X <= x
			 */
			Real cdf(Real x) const
			{
				return 0.5 + std::atan2(x - mu, sigma) / Constants::PI;
			}

			/**
			 * @brief Inverse cumulative distribution function (quantile function)
			 * @param p Probability (must be in (0, 1))
			 * @return Value x such that P(X <= x) = p
			 */
			Real inverseCdf(Real p) const
			{
				if (p <= 0.0 || p >= 1.0)
					throw StatisticsError("Probability must be in (0, 1) in CauchyDistribution::inverseCdf");
				return mu + sigma * std::tan(Constants::PI * (p - 0.5));
			}
		};

		/**
		 * @brief Exponential distribution
		 * 
		 * The exponential distribution models the time between events in a Poisson
		 * point process. It has the memoryless property.
		 * 
		 * PDF: f(x) = Î»Â·exp(-Î»Â·x) for x >= 0
		 * where Î» is the rate parameter (Î» = 1/mean)
		 */
		struct ExponentialDistribution
		{
			Real lambda; // Rate parameter (inverse of mean)

			/**
			 * @brief Construct an exponential distribution
			 * @param rate Rate parameter Î» (must be > 0)
			 */
			ExponentialDistribution(Real rate) : lambda(rate)
			{
				if (lambda <= 0.0)
					throw StatisticsError("Rate parameter must be positive in ExponentialDistribution");
			}

			/**
			 * @brief Probability density function (PDF)
			 * @param x Value at which to evaluate the PDF (must be >= 0)
			 * @return Probability density at x
			 */
			Real pdf(Real x) const
			{
				if (x < 0.0)
					throw StatisticsError("x must be non-negative in ExponentialDistribution::pdf");
				return lambda * std::exp(-lambda * x);
			}

			/**
			 * @brief Cumulative distribution function (CDF)
			 * @param x Value at which to evaluate the CDF (must be >= 0)
			 * @return Probability that X <= x
			 */
			Real cdf(Real x) const
			{
				if (x < 0.0)
					throw StatisticsError("x must be non-negative in ExponentialDistribution::cdf");
				return 1.0 - std::exp(-lambda * x);
			}

			/**
			 * @brief Inverse cumulative distribution function (quantile function)
			 * @param p Probability (must be in [0, 1))
			 * @return Value x such that P(X <= x) = p
			 */
			Real inverseCdf(Real p) const
			{
				if (p < 0.0 || p >= 1.0)
					throw StatisticsError("Probability must be in [0, 1) in ExponentialDistribution::inverseCdf");
				return -std::log(1.0 - p) / lambda;
			}

			/**
			 * @brief Get the mean of the distribution
			 * @return Mean = 1/Î»
			 */
			Real mean() const { return 1.0 / lambda; }

			/**
			 * @brief Get the variance of the distribution
			 * @return Variance = 1/Î»Â²
			 */
			Real variance() const { return 1.0 / (lambda * lambda); }
		};

		/**
		 * @brief Logistic distribution
		 * 
		 * The logistic distribution is used in logistic regression and neural networks.
		 * It resembles the normal distribution but has heavier tails.
		 * 
		 * PDF: f(x) = exp(-z) / (ÏƒÂ·(1 + exp(-z))Â²)
		 * where z = (x - Î¼)/Ïƒ, Î¼ is location, and Ïƒ is scale
		 */
		struct LogisticDistribution
		{
			Real mu;    // Location parameter (mean and median)
			Real sigma; // Scale parameter (related to variance by ÏƒÂ² = 3Â·sÂ²/Ï€Â²)

			/**
			 * @brief Construct a logistic distribution
			 * @param location Location parameter (default: 0)
			 * @param scale Scale parameter (default: 1, must be > 0)
			 */
			LogisticDistribution(Real location = 0.0, Real scale = 1.0)
				: mu(location), sigma(scale)
			{
				if (sigma <= 0.0)
					throw StatisticsError("Scale parameter must be positive in LogisticDistribution");
			}

			/**
			 * @brief Probability density function (PDF)
			 * @param x Value at which to evaluate the PDF
			 * @return Probability density at x
			 */
			Real pdf(Real x) const
			{
				// Standard logistic PDF: f(x) = e^(-z) / (Ïƒ(1 + e^(-z))Â²)
				// where z = (x - Î¼) / Ïƒ
				Real z = (x - mu) / sigma;
				Real exp_neg_z = std::exp(-z);
				Real denom = 1.0 + exp_neg_z;
				return exp_neg_z / (sigma * denom * denom);
			}

			/**
			 * @brief Cumulative distribution function (CDF)
			 * @param x Value at which to evaluate the CDF
			 * @return Probability that X <= x
			 */
			Real cdf(Real x) const
			{
				// Numerically stable computation using the logistic function
				Real z = (x - mu) / sigma;
				Real exp_z = std::exp(-std::abs(z));
				
				if (z >= 0.0)
					return 1.0 / (1.0 + exp_z);
				else
					return exp_z / (1.0 + exp_z);
			}

			/**
			 * @brief Inverse cumulative distribution function (quantile function)
			 * @param p Probability (must be in (0, 1))
			 * @return Value x such that P(X <= x) = p
			 */
			Real inverseCdf(Real p) const
			{
				if (p <= 0.0 || p >= 1.0)
					throw StatisticsError("Probability must be in (0, 1) in LogisticDistribution::inverseCdf");
				return mu + sigma * std::log(p / (1.0 - p));
			}

			/**
			 * @brief Get the mean of the distribution
			 * @return Mean = Î¼
			 */
			Real mean() const { return mu; }

			/**
			 * @brief Get the variance of the distribution
			 * @return Variance = (Ï€Â·Ïƒ)Â²/3
			 */
			Real variance() const 
			{ 
				return (Constants::PI * sigma) * (Constants::PI * sigma) / 3.0;
			}
		};

	} // namespace Statistics
}  // namespace MML


///////////////////////////   mml/algorithms/Statistics/RandomGenerators.h   ///////////////////////////
// RandomGenerators.h
// 
// Random number generators (deviates) for MML (MinimalMathLibrary)
// Extracted from Statistics.h as part of refactoring to improve organization
//
// All generators use Mersenne Twister (std::mt19937_64) for high-quality randomness
///////////////////////////////////////////////////////////////////////////////////////////



namespace MML
{
	namespace Statistics
	{
		/**
		 * @brief Exponential random deviate generator
		 * 
		 * Generates random numbers from an exponential distribution using the
		 * inverse transform method: X = -ln(U)/Î» where U ~ Uniform(0,1)
		 * 
		 * Uses C++20 std::mt19937_64 for random number generation.
		 */
		class ExponentialDeviate
		{
		private:
			std::mt19937_64 _gen;                   // Mersenne Twister 64-bit generator
			std::uniform_real_distribution<Real> _uniform;  // Uniform(0,1) distribution
			Real _lambda;                            // Rate parameter

		public:
			/**
			 * @brief Construct an exponential deviate generator
			 * @param rate Rate parameter Î» (must be > 0)
			 * @param seed Random seed (default: random_device)
			 */
			ExponentialDeviate(Real rate, uint64_t seed = std::random_device{}())
				: _gen(seed), _uniform(0.0, 1.0), _lambda(rate)
			{
				if (rate <= 0.0)
					throw StatisticsError("Rate parameter must be positive in ExponentialDeviate");
			}

			/**
			 * @brief Generate a random exponential deviate
			 * @return Random value from exponential distribution
			 */
			Real generate()
			{
				Real u;
				do {
					u = _uniform(_gen);
				} while (u == 0.0);  // Avoid log(0)
				return -std::log(u) / _lambda;
			}

			/// Alias for generate() to match common usage
			Real operator()() { return generate(); }
		};

		/**
		 * @brief Logistic random deviate generator
		 * 
		 * Generates random numbers from a logistic distribution using the
		 * inverse CDF method: X = Î¼ + ÏƒÂ·ln(U/(1-U))
		 * 
		 * Uses C++20 std::mt19937_64 for random number generation.
		 */
		class LogisticDeviate
		{
		private:
			std::mt19937_64 _gen;
			std::uniform_real_distribution<Real> _uniform;
			Real _mu, _sigma;

		public:
			/**
			 * @brief Construct a logistic deviate generator
			 * @param location Location parameter Î¼
			 * @param scale Scale parameter Ïƒ (must be > 0)
			 * @param seed Random seed
			 */
			LogisticDeviate(Real location, Real scale, uint64_t seed = std::random_device{}())
				: _gen(seed), _uniform(0.0, 1.0), _mu(location), _sigma(scale)
			{
				if (scale <= 0.0)
					throw StatisticsError("Scale parameter must be positive in LogisticDeviate");
			}

			/**
			 * @brief Generate a random logistic deviate
			 * @return Random value from logistic distribution
			 */
			Real generate()
			{
				Real u;
				do {
					u = _uniform(_gen);
				} while (u == 0.0 || u == 1.0);  // Avoid log(0) and division by 0
				return _mu + _sigma * std::log(u / (1.0 - u));
			}

			Real operator()() { return generate(); }
		};

		/**
		 * @brief Normal (Gaussian) random deviate generator using Box-Muller transform
		 * 
		 * Box-Muller method generates pairs of independent normal variates from
		 * uniform random numbers. This implementation caches one value for efficiency.
		 * 
		 * Algorithm: If U1, U2 ~ Uniform(0,1), then
		 *   X = âˆš(-2ln(RÂ²)) Â· V1,  Y = âˆš(-2ln(RÂ²)) Â· V2
		 * where V1, V2 are uniform on unit circle, RÂ² = V1Â² + V2Â²
		 */
		class NormalDeviateBoxMuller
		{
		private:
			std::mt19937_64 _gen;
			std::uniform_real_distribution<Real> _uniform;
			Real _mu, _sigma;
			Real _storedValue;  // Cached value from Box-Muller pair
			bool _hasStored;    // Whether cached value is available

		public:
			/**
			 * @brief Construct a normal deviate generator (Box-Muller method)
			 * @param mean Mean Î¼
			 * @param stddev Standard deviation Ïƒ (must be > 0)
			 * @param seed Random seed
			 */
			NormalDeviateBoxMuller(Real mean, Real stddev, uint64_t seed = std::random_device{}())
				: _gen(seed), _uniform(-1.0, 1.0), _mu(mean), _sigma(stddev),
				  _storedValue(0.0), _hasStored(false)
			{
				if (stddev <= 0.0)
					throw StatisticsError("Standard deviation must be positive in NormalDeviateBoxMuller");
			}

			/**
			 * @brief Generate a random normal deviate
			 * @return Random value from normal distribution
			 */
			Real generate()
			{
				if (_hasStored) {
					_hasStored = false;
					return _mu + _sigma * _storedValue;
				}

				Real v1, v2, rsq, fac;
				do {
					v1 = _uniform(_gen);
					v2 = _uniform(_gen);
					rsq = v1 * v1 + v2 * v2;
				} while (rsq >= 1.0 || rsq == 0.0);

				fac = std::sqrt(-2.0 * std::log(rsq) / rsq);
				_storedValue = v1 * fac;
				_hasStored = true;
				return _mu + _sigma * v2 * fac;
			}

			Real operator()() { return generate(); }
		};

		/**
		 * @brief Cauchy random deviate generator
		 * 
		 * Generates Cauchy variates using the ratio of two uniform random numbers.
		 * The Cauchy distribution has no defined mean or variance.
		 * 
		 * Algorithm: If V1, V2 uniform on unit circle, then X = V1/V2 ~ Cauchy(0,1)
		 */
		class CauchyDeviate
		{
		private:
			std::mt19937_64 _gen;
			std::uniform_real_distribution<Real> _uniform;
			Real _mu, _sigma;

		public:
			/**
			 * @brief Construct a Cauchy deviate generator
			 * @param location Location parameter Î¼
			 * @param scale Scale parameter Ïƒ (must be > 0)
			 * @param seed Random seed
			 */
			CauchyDeviate(Real location, Real scale, uint64_t seed = std::random_device{}())
				: _gen(seed), _uniform(-1.0, 1.0), _mu(location), _sigma(scale)
			{
				if (scale <= 0.0)
					throw StatisticsError("Scale parameter must be positive in CauchyDeviate");
			}

			/**
			 * @brief Generate a random Cauchy deviate
			 * @return Random value from Cauchy distribution
			 */
			Real generate()
			{
				Real v1, v2;
				do {
					v1 = _uniform(_gen);
					v2 = _uniform(_gen);
				} while (v1 * v1 + v2 * v2 >= 1.0 || v2 == 0.0);
				return _mu + _sigma * v1 / v2;
			}

			Real operator()() { return generate(); }
		};

		/**
		 * @brief Normal random deviate generator using Leva's ratio-of-uniforms method
		 * 
		 * Fast and accurate method for generating normal deviates. More efficient
		 * than Box-Muller for single values (no caching needed).
		 * 
		 * Uses a ratio-of-uniforms method with quick acceptance tests.
		 */
		class NormalDeviate
		{
		private:
			std::mt19937_64 _gen;
			std::uniform_real_distribution<Real> _uniform;
			Real _mu, _sigma;

		public:
			/**
			 * @brief Construct a normal deviate generator (Leva's method)
			 * @param mean Mean Î¼
			 * @param stddev Standard deviation Ïƒ (must be > 0)
			 * @param seed Random seed
			 */
			NormalDeviate(Real mean, Real stddev, uint64_t seed = std::random_device{}())
				: _gen(seed), _uniform(0.0, 1.0), _mu(mean), _sigma(stddev)
			{
				if (stddev <= 0.0)
					throw StatisticsError("Standard deviation must be positive in NormalDeviate");
			}

			/**
			 * @brief Generate a random normal deviate
			 * @return Random value from normal distribution
			 */
			Real generate()
			{
				Real u, v, x, y, q;
				do {
					u = _uniform(_gen);
					v = 1.7156 * (_uniform(_gen) - 0.5);
					x = u - 0.449871;
					y = std::abs(v) + 0.386595;
					q = x * x + y * (0.19600 * y - 0.25472 * x);
				} while (q > 0.27597 && 
				        (q > 0.27846 || v * v > -4.0 * std::log(u) * u * u));
				return _mu + _sigma * v / u;
			}

			Real operator()() { return generate(); }
		};

		/**
		 * @brief Gamma random deviate generator
		 * 
		 * Generates gamma distributed random numbers using Marsaglia and Tsang's method.
		 * For shape parameter Î± < 1, uses a transformation.
		 * 
		 * The gamma distribution is used in Bayesian statistics, queuing theory,
		 * and reliability analysis.
		 */
		class GammaDeviate
		{
		private:
			NormalDeviate _normalGen;
			std::mt19937_64 _gen;
			std::uniform_real_distribution<Real> _uniform;
			Real _alpha;      // Shape parameter
			Real _originalAlpha;  // Original shape (before transformation if Î± < 1)
			Real _beta;       // Scale parameter (1/rate)
			Real _a1, _a2;    // Precomputed constants

		public:
			/**
			 * @brief Construct a gamma deviate generator
			 * @param shape Shape parameter Î± (must be > 0)
			 * @param scale Scale parameter Î² (must be > 0, Î² = 1/rate)
			 * @param seed Random seed
			 */
			GammaDeviate(Real shape, Real scale, uint64_t seed = std::random_device{}())
				: _normalGen(0.0, 1.0, seed), _gen(seed), _uniform(0.0, 1.0),
				  _alpha(shape), _originalAlpha(shape), _beta(scale)
			{
				if (shape <= 0.0)
					throw StatisticsError("Shape parameter must be positive in GammaDeviate");
				if (scale <= 0.0)
					throw StatisticsError("Scale parameter must be positive in GammaDeviate");

				// For Î± < 1, use Î±' = Î± + 1 and later transform
				if (_alpha < 1.0)
					_alpha += 1.0;

				_a1 = _alpha - 1.0 / 3.0;
				_a2 = 1.0 / std::sqrt(9.0 * _a1);
			}

			/**
			 * @brief Generate a random gamma deviate
			 * @return Random value from gamma distribution
			 */
			Real generate()
			{
				Real u, v, x;
				do {
					do {
						x = _normalGen.generate();
						v = 1.0 + _a2 * x;
					} while (v <= 0.0);
					
					v = v * v * v;
					u = _uniform(_gen);
				} while (u > 1.0 - 0.331 * x * x * x * x &&
				         std::log(u) > 0.5 * x * x + _a1 * (1.0 - v + std::log(v)));

				// If original Î± < 1, apply transformation
				if (_alpha == _originalAlpha) {
					return _a1 * v / _beta;
				}
				else {
					do {
						u = _uniform(_gen);
					} while (u == 0.0);
					return std::pow(u, 1.0 / _originalAlpha) * _a1 * v / _beta;
				}
			}

			Real operator()() { return generate(); }
		};

		/**
		 * @brief Poisson random deviate generator
		 * 
		 * Generates Poisson distributed random integers. Uses different algorithms
		 * depending on mean Î»:
		 * - Î» < 5: Direct method (multiplicative algorithm)
		 * - Î» â‰¥ 5: Ratio-of-uniforms method (faster for large Î»)
		 * 
		 * The Poisson distribution models the number of events in a fixed interval.
		 */
		class PoissonDeviate
		{
		private:
			std::mt19937_64 _gen;
			std::uniform_real_distribution<Real> _uniform;
			Real _lambda;     // Mean parameter
			Real _sqrtLambda, _logLambda, _lambdaExp;
			Real _previousLambda;  // For caching
			std::vector<Real> _logFactorial;  // Cache of log(k!)

		public:
			/**
			 * @brief Construct a Poisson deviate generator
			 * @param mean Mean parameter Î» (must be > 0)
			 * @param seed Random seed
			 */
			PoissonDeviate(Real mean, uint64_t seed = std::random_device{}())
				: _gen(seed), _uniform(0.0, 1.0), _lambda(mean),
				  _previousLambda(-1.0), _logFactorial(1024, -1.0)
			{
				if (mean <= 0.0)
					throw StatisticsError("Mean parameter must be positive in PoissonDeviate");
			}

			/**
			 * @brief Generate a random Poisson deviate
			 * @return Random integer from Poisson distribution
			 */
			int generate()
			{
				Real u, u2, v, v2, p, t, lfac;
				int k;

				if (_lambda < 5.0) {
					// Direct method for small Î»
					if (_lambda != _previousLambda)
						_lambdaExp = std::exp(-_lambda);
					k = -1;
					t = 1.0;
					do {
						++k;
						t *= _uniform(_gen);
					} while (t > _lambdaExp);
				}
				else {
					// Ratio-of-uniforms method for large Î»
					if (_lambda != _previousLambda) {
						_sqrtLambda = std::sqrt(_lambda);
						_logLambda = std::log(_lambda);
					}

					for (;;) {
						u = 0.64 * _uniform(_gen);
						v = -0.68 + 1.28 * _uniform(_gen);

						if (_lambda > 13.5) {
							v2 = v * v;
							if (v >= 0.0) {
								if (v2 > 6.5 * u * (0.64 - u) * (u + 0.2)) continue;
							}
							else {
								if (v2 > 9.6 * u * (0.66 - u) * (u + 0.07)) continue;
							}
						}

						k = static_cast<int>(std::floor(_sqrtLambda * (v / u) + _lambda + 0.5));
						if (k < 0) continue;

						u2 = u * u;
						if (_lambda > 13.5) {
							if (v >= 0.0) {
								if (v2 < 15.2 * u2 * (0.61 - u) * (0.8 - u)) break;
							}
							else {
								if (v2 < 6.76 * u2 * (0.62 - u) * (1.4 - u)) break;
							}
						}

						// Compute log(k!) using cache or lgamma
						if (k < 1024) {
							if (_logFactorial[k] < 0.0)
								_logFactorial[k] = std::lgamma(k + 1.0);
							lfac = _logFactorial[k];
						}
						else {
							lfac = std::lgamma(k + 1.0);
						}

						p = _sqrtLambda * std::exp(-_lambda + k * _logLambda - lfac);
						if (u2 < p) break;
					}
				}

				_previousLambda = _lambda;
				return k;
			}

			/**
			 * @brief Generate a Poisson deviate with different mean
			 * @param mean New mean parameter Î»
			 * @return Random integer from Poisson(Î»)
			 */
			int generate(Real mean)
			{
				_lambda = mean;
				return generate();
			}

			int operator()() { return generate(); }
		};

		/**
		 * @brief Binomial random deviate generator
		 * 
		 * Generates binomial distributed random integers B(n,p).
		 * Uses different algorithms based on n and p:
		 * - Small n: Bit comparison method
		 * - Medium nÂ·p: Inverse CDF method  
		 * - Large nÂ·p: Ratio-of-uniforms rejection method
		 * 
		 * Models the number of successes in n independent Bernoulli trials.
		 */
		class BinomialDeviate
		{
		private:
			std::mt19937_64 _gen;
			std::uniform_real_distribution<Real> _uniform;
			Real _pp, _p, _pb;          // Probability parameters
			Real _expNP, _np, _glnp, _plog, _pclog, _sq;
			int _n;                      // Number of trials
			int _method;                 // Which algorithm to use (0, 1, or 2)
			
			// For method 0 (small n)
			uint64_t _uz, _uo, _unfin, _diff, _rltp;
			int _pbits[5];
			
			// For method 1 (medium np)
			Real _cdf[64];
			
			// For method 2 (large np)
			Real _logFactorial[1024];

		public:
			/**
			 * @brief Construct a binomial deviate generator
			 * @param trials Number of trials n (must be > 0)
			 * @param probability Success probability p (must be in [0,1])
			 * @param seed Random seed
			 */
			BinomialDeviate(int trials, Real probability, uint64_t seed = std::random_device{}())
				: _gen(seed), _uniform(0.0, 1.0), _pp(probability), _n(trials)
			{
				if (trials <= 0)
					throw StatisticsError("Number of trials must be positive in BinomialDeviate");
				if (probability < 0.0 || probability > 1.0)
					throw StatisticsError("Probability must be in [0,1] in BinomialDeviate");

				// Work with p â‰¤ 0.5 for efficiency, flip at end if needed
				_pb = _p = (probability <= 0.5 ? probability : 1.0 - probability);

				if (_n <= 64) {
					// Method 0: Bit comparison for small n
					_uz = 0;
					_uo = 0xFFFFFFFFFFFFFFFFULL;
					_rltp = 0;
					for (int j = 0; j < 5; j++) {
						_pbits[j] = 1 & static_cast<int>(_pb *= 2.0);
					}
					_pb -= std::floor(_pb);
					_method = 0;
				}
				else if (_n * _p < 30.0) {
					// Method 1: Inverse CDF for medium np
					_cdf[0] = std::exp(_n * std::log(1.0 - _p));
					for (int j = 1; j < 64; j++) {
						_cdf[j] = _cdf[j - 1] + std::exp(
							std::lgamma(_n + 1.0) - std::lgamma(j + 1.0) - std::lgamma(_n - j + 1.0) +
							j * std::log(_p) + (_n - j) * std::log(1.0 - _p));
					}
					_method = 1;
				}
				else {
					// Method 2: Ratio-of-uniforms for large np
					_np = _n * _p;
					_glnp = std::lgamma(_n + 1.0);
					_plog = std::log(_p);
					_pclog = std::log(1.0 - _p);
					_sq = std::sqrt(_np * (1.0 - _p));
					if (_n < 1024) {
						for (int j = 0; j <= _n; j++)
							_logFactorial[j] = std::lgamma(j + 1.0);
					}
					_method = 2;
				}
			}

			/**
			 * @brief Generate a random binomial deviate
			 * @return Random integer from binomial distribution B(n,p)
			 */
			int generate()
			{
				int j, k, kl, km;
				Real y, u, v, u2, v2, b;

				if (_method == 0) {
					// Bit comparison method
					_unfin = _uo;
					for (j = 0; j < 5; j++) {
						_diff = _unfin & (_gen() ^ (_pbits[j] ? _uo : _uz));
						if (_pbits[j])
							_rltp |= _diff;
						else
							_rltp = _rltp & ~_diff;
						_unfin = _unfin & ~_diff;
					}
					k = 0;
					for (j = 0; j < _n; j++) {
						if (_unfin & 1) {
							if (_uniform(_gen) < _pb) ++k;
						}
						else {
							if (_rltp & 1) ++k;
						}
						_unfin >>= 1;
						_rltp >>= 1;
					}
				}
				else if (_method == 1) {
					// Inverse CDF method
					y = _uniform(_gen);
					kl = -1;
					k = 64;
					while (k - kl > 1) {
						km = (kl + k) / 2;
						if (y < _cdf[km])
							k = km;
						else
							kl = km;
					}
				}
				else {
					// Ratio-of-uniforms method
					for (;;) {
						u = 0.645 * _uniform(_gen);
						v = -0.63 + 1.25 * _uniform(_gen);
						v2 = v * v;

						if (v >= 0.0) {
							if (v2 > 6.5 * u * (0.645 - u) * (u + 0.2)) continue;
						}
						else {
							if (v2 > 8.4 * u * (0.645 - u) * (u + 0.1)) continue;
						}

						k = static_cast<int>(std::floor(_sq * (v / u) + _np + 0.5));
						if (k < 0) continue;

						u2 = u * u;
						if (v >= 0.0) {
							if (v2 < 12.25 * u2 * (0.615 - u) * (0.92 - u)) break;
						}
						else {
							if (v2 < 7.84 * u2 * (0.615 - u) * (1.2 - u)) break;
						}

						b = _sq * std::exp(_glnp + k * _plog + (_n - k) * _pclog -
							(_n < 1024 ? _logFactorial[k] + _logFactorial[_n - k]
							           : std::lgamma(k + 1.0) + std::lgamma(_n - k + 1.0)));
						if (u2 < b) break;
					}
				}

				// If we flipped p, flip the result
				if (_p != _pp)
					k = _n - k;

				return k;
			}

			int operator()() { return generate(); }
		};

	} // namespace Statistics
}  // namespace MML


///////////////////////////   mml/algorithms/Statistics/TimeSeries.h   ///////////////////////////



namespace MML {
	namespace Statistics {
		namespace TimeSeries {
			/////////////////////////////////////////////////////////////////////////////////////
			///                           MOVING AVERAGES                                     ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Simple Moving Average (SMA)
			/// @details Computes the unweighted mean of the previous windowSize data points.
			///          Formula: SMA_t = (1/windowSize) * sum(x_{t-windowSize+1} to x_t)
			/// @param data Input time series data
			/// @param windowSize Number of points in the moving window
			/// @return Vector of size (n - windowSize + 1) containing smoothed values
			/// @throws StatisticsError if windowSize > data.size() or windowSize < 1 or data is empty
			static Vector<Real> SimpleMovingAverage(const Vector<Real>& data, int windowSize) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("SimpleMovingAverage: Input data cannot be empty");
				if (windowSize < 1)
					throw StatisticsError("SimpleMovingAverage: Window size must be at least 1");
				if (windowSize > n)
					throw StatisticsError("SimpleMovingAverage: Window size cannot exceed data length");

				int resultSize = n - windowSize + 1;
				Vector<Real> result(resultSize);

				// Compute first window sum
				Real windowSum = 0.0;
				for (int i = 0; i < windowSize; ++i)
					windowSum += data[i];

				result[0] = windowSum / windowSize;

				// Slide the window using running sum (O(n) complexity)
				for (int i = 1; i < resultSize; ++i) {
					windowSum = windowSum - data[i - 1] + data[i + windowSize - 1];
					result[i] = windowSum / windowSize;
				}

				return result;
			}

			/// @brief Exponential Moving Average (EMA) with smoothing factor alpha
			/// @details Applies exponential weighting where recent values have more influence.
			///          Formula: EMA_t = alpha * x_t + (1 - alpha) * EMA_{t-1}
			///          Initial EMA_0 = x_0
			/// @param data Input time series data
			/// @param alpha Smoothing factor in range (0, 1). Higher alpha = more weight on recent values.
			/// @return Vector of same size as input containing EMA values
			/// @throws StatisticsError if alpha not in (0,1) or data is empty
			static Vector<Real> ExponentialMovingAverage(const Vector<Real>& data, Real alpha) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("ExponentialMovingAverage: Input data cannot be empty");
				if (alpha <= 0.0 || alpha >= 1.0)
					throw StatisticsError("ExponentialMovingAverage: Alpha must be in range (0, 1)");

				Vector<Real> result(n);
				result[0] = data[0]; // Initialize with first value

				Real oneMinusAlpha = 1.0 - alpha;
				for (int i = 1; i < n; ++i)
					result[i] = alpha * data[i] + oneMinusAlpha * result[i - 1];

				return result;
			}

			/// @brief Exponential Moving Average (EMA) with span parameter
			/// @details Computes alpha from span: alpha = 2 / (span + 1)
			///          This is the common convention used in pandas.
			/// @param data Input time series data
			/// @param span The span parameter (must be >= 1)
			/// @return Vector of same size as input containing EMA values
			/// @throws StatisticsError if span < 1 or data is empty
			static Vector<Real> ExponentialMovingAverageSpan(const Vector<Real>& data, int span) {
				if (span < 1)
					throw StatisticsError("ExponentialMovingAverageSpan: Span must be at least 1");

				Real alpha = 2.0 / (span + 1.0);
				return ExponentialMovingAverage(data, alpha);
			}

			/// @brief Weighted Moving Average (WMA) with custom weights
			/// @details Computes weighted average over sliding window using provided weights.
			///          Formula: WMA_t = sum(w_i * x_{t-n+1+i}) / sum(w_i)
			/// @param data Input time series data
			/// @param weights Weight vector (window size = weights.size())
			/// @return Vector of size (n - windowSize + 1) containing weighted averages
			/// @throws StatisticsError if weights empty, window > data length, or all weights zero
			static Vector<Real> WeightedMovingAverage(const Vector<Real>& data, const Vector<Real>& weights) {
				int n = data.size();
				int windowSize = weights.size();

				if (n == 0)
					throw StatisticsError("WeightedMovingAverage: Input data cannot be empty");
				if (windowSize == 0)
					throw StatisticsError("WeightedMovingAverage: Weights cannot be empty");
				if (windowSize > n)
					throw StatisticsError("WeightedMovingAverage: Window size cannot exceed data length");

				// Compute weight sum once
				Real weightSum = 0.0;
				for (int i = 0; i < windowSize; ++i)
					weightSum += weights[i];

				if (std::abs(weightSum) < Constants::Eps)
					throw StatisticsError("WeightedMovingAverage: Sum of weights cannot be zero");

				int resultSize = n - windowSize + 1;
				Vector<Real> result(resultSize);

				for (int i = 0; i < resultSize; ++i) {
					Real weighted = 0.0;
					for (int j = 0; j < windowSize; ++j)
						weighted += weights[j] * data[i + j];
					result[i] = weighted / weightSum;
				}

				return result;
			}

			/// @brief Weighted Moving Average (WMA) with linear weights
			/// @details Uses linearly increasing weights: [1, 2, 3, ..., windowSize]
			///          Most recent value gets highest weight.
			/// @param data Input time series data
			/// @param windowSize Number of points in the moving window
			/// @return Vector of size (n - windowSize + 1) containing weighted averages
			static Vector<Real> WeightedMovingAverageLinear(const Vector<Real>& data, int windowSize) {
				if (windowSize < 1)
					throw StatisticsError("WeightedMovingAverageLinear: Window size must be at least 1");

				// Create linear weights [1, 2, 3, ..., windowSize]
				Vector<Real> weights(windowSize);
				for (int i = 0; i < windowSize; ++i)
					weights[i] = static_cast<Real>(i + 1);

				return WeightedMovingAverage(data, weights);
			}


			/////////////////////////////////////////////////////////////////////////////////////
			///                          ROLLING STATISTICS                                   ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Rolling Mean (equivalent to SMA)
			/// @param data Input time series data
			/// @param windowSize Number of points in the rolling window
			/// @return Vector of size (n - windowSize + 1) containing rolling means
			static Vector<Real> RollingMean(const Vector<Real>& data, int windowSize) { return SimpleMovingAverage(data, windowSize); }

			/// @brief Rolling Sum over a sliding window
			/// @param data Input time series data
			/// @param windowSize Number of points in the rolling window
			/// @return Vector of size (n - windowSize + 1) containing rolling sums
			static Vector<Real> RollingSum(const Vector<Real>& data, int windowSize) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("RollingSum: Input data cannot be empty");
				if (windowSize < 1)
					throw StatisticsError("RollingSum: Window size must be at least 1");
				if (windowSize > n)
					throw StatisticsError("RollingSum: Window size cannot exceed data length");

				int resultSize = n - windowSize + 1;
				Vector<Real> result(resultSize);

				// Compute first window sum
				Real windowSum = 0.0;
				for (int i = 0; i < windowSize; ++i)
					windowSum += data[i];

				result[0] = windowSum;

				// Slide using running sum
				for (int i = 1; i < resultSize; ++i) {
					windowSum = windowSum - data[i - 1] + data[i + windowSize - 1];
					result[i] = windowSum;
				}

				return result;
			}

			/// @brief Rolling Variance using Welford's online algorithm for numerical stability
			/// @details Computes sample variance (n-1 denominator) over sliding window.
			/// @param data Input time series data
			/// @param windowSize Number of points in the rolling window (must be >= 2)
			/// @return Vector of size (n - windowSize + 1) containing rolling variances
			static Vector<Real> RollingVariance(const Vector<Real>& data, int windowSize) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("RollingVariance: Input data cannot be empty");
				if (windowSize < 2)
					throw StatisticsError("RollingVariance: Window size must be at least 2 for variance");
				if (windowSize > n)
					throw StatisticsError("RollingVariance: Window size cannot exceed data length");

				int resultSize = n - windowSize + 1;
				Vector<Real> result(resultSize);

				// For each window, compute variance directly
				// Using compensated summation for numerical stability
				for (int i = 0; i < resultSize; ++i) {
					// Compute mean
					Real mean = 0.0;
					for (int j = 0; j < windowSize; ++j)
						mean += data[i + j];
					mean /= windowSize;

					// Compute variance with compensation (Welford-like correction)
					Real sumSq = 0.0;
					Real compensation = 0.0;
					for (int j = 0; j < windowSize; ++j) {
						Real diff = data[i + j] - mean;
						sumSq += diff * diff;
						compensation += diff;
					}
					// Correction term improves numerical stability
					result[i] = (sumSq - compensation * compensation / windowSize) / (windowSize - 1);
				}

				return result;
			}

			/// @brief Rolling Standard Deviation
			/// @param data Input time series data
			/// @param windowSize Number of points in the rolling window (must be >= 2)
			/// @return Vector of size (n - windowSize + 1) containing rolling standard deviations
			static Vector<Real> RollingStdDev(const Vector<Real>& data, int windowSize) {
				Vector<Real> variance = RollingVariance(data, windowSize);

				for (int i = 0; i < variance.size(); ++i)
					variance[i] = std::sqrt(variance[i]);

				return variance;
			}

			/// @brief Rolling Minimum using deque-based O(n) algorithm
			/// @param data Input time series data
			/// @param windowSize Number of points in the rolling window
			/// @return Vector of size (n - windowSize + 1) containing rolling minimums
			static Vector<Real> RollingMin(const Vector<Real>& data, int windowSize) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("RollingMin: Input data cannot be empty");
				if (windowSize < 1)
					throw StatisticsError("RollingMin: Window size must be at least 1");
				if (windowSize > n)
					throw StatisticsError("RollingMin: Window size cannot exceed data length");

				int resultSize = n - windowSize + 1;
				Vector<Real> result(resultSize);

				// Monotonic deque storing indices of potential minimums
				std::deque<int> dq;

				for (int i = 0; i < n; ++i) {
					// Remove elements outside current window
					while (!dq.empty() && dq.front() <= i - windowSize)
						dq.pop_front();

					// Remove elements larger than current (they can never be minimum)
					while (!dq.empty() && data[dq.back()] >= data[i])
						dq.pop_back();

					dq.push_back(i);

					// Start recording results once we have a full window
					if (i >= windowSize - 1)
						result[i - windowSize + 1] = data[dq.front()];
				}

				return result;
			}

			/// @brief Rolling Maximum using deque-based O(n) algorithm
			/// @param data Input time series data
			/// @param windowSize Number of points in the rolling window
			/// @return Vector of size (n - windowSize + 1) containing rolling maximums
			static Vector<Real> RollingMax(const Vector<Real>& data, int windowSize) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("RollingMax: Input data cannot be empty");
				if (windowSize < 1)
					throw StatisticsError("RollingMax: Window size must be at least 1");
				if (windowSize > n)
					throw StatisticsError("RollingMax: Window size cannot exceed data length");

				int resultSize = n - windowSize + 1;
				Vector<Real> result(resultSize);

				// Monotonic deque storing indices of potential maximums
				std::deque<int> dq;

				for (int i = 0; i < n; ++i) {
					// Remove elements outside current window
					while (!dq.empty() && dq.front() <= i - windowSize)
						dq.pop_front();

					// Remove elements smaller than current (they can never be maximum)
					while (!dq.empty() && data[dq.back()] <= data[i])
						dq.pop_back();

					dq.push_back(i);

					// Start recording results once we have a full window
					if (i >= windowSize - 1)
						result[i - windowSize + 1] = data[dq.front()];
				}

				return result;
			}


			/////////////////////////////////////////////////////////////////////////////////////
			///                         AUTOCORRELATION                                       ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Single lag autocorrelation coefficient
			/// @details Measures correlation between x_t and x_{t-lag}
			///          Formula: ACF(k) = Cov(x_t, x_{t-k}) / Var(x_t)
			/// @param data Input time series data
			/// @param lag The lag value (must be >= 0 and < data.size())
			/// @return Autocorrelation coefficient in [-1, 1], ACF(0) = 1.0
			static Real Autocorrelation(const Vector<Real>& data, int lag) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("Autocorrelation: Input data cannot be empty");
				if (lag < 0)
					throw StatisticsError("Autocorrelation: Lag must be non-negative");
				if (lag >= n)
					throw StatisticsError("Autocorrelation: Lag must be less than data length");

				if (lag == 0)
					return 1.0;

				// Compute mean
				Real mean = 0.0;
				for (int i = 0; i < n; ++i)
					mean += data[i];
				mean /= n;

				// Compute variance and covariance at lag
				Real variance = 0.0;
				Real covariance = 0.0;

				for (int i = 0; i < n; ++i) {
					Real diff = data[i] - mean;
					variance += diff * diff;

					if (i >= lag)
						covariance += diff * (data[i - lag] - mean);
				}

				if (std::abs(variance) < Constants::Eps)
					return 0.0; // Constant series has no autocorrelation

				return covariance / variance;
			}

			/// @brief Autocorrelation Function (ACF) for multiple lags
			/// @details Computes ACF for lags 0, 1, 2, ..., maxLag
			/// @param data Input time series data
			/// @param maxLag Maximum lag to compute (inclusive)
			/// @return Vector of size (maxLag + 1) with ACF values
			static Vector<Real> AutocorrelationFunction(const Vector<Real>& data, int maxLag) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("AutocorrelationFunction: Input data cannot be empty");
				if (maxLag < 0)
					throw StatisticsError("AutocorrelationFunction: maxLag must be non-negative");
				if (maxLag >= n)
					throw StatisticsError("AutocorrelationFunction: maxLag must be less than data length");

				Vector<Real> acf(maxLag + 1);

				// Compute mean once
				Real mean = 0.0;
				for (int i = 0; i < n; ++i)
					mean += data[i];
				mean /= n;

				// Compute variance once
				Real variance = 0.0;
				for (int i = 0; i < n; ++i) {
					Real diff = data[i] - mean;
					variance += diff * diff;
				}

				acf[0] = 1.0; // ACF(0) is always 1

				if (std::abs(variance) < Constants::Eps) {
					// Constant series: ACF is 0 for all lags > 0
					for (int k = 1; k <= maxLag; ++k)
						acf[k] = 0.0;
					return acf;
				}

				// Compute ACF for each lag
				for (int k = 1; k <= maxLag; ++k) {
					Real covariance = 0.0;
					for (int i = k; i < n; ++i)
						covariance += (data[i] - mean) * (data[i - k] - mean);

					acf[k] = covariance / variance;
				}

				return acf;
			}

			/// @brief Partial Autocorrelation using Durbin-Levinson recursion
			/// @details Measures direct correlation between x_t and x_{t-k}, removing
			///          indirect effects through intermediate lags.
			/// @param data Input time series data
			/// @param lag The lag value (must be >= 0 and < data.size())
			/// @return Partial autocorrelation coefficient at given lag
			static Real PartialAutocorrelation(const Vector<Real>& data, int lag) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("PartialAutocorrelation: Input data cannot be empty");
				if (lag < 0)
					throw StatisticsError("PartialAutocorrelation: Lag must be non-negative");
				if (lag >= n)
					throw StatisticsError("PartialAutocorrelation: Lag must be less than data length");

				if (lag == 0)
					return 1.0;

				// Get ACF values we need
				Vector<Real> acf = AutocorrelationFunction(data, lag);

				// Durbin-Levinson algorithm
				Vector<Real> phi(lag + 1);
				Vector<Real> phiPrev(lag + 1);

				phi[1] = acf[1];

				for (int k = 2; k <= lag; ++k) {
					// Save previous phi values
					for (int j = 1; j < k; ++j)
						phiPrev[j] = phi[j];

					// Compute numerator and denominator
					Real num = acf[k];
					Real den = 1.0;

					for (int j = 1; j < k; ++j) {
						num -= phiPrev[j] * acf[k - j];
						den -= phiPrev[j] * acf[j];
					}

					if (std::abs(den) < Constants::Eps)
						phi[k] = 0.0;
					else
						phi[k] = num / den;

					// Update phi values
					for (int j = 1; j < k; ++j)
						phi[j] = phiPrev[j] - phi[k] * phiPrev[k - j];
				}

				return phi[lag];
			}

			/// @brief Partial Autocorrelation Function (PACF) for multiple lags
			/// @details Computes PACF for lags 0, 1, 2, ..., maxLag using Durbin-Levinson
			/// @param data Input time series data
			/// @param maxLag Maximum lag to compute (inclusive)
			/// @return Vector of size (maxLag + 1) with PACF values
			static Vector<Real> PartialAutocorrelationFunction(const Vector<Real>& data, int maxLag) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("PartialAutocorrelationFunction: Input data cannot be empty");
				if (maxLag < 0)
					throw StatisticsError("PartialAutocorrelationFunction: maxLag must be non-negative");
				if (maxLag >= n)
					throw StatisticsError("PartialAutocorrelationFunction: maxLag must be less than data length");

				Vector<Real> pacf(maxLag + 1);
				pacf[0] = 1.0;

				if (maxLag == 0)
					return pacf;

				// Get ACF values
				Vector<Real> acf = AutocorrelationFunction(data, maxLag);

				// Durbin-Levinson algorithm - compute all PACF values efficiently
				Vector<Real> phi(maxLag + 1);
				Vector<Real> phiPrev(maxLag + 1);

				phi[1] = acf[1];
				pacf[1] = phi[1];

				for (int k = 2; k <= maxLag; ++k) {
					// Save previous phi values
					for (int j = 1; j < k; ++j)
						phiPrev[j] = phi[j];

					// Compute phi[k]
					Real num = acf[k];
					Real den = 1.0;

					for (int j = 1; j < k; ++j) {
						num -= phiPrev[j] * acf[k - j];
						den -= phiPrev[j] * acf[j];
					}

					if (std::abs(den) < Constants::Eps)
						phi[k] = 0.0;
					else
						phi[k] = num / den;

					pacf[k] = phi[k];

					// Update phi values for next iteration
					for (int j = 1; j < k; ++j)
						phi[j] = phiPrev[j] - phi[k] * phiPrev[k - j];
				}

				return pacf;
			}


			/////////////////////////////////////////////////////////////////////////////////////
			///                      DIFFERENCING AND LAG OPERATIONS                          ///
			/////////////////////////////////////////////////////////////////////////////////////

			/// @brief Create lagged version of time series
			/// @details Returns data shifted by k positions: {x_k, x_{k+1}, ..., x_{n-1}}
			/// @param data Input time series data
			/// @param k Lag amount (number of positions to shift)
			/// @return Vector of size (n - k) with lagged values
			static Vector<Real> Lag(const Vector<Real>& data, int k) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("Lag: Input data cannot be empty");
				if (k < 0)
					throw StatisticsError("Lag: Lag must be non-negative");
				if (k >= n)
					throw StatisticsError("Lag: Lag must be less than data length");

				Vector<Real> result(n - k);
				for (int i = 0; i < n - k; ++i)
					result[i] = data[i + k];

				return result;
			}

			/// @brief Create lag matrix with columns for lags 0, 1, ..., maxLag
			/// @details Each column i contains the series lagged by i positions.
			///          Row j, Column i = data[j + i] for valid indices.
			/// @param data Input time series data
			/// @param maxLag Maximum lag (number of columns - 1)
			/// @return Matrix of size (n - maxLag) x (maxLag + 1)
			static Matrix<Real> LagMatrix(const Vector<Real>& data, int maxLag) {
				int n = data.size();

				if (n == 0)
					throw StatisticsError("LagMatrix: Input data cannot be empty");
				if (maxLag < 0)
					throw StatisticsError("LagMatrix: maxLag must be non-negative");
				if (maxLag >= n)
					throw StatisticsError("LagMatrix: maxLag must be less than data length");

				int nRows = n - maxLag;
				int nCols = maxLag + 1;
				Matrix<Real> result(nRows, nCols);

				for (int i = 0; i < nRows; ++i)
					for (int j = 0; j <= maxLag; ++j)
						result(i, j) = data[maxLag + i - j];

				return result;
			}

			/// @brief First difference of time series
			/// @details Computes d_i = x_{i+1} - x_i
			/// @param data Input time series data
			/// @return Vector of size (n - 1) containing first differences
			static Vector<Real> FirstDifference(const Vector<Real>& data) {
				int n = data.size();

				if (n < 2)
					throw StatisticsError("FirstDifference: Data must have at least 2 elements");

				Vector<Real> result(n - 1);
				for (int i = 0; i < n - 1; ++i)
					result[i] = data[i + 1] - data[i];

				return result;
			}

			/// @brief Apply differencing multiple times
			/// @details order=1 is first difference, order=2 is difference of differences, etc.
			/// @param data Input time series data
			/// @param order Number of times to difference (must be >= 1)
			/// @return Vector of size (n - order) containing differenced values
			static Vector<Real> Difference(const Vector<Real>& data, int order) {
				int n = data.size();

				if (order < 1)
					throw StatisticsError("Difference: Order must be at least 1");
				if (order >= n)
					throw StatisticsError("Difference: Order must be less than data length");

				Vector<Real> result = FirstDifference(data);

				for (int d = 2; d <= order; ++d)
					result = FirstDifference(result);

				return result;
			}

			/// @brief Seasonal difference
			/// @details Computes d_i = x_i - x_{i-period}
			/// @param data Input time series data
			/// @param period Seasonal period (e.g., 12 for monthly, 4 for quarterly)
			/// @return Vector of size (n - period) containing seasonal differences
			static Vector<Real> SeasonalDifference(const Vector<Real>& data, int period) {
				int n = data.size();

				if (period < 1)
					throw StatisticsError("SeasonalDifference: Period must be at least 1");
				if (period >= n)
					throw StatisticsError("SeasonalDifference: Period must be less than data length");

				Vector<Real> result(n - period);
				for (int i = 0; i < n - period; ++i)
					result[i] = data[i + period] - data[i];

				return result;
			}

			/// @brief Cumulative sum (undoes differencing)
			/// @details cumsum[0] = initial, cumsum[i] = cumsum[i-1] + differences[i-1]
			/// @param differences The differenced series
			/// @param initial Starting value (typically the first value of original series)
			/// @return Vector of size (differences.size() + 1) with reconstructed values
			static Vector<Real> CumulativeSum(const Vector<Real>& differences, Real initial) {
				int n = differences.size();

				Vector<Real> result(n + 1);
				result[0] = initial;

				for (int i = 0; i < n; ++i)
					result[i + 1] = result[i] + differences[i];

				return result;
			}

			/// @brief Cumulative sum without initial value (starts at 0)
			/// @param differences The differenced series
			/// @return Vector of size differences.size() with cumulative sums
			static Vector<Real> CumulativeSum(const Vector<Real>& differences) {
				int n = differences.size();

				if (n == 0)
					return Vector<Real>();

				Vector<Real> result(n);
				result[0] = differences[0];

				for (int i = 1; i < n; ++i)
					result[i] = result[i - 1] + differences[i];

				return result;
			}

		} // namespace TimeSeries
	} // namespace Statistics
} // namespace MML


///////////////////////////   mml/algorithms/Statistics/ConfidenceIntervals.h   ///////////////////////////
// ConfidenceIntervals.h
// 
// Confidence interval functions for MML (MinimalMathLibrary)
// Extracted from Statistics.h as part of refactoring to improve organization
//
// Requires: Statistics.h (for basic stats functions and distributions)
///////////////////////////////////////////////////////////////////////////////////////////



namespace MML
{
	namespace Statistics
	{
		/**
		 * @brief Structure to hold confidence interval results
		 */
		struct ConfidenceInterval
		{
			Real estimate;           // Point estimate
			Real lowerBound;         // Lower confidence limit
			Real upperBound;         // Upper confidence limit
			Real marginOfError;      // Half-width of interval
			Real confidenceLevel;    // Confidence level (e.g., 0.95 for 95%)
			std::string parameter;   // What we're estimating (e.g., "Mean", "Proportion")

			ConfidenceInterval(Real est, Real lower, Real upper, Real margin, Real conf, const std::string& param)
				: estimate(est), lowerBound(lower), upperBound(upper), 
				  marginOfError(margin), confidenceLevel(conf), parameter(param) {}
		};

		/**
		 * @brief Confidence Interval for Population Mean (single sample)
		 * 
		 * Uses t-distribution for unknown population variance.
		 * CI = xÌ„ Â± t(Î±/2, df) Ã— (s/âˆšn)
		 * 
		 * @param sample Sample data
		 * @param confidenceLevel Confidence level (default: 0.95 for 95% CI)
		 * @return ConfidenceInterval with bounds
		 */
		inline ConfidenceInterval ConfidenceIntervalMean(
			const Vector<Real>& sample,
			Real confidenceLevel = 0.95
		)
		{
			if (sample.size() < 2)
				throw StatisticsError("ConfidenceIntervalMean requires at least 2 samples");

			if (confidenceLevel <= 0.0 || confidenceLevel >= 1.0)
				throw StatisticsError("Confidence level must be in (0, 1)");

			Real sampleMean = Mean(sample);
			Real sampleStd = StdDev(sample);
			int n = static_cast<int>(sample.size());
			int df = n - 1;

			// Standard error
			Real standardError = sampleStd / std::sqrt(static_cast<Real>(n));

			// Critical value from t-distribution
			Real alpha = 1.0 - confidenceLevel;
			TDistribution tDist(df);
			Real tCritical = tDist.criticalValue(alpha);

			// Margin of error
			Real marginOfError = tCritical * standardError;

			return ConfidenceInterval(
				sampleMean,
				sampleMean - marginOfError,
				sampleMean + marginOfError,
				marginOfError,
				confidenceLevel,
				"Mean"
			);
		}

		/**
		 * @brief Confidence Interval for Difference of Two Means (independent samples)
		 * 
		 * Uses pooled variance assuming equal population variances.
		 * CI = (xÌ„â‚ - xÌ„â‚‚) Â± t(Î±/2, df) Ã— SE
		 * 
		 * @param sample1 First sample
		 * @param sample2 Second sample
		 * @param confidenceLevel Confidence level (default: 0.95)
		 * @return ConfidenceInterval for Î¼â‚ - Î¼â‚‚
		 */
		inline ConfidenceInterval ConfidenceIntervalMeanDifference(
			const Vector<Real>& sample1,
			const Vector<Real>& sample2,
			Real confidenceLevel = 0.95
		)
		{
			if (sample1.size() < 2 || sample2.size() < 2)
				throw StatisticsError("ConfidenceIntervalMeanDifference requires at least 2 samples per group");

			if (confidenceLevel <= 0.0 || confidenceLevel >= 1.0)
				throw StatisticsError("Confidence level must be in (0, 1)");

			Real mean1 = Mean(sample1);
			Real mean2 = Mean(sample2);
			Real var1 = Variance(sample1);
			Real var2 = Variance(sample2);
			int n1 = static_cast<int>(sample1.size());
			int n2 = static_cast<int>(sample2.size());

			// Pooled variance
			Real pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
			Real pooledStd = std::sqrt(pooledVar);

			// Standard error
			Real standardError = pooledStd * std::sqrt(1.0 / n1 + 1.0 / n2);

			// Degrees of freedom
			int df = n1 + n2 - 2;

			// Critical value
			Real alpha = 1.0 - confidenceLevel;
			TDistribution tDist(df);
			Real tCritical = tDist.criticalValue(alpha);

			// Margin of error
			Real marginOfError = tCritical * standardError;

			// Difference
			Real difference = mean1 - mean2;

			return ConfidenceInterval(
				difference,
				difference - marginOfError,
				difference + marginOfError,
				marginOfError,
				confidenceLevel,
				"Mean Difference"
			);
		}

		/**
		 * @brief Confidence Interval for Population Proportion
		 * 
		 * Uses normal approximation (valid for large samples).
		 * CI = pÌ‚ Â± z(Î±/2) Ã— âˆš(pÌ‚(1-pÌ‚)/n)
		 * 
		 * @param successes Number of successes
		 * @param trials Total number of trials
		 * @param confidenceLevel Confidence level (default: 0.95)
		 * @return ConfidenceInterval for proportion
		 */
		inline ConfidenceInterval ConfidenceIntervalProportion(
			int successes,
			int trials,
			Real confidenceLevel = 0.95
		)
		{
			if (trials <= 0)
				throw StatisticsError("Number of trials must be positive");

			if (successes < 0 || successes > trials)
				throw StatisticsError("Successes must be between 0 and trials");

			if (confidenceLevel <= 0.0 || confidenceLevel >= 1.0)
				throw StatisticsError("Confidence level must be in (0, 1)");

			// Sample proportion
			Real pHat = static_cast<Real>(successes) / trials;

			// Standard error
			Real standardError = std::sqrt(pHat * (1.0 - pHat) / trials);

			// Critical value from standard normal
			Real alpha = 1.0 - confidenceLevel;
			NormalDistribution norm(0.0, 1.0);
			Real zCritical = norm.inverseCdf(1.0 - alpha / 2.0);

			// Margin of error
			Real marginOfError = zCritical * standardError;

			// Bounds (clamped to [0, 1])
			Real lower = std::max(0.0, pHat - marginOfError);
			Real upper = std::min(1.0, pHat + marginOfError);

			return ConfidenceInterval(
				pHat,
				lower,
				upper,
				marginOfError,
				confidenceLevel,
				"Proportion"
			);
		}

		/**
		 * @brief Confidence Interval for Difference of Two Proportions
		 * 
		 * Uses normal approximation.
		 * CI = (pÌ‚â‚ - pÌ‚â‚‚) Â± z(Î±/2) Ã— âˆš(pÌ‚â‚(1-pÌ‚â‚)/nâ‚ + pÌ‚â‚‚(1-pÌ‚â‚‚)/nâ‚‚)
		 * 
		 * @param successes1 Successes in first sample
		 * @param trials1 Trials in first sample
		 * @param successes2 Successes in second sample
		 * @param trials2 Trials in second sample
		 * @param confidenceLevel Confidence level (default: 0.95)
		 * @return ConfidenceInterval for pâ‚ - pâ‚‚
		 */
		inline ConfidenceInterval ConfidenceIntervalProportionDifference(
			int successes1, int trials1,
			int successes2, int trials2,
			Real confidenceLevel = 0.95
		)
		{
			if (trials1 <= 0 || trials2 <= 0)
				throw StatisticsError("Number of trials must be positive");

			if (successes1 < 0 || successes1 > trials1 || successes2 < 0 || successes2 > trials2)
				throw StatisticsError("Successes must be between 0 and trials");

			if (confidenceLevel <= 0.0 || confidenceLevel >= 1.0)
				throw StatisticsError("Confidence level must be in (0, 1)");

			// Sample proportions
			Real p1 = static_cast<Real>(successes1) / trials1;
			Real p2 = static_cast<Real>(successes2) / trials2;

			// Standard error
			Real standardError = std::sqrt(
				p1 * (1.0 - p1) / trials1 + 
				p2 * (1.0 - p2) / trials2
			);

			// Critical value
			Real alpha = 1.0 - confidenceLevel;
			NormalDistribution norm(0.0, 1.0);
			Real zCritical = norm.inverseCdf(1.0 - alpha / 2.0);

			// Margin of error
			Real marginOfError = zCritical * standardError;

			// Difference
			Real difference = p1 - p2;

			return ConfidenceInterval(
				difference,
				difference - marginOfError,
				difference + marginOfError,
				marginOfError,
				confidenceLevel,
				"Proportion Difference"
			);
		}

		/**
		 * @brief Confidence Interval for Mean of Paired Differences
		 * 
		 * For paired data (before-after, matched pairs).
		 * CI = dÌ„ Â± t(Î±/2, df) Ã— (s_d/âˆšn)
		 * 
		 * @param before First measurements
		 * @param after Second measurements
		 * @param confidenceLevel Confidence level (default: 0.95)
		 * @return ConfidenceInterval for mean difference
		 */
		inline ConfidenceInterval ConfidenceIntervalPairedDifference(
			const Vector<Real>& before,
			const Vector<Real>& after,
			Real confidenceLevel = 0.95
		)
		{
			if (before.size() != after.size())
				throw StatisticsError("ConfidenceIntervalPairedDifference requires equal sample sizes");

			if (before.size() < 2)
				throw StatisticsError("ConfidenceIntervalPairedDifference requires at least 2 pairs");

			if (confidenceLevel <= 0.0 || confidenceLevel >= 1.0)
				throw StatisticsError("Confidence level must be in (0, 1)");

			// Compute differences
			Vector<Real> differences(before.size());
			for (size_t i = 0; i < before.size(); i++)
				differences[i] = after[i] - before[i];

			// Use standard mean CI on differences
			return ConfidenceIntervalMean(differences, confidenceLevel);
		}

	} // namespace Statistics
}  // namespace MML


///////////////////////////   mml/algorithms/Statistics/HypothesisTesting.h   ///////////////////////////
// HypothesisTesting.h
// 
// Statistical hypothesis testing functions for MML (MinimalMathLibrary)
// Extracted from Statistics.h as part of refactoring to improve organization
//
// Requires: Statistics.h (for basic stats functions and distributions)
///////////////////////////////////////////////////////////////////////////////////////////



namespace MML
{
	namespace Statistics
	{
		/**
		 * @brief Result structure for hypothesis tests
		 * 
		 * Contains all relevant information from a hypothesis test:
		 * - Test statistic and its distribution
		 * - P-value and decision at given confidence level
		 * - Degrees of freedom if applicable
		 */
		struct HypothesisTestResult
		{
			Real testStatistic;      ///< Computed test statistic (t, z, chi-square, F, etc.)
			Real pValue;             ///< P-value for the test
			Real criticalValue;      ///< Critical value at the given significance level
			bool rejectNull;         ///< Whether to reject the null hypothesis
			Real confidenceLevel;    ///< Confidence level used (e.g., 0.95 for 95%)
			int degreesOfFreedom;    ///< Degrees of freedom (if applicable, -1 otherwise)
			std::string testName;    ///< Descriptive name of the test

			/**
			 * @brief Construct a hypothesis test result
			 */
			HypothesisTestResult(
				Real statistic = 0.0,
				Real p = 0.0,
				Real critical = 0.0,
				bool reject = false,
				Real confidence = 0.95,
				int df = -1,
				const std::string& name = "Hypothesis Test"
			) : testStatistic(statistic),
			    pValue(p),
			    criticalValue(critical),
			    rejectNull(reject),
			    confidenceLevel(confidence),
			    degreesOfFreedom(df),
			    testName(name)
			{}
		};

		/**
		 * @brief One-sample t-test
		 * 
		 * Tests the null hypothesis H0: Î¼ = Î¼0 against H1: Î¼ â‰  Î¼0
		 * where Î¼ is the population mean.
		 * 
		 * Test statistic: t = (xÌ„ - Î¼0) / (s / âˆšn)
		 * where xÌ„ is sample mean, s is sample standard deviation, n is sample size
		 * 
		 * @param sample Vector of sample values
		 * @param mu0 Hypothesized population mean
		 * @param alpha Significance level (default: 0.05 for 95% confidence)
		 * @return HypothesisTestResult with test details
		 */
		inline HypothesisTestResult OneSampleTTest(
			const Vector<Real>& sample,
			Real mu0,
			Real alpha = 0.05
		)
		{
			if (sample.size() < 2)
				throw StatisticsError("OneSampleTTest requires at least 2 samples");

			if (alpha <= 0.0 || alpha >= 1.0)
				throw StatisticsError("Significance level alpha must be in (0, 1)");

			// Compute sample statistics
			Real sampleMean = Mean(sample);
			Real sampleStd = StdDev(sample);
			int n = static_cast<int>(sample.size());
			int df = n - 1;

			// Handle zero variance edge case
			if (sampleStd == 0.0) {
				// All values are identical
				Real diff = std::abs(sampleMean - mu0);
				if (diff < std::numeric_limits<Real>::epsilon()) {
					// Perfect match with mu0 - cannot reject null
					return HypothesisTestResult(0.0, 1.0, 0.0, false, 1.0 - alpha, df, "One-Sample t-Test");
				}
				else {
					// All values identical but different from mu0 - strong evidence against null
					// Return large finite t-statistic instead of infinity
					Real largeT = (sampleMean > mu0) ? 1000.0 : -1000.0;
					return HypothesisTestResult(largeT, 0.0, 0.0, true, 1.0 - alpha, df, "One-Sample t-Test");
				}
			}

			// Compute t-statistic
			Real standardError = sampleStd / std::sqrt(static_cast<Real>(n));
			Real tStatistic = (sampleMean - mu0) / standardError;

			// Create t-distribution with appropriate degrees of freedom
			TDistribution tDist(df);

			// Compute two-tailed p-value
			Real pValue = tDist.twoTailedPValue(tStatistic);

			// Critical value for two-tailed test
			Real criticalValue = tDist.criticalValue(alpha);

			// Decision: reject if |t| > critical value (or equivalently, p < alpha)
			bool rejectNull = std::abs(tStatistic) > criticalValue;

			return HypothesisTestResult(
				tStatistic,
				pValue,
				criticalValue,
				rejectNull,
				1.0 - alpha,
				df,
				"One-Sample t-Test"
			);
		}

		/**
		 * @brief Two-sample t-test with equal variances (pooled)
		 * 
		 * Tests H0: Î¼1 = Î¼2 against H1: Î¼1 â‰  Î¼2
		 * Assumes equal population variances (use Welch's t-test if unequal).
		 * 
		 * Test statistic: t = (xÌ„1 - xÌ„2) / (sp Â· âˆš(1/n1 + 1/n2))
		 * where spÂ² = ((n1-1)s1Â² + (n2-1)s2Â²) / (n1 + n2 - 2) is pooled variance
		 * 
		 * @param sample1 First sample
		 * @param sample2 Second sample
		 * @param alpha Significance level (default: 0.05)
		 * @return HypothesisTestResult with test details
		 */
		inline HypothesisTestResult TwoSampleTTest(
			const Vector<Real>& sample1,
			const Vector<Real>& sample2,
			Real alpha = 0.05
		)
		{
			if (sample1.size() < 2 || sample2.size() < 2)
				throw StatisticsError("TwoSampleTTest requires at least 2 samples in each group");

			if (alpha <= 0.0 || alpha >= 1.0)
				throw StatisticsError("Significance level alpha must be in (0, 1)");

			// Compute sample statistics
			Real mean1 = Mean(sample1);
			Real mean2 = Mean(sample2);
			Real var1 = Variance(sample1);
			Real var2 = Variance(sample2);
			int n1 = static_cast<int>(sample1.size());
			int n2 = static_cast<int>(sample2.size());

			// Pooled variance
			Real pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
			Real pooledStd = std::sqrt(pooledVar);

			// Standard error
			Real standardError = pooledStd * std::sqrt(1.0 / n1 + 1.0 / n2);

			// t-statistic
			Real tStatistic = (mean1 - mean2) / standardError;

			// Degrees of freedom
			int df = n1 + n2 - 2;

			// Create t-distribution
			TDistribution tDist(df);

			// Two-tailed p-value
			Real pValue = tDist.twoTailedPValue(tStatistic);

			// Critical value
			Real criticalValue = tDist.criticalValue(alpha);

			// Decision
			bool rejectNull = std::abs(tStatistic) > criticalValue;

			return HypothesisTestResult(
				tStatistic,
				pValue,
				criticalValue,
				rejectNull,
				1.0 - alpha,
				df,
				"Two-Sample t-Test (Pooled)"
			);
		}

		/**
		 * @brief Welch's t-test (unequal variances)
		 * 
		 * Tests H0: Î¼1 = Î¼2 against H1: Î¼1 â‰  Î¼2
		 * Does NOT assume equal variances (more robust than pooled t-test).
		 * 
		 * Test statistic: t = (xÌ„1 - xÌ„2) / âˆš(s1Â²/n1 + s2Â²/n2)
		 * Degrees of freedom use Welch-Satterthwaite equation
		 * 
		 * @param sample1 First sample
		 * @param sample2 Second sample
		 * @param alpha Significance level (default: 0.05)
		 * @return HypothesisTestResult with test details
		 */
		inline HypothesisTestResult WelchTTest(
			const Vector<Real>& sample1,
			const Vector<Real>& sample2,
			Real alpha = 0.05
		)
		{
			if (sample1.size() < 2 || sample2.size() < 2)
				throw StatisticsError("WelchTTest requires at least 2 samples in each group");

			if (alpha <= 0.0 || alpha >= 1.0)
				throw StatisticsError("Significance level alpha must be in (0, 1)");

			// Compute sample statistics
			Real mean1 = Mean(sample1);
			Real mean2 = Mean(sample2);
			Real var1 = Variance(sample1);
			Real var2 = Variance(sample2);
			int n1 = static_cast<int>(sample1.size());
			int n2 = static_cast<int>(sample2.size());

			// Standard error (Welch's formula)
			Real se1 = var1 / n1;
			Real se2 = var2 / n2;
			Real standardError = std::sqrt(se1 + se2);

			// t-statistic
			Real tStatistic = (mean1 - mean2) / standardError;

			// Welch-Satterthwaite degrees of freedom
			Real numerator = (se1 + se2) * (se1 + se2);
			Real denominator = (se1 * se1) / (n1 - 1) + (se2 * se2) / (n2 - 1);
			int df = static_cast<int>(std::floor(numerator / denominator));

			// Ensure df is at least 1
			if (df < 1) df = 1;

			// Create t-distribution
			TDistribution tDist(df);

			// Two-tailed p-value
			Real pValue = tDist.twoTailedPValue(tStatistic);

			// Critical value
			Real criticalValue = tDist.criticalValue(alpha);

			// Decision
			bool rejectNull = std::abs(tStatistic) > criticalValue;

			return HypothesisTestResult(
				tStatistic,
				pValue,
				criticalValue,
				rejectNull,
				1.0 - alpha,
				df,
				"Welch's t-Test (Unequal Variances)"
			);
		}

		/**
		 * @brief Paired t-test
		 * 
		 * Tests H0: Î¼d = 0 against H1: Î¼d â‰  0
		 * where Î¼d is the mean difference between paired observations.
		 * 
		 * Equivalent to one-sample t-test on differences.
		 * 
		 * @param before First measurement (e.g., before treatment)
		 * @param after Second measurement (e.g., after treatment)
		 * @param alpha Significance level (default: 0.05)
		 * @return HypothesisTestResult with test details
		 */
		inline HypothesisTestResult PairedTTest(
			const Vector<Real>& before,
			const Vector<Real>& after,
			Real alpha = 0.05
		)
		{
			if (before.size() != after.size())
				throw StatisticsError("PairedTTest requires equal sample sizes");

			if (before.size() < 2)
				throw StatisticsError("PairedTTest requires at least 2 pairs");

			if (alpha <= 0.0 || alpha >= 1.0)
				throw StatisticsError("Significance level alpha must be in (0, 1)");

			// Compute differences
			Vector<Real> differences(before.size());
			for (size_t i = 0; i < before.size(); i++)
				differences[i] = after[i] - before[i];

			// Perform one-sample t-test on differences (testing mean = 0)
			auto result = OneSampleTTest(differences, 0.0, alpha);

			// Update test name
			result.testName = "Paired t-Test";

			return result;
		}

		/**
		 * @brief Chi-Square Goodness-of-Fit Test
		 * 
		 * Tests whether observed frequencies match expected frequencies.
		 * H0: Data follows the expected distribution
		 * H1: Data does not follow the expected distribution
		 * 
		 * Test statistic: Ï‡Â² = Î£((O_i - E_i)Â² / E_i)
		 * 
		 * @param observed Vector of observed frequencies
		 * @param expected Vector of expected frequencies (must sum to same as observed)
		 * @param alpha Significance level (default: 0.05)
		 * @return HypothesisTestResult with test details
		 * @throws StatisticsError if sizes don't match, frequencies invalid, or expected has zeros
		 */
		inline HypothesisTestResult ChiSquareGoodnessOfFit(
			const Vector<Real>& observed,
			const Vector<Real>& expected,
			Real alpha = 0.05
		)
		{
			int n = observed.size();
			if (n < 2)
				throw StatisticsError("ChiSquareGoodnessOfFit requires at least 2 categories");

			if (expected.size() != n)
				throw StatisticsError("Observed and expected must have the same size");

			if (alpha <= 0.0 || alpha >= 1.0)
				throw StatisticsError("Significance level alpha must be in (0, 1)");

			// Validate frequencies
			Real obsSum = 0.0, expSum = 0.0;
			for (int i = 0; i < n; i++) {
				if (observed[i] < 0.0)
					throw StatisticsError("Observed frequencies must be non-negative");
				if (expected[i] <= 0.0)
					throw StatisticsError("Expected frequencies must be positive");
				obsSum += observed[i];
				expSum += expected[i];
			}

			// Check that sums match (within tolerance)
			if (std::abs(obsSum - expSum) > 1e-6 * std::max(obsSum, expSum))
				throw StatisticsError("Observed and expected frequencies must sum to the same value");

			// Compute chi-square statistic
			Real chiSquare = 0.0;
			for (int i = 0; i < n; i++) {
				Real diff = observed[i] - expected[i];
				chiSquare += (diff * diff) / expected[i];
			}

			// Degrees of freedom = number of categories - 1
			int df = n - 1;

			// Create chi-square distribution
			ChiSquareDistribution chiDist(df);

			// Compute p-value (right-tail)
			Real pValue = chiDist.rightTailPValue(chiSquare);

			// Critical value
			Real criticalValue = chiDist.criticalValue(alpha);

			// Decision: reject if Ï‡Â² > critical value
			bool rejectNull = chiSquare > criticalValue;

			return HypothesisTestResult(
				chiSquare,
				pValue,
				criticalValue,
				rejectNull,
				1.0 - alpha,
				df,
				"Chi-Square Goodness-of-Fit"
			);
		}

		/**
		 * @brief Chi-Square Test of Independence
		 * 
		 * Tests whether two categorical variables are independent.
		 * H0: Variables are independent
		 * H1: Variables are dependent (associated)
		 * 
		 * @param contingencyTable Matrix of observed frequencies (rows Ã— columns)
		 * @param alpha Significance level (default: 0.05)
		 * @return HypothesisTestResult with test details
		 * @throws StatisticsError if table too small or has invalid frequencies
		 */
		inline HypothesisTestResult ChiSquareIndependence(
			const Matrix<Real>& contingencyTable,
			Real alpha = 0.05
		)
		{
			int rows = contingencyTable.RowNum();
			int cols = contingencyTable.ColNum();

			if (rows < 2 || cols < 2)
				throw StatisticsError("ChiSquareIndependence requires at least 2x2 table");

			if (alpha <= 0.0 || alpha >= 1.0)
				throw StatisticsError("Significance level alpha must be in (0, 1)");

			// Compute row and column totals
			Vector<Real> rowTotals(rows);
			Vector<Real> colTotals(cols);
			Real grandTotal = 0.0;

			for (int i = 0; i < rows; i++) {
				rowTotals[i] = 0.0;
				for (int j = 0; j < cols; j++) {
					if (contingencyTable(i, j) < 0.0)
						throw StatisticsError("Frequencies must be non-negative");
					rowTotals[i] += contingencyTable(i, j);
					grandTotal += contingencyTable(i, j);
				}
			}

			for (int j = 0; j < cols; j++) {
				colTotals[j] = 0.0;
				for (int i = 0; i < rows; i++) {
					colTotals[j] += contingencyTable(i, j);
				}
			}

			if (grandTotal <= 0.0)
				throw StatisticsError("Table must have positive total frequency");

			// Compute chi-square statistic
			Real chiSquare = 0.0;
			for (int i = 0; i < rows; i++) {
				for (int j = 0; j < cols; j++) {
					// Expected frequency under independence
					Real expected = (rowTotals[i] * colTotals[j]) / grandTotal;
					if (expected < 1.0) {
						// Warning: expected frequency < 1 may give unreliable results
						// But we'll continue (user should be aware)
					}
					Real observed = contingencyTable(i, j);
					Real diff = observed - expected;
					chiSquare += (diff * diff) / expected;
				}
			}

			// Degrees of freedom = (rows - 1) * (cols - 1)
			int df = (rows - 1) * (cols - 1);

			// Create chi-square distribution
			ChiSquareDistribution chiDist(df);

			// Compute p-value (right-tail)
			Real pValue = chiDist.rightTailPValue(chiSquare);

			// Critical value
			Real criticalValue = chiDist.criticalValue(alpha);

			// Decision: reject if Ï‡Â² > critical value
			bool rejectNull = chiSquare > criticalValue;

			return HypothesisTestResult(
				chiSquare,
				pValue,
				criticalValue,
				rejectNull,
				1.0 - alpha,
				df,
				"Chi-Square Independence Test"
			);
		}

		/**
		 * @brief One-Way ANOVA (Analysis of Variance)
		 * 
		 * Tests whether the means of three or more groups are equal.
		 * H0: Î¼â‚ = Î¼â‚‚ = Î¼â‚ƒ = ... = Î¼â‚– (all group means equal)
		 * H1: At least one mean differs
		 * 
		 * F-statistic = (Between-group variance) / (Within-group variance)
		 *             = (SSB/df_between) / (SSW/df_within)
		 * 
		 * @param groups Vector of groups, where each group is a vector of observations
		 * @param alpha Significance level (default: 0.05)
		 * @return HypothesisTestResult with F-statistic and p-value
		 * @throws StatisticsError if fewer than 2 groups, any group too small, or empty groups
		 */
		inline HypothesisTestResult OneWayANOVA(
			const std::vector<Vector<Real>>& groups,
			Real alpha = 0.05
		)
		{
			int k = static_cast<int>(groups.size());  // number of groups
			if (k < 2)
				throw StatisticsError("OneWayANOVA requires at least 2 groups");

			if (alpha <= 0.0 || alpha >= 1.0)
				throw StatisticsError("Significance level alpha must be in (0, 1)");

			// Validate groups and compute total sample size
			int N = 0;  // total number of observations
			for (int i = 0; i < k; i++) {
				if (groups[i].size() < 2)
					throw StatisticsError("OneWayANOVA requires at least 2 observations per group");
				N += static_cast<int>(groups[i].size());
			}

			// Compute group means and grand mean
			Vector<Real> groupMeans(k);
			Vector<int> groupSizes(k);
			Real grandSum = 0.0;

			for (int i = 0; i < k; i++) {
				groupMeans[i] = Mean(groups[i]);
				groupSizes[i] = static_cast<int>(groups[i].size());
				grandSum += groupMeans[i] * groupSizes[i];
			}

			Real grandMean = grandSum / N;

			// Compute Sum of Squares Between groups (SSB)
			Real SSB = 0.0;
			for (int i = 0; i < k; i++) {
				Real diff = groupMeans[i] - grandMean;
				SSB += groupSizes[i] * diff * diff;
			}

			// Compute Sum of Squares Within groups (SSW)
			Real SSW = 0.0;
			for (int i = 0; i < k; i++) {
				for (int j = 0; j < groupSizes[i]; j++) {
					Real diff = groups[i][j] - groupMeans[i];
					SSW += diff * diff;
				}
			}

			// Degrees of freedom
			int df_between = k - 1;           // between groups
			int df_within = N - k;            // within groups
			int df_total = N - 1;             // total

			// Mean squares
			Real MSB = SSB / df_between;      // Mean square between
			Real MSW = SSW / df_within;       // Mean square within

			// F-statistic
			Real F = MSB / MSW;

			// Create F-distribution
			FDistribution fDist(df_between, df_within);

			// Compute p-value (right-tail)
			Real pValue = fDist.rightTailPValue(F);

			// Critical value
			Real criticalValue = fDist.criticalValue(alpha);

			// Decision: reject if F > critical value
			bool rejectNull = F > criticalValue;

			return HypothesisTestResult(
				F,
				pValue,
				criticalValue,
				rejectNull,
				1.0 - alpha,
				df_between,  // Store between-groups df in result
				"One-Way ANOVA"
			);
		}

	} // namespace Statistics
}  // namespace MML


///////////////////////////   mml/algorithms/Statistics/RankCorrelation.h   ///////////////////////////
// RankCorrelation.h
// 
// Rank-based correlation methods for MML (MinimalMathLibrary)
// Extracted from Statistics.h as part of refactoring to improve organization
//
// Contains: Spearman's rho, Kendall's tau, and helper functions
///////////////////////////////////////////////////////////////////////////////////////////



namespace MML
{
	namespace Statistics
	{
		/**
		 * @brief Compute ranks for a dataset
		 * 
		 * Converts raw data values to ranks (1-based). Tied values receive
		 * the average of the ranks they would have received.
		 * 
		 * Example: [5, 2, 2, 8] â†’ [3, 1.5, 1.5, 4]
		 * 
		 * @param data Vector of values to rank
		 * @return Vector of ranks (1-based, with average ranks for ties)
		 * 
		 * @note Uses average ranking for ties: if values at positions 2,3,4
		 *       are tied, they all receive rank (2+3+4)/3 = 3
		 * 
		 * Complexity: O(n log n) for sorting
		 */
		static Vector<Real> ComputeRanks(const Vector<Real>& data)
		{
			int n = data.size();
			if (n == 0)
				return Vector<Real>();

			// Create index array and sort by values
			std::vector<int> indices(n);
			for (int i = 0; i < n; i++)
				indices[i] = i;

			std::sort(indices.begin(), indices.end(), [&data](int a, int b) {
				return data[a] < data[b];
			});

			// Assign ranks with tie handling (average ranks for ties)
			Vector<Real> ranks(n);
			int i = 0;
			while (i < n) {
				int j = i;
				// Find extent of tied values
				while (j < n - 1 && std::abs(data[indices[j + 1]] - data[indices[i]]) < 1e-14)
					j++;

				// Average rank for tied values
				Real avgRank = (i + 1 + j + 1) / 2.0;  // 1-based ranks
				for (int k = i; k <= j; k++)
					ranks[indices[k]] = avgRank;

				i = j + 1;
			}

			return ranks;
		}

		/**
		 * @brief Compute Spearman's rank correlation coefficient
		 * 
		 * Ï (rho) = 1 - 6Â·Î£dÂ²áµ¢ / (n(nÂ²-1))  [no ties formula]
		 * 
		 * For data with ties, computes Pearson correlation on ranks.
		 * 
		 * Spearman correlation measures monotonic relationship (not just linear).
		 * Values range from -1 (perfect negative monotonic) to +1 (perfect positive).
		 * 
		 * @param x First variable (vector of values)
		 * @param y Second variable (must have same size as x)
		 * @return Spearman correlation coefficient Ï in [-1, 1]
		 * @throws StatisticsError if vectors are empty, have different sizes,
		 *         or have fewer than 2 elements
		 * 
		 * Complexity: O(n log n) due to ranking
		 */
		static Real SpearmanCorrelation(const Vector<Real>& x, const Vector<Real>& y)
		{
			int n = x.size();
			if (n < 2)
				throw StatisticsError("Vector size must be at least 2 in SpearmanCorrelation");
			if (y.size() != n)
				throw StatisticsError("Vectors must have the same size in SpearmanCorrelation");

			// Compute ranks
			Vector<Real> rankX = ComputeRanks(x);
			Vector<Real> rankY = ComputeRanks(y);

			// Use Pearson correlation on ranks (handles ties correctly)
			return PearsonCorrelation(rankX, rankY);
		}

		/**
		 * @brief Result structure for rank correlation with significance test
		 */
		struct RankCorrelationResult
		{
			Real rho;              ///< Correlation coefficient (Spearman or Kendall)
			Real zScore;           ///< z-score for large sample approximation
			int n;                 ///< Sample size

			/**
			 * @brief Check if correlation is significant at given alpha level
			 * 
			 * Uses normal approximation (valid for n > 10)
			 * Critical z-values: Î±=0.05 â†’ z=1.96, Î±=0.01 â†’ z=2.576
			 */
			bool IsSignificant(Real alpha = 0.05) const
			{
				Real criticalZ = (alpha <= 0.01) ? 2.576 : 1.96;
				return std::abs(zScore) > criticalZ;
			}
		};

		/**
		 * @brief Compute Spearman correlation with significance test
		 * 
		 * Returns correlation coefficient with z-score for significance testing.
		 * Uses large-sample approximation: z = ÏÂ·âˆš(n-1)
		 * 
		 * @param x First variable
		 * @param y Second variable
		 * @return RankCorrelationResult with rho, zScore, and n
		 * @throws StatisticsError if vectors are invalid
		 */
		static RankCorrelationResult SpearmanCorrelationWithTest(const Vector<Real>& x, const Vector<Real>& y)
		{
			int n = x.size();
			if (n < 3)
				throw StatisticsError("Need at least 3 observations for significance test in SpearmanCorrelationWithTest");

			Real rho = SpearmanCorrelation(x, y);

			// Large sample approximation: z = rho * sqrt(n - 1)
			Real zScore = rho * std::sqrt(static_cast<Real>(n - 1));

			return RankCorrelationResult{rho, zScore, n};
		}

		/**
		 * @brief Compute Kendall's tau-b rank correlation coefficient
		 * 
		 * Ï„_b = (C - D) / âˆš((C + D + Tx)(C + D + Ty))
		 * 
		 * where:
		 * - C = number of concordant pairs
		 * - D = number of discordant pairs
		 * - Tx = pairs tied only in x
		 * - Ty = pairs tied only in y
		 * 
		 * Kendall's tau is more robust than Spearman for small samples
		 * and has a more intuitive interpretation (probability difference).
		 * 
		 * @param x First variable (vector of values)
		 * @param y Second variable (must have same size as x)
		 * @return Kendall tau-b coefficient in [-1, 1]
		 * @throws StatisticsError if vectors are empty, have different sizes,
		 *         or have fewer than 2 elements
		 * 
		 * Complexity: O(nÂ²) - naive implementation
		 */
		static Real KendallCorrelation(const Vector<Real>& x, const Vector<Real>& y)
		{
			int n = x.size();
			if (n < 2)
				throw StatisticsError("Vector size must be at least 2 in KendallCorrelation");
			if (y.size() != n)
				throw StatisticsError("Vectors must have the same size in KendallCorrelation");

			long long concordant = 0;
			long long discordant = 0;
			long long tiedX = 0;
			long long tiedY = 0;

			const Real eps = 1e-14;

			// Count all pairs
			for (int i = 0; i < n - 1; i++) {
				for (int j = i + 1; j < n; j++) {
					Real dx = x[j] - x[i];
					Real dy = y[j] - y[i];

					bool xTied = std::abs(dx) < eps;
					bool yTied = std::abs(dy) < eps;

					if (xTied && yTied) {
						// Both tied - don't count
						continue;
					} else if (xTied) {
						tiedX++;
					} else if (yTied) {
						tiedY++;
					} else if ((dx > 0 && dy > 0) || (dx < 0 && dy < 0)) {
						concordant++;
					} else {
						discordant++;
					}
				}
			}

			// tau-b formula with tie correction
			Real numerator = static_cast<Real>(concordant - discordant);
			Real denom1 = static_cast<Real>(concordant + discordant + tiedX);
			Real denom2 = static_cast<Real>(concordant + discordant + tiedY);

			if (denom1 <= 0.0 || denom2 <= 0.0)
				return 0.0;  // All pairs tied

			return numerator / std::sqrt(denom1 * denom2);
		}

		/**
		 * @brief Compute Kendall correlation with significance test
		 * 
		 * Returns correlation coefficient with z-score for significance testing.
		 * Uses asymptotic normal approximation:
		 * z = Ï„ / âˆš(2(2n+5) / 9n(n-1))
		 * 
		 * @param x First variable
		 * @param y Second variable
		 * @return RankCorrelationResult with tau (as rho), zScore, and n
		 * @throws StatisticsError if vectors are invalid
		 */
		static RankCorrelationResult KendallCorrelationWithTest(const Vector<Real>& x, const Vector<Real>& y)
		{
			int n = x.size();
			if (n < 3)
				throw StatisticsError("Need at least 3 observations for significance test in KendallCorrelationWithTest");

			Real tau = KendallCorrelation(x, y);

			// Standard error for Kendall's tau (no ties):
			// SE = sqrt(2(2n+5) / 9n(n-1))
			Real variance = (2.0 * (2.0 * n + 5.0)) / (9.0 * n * (n - 1));
			Real zScore = tau / std::sqrt(variance);

			return RankCorrelationResult{tau, zScore, n};
		}
	}
}


///////////////////////////   mml/algorithms/Optimization.h   ///////////////////////////



namespace MML
{
	/**
	 * Custom exception for optimization algorithm failures.
	 */
	class OptimizationError : public std::runtime_error
	{
		int _iterations;
	public:
		OptimizationError(std::string inMessage, int iterations = 0) 
			: std::runtime_error(inMessage), _iterations(iterations) { }
		
		int iterations() const noexcept { return _iterations; }
	};

	/**
	 * @brief Struct to hold results from minimization algorithms.
	 * 
	 * Contains the location of the minimum, the function value at that point,
	 * the number of iterations used, and convergence status.
	 */
	struct MinimizationResult
	{
		Real xmin;              ///< Location of the minimum
		Real fmin;              ///< Function value at the minimum
		int iterations;         ///< Number of iterations performed
		bool converged;         ///< Whether the algorithm converged
		
		MinimizationResult() : xmin(0), fmin(0), iterations(0), converged(false) {}
		MinimizationResult(Real x, Real f, int iter, bool conv = true) 
			: xmin(x), fmin(f), iterations(iter), converged(conv) {}
	};

	/**
	 * @brief Struct to hold a bracket around a minimum.
	 * 
	 * Contains three points (ax, bx, cx) and their function values (fa, fb, fc)
	 * such that bx is between ax and cx, and fb < min(fa, fc).
	 * This guarantees a minimum exists in the interval [ax, cx].
	 */
	struct MinimumBracket
	{
		Real ax, bx, cx;        ///< Three points bracketing the minimum
		Real fa, fb, fc;        ///< Function values at those points
		bool valid;             ///< Whether a valid bracket was found
		
		MinimumBracket() : ax(0), bx(0), cx(0), fa(0), fb(0), fc(0), valid(false) {}
	};

	/**
	 * @brief Namespace containing function minimization algorithms.
	 * 
	 * Implements algorithms from Numerical Recipes Chapter 10:
	 * - BracketMinimum: Initially bracketing a minimum (Â§10.1)
	 * - GoldenSectionSearch: Golden section search in one dimension (Â§10.2)
	 * - BrentMinimize: Parabolic interpolation and Brent's method (Â§10.3)
	 * - BrentMinimizeWithDeriv: One-dimensional search with first derivatives (Â§10.4)
	 * 
	 * USAGE PATTERN:
	 * @code
	 * // 1. Define or create a function to minimize
	 * RealFunctionFromStdFunc func([](Real x) { return (x-2)*(x-2) + 1; });
	 * 
	 * // 2. Find initial bracket
	 * MinimumBracket bracket = Minimization::BracketMinimum(func, 0.0, 1.0);
	 * 
	 * // 3. Refine using Brent's method
	 * MinimizationResult result = Minimization::BrentMinimize(func, bracket);
	 * 
	 * // Result: xmin â‰ˆ 2.0, fmin â‰ˆ 1.0
	 * @endcode
	 */
	namespace Minimization
	{
		/*********************************************************************/
		/*****                  10.1 Bracket Minimum                     *****/
		/*********************************************************************/
		/**
		 * @brief Find an initial bracket containing a minimum of a function.
		 * 
		 * Given an initial interval [a, b], this function searches for a triplet
		 * (ax, bx, cx) such that fb < fa and fb < fc, guaranteeing that a minimum
		 * exists between ax and cx (for a continuous function).
		 * 
		 * ALGORITHM:
		 * The algorithm uses the golden ratio (â‰ˆ1.618) for geometric expansion and
		 * parabolic interpolation to efficiently find a bracketing triplet:
		 * 
		 * 1. Start with two points a, b and evaluate f(a) and f(b)
		 * 2. If f(b) > f(a), swap so we're going "downhill"
		 * 3. Use golden ratio to generate a third point c beyond b
		 * 4. While f(b) > f(c) (still going downhill):
		 *    - Try parabolic extrapolation for next point
		 *    - Apply various safeguards to prevent runaway expansion
		 *    - Update triplet and continue
		 * 5. Return when f(b) < f(c), ensuring bracket is valid
		 * 
		 * GOLDEN RATIO:
		 * The golden ratio Ï† = (1 + âˆš5)/2 â‰ˆ 1.618034 is used because:
		 * - It provides optimal interval expansion rate
		 * - Parabolic interpolation through three points spaced by Ï† tends to
		 *   converge well for smooth functions
		 * 
		 * PARABOLIC INTERPOLATION:
		 * When applicable, the algorithm fits a parabola through the three points
		 * and uses its minimum as the next guess. This can dramatically accelerate
		 * bracketing for smooth, unimodal functions.
		 * 
		 * SAFEGUARDS:
		 * - GLIMIT (100x interval) prevents unbounded expansion
		 * - TINY prevents division by zero in parabolic step
		 * - Various geometric checks ensure monotonic progress
		 * 
		 * COMPLEXITY:
		 * - Typically O(log(distance_to_minimum)) function evaluations
		 * - Worst case: function may evaluate many times if minimum is very far
		 * 
		 * @param func   Real function to minimize
		 * @param a      Initial left point of search interval
		 * @param b      Initial right point of search interval  
		 * @return MinimumBracket containing the bracket (ax,bx,cx) with function values
		 * 
		 * POSTCONDITION (if valid):
		 * - bx is between ax and cx
		 * - fb <= fa and fb <= fc
		 * - A minimum exists in [ax, cx]
		 * 
		 * @note Based on Numerical Recipes Â§10.1 (mnbrak)
		 * @see GoldenSectionSearch, BrentMinimize for methods to refine the bracket
		 */
		static MinimumBracket BracketMinimum(const IRealFunction& func, Real a, Real b)
		{
			const Real GOLD = 1.618034;    // Golden ratio
			const Real GLIMIT = 100.0;     // Maximum magnification for parabolic step
			const Real TINY = 1.0e-20;     // Small number to prevent division by zero

			MinimumBracket result;
			result.ax = a;
			result.bx = b;
			
			result.fa = func(result.ax);
			result.fb = func(result.bx);
			
			// Ensure we're going downhill from ax to bx
			if (result.fb > result.fa)
			{
				std::swap(result.ax, result.bx);
				std::swap(result.fa, result.fb);
			}
			
			// First guess for cx using golden ratio
			result.cx = result.bx + GOLD * (result.bx - result.ax);
			result.fc = func(result.cx);
			
			Real fu;
			
			// Keep bracketing until we have fb < fc (minimum bracketed)
			while (result.fb > result.fc)
			{
				// Parabolic extrapolation to find potential minimum
				Real r = (result.bx - result.ax) * (result.fb - result.fc);
				Real q = (result.bx - result.cx) * (result.fb - result.fa);
				Real u = result.bx - ((result.bx - result.cx) * q - (result.bx - result.ax) * r) /
				        (2.0 * std::copysign(std::max(std::abs(q - r), TINY), q - r));
				Real ulim = result.bx + GLIMIT * (result.cx - result.bx);
				
				// Test various possibilities for u
				if ((result.bx - u) * (u - result.cx) > 0.0)
				{
					// u is between bx and cx
					fu = func(u);
					if (fu < result.fc)
					{
						// Minimum between bx and cx
						result.ax = result.bx;
						result.bx = u;
						result.fa = result.fb;
						result.fb = fu;
						result.valid = true;
						return result;
					}
					else if (fu > result.fb)
					{
						// Minimum between ax and u
						result.cx = u;
						result.fc = fu;
						result.valid = true;
						return result;
					}
					// Parabolic fit was useless, use golden section
					u = result.cx + GOLD * (result.cx - result.bx);
					fu = func(u);
				}
				else if ((result.cx - u) * (u - ulim) > 0.0)
				{
					// u is between cx and limit
					fu = func(u);
					if (fu < result.fc)
					{
						// Shift triplet
						result.bx = result.cx;
						result.cx = u;
						u = result.cx + GOLD * (result.cx - result.bx);
						result.fb = result.fc;
						result.fc = fu;
						fu = func(u);
					}
				}
				else if ((u - ulim) * (ulim - result.cx) >= 0.0)
				{
					// u is beyond the limit
					u = ulim;
					fu = func(u);
				}
				else
				{
					// Reject parabolic u, use golden section
					u = result.cx + GOLD * (result.cx - result.bx);
					fu = func(u);
				}
				
				// Shift triplet (ax, bx, cx) <- (bx, cx, u)
				result.ax = result.bx;
				result.bx = result.cx;
				result.cx = u;
				result.fa = result.fb;
				result.fb = result.fc;
				result.fc = fu;
			}
			
			result.valid = true;
			return result;
		}

		/*********************************************************************/
		/*****          10.2 Golden Section Search                       *****/
		/*********************************************************************/
		/**
		 * @brief Find minimum using golden section search.
		 * 
		 * Given a bracketing triplet (ax, bx, cx) where fb < fa and fb < fc,
		 * this algorithm successively narrows the bracket until the minimum
		 * is found to the desired tolerance.
		 * 
		 * ALGORITHM:
		 * Golden section search is based on dividing intervals using the golden ratio
		 * Ï† = (âˆš5-1)/2 â‰ˆ 0.618034. At each step:
		 * 
		 * 1. The largest interval is divided by the golden ratio
		 * 2. A new point is evaluated, creating two overlapping subintervals
		 * 3. The interval containing the minimum is kept
		 * 4. Process repeats until interval width < tolerance
		 * 
		 * WHY GOLDEN RATIO?
		 * The golden ratio has a unique property: if you divide an interval by Ï†,
		 * you can reuse one of the evaluation points in the next iteration.
		 * This means only ONE new function evaluation per iteration!
		 * 
		 * Alternative ratio (like bisection) would require TWO evaluations.
		 * Golden section achieves the same O(log N) convergence with half the work.
		 * 
		 * CONVERGENCE:
		 * - Linear convergence with ratio 0.618
		 * - After k iterations, interval reduced by factor Ï†^k
		 * - For 10^-8 tolerance: ~40 iterations needed
		 * - Each iteration requires exactly 1 function evaluation
		 * 
		 * COMPLEXITY:
		 * - O(log(1/tol)) function evaluations
		 * - Guaranteed convergence for any unimodal function
		 * 
		 * WHEN TO USE:
		 * - Function is expensive to evaluate
		 * - Derivatives not available
		 * - Function may not be smooth enough for Brent's method
		 * - Simplicity is more important than raw speed
		 * 
		 * @param func    Real function to minimize
		 * @param bracket Pre-computed bracket from BracketMinimum
		 * @param tol     Fractional tolerance (default: 3e-8, â‰ˆ âˆš(machine epsilon))
		 * @return MinimizationResult with xmin, fmin, and iteration count
		 * 
		 * @note Based on Numerical Recipes Â§10.2
		 * @see BracketMinimum to obtain initial bracket
		 * @see BrentMinimize for typically faster convergence
		 */
		static MinimizationResult GoldenSectionSearch(const IRealFunction& func, 
		                                              const MinimumBracket& bracket,
		                                              Real tol = 3.0e-8)
		{
			const Real R = 0.61803399;  // Golden ratio conjugate (1 - Ï†) = (âˆš5-1)/2
			const Real C = 1.0 - R;     // = 1/Ï† = 2/(âˆš5+1)
			
			MinimizationResult result;
			result.converged = false;
			result.iterations = 0;
			
			Real x0 = bracket.ax;
			Real x3 = bracket.cx;
			Real x1, x2;
			
			// Make x0 to x3 the smaller segment
			if (std::abs(bracket.cx - bracket.bx) > std::abs(bracket.bx - bracket.ax))
			{
				x1 = bracket.bx;
				x2 = bracket.bx + C * (bracket.cx - bracket.bx);
			}
			else
			{
				x2 = bracket.bx;
				x1 = bracket.bx - C * (bracket.bx - bracket.ax);
			}
			
			Real f1 = func(x1);
			Real f2 = func(x2);
			
			// Main iteration loop
			while (std::abs(x3 - x0) > tol * (std::abs(x1) + std::abs(x2)))
			{
				result.iterations++;
				
				if (f2 < f1)
				{
					// Minimum is in [x1, x3], narrow from left
					x0 = x1;
					x1 = x2;
					x2 = R * x2 + C * x3;
					f1 = f2;
					f2 = func(x2);
				}
				else
				{
					// Minimum is in [x0, x2], narrow from right
					x3 = x2;
					x2 = x1;
					x1 = R * x1 + C * x0;
					f2 = f1;
					f1 = func(x1);
				}
			}
			
			// Return best point found
			if (f1 < f2)
			{
				result.xmin = x1;
				result.fmin = f1;
			}
			else
			{
				result.xmin = x2;
				result.fmin = f2;
			}
			
			result.converged = true;
			return result;
		}

		/**
		 * @brief Convenience function combining bracketing and golden section search.
		 * 
		 * @param func  Real function to minimize
		 * @param a     Initial left search bound
		 * @param b     Initial right search bound
		 * @param tol   Fractional tolerance
		 * @return MinimizationResult with xmin, fmin, and iteration count
		 */
		static MinimizationResult GoldenSectionSearch(const IRealFunction& func,
		                                              Real a, Real b,
		                                              Real tol = 3.0e-8)
		{
			MinimumBracket bracket = BracketMinimum(func, a, b);
			if (!bracket.valid)
				throw OptimizationError("Failed to bracket minimum in GoldenSectionSearch");
			return GoldenSectionSearch(func, bracket, tol);
		}

		/*********************************************************************/
		/*****      10.3 Brent's Method (Parabolic Interpolation)        *****/
		/*********************************************************************/
		/**
		 * @brief Find minimum using Brent's method with parabolic interpolation.
		 * 
		 * Brent's method combines the reliability of golden section search with
		 * the speed of parabolic interpolation. It's the standard choice for
		 * one-dimensional minimization when derivatives are not available.
		 * 
		 * ALGORITHM:
		 * Brent's method maintains a bracketing interval [a,b] and tracks three
		 * points: x (best point so far), w (second best), v (previous w).
		 * 
		 * At each iteration:
		 * 1. Fit a parabola through x, w, v
		 * 2. If parabolic step is:
		 *    - Within the bracket AND
		 *    - Less than half the previous step AND
		 *    - Not too close to endpoints
		 *    â†’ Accept parabolic step (fast quadratic convergence)
		 * 3. Otherwise:
		 *    â†’ Use golden section step (guaranteed progress)
		 * 
		 * CONVERGENCE:
		 * - Superlinear convergence when parabolic steps accepted
		 * - Near-quadratic for smooth functions
		 * - Falls back to linear (golden section) for difficult functions
		 * - Never worse than golden section
		 * 
		 * SAFEGUARDS:
		 * - Parabolic step must stay within bracket
		 * - Step must be decreasing (not just bouncing)
		 * - Minimum step size prevents infinite loops near tolerance
		 * - Track e (extent of movement) to detect stalling
		 * 
		 * WHY BRENT'S METHOD?
		 * - Best of both worlds: fast when possible, robust always
		 * - No function derivatives needed
		 * - Guaranteed convergence for continuous functions
		 * - Industry standard for 1D minimization
		 * 
		 * COMPLEXITY:
		 * - Best case: O(log log(1/tol)) for smooth unimodal functions
		 * - Worst case: O(log(1/tol)) - same as golden section
		 * - Typically 2-3x faster than pure golden section
		 * 
		 * @param func    Real function to minimize
		 * @param bracket Pre-computed bracket from BracketMinimum
		 * @param tol     Fractional tolerance (default: 3e-8)
		 * @param maxIter Maximum iterations (default: 100)
		 * @return MinimizationResult with xmin, fmin, and iteration count
		 * 
		 * @throws OptimizationError if maximum iterations exceeded
		 * 
		 * @note Based on Numerical Recipes Â§10.3
		 * @see BracketMinimum to obtain initial bracket
		 * @see BrentMinimizeWithDeriv for version using derivatives
		 */
		static MinimizationResult BrentMinimize(const IRealFunction& func,
		                                        const MinimumBracket& bracket,
		                                        Real tol = 3.0e-8,
		                                        int maxIter = 100)
		{
			const Real CGOLD = 0.3819660;  // Golden ratio for section (1 - 1/Ï†)
			const Real ZEPS = std::numeric_limits<Real>::epsilon() * 1.0e-3;
			
			MinimizationResult result;
			result.converged = false;
			result.iterations = 0;
			
			Real a, b, d = 0.0, etemp, fu, fv, fw, fx;
			Real p, q, r, tol1, tol2, u, v, w, x, xm;
			Real e = 0.0;  // Distance moved on the step before last
			
			// a and b must be in ascending order
			a = (bracket.ax < bracket.cx) ? bracket.ax : bracket.cx;
			b = (bracket.ax > bracket.cx) ? bracket.ax : bracket.cx;
			
			// Initialize x, w, v to the best point (bx from bracket)
			x = w = v = bracket.bx;
			fw = fv = fx = func(x);
			
			for (int iter = 0; iter < maxIter; iter++)
			{
				result.iterations++;
				xm = 0.5 * (a + b);  // Midpoint
				tol1 = tol * std::abs(x) + ZEPS;
				tol2 = 2.0 * tol1;
				
				// Test for convergence
				if (std::abs(x - xm) <= (tol2 - 0.5 * (b - a)))
				{
					result.xmin = x;
					result.fmin = fx;
					result.converged = true;
					return result;
				}
				
				// Try parabolic interpolation
				if (std::abs(e) > tol1)
				{
					// Fit parabola
					r = (x - w) * (fx - fv);
					q = (x - v) * (fx - fw);
					p = (x - v) * q - (x - w) * r;
					q = 2.0 * (q - r);
					if (q > 0.0) p = -p;
					q = std::abs(q);
					etemp = e;
					e = d;
					
					// Accept parabolic step?
					if (std::abs(p) >= std::abs(0.5 * q * etemp) || 
					    p <= q * (a - x) || p >= q * (b - x))
					{
						// No, use golden section instead
						e = (x >= xm) ? a - x : b - x;
						d = CGOLD * e;
					}
					else
					{
						// Yes, take parabolic step
						d = p / q;
						u = x + d;
						// Don't step too close to boundaries
						if (u - a < tol2 || b - u < tol2)
							d = std::copysign(tol1, xm - x);
					}
				}
				else
				{
					// Golden section step
					e = (x >= xm) ? a - x : b - x;
					d = CGOLD * e;
				}
				
				// Function evaluation (never closer than tol1)
				u = (std::abs(d) >= tol1) ? x + d : x + std::copysign(tol1, d);
				fu = func(u);
				
				// Update bracket and best points
				if (fu <= fx)
				{
					if (u >= x) a = x; else b = x;
					// Shift (v, w, x) <- (w, x, u)
					v = w; w = x; x = u;
					fv = fw; fw = fx; fx = fu;
				}
				else
				{
					if (u < x) a = u; else b = u;
					if (fu <= fw || w == x)
					{
						v = w; w = u;
						fv = fw; fw = fu;
					}
					else if (fu <= fv || v == x || v == w)
					{
						v = u;
						fv = fu;
					}
				}
			}
			
			// Failed to converge
			result.xmin = x;
			result.fmin = fx;
			result.converged = false;
			throw OptimizationError("Maximum iterations exceeded in BrentMinimize", maxIter);
		}

		/**
		 * @brief Convenience function combining bracketing and Brent's method.
		 * 
		 * @param func    Real function to minimize
		 * @param a       Initial left search bound
		 * @param b       Initial right search bound
		 * @param tol     Fractional tolerance
		 * @param maxIter Maximum iterations
		 * @return MinimizationResult with xmin, fmin, and iteration count
		 */
		static MinimizationResult BrentMinimize(const IRealFunction& func,
		                                        Real a, Real b,
		                                        Real tol = 3.0e-8,
		                                        int maxIter = 100)
		{
			MinimumBracket bracket = BracketMinimum(func, a, b);
			if (!bracket.valid)
				throw OptimizationError("Failed to bracket minimum in BrentMinimize");
			return BrentMinimize(func, bracket, tol, maxIter);
		}

		/*********************************************************************/
		/*****   10.4 One-Dimensional Search with First Derivatives      *****/
		/*********************************************************************/
		/**
		 * @brief Find minimum using Brent's method with derivative information.
		 * 
		 * When derivatives are available, this method can converge faster than
		 * standard Brent's method by using derivative information to guide
		 * the search direction and perform secant-like updates.
		 * 
		 * ALGORITHM:
		 * Similar to BrentMinimize but additionally tracks derivatives:
		 * 
		 * 1. Maintains bracket [a,b] and three points (x,w,v) with function
		 *    values AND derivatives
		 * 2. Uses secant method with derivatives for extrapolation:
		 *    - d1 = derivative-based step from (x,dx) and (w,dw)
		 *    - d2 = derivative-based step from (x,dx) and (v,dv)
		 * 3. Takes smaller step if it's acceptable, else bisection
		 * 4. Uses sign of derivative to determine which half of bracket to keep
		 * 
		 * DERIVATIVE USAGE:
		 * - Derivative sign indicates direction to minimum
		 * - If f'(x) < 0: minimum is to the right of x
		 * - If f'(x) > 0: minimum is to the left of x
		 * - Secant update: x_new = x - f'(x) * (x - x_prev) / (f'(x) - f'(x_prev))
		 * 
		 * CONVERGENCE:
		 * - Superlinear (order â‰ˆ 1.618) when secant steps accepted
		 * - Faster than derivative-free Brent for smooth functions
		 * - Falls back to bisection when needed
		 * 
		 * WHEN TO USE:
		 * - Derivative is cheap to compute (automatic differentiation, closed form)
		 * - Function is smooth with well-behaved derivative
		 * - Maximum speed is important
		 * 
		 * WHEN NOT TO USE:
		 * - Derivative is expensive (numerical differentiation)
		 * - Function has discontinuous derivatives
		 * - Simplicity is preferred over speed
		 * 
		 * @param func    Real function to minimize (must have operator())
		 * @param dfunc   Derivative function (df/dx)
		 * @param bracket Pre-computed bracket from BracketMinimum
		 * @param tol     Fractional tolerance (default: 3e-8)
		 * @param maxIter Maximum iterations (default: 100)
		 * @return MinimizationResult with xmin, fmin, and iteration count
		 * 
		 * @throws OptimizationError if maximum iterations exceeded
		 * 
		 * @note Based on Numerical Recipes Â§10.4 (dbrent)
		 * @see BrentMinimize for version without derivatives
		 */
		static MinimizationResult BrentMinimizeWithDeriv(const IRealFunction& func,
		                                                  const IRealFunction& dfunc,
		                                                  const MinimumBracket& bracket,
		                                                  Real tol = 3.0e-8,
		                                                  int maxIter = 100)
		{
			const Real ZEPS = std::numeric_limits<Real>::epsilon() * 1.0e-3;
			
			MinimizationResult result;
			result.converged = false;
			result.iterations = 0;
			
			bool ok1, ok2;
			Real a, b, d = 0.0, d1, d2, du, dv, dw, dx, e = 0.0;
			Real fu, fv, fw, fx, olde, tol1, tol2, u, u1, u2, v, w, x, xm;
			
			// a and b must be in ascending order
			a = (bracket.ax < bracket.cx) ? bracket.ax : bracket.cx;
			b = (bracket.ax > bracket.cx) ? bracket.ax : bracket.cx;
			
			// Initialize x, w, v to the best point
			x = w = v = bracket.bx;
			fw = fv = fx = func(x);
			dw = dv = dx = dfunc(x);
			
			for (int iter = 0; iter < maxIter; iter++)
			{
				result.iterations++;
				xm = 0.5 * (a + b);
				tol1 = tol * std::abs(x) + ZEPS;
				tol2 = 2.0 * tol1;
				
				// Test for convergence
				if (std::abs(x - xm) <= (tol2 - 0.5 * (b - a)))
				{
					result.xmin = x;
					result.fmin = fx;
					result.converged = true;
					return result;
				}
				
				if (std::abs(e) > tol1)
				{
					// Use derivatives for secant extrapolation
					d1 = 2.0 * (b - a);
					d2 = d1;
					
					if (dw != dx) d1 = (w - x) * dx / (dx - dw);
					if (dv != dx) d2 = (v - x) * dx / (dx - dv);
					
					u1 = x + d1;
					u2 = x + d2;
					
					// Check if either step is acceptable
					ok1 = (a - u1) * (u1 - b) > 0.0 && dx * d1 <= 0.0;
					ok2 = (a - u2) * (u2 - b) > 0.0 && dx * d2 <= 0.0;
					
					olde = e;
					e = d;
					
					if (ok1 || ok2)
					{
						// Choose the smaller step if both are okay
						if (ok1 && ok2)
							d = (std::abs(d1) < std::abs(d2)) ? d1 : d2;
						else if (ok1)
							d = d1;
						else
							d = d2;
						
						if (std::abs(d) <= std::abs(0.5 * olde))
						{
							u = x + d;
							if (u - a < tol2 || b - u < tol2)
								d = std::copysign(tol1, xm - x);
						}
						else
						{
							// Bisection
							e = (dx >= 0.0) ? a - x : b - x;
							d = 0.5 * e;
						}
					}
					else
					{
						// Bisection
						e = (dx >= 0.0) ? a - x : b - x;
						d = 0.5 * e;
					}
				}
				else
				{
					// Bisection
					e = (dx >= 0.0) ? a - x : b - x;
					d = 0.5 * e;
				}
				
				// Function evaluation
				if (std::abs(d) >= tol1)
				{
					u = x + d;
					fu = func(u);
				}
				else
				{
					u = x + std::copysign(tol1, d);
					fu = func(u);
					if (fu > fx)
					{
						// Minimum bracketed, return
						result.xmin = x;
						result.fmin = fx;
						result.converged = true;
						return result;
					}
				}
				
				du = dfunc(u);
				
				// Update bracket and best points
				if (fu <= fx)
				{
					if (u >= x) a = x; else b = x;
					// Shift (v,w,x) <- (w,x,u)
					v = w; fv = fw; dv = dw;
					w = x; fw = fx; dw = dx;
					x = u; fx = fu; dx = du;
				}
				else
				{
					if (u < x) a = u; else b = u;
					if (fu <= fw || w == x)
					{
						v = w; fv = fw; dv = dw;
						w = u; fw = fu; dw = du;
					}
					else if (fu < fv || v == x || v == w)
					{
						v = u; fv = fu; dv = du;
					}
				}
			}
			
			// Failed to converge
			result.xmin = x;
			result.fmin = fx;
			result.converged = false;
			throw OptimizationError("Maximum iterations exceeded in BrentMinimizeWithDeriv", maxIter);
		}

		/**
		 * @brief Convenience function combining bracketing and derivative-based Brent.
		 * 
		 * @param func    Real function to minimize
		 * @param dfunc   Derivative function
		 * @param a       Initial left search bound
		 * @param b       Initial right search bound
		 * @param tol     Fractional tolerance
		 * @param maxIter Maximum iterations
		 * @return MinimizationResult with xmin, fmin, and iteration count
		 */
		static MinimizationResult BrentMinimizeWithDeriv(const IRealFunction& func,
		                                                  const IRealFunction& dfunc,
		                                                  Real a, Real b,
		                                                  Real tol = 3.0e-8,
		                                                  int maxIter = 100)
		{
			MinimumBracket bracket = BracketMinimum(func, a, b);
			if (!bracket.valid)
				throw OptimizationError("Failed to bracket minimum in BrentMinimizeWithDeriv");
			return BrentMinimizeWithDeriv(func, dfunc, bracket, tol, maxIter);
		}

		/*********************************************************************/
		/*****                 Maximization wrappers                     *****/
		/*********************************************************************/
		/**
		 * @brief Find maximum using golden section search (negates function).
		 * 
		 * @param func  Real function to maximize
		 * @param a     Initial left search bound
		 * @param b     Initial right search bound
		 * @param tol   Fractional tolerance
		 * @return MinimizationResult with xmax, fmax (note: fmax is actual max value)
		 */
		static MinimizationResult GoldenSectionMaximize(const IRealFunction& func,
		                                                 Real a, Real b,
		                                                 Real tol = 3.0e-8)
		{
			// Negate function to turn maximum into minimum
			RealFunctionFromStdFunc negFunc([&func](Real x) { return -func(x); });
			MinimizationResult result = GoldenSectionSearch(negFunc, a, b, tol);
			result.fmin = -result.fmin;  // Restore original function value
			return result;
		}

		/**
		 * @brief Find maximum using Brent's method (negates function).
		 * 
		 * @param func    Real function to maximize
		 * @param a       Initial left search bound
		 * @param b       Initial right search bound
		 * @param tol     Fractional tolerance
		 * @param maxIter Maximum iterations
		 * @return MinimizationResult with xmax, fmax
		 */
		static MinimizationResult BrentMaximize(const IRealFunction& func,
		                                         Real a, Real b,
		                                         Real tol = 3.0e-8,
		                                         int maxIter = 100)
		{
			RealFunctionFromStdFunc negFunc([&func](Real x) { return -func(x); });
			MinimizationResult result = BrentMinimize(negFunc, a, b, tol, maxIter);
			result.fmin = -result.fmin;
			return result;
		}

	}  // namespace Minimization
}  // namespace MML


///////////////////////////   mml/algorithms/Optimization/OptimizationCommon.h   ///////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////
// OptimizationCommon.h - Base infrastructure for flexible optimization framework
// 
// Provides:
//   - OptimizationState: Encapsulates current state during optimization
//   - OptimizationResult: Enhanced result structure with trajectory and diagnostics
//   - ITerminationCriterion: Interface for pluggable termination criteria
//   - IOptimizationObserver: Observer pattern for progress monitoring
//
// This is the foundation for the new optimization framework, designed to be:
//   - Extensible (add new criteria/observers without modifying optimizers)
//   - Flexible (compose criteria, chain observers)
//   - Backward compatible (old APIs still work)
//   - Zero overhead (no cost if features not used)
///////////////////////////////////////////////////////////////////////////////////////////

namespace MML
{

///////////////////////////////////////////////////////////////////////////////////////////
// OPTIMIZATION STATE - Encapsulates current state during optimization
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Encapsulates the current state of an optimization algorithm
/// @details Contains all relevant information about the current iteration,
///          allowing termination criteria and observers to make decisions
template <typename Real>
struct OptimizationState
{
    // Iteration counters
    int iteration;              ///< Current iteration number (0-based)
    int funcEvals;              ///< Total function evaluations so far
    int gradEvals;              ///< Total gradient evaluations (for gradient-based methods)
    
    // Current solution
    Vector<Real> xCurrent;      ///< Current solution vector
    Real fCurrent;              ///< Current function value
    
    // Best solution so far
    Vector<Real> xBest;         ///< Best solution found so far
    Real fBest;                 ///< Best function value found so far
    
    // Convergence metrics (method-specific)
    Real gradNorm;              ///< Gradient norm (for gradient-based methods)
    Real stepSize;              ///< Last step size taken
    Real simplexSize;           ///< Simplex size (for Nelder-Mead)
    Real directionChange;       ///< Direction change angle (for Powell, CG)
    
    // Stochastic method metrics
    Real temperature;           ///< Temperature (for Simulated Annealing)
    int acceptedMoves;          ///< Number of accepted moves (for SA/MCMC)
    int rejectedMoves;          ///< Number of rejected moves (for SA/MCMC)
    
    // Stagnation tracking
    int iterSinceImprovement;   ///< Iterations without improvement in fBest
    Real fBestPrevious;         ///< Previous best function value (for tracking improvement)
    
    // Timing
    double elapsedTime;         ///< Wall-clock time since start (seconds)
    
    /// @brief Default constructor initializes all fields to safe defaults
    OptimizationState()
        : iteration(0), funcEvals(0), gradEvals(0),
          fCurrent(std::numeric_limits<Real>::max()),
          fBest(std::numeric_limits<Real>::max()),
          gradNorm(0), stepSize(0), simplexSize(0), directionChange(0),
          temperature(0), acceptedMoves(0), rejectedMoves(0),
          iterSinceImprovement(0), 
          fBestPrevious(std::numeric_limits<Real>::max()),
          elapsedTime(0.0)
    {}
    
    /// @brief Check if there was improvement in this iteration
    bool HasImproved() const {
        return fBest < fBestPrevious - std::numeric_limits<Real>::epsilon();
    }
    
    /// @brief Get acceptance rate (for stochastic methods)
    Real GetAcceptanceRate() const {
        int total = acceptedMoves + rejectedMoves;
        return total > 0 ? static_cast<Real>(acceptedMoves) / total : Real(0);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////
// OPTIMIZATION RESULT - Enhanced result structure with trajectory and diagnostics
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Enhanced optimization result with trajectory and diagnostics
/// @details Replaces the old simple result structs with richer information
template <typename Real>
struct OptimizationResult
{
    // Solution
    Vector<Real> xBest;         ///< Best solution found
    Real fBest;                 ///< Best function value
    
    // Convergence information
    bool converged;             ///< Whether optimization converged successfully
    std::string terminationReason;  ///< Human-readable reason for termination
    
    // Statistics
    int iterations;             ///< Total iterations performed
    int funcEvals;              ///< Total function evaluations
    int gradEvals;              ///< Total gradient evaluations (gradient-based methods)
    int acceptedMoves;          ///< Accepted moves (stochastic methods)
    int rejectedMoves;          ///< Rejected moves (stochastic methods)
    double elapsedTime;         ///< Total wall-clock time (seconds)
    
    // Final state diagnostics
    Real finalGradNorm;         ///< Final gradient norm (gradient methods)
    Real finalStepSize;         ///< Final step size
    Real finalTemperature;      ///< Final temperature (Simulated Annealing)
    Real finalSimplexSize;      ///< Final simplex size (Nelder-Mead)
    
    // Optional trajectory (populated if TrajectoryObserver used)
    std::vector<OptimizationState<Real>> trajectory;
    
    /// @brief Default constructor
    OptimizationResult()
        : fBest(std::numeric_limits<Real>::max()),
          converged(false),
          terminationReason("Not started"),
          iterations(0), funcEvals(0), gradEvals(0),
          acceptedMoves(0), rejectedMoves(0),
          elapsedTime(0.0),
          finalGradNorm(0), finalStepSize(0),
          finalTemperature(0), finalSimplexSize(0)
    {}
    
    /// @brief Get acceptance rate (for stochastic methods)
    Real GetAcceptanceRate() const {
        int total = acceptedMoves + rejectedMoves;
        return total > 0 ? static_cast<Real>(acceptedMoves) / total : Real(0);
    }
    
    /// @brief Check if trajectory was recorded
    bool HasTrajectory() const {
        return !trajectory.empty();
    }
};

///////////////////////////////////////////////////////////////////////////////////////////
// TERMINATION CRITERION INTERFACE
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Interface for termination criteria
/// @details Allows pluggable, composable stopping conditions for optimization
template <typename Real>
class ITerminationCriterion
{
public:
    virtual ~ITerminationCriterion() = default;
    
    /// @brief Check if optimization should terminate
    /// @param state Current optimization state
    /// @return true if optimization should stop, false to continue
    virtual bool ShouldTerminate(const OptimizationState<Real>& state) const = 0;
    
    /// @brief Get human-readable reason for termination
    /// @return String describing why termination occurred (if applicable)
    virtual std::string GetReason() const = 0;
    
    /// @brief Reset criterion for new optimization run
    /// @details Called before starting a new optimization to clear any state
    virtual void Reset() = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////
// OPTIMIZATION OBSERVER INTERFACE
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Observer interface for monitoring optimization progress
/// @details Allows callbacks at key points during optimization for:
///          - Progress monitoring and logging
///          - Intermediate result saving (checkpointing)
///          - Custom early stopping logic
///          - GUI updates, plotting, etc.
template <typename Real>
class IOptimizationObserver
{
public:
    virtual ~IOptimizationObserver() = default;
    
    /// @brief Called at the start of optimization
    /// @param state Initial state (iteration 0)
    virtual void OnStart(const OptimizationState<Real>& state) = 0;
    
    /// @brief Called after each iteration
    /// @param state Current state after iteration
    /// @return true to continue optimization, false to abort
    /// @note Returning false allows observers to implement custom early stopping
    virtual bool OnIteration(const OptimizationState<Real>& state) = 0;
    
    /// @brief Called when optimization completes (success or abort)
    /// @param state Final state
    /// @param reason Termination reason string
    virtual void OnComplete(const OptimizationState<Real>& state, 
                           const std::string& reason) = 0;
};

///////////////////////////////////////////////////////////////////////////////////////////
// HELPER FUNCTIONS
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Create an OptimizationResult from final OptimizationState
/// @param state Final state
/// @param reason Termination reason
/// @param converged Whether optimization converged successfully
/// @return Populated OptimizationResult
template <typename Real>
OptimizationResult<Real> CreateResult(const OptimizationState<Real>& state,
                                       const std::string& reason,
                                       bool converged)
{
    OptimizationResult<Real> result;
    
    result.xBest = state.xBest;
    result.fBest = state.fBest;
    result.converged = converged;
    result.terminationReason = reason;
    
    result.iterations = state.iteration;
    result.funcEvals = state.funcEvals;
    result.gradEvals = state.gradEvals;
    result.acceptedMoves = state.acceptedMoves;
    result.rejectedMoves = state.rejectedMoves;
    result.elapsedTime = state.elapsedTime;
    
    result.finalGradNorm = state.gradNorm;
    result.finalStepSize = state.stepSize;
    result.finalTemperature = state.temperature;
    result.finalSimplexSize = state.simplexSize;
    
    return result;
}

} // namespace MML


///////////////////////////   mml/algorithms/Optimization/OptimizationObservers.h   ///////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////
// OptimizationObservers.h - Standard observers for optimization progress monitoring
//
// Provides concrete implementations of IOptimizationObserver:
//   - ConsoleObserver: Prints progress to console
//   - TrajectoryObserver: Saves OptimizationState snapshots with CSV export
//   - CallbackObserver: Lambda-friendly custom callbacks
//   - NullObserver: No-op observer (for disabling observation)
//
// Observers enable:
//   - Progress monitoring and logging
//   - Intermediate result saving (checkpointing)
//   - Custom early stopping logic
//   - GUI updates, plotting, analysis
//
// Usage patterns:
//   - Single observer: direct use
//   - Multiple observers: wrap in MultiObserver
//   - Custom behavior: use CallbackObserver with lambdas
///////////////////////////////////////////////////////////////////////////////////////////

namespace MML
{

///////////////////////////////////////////////////////////////////////////////////////////
// NULL OBSERVER (for disabling observation)
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief No-op observer that does nothing
/// @details Useful as a default when no observation needed
template <typename Real>
class NullObserver : public IOptimizationObserver<Real>
{
public:
    void OnStart(const OptimizationState<Real>&) override {}
    bool OnIteration(const OptimizationState<Real>&) override { return true; }
    void OnComplete(const OptimizationState<Real>&, const std::string&) override {}
};

///////////////////////////////////////////////////////////////////////////////////////////
// CONSOLE OBSERVER
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Prints optimization progress to console
/// @details Configurable output frequency and verbosity
template <typename Real>
class ConsoleObserver : public IOptimizationObserver<Real>
{
private:
    int _printEvery;        ///< Print every N iterations (1 = every iteration)
    bool _verbose;          ///< Verbose output (more details)
    std::ostream& _out;     ///< Output stream (default: std::cout)
    
public:
    /// @brief Constructor
    /// @param printEvery Print every N iterations (default: 1)
    /// @param verbose Verbose output with more details (default: false)
    /// @param out Output stream (default: std::cout)
    explicit ConsoleObserver(int printEvery = 1, bool verbose = false, 
                            std::ostream& out = std::cout)
        : _printEvery(printEvery), _verbose(verbose), _out(out)
    {
        if (printEvery <= 0) {
            throw std::invalid_argument("ConsoleObserver: printEvery must be positive");
        }
    }
    
    void OnStart(const OptimizationState<Real>& state) override {
        _out << "\n=== Optimization Started ===" << std::endl;
        _out << "Initial f = " << state.fCurrent << std::endl;
        if (_verbose) {
            _out << "Dimension = " << state.xCurrent.size() << std::endl;
        }
        _out << std::endl;
        
        // Print header
        _out << std::setw(8) << "Iter" 
             << std::setw(15) << "fBest"
             << std::setw(12) << "fEvals";
        
        if (_verbose) {
            _out << std::setw(12) << "Accepted"
                 << std::setw(12) << "AcceptRate"
                 << std::setw(12) << "Time(s)";
        }
        _out << std::endl;
        _out << std::string(80, '-') << std::endl;
    }
    
    bool OnIteration(const OptimizationState<Real>& state) override {
        if (state.iteration % _printEvery == 0) {
            _out << std::setw(8) << state.iteration
                 << std::setw(15) << std::scientific << std::setprecision(6) 
                 << state.fBest
                 << std::setw(12) << state.funcEvals;
            
            if (_verbose) {
                _out << std::setw(12) << state.acceptedMoves
                     << std::setw(12) << std::fixed << std::setprecision(3) 
                     << state.GetAcceptanceRate()
                     << std::setw(12) << std::fixed << std::setprecision(2) 
                     << state.elapsedTime;
            }
            _out << std::endl;
        }
        return true;  // Continue optimization
    }
    
    void OnComplete(const OptimizationState<Real>& state, 
                   const std::string& reason) override {
        _out << std::string(80, '-') << std::endl;
        _out << "\n=== Optimization Complete ===" << std::endl;
        _out << "Reason: " << reason << std::endl;
        _out << "Final fBest = " << state.fBest << std::endl;
        _out << "Iterations: " << state.iteration << std::endl;
        _out << "Function evaluations: " << state.funcEvals << std::endl;
        
        if (_verbose) {
            _out << "Elapsed time: " << state.elapsedTime << " seconds" << std::endl;
            if (state.acceptedMoves > 0 || state.rejectedMoves > 0) {
                _out << "Acceptance rate: " << state.GetAcceptanceRate() << std::endl;
            }
            if (state.gradNorm > 0) {
                _out << "Final gradient norm: " << state.gradNorm << std::endl;
            }
        }
        _out << std::endl;
    }
    
    void SetPrintEvery(int printEvery) { 
        if (printEvery <= 0) {
            throw std::invalid_argument("printEvery must be positive");
        }
        _printEvery = printEvery; 
    }
    void SetVerbose(bool verbose) { _verbose = verbose; }
};

///////////////////////////////////////////////////////////////////////////////////////////
// TRAJECTORY OBSERVER
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Saves OptimizationState snapshots for post-analysis
/// @details Allows trajectory visualization, convergence analysis, etc.
template <typename Real>
class TrajectoryObserver : public IOptimizationObserver<Real>
{
private:
    std::vector<OptimizationState<Real>> _trajectory;
    int _saveEvery;     ///< Save every N iterations (1 = every iteration)
    size_t _maxSize;    ///< Maximum trajectory size (0 = unlimited)
    
public:
    /// @brief Constructor
    /// @param saveEvery Save state every N iterations (default: 1)
    /// @param maxSize Maximum trajectory size, 0 for unlimited (default: 0)
    explicit TrajectoryObserver(int saveEvery = 1, size_t maxSize = 0)
        : _saveEvery(saveEvery), _maxSize(maxSize)
    {
        if (saveEvery <= 0) {
            throw std::invalid_argument("TrajectoryObserver: saveEvery must be positive");
        }
    }
    
    void OnStart(const OptimizationState<Real>& state) override {
        _trajectory.clear();
        _trajectory.push_back(state);  // Save initial state
    }
    
    bool OnIteration(const OptimizationState<Real>& state) override {
        if (state.iteration % _saveEvery == 0) {
            // Check size limit
            if (_maxSize > 0 && _trajectory.size() >= _maxSize) {
                // Keep first and last, downsample middle
                DownsampleTrajectory();
            }
            _trajectory.push_back(state);
        }
        return true;  // Continue
    }
    
    void OnComplete(const OptimizationState<Real>& state, 
                   const std::string&) override {
        // Always save final state if not already saved
        if (_trajectory.empty() || _trajectory.back().iteration != state.iteration) {
            _trajectory.push_back(state);
        }
    }
    
    /// @brief Get the recorded trajectory
    const std::vector<OptimizationState<Real>>& GetTrajectory() const {
        return _trajectory;
    }
    
    /// @brief Get trajectory size
    size_t GetSize() const {
        return _trajectory.size();
    }
    
    /// @brief Clear trajectory (free memory)
    void Clear() {
        _trajectory.clear();
    }
    
    /// @brief Export trajectory to CSV file
    /// @param filename Output file path
    /// @param includeX Include solution vector components (default: false, can be large)
    void ExportCSV(const std::string& filename, bool includeX = false) const {
        std::ofstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("TrajectoryObserver: Cannot open file " + filename);
        }
        
        // Header
        file << "iteration,funcEvals,fCurrent,fBest,gradNorm,stepSize,temperature,"
             << "acceptedMoves,rejectedMoves,acceptRate,iterSinceImprovement,elapsedTime";
        
        if (includeX && !_trajectory.empty()) {
            size_t dim = _trajectory[0].xBest.size();
            for (size_t i = 0; i < dim; ++i) {
                file << ",x" << i;
            }
        }
        file << std::endl;
        
        // Data
        for (const auto& state : _trajectory) {
            file << state.iteration << ","
                 << state.funcEvals << ","
                 << state.fCurrent << ","
                 << state.fBest << ","
                 << state.gradNorm << ","
                 << state.stepSize << ","
                 << state.temperature << ","
                 << state.acceptedMoves << ","
                 << state.rejectedMoves << ","
                 << state.GetAcceptanceRate() << ","
                 << state.iterSinceImprovement << ","
                 << state.elapsedTime;
            
            if (includeX) {
                for (size_t i = 0; i < state.xBest.size(); ++i) {
                    file << "," << state.xBest[i];
                }
            }
            file << std::endl;
        }
        
        file.close();
    }
    
    /// @brief Export convergence plot data (iteration vs fBest)
    void ExportConvergencePlot(const std::string& filename) const {
        std::ofstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("TrajectoryObserver: Cannot open file " + filename);
        }
        
        file << "iteration,fBest" << std::endl;
        for (const auto& state : _trajectory) {
            file << state.iteration << "," << state.fBest << std::endl;
        }
        
        file.close();
    }
    
private:
    /// @brief Downsample trajectory when size limit reached
    void DownsampleTrajectory() {
        if (_trajectory.size() <= 2) return;
        
        // Keep every other element (simple decimation)
        std::vector<OptimizationState<Real>> downsampled;
        downsampled.reserve(_trajectory.size() / 2 + 1);
        
        for (size_t i = 0; i < _trajectory.size(); i += 2) {
            downsampled.push_back(_trajectory[i]);
        }
        
        _trajectory = std::move(downsampled);
        _saveEvery *= 2;  // Adjust save frequency
    }
};

///////////////////////////////////////////////////////////////////////////////////////////
// CALLBACK OBSERVER
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Lambda-friendly observer for custom callbacks
/// @details Allows inline custom logic without creating new observer classes
template <typename Real>
class CallbackObserver : public IOptimizationObserver<Real>
{
private:
    std::function<void(const OptimizationState<Real>&)> _onStartCallback;
    std::function<bool(const OptimizationState<Real>&)> _onIterCallback;
    std::function<void(const OptimizationState<Real>&, const std::string&)> _onCompleteCallback;
    
public:
    CallbackObserver() = default;
    
    /// @brief Set callback for optimization start
    void SetOnStart(std::function<void(const OptimizationState<Real>&)> callback) {
        _onStartCallback = callback;
    }
    
    /// @brief Set callback for each iteration
    /// @note Callback should return true to continue, false to abort
    void SetOnIteration(std::function<bool(const OptimizationState<Real>&)> callback) {
        _onIterCallback = callback;
    }
    
    /// @brief Set callback for optimization completion
    void SetOnComplete(
        std::function<void(const OptimizationState<Real>&, const std::string&)> callback) {
        _onCompleteCallback = callback;
    }
    
    void OnStart(const OptimizationState<Real>& state) override {
        if (_onStartCallback) {
            _onStartCallback(state);
        }
    }
    
    bool OnIteration(const OptimizationState<Real>& state) override {
        if (_onIterCallback) {
            return _onIterCallback(state);
        }
        return true;  // Continue by default
    }
    
    void OnComplete(const OptimizationState<Real>& state, 
                   const std::string& reason) override {
        if (_onCompleteCallback) {
            _onCompleteCallback(state, reason);
        }
    }
};

///////////////////////////////////////////////////////////////////////////////////////////
// MULTI OBSERVER (Composite)
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Combines multiple observers into one
/// @details Calls all observers in sequence
template <typename Real>
class MultiObserver : public IOptimizationObserver<Real>
{
private:
    std::vector<std::shared_ptr<IOptimizationObserver<Real>>> _observers;
    
public:
    MultiObserver() = default;
    
    /// @brief Add an observer to the collection
    void AddObserver(std::shared_ptr<IOptimizationObserver<Real>> observer) {
        if (!observer) {
            throw std::invalid_argument("MultiObserver: Cannot add null observer");
        }
        _observers.push_back(observer);
    }
    
    /// @brief Add observer by constructing in-place
    template<typename ObserverType, typename... Args>
    void AddObserver(Args&&... args) {
        _observers.push_back(
            std::make_shared<ObserverType>(std::forward<Args>(args)...)
        );
    }
    
    void OnStart(const OptimizationState<Real>& state) override {
        for (auto& obs : _observers) {
            obs->OnStart(state);
        }
    }
    
    bool OnIteration(const OptimizationState<Real>& state) override {
        // If any observer returns false, abort
        for (auto& obs : _observers) {
            if (!obs->OnIteration(state)) {
                return false;
            }
        }
        return true;
    }
    
    void OnComplete(const OptimizationState<Real>& state, 
                   const std::string& reason) override {
        for (auto& obs : _observers) {
            obs->OnComplete(state, reason);
        }
    }
    
    size_t GetObserverCount() const { return _observers.size(); }
    void Clear() { _observers.clear(); }
};

///////////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE CALLBACK PATTERNS
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Example: Checkpointing callback (saves state every N iterations)
template <typename Real>
std::function<bool(const OptimizationState<Real>&)> 
MakeCheckpointCallback(int saveEvery, const std::string& baseFilename) {
    return [saveEvery, baseFilename](const OptimizationState<Real>& state) {
        if (state.iteration % saveEvery == 0) {
            std::string filename = baseFilename + "_iter" + 
                                 std::to_string(state.iteration) + ".txt";
            std::ofstream file(filename);
            if (file.is_open()) {
                file << "iteration: " << state.iteration << std::endl;
                file << "fBest: " << state.fBest << std::endl;
                file << "xBest:";
                for (size_t i = 0; i < state.xBest.size(); ++i) {
                    file << " " << state.xBest[i];
                }
                file << std::endl;
                file.close();
            }
        }
        return true;  // Continue
    };
}

/// @brief Example: Early stopping if function value too good (sanity check)
template <typename Real>
std::function<bool(const OptimizationState<Real>&)> 
MakeEarlyStoppingCallback(Real stopIfBelow) {
    return [stopIfBelow](const OptimizationState<Real>& state) {
        return state.fBest >= stopIfBelow;  // Stop if too good
    };
}

/// @brief Example: Alert if stagnation detected
template <typename Real>
std::function<bool(const OptimizationState<Real>&)> 
MakeStagnationAlertCallback(int alertAfter) {
    return [alertAfter](const OptimizationState<Real>& state) {
        if (state.iterSinceImprovement == alertAfter) {
            std::cout << "âš  ALERT: No improvement for " << alertAfter 
                     << " iterations!" << std::endl;
        }
        return true;  // Continue
    };
}

} // namespace MML


///////////////////////////   mml/algorithms/Optimization/TerminationCriteria.h   ///////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////
// TerminationCriteria.h - Standard termination criteria for optimization
//
// Provides concrete implementations of ITerminationCriterion:
//   - MaxIterationsCriterion: Stop after N iterations
//   - FunctionToleranceCriterion: Converged when f change is small
//   - GradientNormCriterion: Stop when gradient norm is small
//   - StagnationCriterion: Stop after N iterations without improvement
//   - TimeLimitCriterion: Wall-clock time limit
//   - TargetValueCriterion: Stop when target function value reached
//   - CompositeCriterion: Combine multiple criteria with AND/OR logic
//
// All criteria are:
//   - Stateless or properly reset-able
//   - Thread-safe for const methods
//   - Provide clear termination reasons
///////////////////////////////////////////////////////////////////////////////////////////

namespace MML
{

///////////////////////////////////////////////////////////////////////////////////////////
// MAX ITERATIONS CRITERION
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Terminate after maximum number of iterations
template <typename Real>
class MaxIterationsCriterion : public ITerminationCriterion<Real>
{
private:
    int _maxIter;
    
public:
    explicit MaxIterationsCriterion(int maxIter) 
        : _maxIter(maxIter) 
    {
        if (maxIter <= 0) {
            throw std::invalid_argument("MaxIterationsCriterion: maxIter must be positive");
        }
    }
    
    bool ShouldTerminate(const OptimizationState<Real>& state) const override {
        return state.iteration >= _maxIter;
    }
    
    std::string GetReason() const override {
        return "Maximum iterations reached (" + std::to_string(_maxIter) + ")";
    }
    
    void Reset() override {
        // Stateless - nothing to reset
    }
    
    int GetMaxIterations() const { return _maxIter; }
};

///////////////////////////////////////////////////////////////////////////////////////////
// FUNCTION TOLERANCE CRITERION
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Terminate when function value change is below tolerance
/// @details Checks relative change: |f_new - f_old| / (|f_old| + |f_new| + eps) < ftol
template <typename Real>
class FunctionToleranceCriterion : public ITerminationCriterion<Real>
{
private:
    Real _ftol;
    mutable Real _fBestPrev;
    mutable bool _initialized;
    
public:
    explicit FunctionToleranceCriterion(Real ftol) 
        : _ftol(ftol), _fBestPrev(0), _initialized(false)
    {
        if (ftol <= 0) {
            throw std::invalid_argument("FunctionToleranceCriterion: ftol must be positive");
        }
    }
    
    bool ShouldTerminate(const OptimizationState<Real>& state) const override {
        if (!_initialized) {
            _fBestPrev = state.fBest;
            _initialized = true;
            return false;  // Need at least one iteration
        }
        
        // Relative change in function value
        Real fChange = std::abs(_fBestPrev - state.fBest);
        Real fScale = std::abs(_fBestPrev) + std::abs(state.fBest) + Real(1e-10);
        Real relativeChange = fChange / fScale;
        
        bool converged = relativeChange < _ftol;
        
        // Update for next iteration
        _fBestPrev = state.fBest;
        
        return converged;
    }
    
    std::string GetReason() const override {
        return "Function value converged (ftol = " + std::to_string(_ftol) + ")";
    }
    
    void Reset() override {
        _initialized = false;
        _fBestPrev = 0;
    }
    
    Real GetTolerance() const { return _ftol; }
};

///////////////////////////////////////////////////////////////////////////////////////////
// GRADIENT NORM CRITERION
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Terminate when gradient norm is below threshold
/// @details For gradient-based optimization methods (BFGS, CG, etc.)
template <typename Real>
class GradientNormCriterion : public ITerminationCriterion<Real>
{
private:
    Real _gtol;
    
public:
    explicit GradientNormCriterion(Real gtol) 
        : _gtol(gtol)
    {
        if (gtol <= 0) {
            throw std::invalid_argument("GradientNormCriterion: gtol must be positive");
        }
    }
    
    bool ShouldTerminate(const OptimizationState<Real>& state) const override {
        return state.gradNorm < _gtol;
    }
    
    std::string GetReason() const override {
        return "Gradient norm below threshold (gtol = " + std::to_string(_gtol) + ")";
    }
    
    void Reset() override {
        // Stateless
    }
    
    Real GetTolerance() const { return _gtol; }
};

///////////////////////////////////////////////////////////////////////////////////////////
// STAGNATION CRITERION
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Terminate when no improvement for N iterations
/// @details Detects when optimization is stuck in a local minimum or plateau
template <typename Real>
class StagnationCriterion : public ITerminationCriterion<Real>
{
private:
    int _maxStagnation;
    
public:
    explicit StagnationCriterion(int maxStagnation) 
        : _maxStagnation(maxStagnation)
    {
        if (maxStagnation <= 0) {
            throw std::invalid_argument("StagnationCriterion: maxStagnation must be positive");
        }
    }
    
    bool ShouldTerminate(const OptimizationState<Real>& state) const override {
        return state.iterSinceImprovement >= _maxStagnation;
    }
    
    std::string GetReason() const override {
        return "Stagnation detected (no improvement for " + 
               std::to_string(_maxStagnation) + " iterations)";
    }
    
    void Reset() override {
        // State tracked in OptimizationState
    }
    
    int GetMaxStagnation() const { return _maxStagnation; }
};

///////////////////////////////////////////////////////////////////////////////////////////
// TIME LIMIT CRITERION
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Terminate after wall-clock time limit
/// @details Useful for real-time applications or benchmarking
template <typename Real>
class TimeLimitCriterion : public ITerminationCriterion<Real>
{
private:
    double _maxSeconds;
    
public:
    explicit TimeLimitCriterion(double maxSeconds) 
        : _maxSeconds(maxSeconds)
    {
        if (maxSeconds <= 0) {
            throw std::invalid_argument("TimeLimitCriterion: maxSeconds must be positive");
        }
    }
    
    bool ShouldTerminate(const OptimizationState<Real>& state) const override {
        return state.elapsedTime >= _maxSeconds;
    }
    
    std::string GetReason() const override {
        return "Time limit exceeded (" + std::to_string(_maxSeconds) + " seconds)";
    }
    
    void Reset() override {
        // Time tracked in OptimizationState
    }
    
    double GetMaxSeconds() const { return _maxSeconds; }
    double GetMaxMinutes() const { return _maxSeconds / 60.0; }
};

///////////////////////////////////////////////////////////////////////////////////////////
// TARGET VALUE CRITERION
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Terminate when target function value reached
/// @details Useful when you know the global optimum or a satisfactory value
template <typename Real>
class TargetValueCriterion : public ITerminationCriterion<Real>
{
private:
    Real _targetValue;
    Real _tolerance;
    
public:
    TargetValueCriterion(Real targetValue, Real tolerance = Real(1e-6)) 
        : _targetValue(targetValue), _tolerance(tolerance)
    {
        if (tolerance < 0) {
            throw std::invalid_argument("TargetValueCriterion: tolerance must be non-negative");
        }
    }
    
    bool ShouldTerminate(const OptimizationState<Real>& state) const override {
        return state.fBest <= _targetValue + _tolerance;
    }
    
    std::string GetReason() const override {
        return "Target function value reached (target = " + 
               std::to_string(_targetValue) + " Â± " + std::to_string(_tolerance) + ")";
    }
    
    void Reset() override {
        // Stateless
    }
    
    Real GetTargetValue() const { return _targetValue; }
    Real GetTolerance() const { return _tolerance; }
};

///////////////////////////////////////////////////////////////////////////////////////////
// SIMPLEX SIZE CRITERION
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Terminate when simplex size is below threshold (Nelder-Mead specific)
template <typename Real>
class SimplexSizeCriterion : public ITerminationCriterion<Real>
{
private:
    Real _threshold;
    
public:
    explicit SimplexSizeCriterion(Real threshold) 
        : _threshold(threshold)
    {
        if (threshold <= 0) {
            throw std::invalid_argument("SimplexSizeCriterion: threshold must be positive");
        }
    }
    
    bool ShouldTerminate(const OptimizationState<Real>& state) const override {
        return state.simplexSize < _threshold;
    }
    
    std::string GetReason() const override {
        return "Simplex converged (size = " + std::to_string(_threshold) + ")";
    }
    
    void Reset() override {
        // Stateless
    }
    
    Real GetThreshold() const { return _threshold; }
};

///////////////////////////////////////////////////////////////////////////////////////////
// COMPOSITE CRITERION
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Combine multiple criteria with AND or OR logic
/// @details Allows complex stopping conditions like:
///          "Stop if (maxIter OR stagnation) AND (ftol OR gtol)"
template <typename Real>
class CompositeCriterion : public ITerminationCriterion<Real>
{
public:
    enum class Mode { 
        ANY,  ///< OR: Stop if ANY criterion met
        ALL   ///< AND: Stop only if ALL criteria met
    };
    
private:
    std::vector<std::unique_ptr<ITerminationCriterion<Real>>> _criteria;
    Mode _mode;
    mutable std::string _reason;
    
public:
    explicit CompositeCriterion(Mode mode = Mode::ANY) 
        : _mode(mode) 
    {}
    
    /// @brief Add a criterion to the composite
    void AddCriterion(std::unique_ptr<ITerminationCriterion<Real>> criterion) {
        if (!criterion) {
            throw std::invalid_argument("CompositeCriterion: Cannot add null criterion");
        }
        _criteria.push_back(std::move(criterion));
    }
    
    /// @brief Convenience: Add criterion by constructing in-place
    template<typename CriterionType, typename... Args>
    void AddCriterion(Args&&... args) {
        _criteria.push_back(
            std::make_unique<CriterionType>(std::forward<Args>(args)...)
        );
    }
    
    bool ShouldTerminate(const OptimizationState<Real>& state) const override {
        if (_criteria.empty()) {
            return false;  // No criteria = never stop
        }
        
        if (_mode == Mode::ANY) {
            // OR logic: stop if ANY criterion met
            for (const auto& crit : _criteria) {
                if (crit->ShouldTerminate(state)) {
                    _reason = crit->GetReason();
                    return true;
                }
            }
            return false;
        }
        else {
            // AND logic: stop only if ALL criteria met
            std::vector<std::string> reasons;
            bool allMet = true;
            
            for (const auto& crit : _criteria) {
                if (crit->ShouldTerminate(state)) {
                    reasons.push_back(crit->GetReason());
                }
                else {
                    allMet = false;
                }
            }
            
            if (allMet && !reasons.empty()) {
                // Combine all reasons
                _reason = "Multiple criteria met: ";
                for (size_t i = 0; i < reasons.size(); ++i) {
                    if (i > 0) _reason += "; ";
                    _reason += reasons[i];
                }
                return true;
            }
            return false;
        }
    }
    
    std::string GetReason() const override {
        return _reason.empty() ? "Composite criterion not yet evaluated" : _reason;
    }
    
    void Reset() override {
        for (auto& crit : _criteria) {
            crit->Reset();
        }
        _reason.clear();
    }
    
    Mode GetMode() const { return _mode; }
    size_t GetCriterionCount() const { return _criteria.size(); }
};

///////////////////////////////////////////////////////////////////////////////////////////
// FACTORY HELPERS
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Create default termination criterion (common pattern)
/// @details Returns: maxIter OR stagnation (whichever comes first)
template <typename Real>
std::unique_ptr<ITerminationCriterion<Real>> CreateDefaultCriterion(
    int maxIter = 1000, 
    int maxStagnation = 100)
{
    auto composite = std::make_unique<CompositeCriterion<Real>>(
        CompositeCriterion<Real>::Mode::ANY
    );
    composite->AddCriterion(std::make_unique<MaxIterationsCriterion<Real>>(maxIter));
    composite->AddCriterion(std::make_unique<StagnationCriterion<Real>>(maxStagnation));
    return composite;
}

/// @brief Create tolerance-based criterion (for precise optimization)
/// @details Returns: (ftol AND gtol) OR maxIter (safety net)
template <typename Real>
std::unique_ptr<ITerminationCriterion<Real>> CreateToleranceCriterion(
    Real ftol = Real(1e-8),
    Real gtol = Real(1e-6),
    int maxIter = 10000)
{
    auto composite = std::make_unique<CompositeCriterion<Real>>(
        CompositeCriterion<Real>::Mode::ANY
    );
    
    // ftol AND gtol
    auto innerComposite = std::make_unique<CompositeCriterion<Real>>(
        CompositeCriterion<Real>::Mode::ALL
    );
    innerComposite->AddCriterion(std::make_unique<FunctionToleranceCriterion<Real>>(ftol));
    innerComposite->AddCriterion(std::make_unique<GradientNormCriterion<Real>>(gtol));
    
    composite->AddCriterion(std::move(innerComposite));
    composite->AddCriterion(std::make_unique<MaxIterationsCriterion<Real>>(maxIter));
    
    return composite;
}

} // namespace MML


///////////////////////////   mml/algorithms/Optimization/OptimizationConfig.h   ///////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////
// OptimizationConfig.h - Fluent builder API for optimization configuration
//
// Provides OptimizationConfig class with fluent API for configuring:
//   - Termination criteria (pluggable, composable)
//   - Observers (console, trajectory, custom callbacks)
//   - Convenient defaults and presets
//
// Design goals:
//   - User-friendly: Readable, self-documenting API
//   - Flexible: Mix and match criteria and observers
//   - Safe: Sensible defaults, validated inputs
//   - Zero overhead: Only allocate what's used
//
// Usage example:
//   OptimizationConfig<double> config;
//   config.WithMaxIterations(5000)
//         .WithTolerance(1e-8)
//         .WithConsoleOutput(50)
//         .WithTrajectory(10);
//
//   SimulatedAnnealing<double> sa(config);
//   auto result = sa.Minimize(func, x0);
///////////////////////////////////////////////////////////////////////////////////////////

namespace MML
{

///////////////////////////////////////////////////////////////////////////////////////////
// OPTIMIZATION CONFIG - Fluent Builder
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Fluent builder for optimization configuration
/// @details Provides convenient API for configuring termination and observation
template <typename Real>
class OptimizationConfig
{
private:
    std::unique_ptr<ITerminationCriterion<Real>> _criterion;
    std::vector<std::shared_ptr<IOptimizationObserver<Real>>> _observers;
    
public:
    /// @brief Default constructor with sensible defaults
    /// @details Default: 1000 iterations OR 100 stagnation (whichever first)
    OptimizationConfig() {
        // Default criterion: maxIter OR stagnation
        _criterion = CreateDefaultCriterion<Real>(1000, 100);
    }
    
    /// @brief Copy constructor (deep copy of criterion, shared observers)
    OptimizationConfig(const OptimizationConfig&) = delete;  // Disable for now
    
    /// @brief Move constructor
    OptimizationConfig(OptimizationConfig&&) = default;
    
    /// @brief Assignment operators
    OptimizationConfig& operator=(const OptimizationConfig&) = delete;
    OptimizationConfig& operator=(OptimizationConfig&&) = default;
    
    //=================================================================================
    // TERMINATION CRITERIA CONFIGURATION
    //=================================================================================
    
    /// @brief Set maximum iterations (replaces current criterion)
    OptimizationConfig& WithMaxIterations(int maxIter) {
        _criterion = std::make_unique<MaxIterationsCriterion<Real>>(maxIter);
        return *this;
    }
    
    /// @brief Set function tolerance (replaces current criterion)
    OptimizationConfig& WithTolerance(Real ftol) {
        _criterion = std::make_unique<FunctionToleranceCriterion<Real>>(ftol);
        return *this;
    }
    
    /// @brief Set gradient norm tolerance (for gradient-based methods)
    OptimizationConfig& WithGradientTolerance(Real gtol) {
        _criterion = std::make_unique<GradientNormCriterion<Real>>(gtol);
        return *this;
    }
    
    /// @brief Set stagnation detection (replaces current criterion)
    OptimizationConfig& WithStagnation(int maxStagnation) {
        _criterion = std::make_unique<StagnationCriterion<Real>>(maxStagnation);
        return *this;
    }
    
    /// @brief Set time limit in seconds (replaces current criterion)
    OptimizationConfig& WithTimeLimit(double maxSeconds) {
        _criterion = std::make_unique<TimeLimitCriterion<Real>>(maxSeconds);
        return *this;
    }
    
    /// @brief Set time limit in minutes (convenience)
    OptimizationConfig& WithTimeLimitMinutes(double maxMinutes) {
        return WithTimeLimit(maxMinutes * 60.0);
    }
    
    /// @brief Set target value (replaces current criterion)
    OptimizationConfig& WithTargetValue(Real target, Real tolerance = Real(1e-6)) {
        _criterion = std::make_unique<TargetValueCriterion<Real>>(target, tolerance);
        return *this;
    }
    
    /// @brief Set custom termination criterion (replaces current)
    OptimizationConfig& WithCustomCriterion(
        std::unique_ptr<ITerminationCriterion<Real>> criterion) {
        if (!criterion) {
            throw std::invalid_argument("OptimizationConfig: Cannot set null criterion");
        }
        _criterion = std::move(criterion);
        return *this;
    }
    
    //=================================================================================
    // COMPOSITE CRITERIA (Advanced)
    //=================================================================================
    
    /// @brief Start building composite criterion with OR logic
    /// @details After calling this, use AndCriterion() or OrCriterion() to add more
    OptimizationConfig& WithAnyCriterion() {
        _criterion = std::make_unique<CompositeCriterion<Real>>(
            CompositeCriterion<Real>::Mode::ANY
        );
        return *this;
    }
    
    /// @brief Start building composite criterion with AND logic
    OptimizationConfig& WithAllCriteria() {
        _criterion = std::make_unique<CompositeCriterion<Real>>(
            CompositeCriterion<Real>::Mode::ALL
        );
        return *this;
    }
    
    /// @brief Add criterion to composite with OR logic (must call WithAnyCriterion first)
    template<typename CriterionType, typename... Args>
    OptimizationConfig& OrCriterion(Args&&... args) {
        auto* composite = dynamic_cast<CompositeCriterion<Real>*>(_criterion.get());
        if (!composite) {
            throw std::logic_error("OrCriterion requires composite criterion");
        }
        composite->template AddCriterion<CriterionType>(std::forward<Args>(args)...);
        return *this;
    }
    
    /// @brief Add criterion to composite with AND logic (must call WithAllCriteria first)
    template<typename CriterionType, typename... Args>
    OptimizationConfig& AndCriterion(Args&&... args) {
        auto* composite = dynamic_cast<CompositeCriterion<Real>*>(_criterion.get());
        if (!composite) {
            throw std::logic_error("AndCriterion requires composite criterion");
        }
        composite->template AddCriterion<CriterionType>(std::forward<Args>(args)...);
        return *this;
    }
    
    //=================================================================================
    // COMMON PATTERNS (Convenience)
    //=================================================================================
    
    /// @brief Standard pattern: maxIter OR stagnation
    OptimizationConfig& WithStandardTermination(int maxIter = 1000, 
                                                 int maxStagnation = 100) {
        _criterion = CreateDefaultCriterion<Real>(maxIter, maxStagnation);
        return *this;
    }
    
    /// @brief Precise pattern: (ftol AND gtol) OR maxIter
    OptimizationConfig& WithPreciseTermination(Real ftol = Real(1e-8),
                                                Real gtol = Real(1e-6),
                                                int maxIter = 10000) {
        _criterion = CreateToleranceCriterion<Real>(ftol, gtol, maxIter);
        return *this;
    }
    
    /// @brief Timed pattern: maxTime OR maxIter (safety net)
    OptimizationConfig& WithTimedTermination(double maxSeconds, 
                                             int maxIter = 100000) {
        auto composite = std::make_unique<CompositeCriterion<Real>>(
            CompositeCriterion<Real>::Mode::ANY
        );
        composite->template AddCriterion<TimeLimitCriterion<Real>>(maxSeconds);
        composite->template AddCriterion<MaxIterationsCriterion<Real>>(maxIter);
        _criterion = std::move(composite);
        return *this;
    }
    
    //=================================================================================
    // OBSERVER CONFIGURATION
    //=================================================================================
    
    /// @brief Add console output observer
    OptimizationConfig& WithConsoleOutput(int printEvery = 1, bool verbose = false) {
        _observers.push_back(
            std::make_shared<ConsoleObserver<Real>>(printEvery, verbose)
        );
        return *this;
    }
    
    /// @brief Add trajectory recording observer
    OptimizationConfig& WithTrajectory(int saveEvery = 1, size_t maxSize = 0) {
        _observers.push_back(
            std::make_shared<TrajectoryObserver<Real>>(saveEvery, maxSize)
        );
        return *this;
    }
    
    /// @brief Add custom observer
    OptimizationConfig& AddObserver(std::shared_ptr<IOptimizationObserver<Real>> observer) {
        if (!observer) {
            throw std::invalid_argument("OptimizationConfig: Cannot add null observer");
        }
        _observers.push_back(observer);
        return *this;
    }
    
    /// @brief Add observer by constructing in-place
    template<typename ObserverType, typename... Args>
    OptimizationConfig& AddObserver(Args&&... args) {
        _observers.push_back(
            std::make_shared<ObserverType>(std::forward<Args>(args)...)
        );
        return *this;
    }
    
    /// @brief Add callback observer with lambda
    OptimizationConfig& WithCallback(
        std::function<bool(const OptimizationState<Real>&)> onIteration) {
        auto callback = std::make_shared<CallbackObserver<Real>>();
        callback->SetOnIteration(onIteration);
        _observers.push_back(callback);
        return *this;
    }
    
    /// @brief Add full callback observer (start, iteration, complete)
    OptimizationConfig& WithCallbacks(
        std::function<void(const OptimizationState<Real>&)> onStart,
        std::function<bool(const OptimizationState<Real>&)> onIteration,
        std::function<void(const OptimizationState<Real>&, const std::string&)> onComplete) {
        auto callback = std::make_shared<CallbackObserver<Real>>();
        callback->SetOnStart(onStart);
        callback->SetOnIteration(onIteration);
        callback->SetOnComplete(onComplete);
        _observers.push_back(callback);
        return *this;
    }
    
    //=================================================================================
    // ACCESSORS (for optimizers)
    //=================================================================================
    
    /// @brief Get termination criterion (const)
    const ITerminationCriterion<Real>* GetCriterion() const {
        return _criterion.get();
    }
    
    /// @brief Get termination criterion (mutable, for reset)
    ITerminationCriterion<Real>* GetCriterion() {
        return _criterion.get();
    }
    
    /// @brief Get observers (const)
    const std::vector<std::shared_ptr<IOptimizationObserver<Real>>>& 
    GetObservers() const {
        return _observers;
    }
    
    /// @brief Get observers (mutable)
    std::vector<std::shared_ptr<IOptimizationObserver<Real>>>& 
    GetObservers() {
        return _observers;
    }
    
    /// @brief Check if any observers configured
    bool HasObservers() const {
        return !_observers.empty();
    }
    
    /// @brief Get specific observer by type (returns first match)
    template<typename ObserverType>
    std::shared_ptr<ObserverType> GetObserver() const {
        for (const auto& obs : _observers) {
            auto typed = std::dynamic_pointer_cast<ObserverType>(obs);
            if (typed) return typed;
        }
        return nullptr;
    }
    
    /// @brief Get trajectory observer (convenience for accessing trajectory)
    std::shared_ptr<TrajectoryObserver<Real>> GetTrajectoryObserver() const {
        return GetObserver<TrajectoryObserver<Real>>();
    }
    
    //=================================================================================
    // UTILITY
    //=================================================================================
    
    /// @brief Clear all observers
    OptimizationConfig& ClearObservers() {
        _observers.clear();
        return *this;
    }
    
    /// @brief Reset criterion and observers for new optimization run
    void Reset() {
        if (_criterion) {
            _criterion->Reset();
        }
        // Observers are reset by optimizer calling OnStart
    }
    
    /// @brief Create a copy with new instances (deep copy)
    OptimizationConfig Clone() const {
        // Note: This is tricky with unique_ptr criterion
        // For now, throw if cloning needed - users should build new config
        throw std::logic_error("OptimizationConfig cloning not yet implemented");
    }
};

///////////////////////////////////////////////////////////////////////////////////////////
// PRESET CONFIGS (Factory Functions)
///////////////////////////////////////////////////////////////////////////////////////////

/// @brief Create quick config for fast prototyping
template <typename Real>
OptimizationConfig<Real> QuickConfig(int maxIter = 100) {
    OptimizationConfig<Real> config;
    config.WithMaxIterations(maxIter)
          .WithConsoleOutput(10);
    return config;
}

/// @brief Create production config (precise, monitored)
template <typename Real>
OptimizationConfig<Real> ProductionConfig(Real ftol = Real(1e-8),
                                          Real gtol = Real(1e-6)) {
    OptimizationConfig<Real> config;
    config.WithPreciseTermination(ftol, gtol, 10000)
          .WithConsoleOutput(100, true)
          .WithTrajectory(50);
    return config;
}

/// @brief Create debug config (verbose output, full trajectory)
template <typename Real>
OptimizationConfig<Real> DebugConfig(int maxIter = 1000) {
    OptimizationConfig<Real> config;
    config.WithMaxIterations(maxIter)
          .WithConsoleOutput(1, true)   // Every iteration, verbose
          .WithTrajectory(1);            // Full trajectory
    return config;
}

/// @brief Create benchmark config (timed, minimal output)
template <typename Real>
OptimizationConfig<Real> BenchmarkConfig(double maxSeconds) {
    OptimizationConfig<Real> config;
    config.WithTimeLimit(maxSeconds);
    // No observers for minimal overhead
    return config;
}

} // namespace MML


///////////////////////////   mml/algorithms/Optimization/OptimizationMultidim.h   ///////////////////////////




namespace MML
{
    /////////////////////////////////////////////////////////////////////
    ///                 MULTIDIMENSIONAL OPTIMIZATION                 ///
    /////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///                     MultidimOptimizationError                       ///
    ///////////////////////////////////////////////////////////////////////////
    class MultidimOptimizationError : public std::runtime_error
    {
    public:
        explicit MultidimOptimizationError(const std::string& message)
            : std::runtime_error("MultidimOptimizationError: " + message) {}
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                  MultidimMinimizationResult                        ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Result structure for multidimensional minimization
     */
    struct MultidimMinimizationResult
    {
        Vector<Real> xmin;      ///< Location of minimum
        Real         fmin;       ///< Function value at minimum
        int          iterations; ///< Number of iterations (or function evaluations)
        bool         converged;  ///< True if converged within tolerance

        MultidimMinimizationResult()
            : fmin(0.0), iterations(0), converged(false) {}

        MultidimMinimizationResult(const Vector<Real>& x, Real f, int iter, bool conv)
            : xmin(x), fmin(f), iterations(iter), converged(conv) {}
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                 Simplex (Nelder-Mead) Minimization                 ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Downhill simplex (Nelder-Mead) method for multidimensional minimization
     * 
     * The Nelder-Mead simplex method is a direct search method that does not require 
     * derivatives. It works by maintaining a simplex (a geometric figure with N+1 vertices 
     * in N dimensions) and iteratively replacing the worst vertex.
     * 
     * Reference: Numerical Recipes Chapter 10.5, Nelder & Mead (1965)
     * 
     * The algorithm uses four basic operations:
     * - Reflection: Reflect the worst point through the centroid
     * - Expansion: If reflection is good, try going further
     * - Contraction: If reflection is bad, try a point between worst and centroid
     * - Shrink: If all else fails, shrink the simplex toward the best point
     * 
     * Standard coefficients:
     * - alpha = 1.0 (reflection coefficient)
     * - gamma = 2.0 (expansion coefficient)
     * - rho = 0.5 (contraction coefficient)  
     * - sigma = 0.5 (shrink coefficient)
     */
    class NelderMead
    {
    public:
        // Simplex coefficients
        static constexpr Real ALPHA = 1.0;   // Reflection coefficient
        static constexpr Real GAMMA = 2.0;   // Expansion coefficient
        static constexpr Real RHO   = 0.5;   // Contraction coefficient
        static constexpr Real SIGMA = 0.5;   // Shrink coefficient

    private:
        Real _ftol;         // Fractional tolerance for convergence
        int  _maxIter;      // Maximum iterations
        int  _nfunc;        // Number of function evaluations
        int  _ndim;         // Problem dimension
        int  _mpts;         // Number of simplex points (ndim + 1)

        Matrix<Real> _p;    // Simplex vertices [mpts x ndim]
        Vector<Real> _y;    // Function values at vertices [mpts]

    public:
        /**
         * @brief Construct Nelder-Mead optimizer
         * @param ftol Fractional convergence tolerance (default 1e-8)
         * @param maxIter Maximum iterations (default 5000)
         */
        NelderMead(Real ftol = 1.0e-8, int maxIter = 5000)
            : _ftol(ftol), _maxIter(maxIter), _nfunc(0), _ndim(0), _mpts(0) {}

        Real getFtol() const { return _ftol; }
        void setFtol(Real ftol) { _ftol = ftol; }

        int getMaxIter() const { return _maxIter; }
        void setMaxIter(int maxIter) { _maxIter = maxIter; }

        int getNumFuncEvals() const { return _nfunc; }

        /**
         * @brief Get the final simplex (for analysis/debugging)
         */
        const Matrix<Real>& getSimplex() const { return _p; }

        /**
         * @brief Get function values at simplex vertices
         */
        const Vector<Real>& getSimplexValues() const { return _y; }

        ///////////////////////////////////////////////////////////////////////////
        ///                      Minimize with uniform delta                    ///
        ///////////////////////////////////////////////////////////////////////////
        /**
         * @brief Minimize using a starting point with uniform perturbation
         * @tparam N Dimension of the problem
         * @param func Scalar function to minimize
         * @param start Starting point
         * @param delta Uniform perturbation for creating initial simplex (default 1.0)
         * @return Minimization result
         * 
         * Creates initial simplex by adding delta to each coordinate of start
         */
        template<int N>
        MultidimMinimizationResult Minimize(const IScalarFunction<N>& func,
                                            const VectorN<Real, N>& start,
                                            Real delta = 1.0)
        {
            Vector<Real> deltas(N, delta);
            return Minimize(func, start, deltas);
        }

        ///////////////////////////////////////////////////////////////////////////
        ///                    Minimize with per-dimension deltas               ///
        ///////////////////////////////////////////////////////////////////////////
        /**
         * @brief Minimize using a starting point with per-dimension perturbations
         * @tparam N Dimension of the problem
         * @param func Scalar function to minimize
         * @param start Starting point
         * @param deltas Per-dimension perturbations for initial simplex
         * @return Minimization result
         * 
         * Creates initial simplex by adding deltas[i] to coordinate i of start
         */
        template<int N>
        MultidimMinimizationResult Minimize(const IScalarFunction<N>& func,
                                            const VectorN<Real, N>& start,
                                            const Vector<Real>& deltas)
        {
            if (deltas.size() != N)
                throw MultidimOptimizationError("Deltas vector dimension mismatch");

            // Create initial simplex: N+1 vertices
            _ndim = N;
            _mpts = N + 1;
            _p = Matrix<Real>(_mpts, _ndim);
            _y = Vector<Real>(_mpts);

            // First vertex is the starting point
            for (int j = 0; j < _ndim; ++j)
                _p(0, j) = start[j];

            // Other vertices: perturb one coordinate at a time
            for (int i = 1; i <= _ndim; ++i)
            {
                for (int j = 0; j < _ndim; ++j)
                    _p(i, j) = start[j];
                _p(i, i - 1) += deltas[i - 1];
            }

            return MinimizeFromSimplex(func);
        }

        ///////////////////////////////////////////////////////////////////////////
        ///                    Minimize from explicit simplex                   ///
        ///////////////////////////////////////////////////////////////////////////
        /**
         * @brief Minimize from an explicitly specified initial simplex
         * @tparam N Dimension of the problem
         * @param func Scalar function to minimize
         * @param simplex Initial simplex as (N+1) x N matrix (rows are vertices)
         * @return Minimization result
         */
        template<int N>
        MultidimMinimizationResult Minimize(const IScalarFunction<N>& func,
                                            const Matrix<Real>& simplex)
        {
            if (simplex.RowNum() != N + 1 || simplex.ColNum() != N)
                throw MultidimOptimizationError("Simplex dimensions invalid: expected " +
                    std::to_string(N + 1) + " x " + std::to_string(N));

            _ndim = N;
            _mpts = N + 1;
            _p = simplex;
            _y = Vector<Real>(_mpts);

            return MinimizeFromSimplex(func);
        }

    private:
        ///////////////////////////////////////////////////////////////////////////
        ///                   Core Nelder-Mead Algorithm                        ///
        ///////////////////////////////////////////////////////////////////////////
        template<int N>
        MultidimMinimizationResult MinimizeFromSimplex(const IScalarFunction<N>& func)
        {
            const Real TINY = 1.0e-10;
            int ihi, ilo, inhi;
            VectorN<Real, N> x;
            Vector<Real> psum(_ndim);

            // Evaluate function at all simplex vertices
            for (int i = 0; i < _mpts; ++i)
            {
                for (int j = 0; j < _ndim; ++j)
                    x[j] = _p(i, j);
                _y[i] = func(x);
            }
            _nfunc = _mpts;

            // Compute initial psum (sum of vertex coordinates)
            GetPsum(psum);

            // Main iteration loop
            for (int iter = 0; iter < _maxIter; ++iter)
            {
                // Find lowest (best), highest (worst), and next-highest
                ilo = 0;
                if (_y[0] > _y[1])
                {
                    ihi = 0;
                    inhi = 1;
                }
                else
                {
                    ihi = 1;
                    inhi = 0;
                }

                for (int i = 0; i < _mpts; ++i)
                {
                    if (_y[i] <= _y[ilo]) ilo = i;
                    if (_y[i] > _y[ihi])
                    {
                        inhi = ihi;
                        ihi = i;
                    }
                    else if (_y[i] > _y[inhi] && i != ihi)
                    {
                        inhi = i;
                    }
                }

                // Check convergence
                Real rtol = 2.0 * std::abs(_y[ihi] - _y[ilo]) /
                            (std::abs(_y[ihi]) + std::abs(_y[ilo]) + TINY);

                if (rtol < _ftol)
                {
                    // Converged - swap best to position 0
                    std::swap(_y[0], _y[ilo]);
                    for (int j = 0; j < _ndim; ++j)
                    {
                        std::swap(_p(0, j), _p(ilo, j));
                        x[j] = _p(0, j);
                    }

                    Vector<Real> result(_ndim);
                    for (int j = 0; j < _ndim; ++j)
                        result[j] = x[j];

                    return MultidimMinimizationResult(result, _y[0], _nfunc, true);
                }

                // Check iteration limit
                if (_nfunc >= _maxIter)
                {
                    Vector<Real> result(_ndim);
                    for (int j = 0; j < _ndim; ++j)
                        result[j] = _p(ilo, j);
                    return MultidimMinimizationResult(result, _y[ilo], _nfunc, false);
                }

                // Try reflection
                Real ytry = Amotry<N>(psum, ihi, -ALPHA, func);
                _nfunc++;

                if (ytry <= _y[ilo])
                {
                    // Reflection is better than best - try expansion
                    ytry = Amotry<N>(psum, ihi, GAMMA, func);
                    _nfunc++;
                }
                else if (ytry >= _y[inhi])
                {
                    // Reflection is worse than second-worst
                    Real ysave = _y[ihi];
                    ytry = Amotry<N>(psum, ihi, RHO, func);
                    _nfunc++;

                    if (ytry >= ysave)
                    {
                        // Contraction failed - do shrink
                        for (int i = 0; i < _mpts; ++i)
                        {
                            if (i != ilo)
                            {
                                for (int j = 0; j < _ndim; ++j)
                                {
                                    _p(i, j) = SIGMA * (_p(i, j) + _p(ilo, j));
                                    x[j] = _p(i, j);
                                }
                                _y[i] = func(x);
                            }
                        }
                        _nfunc += _ndim;
                        GetPsum(psum);
                    }
                }
            }

            // Max iterations reached without convergence
            int ilo_final = 0;
            for (int i = 1; i < _mpts; ++i)
                if (_y[i] < _y[ilo_final]) ilo_final = i;

            Vector<Real> result(_ndim);
            for (int j = 0; j < _ndim; ++j)
                result[j] = _p(ilo_final, j);

            return MultidimMinimizationResult(result, _y[ilo_final], _nfunc, false);
        }

        ///////////////////////////////////////////////////////////////////////////
        ///                           Helper Functions                          ///
        ///////////////////////////////////////////////////////////////////////////
        
        /**
         * @brief Compute sum of vertex coordinates (for centroid calculation)
         */
        void GetPsum(Vector<Real>& psum)
        {
            for (int j = 0; j < _ndim; ++j)
            {
                Real sum = 0.0;
                for (int i = 0; i < _mpts; ++i)
                    sum += _p(i, j);
                psum[j] = sum;
            }
        }

        /**
         * @brief Extrapolate by a factor through the face opposite the high point
         * @tparam N Problem dimension
         * @param psum Sum of vertex coordinates
         * @param ihi Index of highest (worst) point
         * @param fac Extrapolation factor
         * @param func Function to evaluate
         * @return Function value at trial point
         * 
         * This implements the core simplex transformation. The trial point is:
         * ptry = psum * (1-fac)/ndim - p[ihi] * ((1-fac)/ndim - fac)
         *      = centroid_of_face - fac * (centroid_of_face - p[ihi])
         * 
         * For fac = -1: reflection through centroid
         * For fac = 2: expansion beyond reflection point
         * For fac = 0.5: contraction toward centroid
         */
        template<int N>
        Real Amotry(Vector<Real>& psum, int ihi, Real fac, const IScalarFunction<N>& func)
        {
            VectorN<Real, N> ptry;
            Real fac1 = (1.0 - fac) / _ndim;
            Real fac2 = fac1 - fac;

            for (int j = 0; j < _ndim; ++j)
                ptry[j] = psum[j] * fac1 - _p(ihi, j) * fac2;

            Real ytry = func(ptry);

            if (ytry < _y[ihi])
            {
                // Accept the new point
                _y[ihi] = ytry;
                for (int j = 0; j < _ndim; ++j)
                {
                    psum[j] += ptry[j] - _p(ihi, j);
                    _p(ihi, j) = ptry[j];
                }
            }
            return ytry;
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                   Convenience Wrapper Functions                     ///
    ///////////////////////////////////////////////////////////////////////////

    /**
     * @brief Minimize a scalar function using Nelder-Mead
     * @tparam N Dimension of the problem
     * @param func Function to minimize
     * @param start Starting point
     * @param delta Initial simplex size (default 1.0)
     * @param ftol Convergence tolerance (default 1e-8)
     * @return Minimization result
     */
    template<int N>
    MultidimMinimizationResult NelderMeadMinimize(
        const IScalarFunction<N>& func,
        const VectorN<Real, N>& start,
        Real delta = 1.0,
        Real ftol = 1.0e-8)
    {
        NelderMead optimizer(ftol);
        return optimizer.Minimize(func, start, delta);
    }

    /**
     * @brief Minimize a scalar function using Nelder-Mead with custom deltas
     * @tparam N Dimension of the problem
     * @param func Function to minimize
     * @param start Starting point
     * @param deltas Per-dimension simplex sizes
     * @param ftol Convergence tolerance (default 1e-8)
     * @return Minimization result
     */
    template<int N>
    MultidimMinimizationResult NelderMeadMinimize(
        const IScalarFunction<N>& func,
        const VectorN<Real, N>& start,
        const Vector<Real>& deltas,
        Real ftol = 1.0e-8)
    {
        NelderMead optimizer(ftol);
        return optimizer.Minimize(func, start, deltas);
    }

    ///////////////////////////////////////////////////////////////////////////
    ///                     Maximization Wrapper                            ///
    ///////////////////////////////////////////////////////////////////////////

    /**
     * @brief Helper class to negate a function for maximization
     */
    template<int N>
    class NegatedScalarFunction : public IScalarFunction<N>
    {
    private:
        const IScalarFunction<N>& _func;

    public:
        explicit NegatedScalarFunction(const IScalarFunction<N>& func) : _func(func) {}

        Real operator()(const VectorN<Real, N>& x) const override
        {
            return -_func(x);
        }
    };

    /**
     * @brief Maximize a scalar function using Nelder-Mead
     * @tparam N Dimension of the problem
     * @param func Function to maximize
     * @param start Starting point
     * @param delta Initial simplex size (default 1.0)
     * @param ftol Convergence tolerance (default 1e-8)
     * @return Maximization result (fmin is negated to give actual maximum value)
     */
    template<int N>
    MultidimMinimizationResult NelderMeadMaximize(
        const IScalarFunction<N>& func,
        const VectorN<Real, N>& start,
        Real delta = 1.0,
        Real ftol = 1.0e-8)
    {
        NegatedScalarFunction<N> negFunc(func);
        NelderMead optimizer(ftol);
        auto result = optimizer.Minimize(negFunc, start, delta);
        result.fmin = -result.fmin;  // Convert back to maximum value
        return result;
    }

    /////////////////////////////////////////////////////////////////////
    ///                     LINE SEARCH METHODS                       ///
    /////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///            Interface for differentiable scalar functions            ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Interface for N-dimensional scalar function with gradient
     * 
     * Functions that provide gradient information can use more efficient
     * optimization methods like conjugate gradient or BFGS.
     */
    template<int N>
    class IDifferentiableScalarFunction : public IScalarFunction<N>
    {
    public:
        /**
         * @brief Compute the gradient at point x
         * @param x Point at which to evaluate gradient
         * @param grad Output gradient vector (filled by this method)
         */
        virtual void Gradient(const VectorN<Real, N>& x, VectorN<Real, N>& grad) const = 0;

        virtual ~IDifferentiableScalarFunction() = default;
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                    1D function along a line                         ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Wrapper to convert N-dim function to 1D function along a line
     * 
     * Given f(x) in N dimensions, creates g(t) = f(p + t*xi) for line search.
     * This is used by all line-search based optimizers.
     */
    template<int N>
    class LineFunction : public IRealFunction
    {
    private:
        const IScalarFunction<N>& _func;
        const VectorN<Real, N>& _p;       // Base point
        const VectorN<Real, N>& _xi;      // Direction

    public:
        LineFunction(const IScalarFunction<N>& func,
                     const VectorN<Real, N>& p,
                     const VectorN<Real, N>& xi)
            : _func(func), _p(p), _xi(xi) {}

        Real operator()(Real t) const override
        {
            VectorN<Real, N> xt;
            for (int j = 0; j < N; ++j)
                xt[j] = _p[j] + t * _xi[j];
            return _func(xt);
        }
    };

    /**
     * @brief 1D function with derivative along a line (for gradient-based methods)
     */
    template<int N>
    class DLineFunction : public IRealFunction
    {
    private:
        const IDifferentiableScalarFunction<N>& _func;
        VectorN<Real, N> _p;       // Base point (mutable for evaluation)
        VectorN<Real, N> _xi;      // Direction
        mutable VectorN<Real, N> _xt;      // Current point
        mutable VectorN<Real, N> _grad;    // Gradient at current point

    public:
        DLineFunction(const IDifferentiableScalarFunction<N>& func,
                      const VectorN<Real, N>& p,
                      const VectorN<Real, N>& xi)
            : _func(func), _p(p), _xi(xi) {}

        void updateBasePoint(const VectorN<Real, N>& p) { _p = p; }
        void updateDirection(const VectorN<Real, N>& xi) { _xi = xi; }

        Real operator()(Real t) const override
        {
            for (int j = 0; j < N; ++j)
                _xt[j] = _p[j] + t * _xi[j];
            return _func(_xt);
        }

        /**
         * @brief Compute directional derivative df/dt = grad(f) Â· xi
         */
        Real derivative(Real t) const
        {
            for (int j = 0; j < N; ++j)
                _xt[j] = _p[j] + t * _xi[j];
            _func.Gradient(_xt, _grad);

            Real df = 0.0;
            for (int j = 0; j < N; ++j)
                df += _grad[j] * _xi[j];
            return df;
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                      Line Minimization                              ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Line minimization helper for N-dimensional optimization
     * 
     * Given a point p and direction xi, finds the minimum along the line
     * p + t*xi using Brent's method, then updates p and xi.
     */
    class LineMinimizer
    {
    public:
        /**
         * @brief Minimize function along line p + t*xi
         * @tparam N Problem dimension
         * @param func Function to minimize
         * @param p Current point (updated to minimum along line)
         * @param xi Search direction (updated to displacement vector)
         * @return Function value at minimum
         */
        template<int N>
        static Real Minimize(const IScalarFunction<N>& func,
                             VectorN<Real, N>& p,
                             VectorN<Real, N>& xi,
                             Real tol = 3.0e-8)
        {
            LineFunction<N> f1dim(func, p, xi);

            // Bracket the minimum
            auto bracket = Minimization::BracketMinimum(f1dim, 0.0, 1.0);
            if (!bracket.valid)
            {
                // Try with different initial interval
                bracket = Minimization::BracketMinimum(f1dim, 0.0, 0.1);
            }

            // Find minimum using Brent's method
            auto result = Minimization::BrentMinimize(f1dim, bracket, tol);
            Real xmin = result.xmin;

            // Update p and xi
            for (int j = 0; j < N; ++j)
            {
                xi[j] *= xmin;
                p[j] += xi[j];
            }

            return result.fmin;
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                      Powell's Method                                ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Powell's direction set method for multidimensional minimization
     * 
     * Powell's method is a derivative-free optimization method that performs
     * successive line minimizations along a set of directions that are updated
     * to become mutually conjugate.
     * 
     * Reference: Numerical Recipes Chapter 10.7
     * 
     * The algorithm:
     * 1. Start with N unit vectors as search directions
     * 2. Minimize along each direction in sequence
     * 3. Construct new direction from total displacement
     * 4. Replace direction with largest decrease with new direction
     * 5. Repeat until convergence
     * 
     * This method is particularly effective when:
     * - Derivatives are not available
     * - Function is smooth and well-behaved
     * - Problem dimension is moderate (N < 20)
     */
    class Powell
    {
    private:
        Real _ftol;         // Fractional tolerance
        int  _maxIter;      // Maximum iterations
        int  _iter;         // Iteration counter
        Real _fret;         // Current function value

    public:
        Powell(Real ftol = 3.0e-8, int maxIter = 200)
            : _ftol(ftol), _maxIter(maxIter), _iter(0), _fret(0.0) {}

        Real getFtol() const { return _ftol; }
        void setFtol(Real ftol) { _ftol = ftol; }

        int getMaxIter() const { return _maxIter; }
        void setMaxIter(int maxIter) { _maxIter = maxIter; }

        int getIterations() const { return _iter; }
        Real getCurrentFValue() const { return _fret; }

        /**
         * @brief Minimize using starting point with identity direction matrix
         */
        template<int N>
        MultidimMinimizationResult Minimize(const IScalarFunction<N>& func,
                                            const VectorN<Real, N>& start)
        {
            // Initialize direction matrix to identity
            Matrix<Real> ximat(N, N, 0.0);
            for (int i = 0; i < N; ++i)
                ximat(i, i) = 1.0;

            return Minimize(func, start, ximat);
        }

        /**
         * @brief Minimize with custom initial direction matrix
         */
        template<int N>
        MultidimMinimizationResult Minimize(const IScalarFunction<N>& func,
                                            const VectorN<Real, N>& start,
                                            Matrix<Real>& ximat)
        {
            const Real TINY = 1.0e-25;

            VectorN<Real, N> p = start;
            VectorN<Real, N> pt, ptt, xi;

            _fret = func(p);

            // Save initial point
            for (int j = 0; j < N; ++j)
                pt[j] = p[j];

            for (_iter = 0; _iter < _maxIter; ++_iter)
            {
                Real fp = _fret;
                int ibig = 0;
                Real del = 0.0;

                // Minimize along each direction
                for (int i = 0; i < N; ++i)
                {
                    // Extract i-th direction from matrix columns
                    for (int j = 0; j < N; ++j)
                        xi[j] = ximat(j, i);

                    Real fptt = _fret;
                    _fret = LineMinimizer::Minimize(func, p, xi, _ftol);

                    // Track direction with largest decrease
                    if (fptt - _fret > del)
                    {
                        del = fptt - _fret;
                        ibig = i + 1;
                    }
                }

                // Check convergence
                if (2.0 * (fp - _fret) <= _ftol * (std::abs(fp) + std::abs(_fret)) + TINY)
                {
                    Vector<Real> result(N);
                    for (int j = 0; j < N; ++j)
                        result[j] = p[j];
                    return MultidimMinimizationResult(result, _fret, _iter + 1, true);
                }

                // Construct extrapolated point and new direction
                for (int j = 0; j < N; ++j)
                {
                    ptt[j] = 2.0 * p[j] - pt[j];  // Extrapolated point
                    xi[j] = p[j] - pt[j];          // New direction
                    pt[j] = p[j];                  // Save current point
                }

                Real fptt = func(ptt);

                if (fptt < fp)
                {
                    Real t = 2.0 * (fp - 2.0 * _fret + fptt) *
                             (fp - _fret - del) * (fp - _fret - del) -
                             del * (fp - fptt) * (fp - fptt);

                    if (t < 0.0)
                    {
                        // Replace direction ibig with new direction
                        _fret = LineMinimizer::Minimize(func, p, xi, _ftol);

                        for (int j = 0; j < N; ++j)
                        {
                            ximat(j, ibig - 1) = ximat(j, N - 1);
                            ximat(j, N - 1) = xi[j];
                        }
                    }
                }
            }

            // Max iterations reached
            Vector<Real> result(N);
            for (int j = 0; j < N; ++j)
                result[j] = p[j];
            return MultidimMinimizationResult(result, _fret, _iter, false);
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///            Conjugate Gradient Method (Fletcher-Reeves-Polak-Ribiere)///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Conjugate gradient method for minimization with derivatives
     * 
     * The conjugate gradient method is one of the most effective methods for
     * minimizing smooth functions when gradients are available. It generates
     * search directions that are conjugate with respect to the Hessian.
     * 
     * Reference: Numerical Recipes Chapter 10.8
     * 
     * Two variants are implemented:
     * - Fletcher-Reeves: gamma = (g_new Â· g_new) / (g_old Â· g_old)
     * - Polak-Ribiere:   gamma = (g_new Â· (g_new - g_old)) / (g_old Â· g_old)
     * 
     * Polak-Ribiere is generally preferred as it automatically resets to
     * steepest descent when progress stalls.
     * 
     * The algorithm:
     * 1. Compute gradient at starting point
     * 2. Set initial search direction to negative gradient (steepest descent)
     * 3. Minimize along search direction
     * 4. Compute new gradient
     * 5. Update search direction using conjugate gradient formula
     * 6. Repeat until convergence
     */
    class ConjugateGradient
    {
    public:
        enum class Method
        {
            FletcherReeves,  // Original CG formula
            PolakRibiere     // Generally preferred variant
        };

    private:
        Real   _ftol;       // Function tolerance
        Real   _gtol;       // Gradient tolerance
        int    _maxIter;    // Maximum iterations
        int    _iter;       // Iteration counter
        Real   _fret;       // Current function value
        Method _method;     // CG variant

    public:
        ConjugateGradient(Real ftol = 3.0e-8, Real gtol = 1.0e-8, 
                          int maxIter = 200, Method method = Method::PolakRibiere)
            : _ftol(ftol), _gtol(gtol), _maxIter(maxIter), 
              _iter(0), _fret(0.0), _method(method) {}

        Real getFtol() const { return _ftol; }
        void setFtol(Real ftol) { _ftol = ftol; }

        Real getGtol() const { return _gtol; }
        void setGtol(Real gtol) { _gtol = gtol; }

        int getMaxIter() const { return _maxIter; }
        void setMaxIter(int maxIter) { _maxIter = maxIter; }

        Method getMethod() const { return _method; }
        void setMethod(Method method) { _method = method; }

        int getIterations() const { return _iter; }
        Real getCurrentFValue() const { return _fret; }

        /**
         * @brief Minimize a differentiable function using conjugate gradient
         */
        template<int N>
        MultidimMinimizationResult Minimize(const IDifferentiableScalarFunction<N>& func,
                                            const VectorN<Real, N>& start)
        {
            const Real EPS = 1.0e-18;

            VectorN<Real, N> p = start;
            VectorN<Real, N> g, h, xi;

            // Evaluate function and gradient at starting point
            Real fp = func(p);
            func.Gradient(p, xi);

            // Initialize: g = -gradient, h = xi = g (steepest descent)
            for (int j = 0; j < N; ++j)
            {
                g[j] = -xi[j];
                xi[j] = h[j] = g[j];
            }

            for (_iter = 0; _iter < _maxIter; ++_iter)
            {
                // Line minimization along xi
                _fret = LineMinimizer::Minimize(func, p, xi, _ftol);

                // Check function convergence
                if (2.0 * std::abs(_fret - fp) <= _ftol * (std::abs(_fret) + std::abs(fp) + EPS))
                {
                    Vector<Real> result(N);
                    for (int j = 0; j < N; ++j)
                        result[j] = p[j];
                    return MultidimMinimizationResult(result, _fret, _iter + 1, true);
                }

                fp = _fret;

                // Compute new gradient
                func.Gradient(p, xi);

                // Check gradient convergence
                Real test = 0.0;
                Real den = std::max(std::abs(fp), REAL(1.0));
                for (int j = 0; j < N; ++j)
                {
                    Real temp = std::abs(xi[j]) * std::max(std::abs(p[j]), REAL(1.0)) / den;
                    if (temp > test) test = temp;
                }
                if (test < _gtol)
                {
                    Vector<Real> result(N);
                    for (int j = 0; j < N; ++j)
                        result[j] = p[j];
                    return MultidimMinimizationResult(result, _fret, _iter + 1, true);
                }

                // Compute gamma (CG update coefficient)
                Real gg = 0.0, dgg = 0.0;
                for (int j = 0; j < N; ++j)
                {
                    gg += g[j] * g[j];

                    if (_method == Method::FletcherReeves)
                    {
                        dgg += xi[j] * xi[j];  // Fletcher-Reeves
                    }
                    else
                    {
                        dgg += (xi[j] + g[j]) * xi[j];  // Polak-Ribiere
                    }
                }

                if (gg == 0.0)
                {
                    // Gradient is zero - we're done
                    Vector<Real> result(N);
                    for (int j = 0; j < N; ++j)
                        result[j] = p[j];
                    return MultidimMinimizationResult(result, _fret, _iter + 1, true);
                }

                Real gam = dgg / gg;

                // Update search direction
                for (int j = 0; j < N; ++j)
                {
                    g[j] = -xi[j];
                    xi[j] = h[j] = g[j] + gam * h[j];
                }
            }

            // Max iterations reached
            Vector<Real> result(N);
            for (int j = 0; j < N; ++j)
                result[j] = p[j];
            return MultidimMinimizationResult(result, _fret, _iter, false);
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///               BFGS Quasi-Newton Method                              ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief BFGS (Broyden-Fletcher-Goldfarb-Shanno) quasi-Newton method
     * 
     * BFGS is one of the most effective methods for smooth unconstrained
     * optimization. It builds an approximation to the inverse Hessian matrix
     * using only gradient information.
     * 
     * The algorithm:
     * 1. Start with identity approximation to inverse Hessian
     * 2. Compute search direction p = -H * gradient
     * 3. Line search to find step size
     * 4. Update inverse Hessian approximation using BFGS formula
     * 5. Repeat until convergence
     * 
     * Advantages:
     * - Superlinear convergence rate
     * - Only requires gradient (not Hessian)
     * - Self-correcting: recovers from poor initial H estimate
     * 
     * Disadvantages:
     * - O(NÂ²) storage for inverse Hessian approximation
     * - May be expensive for very large N
     */
    class BFGS
    {
    private:
        Real _ftol;         // Function tolerance
        Real _gtol;         // Gradient tolerance
        int  _maxIter;      // Maximum iterations
        int  _iter;         // Iteration counter
        Real _fret;         // Current function value

    public:
        BFGS(Real ftol = 3.0e-8, Real gtol = 1.0e-8, int maxIter = 200)
            : _ftol(ftol), _gtol(gtol), _maxIter(maxIter), _iter(0), _fret(0.0) {}

        Real getFtol() const { return _ftol; }
        void setFtol(Real ftol) { _ftol = ftol; }

        Real getGtol() const { return _gtol; }
        void setGtol(Real gtol) { _gtol = gtol; }

        int getMaxIter() const { return _maxIter; }
        void setMaxIter(int maxIter) { _maxIter = maxIter; }

        int getIterations() const { return _iter; }
        Real getCurrentFValue() const { return _fret; }

        /**
         * @brief Minimize using BFGS quasi-Newton method
         */
        template<int N>
        MultidimMinimizationResult Minimize(const IDifferentiableScalarFunction<N>& func,
                                            const VectorN<Real, N>& start)
        {
            const Real EPS = 1.0e-18;
            const Real STPMX = 100.0;  // Maximum step size

            VectorN<Real, N> p = start;
            VectorN<Real, N> g, dg, hdg, pnew, xi;
            Matrix<Real> hessin(N, N, 0.0);

            // Initialize inverse Hessian to identity
            for (int i = 0; i < N; ++i)
                hessin(i, i) = 1.0;

            // Evaluate function and gradient
            _fret = func(p);
            func.Gradient(p, g);

            // Initial search direction is steepest descent
            for (int j = 0; j < N; ++j)
                xi[j] = -g[j];

            // Compute maximum step size
            Real sum = 0.0;
            for (int j = 0; j < N; ++j)
                sum += p[j] * p[j];
            Real stpmax = STPMX * std::max(std::sqrt(sum), static_cast<Real>(N));

            for (_iter = 0; _iter < _maxIter; ++_iter)
            {
                // Line search along xi
                Real fp = _fret;
                VectorN<Real, N> pold = p;

                // Perform line minimization
                _fret = LineSearchBacktrack(func, p, g, xi, stpmax);

                // Check for convergence on function value
                if (2.0 * std::abs(_fret - fp) <= _ftol * (std::abs(_fret) + std::abs(fp) + EPS))
                {
                    Vector<Real> result(N);
                    for (int j = 0; j < N; ++j)
                        result[j] = p[j];
                    return MultidimMinimizationResult(result, _fret, _iter + 1, true);
                }

                // Update xi to be the actual step taken
                for (int j = 0; j < N; ++j)
                    xi[j] = p[j] - pold[j];

                // Save old gradient and compute new gradient
                for (int j = 0; j < N; ++j)
                    dg[j] = g[j];
                func.Gradient(p, g);

                // Check gradient convergence
                Real test = 0.0;
                Real den = std::max(std::abs(_fret), REAL(1.0));
                for (int j = 0; j < N; ++j)
                {
                    Real temp = std::abs(g[j]) * std::max(std::abs(p[j]), REAL(1.0)) / den;
                    if (temp > test) test = temp;
                }
                if (test < _gtol)
                {
                    Vector<Real> result(N);
                    for (int j = 0; j < N; ++j)
                        result[j] = p[j];
                    return MultidimMinimizationResult(result, _fret, _iter + 1, true);
                }

                // Compute gradient difference
                for (int j = 0; j < N; ++j)
                    dg[j] = g[j] - dg[j];

                // Compute H * dg
                for (int i = 0; i < N; ++i)
                {
                    hdg[i] = 0.0;
                    for (int j = 0; j < N; ++j)
                        hdg[i] += hessin(i, j) * dg[j];
                }

                // BFGS update of inverse Hessian
                Real fac = 0.0, fae = 0.0, sumdg = 0.0, sumxi = 0.0;
                for (int j = 0; j < N; ++j)
                {
                    fac += dg[j] * xi[j];
                    fae += dg[j] * hdg[j];
                    sumdg += dg[j] * dg[j];
                    sumxi += xi[j] * xi[j];
                }

                if (fac > std::sqrt(EPS * sumdg * sumxi))
                {
                    fac = 1.0 / fac;
                    Real fad = 1.0 / fae;

                    // Vector that makes BFGS different from DFP
                    for (int j = 0; j < N; ++j)
                        dg[j] = fac * xi[j] - fad * hdg[j];

                    // BFGS formula for updating inverse Hessian
                    for (int i = 0; i < N; ++i)
                    {
                        for (int j = i; j < N; ++j)
                        {
                            hessin(i, j) += fac * xi[i] * xi[j] - 
                                            fad * hdg[i] * hdg[j] +
                                            fae * dg[i] * dg[j];
                            hessin(j, i) = hessin(i, j);
                        }
                    }
                }

                // Compute new search direction
                for (int i = 0; i < N; ++i)
                {
                    xi[i] = 0.0;
                    for (int j = 0; j < N; ++j)
                        xi[i] -= hessin(i, j) * g[j];
                }
            }

            // Max iterations reached
            Vector<Real> result(N);
            for (int j = 0; j < N; ++j)
                result[j] = p[j];
            return MultidimMinimizationResult(result, _fret, _iter, false);
        }

    private:
        /**
         * @brief Backtracking line search with Armijo condition
         */
        template<int N>
        Real LineSearchBacktrack(const IDifferentiableScalarFunction<N>& func,
                                 VectorN<Real, N>& p,
                                 const VectorN<Real, N>& g,
                                 VectorN<Real, N>& xi,
                                 Real stpmax)
        {
            const Real ALF = 1.0e-4;   // Ensures sufficient decrease
            const Real TOLX = 1.0e-12; // Convergence criterion on x

            // Scale if step is too big
            Real sum = 0.0;
            for (int j = 0; j < N; ++j)
                sum += xi[j] * xi[j];
            sum = std::sqrt(sum);

            if (sum > stpmax)
            {
                Real scale = stpmax / sum;
                for (int j = 0; j < N; ++j)
                    xi[j] *= scale;
            }

            // Compute slope
            Real slope = 0.0;
            for (int j = 0; j < N; ++j)
                slope += g[j] * xi[j];

            if (slope >= 0.0)
            {
                // Reset to steepest descent if slope is not negative
                for (int j = 0; j < N; ++j)
                    xi[j] = -g[j];
                slope = 0.0;
                for (int j = 0; j < N; ++j)
                    slope += g[j] * xi[j];
            }

            // Compute lambda_min
            Real test = 0.0;
            for (int j = 0; j < N; ++j)
            {
                Real temp = std::abs(xi[j]) / std::max(std::abs(p[j]), REAL(1.0));
                if (temp > test) test = temp;
            }
            Real alamin = TOLX / test;

            Real alam = 1.0;  // Always try full Newton step first
            Real f = func(p);
            Real alam2 = 0.0, f2 = 0.0;

            for (;;)
            {
                VectorN<Real, N> pnew;
                for (int j = 0; j < N; ++j)
                    pnew[j] = p[j] + alam * xi[j];

                Real fnew = func(pnew);

                if (alam < alamin)
                {
                    // Convergence on delta x
                    for (int j = 0; j < N; ++j)
                        p[j] = pnew[j];
                    return fnew;
                }
                else if (fnew <= f + ALF * alam * slope)
                {
                    // Sufficient decrease - accept step
                    for (int j = 0; j < N; ++j)
                        p[j] = pnew[j];
                    return fnew;
                }
                else
                {
                    // Backtrack
                    Real tmplam;
                    if (alam == 1.0)
                    {
                        // First backtrack: quadratic
                        tmplam = -slope / (2.0 * (fnew - f - slope));
                    }
                    else
                    {
                        // Subsequent backtracks: cubic
                        Real rhs1 = fnew - f - alam * slope;
                        Real rhs2 = f2 - f - alam2 * slope;
                        Real a = (rhs1 / (alam * alam) - rhs2 / (alam2 * alam2)) /
                                 (alam - alam2);
                        Real b = (-alam2 * rhs1 / (alam * alam) +
                                  alam * rhs2 / (alam2 * alam2)) / (alam - alam2);

                        if (a == 0.0)
                        {
                            tmplam = -slope / (2.0 * b);
                        }
                        else
                        {
                            Real disc = b * b - 3.0 * a * slope;
                            if (disc < 0.0)
                                tmplam = 0.5 * alam;
                            else if (b <= 0.0)
                                tmplam = (-b + std::sqrt(disc)) / (3.0 * a);
                            else
                                tmplam = -slope / (b + std::sqrt(disc));
                        }

                        // Limit step size reduction
                        if (tmplam > 0.5 * alam)
                            tmplam = 0.5 * alam;
                    }

                    alam2 = alam;
                    f2 = fnew;
                    alam = std::max(tmplam, REAL(0.1) * alam);
                }
            }
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                   Convenience Wrapper Functions                     ///
    ///////////////////////////////////////////////////////////////////////////

    /**
     * @brief Minimize using Powell's method (no derivatives needed)
     */
    template<int N>
    MultidimMinimizationResult PowellMinimize(
        const IScalarFunction<N>& func,
        const VectorN<Real, N>& start,
        Real ftol = 3.0e-8)
    {
        Powell optimizer(ftol);
        return optimizer.Minimize(func, start);
    }

    /**
     * @brief Minimize using conjugate gradient (requires derivatives)
     */
    template<int N>
    MultidimMinimizationResult ConjugateGradientMinimize(
        const IDifferentiableScalarFunction<N>& func,
        const VectorN<Real, N>& start,
        Real ftol = 3.0e-8,
        ConjugateGradient::Method method = ConjugateGradient::Method::PolakRibiere)
    {
        ConjugateGradient optimizer(ftol, 1.0e-8, 200, method);
        return optimizer.Minimize(func, start);
    }

    /**
     * @brief Minimize using BFGS quasi-Newton method (requires derivatives)
     */
    template<int N>
    MultidimMinimizationResult BFGSMinimize(
        const IDifferentiableScalarFunction<N>& func,
        const VectorN<Real, N>& start,
        Real ftol = 3.0e-8)
    {
        BFGS optimizer(ftol);
        return optimizer.Minimize(func, start);
    }

} // namespace MML


///////////////////////////   mml/algorithms/Optimization/SimulatedAnnealing.h   ///////////////////////////



// New optimization framework (optional)


namespace MML
{
    /////////////////////////////////////////////////////////////////////
    ///                   HEURISTIC OPTIMIZATION                      ///
    /////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///                   HeuristicOptimizationError                        ///
    ///////////////////////////////////////////////////////////////////////////
    class HeuristicOptimizationError : public std::runtime_error
    {
    public:
        explicit HeuristicOptimizationError(const std::string& message)
            : std::runtime_error("HeuristicOptimizationError: " + message) {}
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                  HeuristicOptimizationResult                        ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Result structure for heuristic optimization methods
     */
    struct HeuristicOptimizationResult
    {
        Vector<Real> xbest;        ///< Best solution found
        Real         fbest;         ///< Function value at best solution
        int          iterations;    ///< Number of iterations performed
        int          funcEvals;     ///< Total function evaluations
        int          acceptedMoves; ///< Number of accepted moves (for SA)
        bool         converged;     ///< True if convergence criterion met

        HeuristicOptimizationResult()
            : fbest(std::numeric_limits<Real>::max()), iterations(0), 
              funcEvals(0), acceptedMoves(0), converged(false) {}

        HeuristicOptimizationResult(const Vector<Real>& x, Real f, int iter, 
                                    int fEvals, int accepted, bool conv)
            : xbest(x), fbest(f), iterations(iter), funcEvals(fEvals),
              acceptedMoves(accepted), converged(conv) {}
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                     Cooling Schedule Interface                      ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Interface for temperature cooling schedules
     */
    class ICoolingSchedule
    {
    public:
        virtual ~ICoolingSchedule() = default;
        
        /**
         * @brief Get the temperature at a given iteration
         * @param iteration Current iteration number (0-based)
         * @param T0 Initial temperature
         * @return Temperature at this iteration
         */
        virtual Real Temperature(int iteration, Real T0) const = 0;
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                     Exponential Cooling Schedule                    ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Exponential (geometric) cooling: T(k) = T0 * alpha^k
     * 
     * This is the most common cooling schedule. Temperature decreases
     * geometrically with each iteration.
     */
    class ExponentialCooling : public ICoolingSchedule
    {
    private:
        Real _alpha;  ///< Cooling rate (0 < alpha < 1, typically 0.9-0.99)

    public:
        /**
         * @brief Construct exponential cooling schedule
         * @param alpha Cooling rate (default 0.95)
         */
        explicit ExponentialCooling(Real alpha = 0.95) : _alpha(alpha)
        {
            if (alpha <= 0.0 || alpha >= 1.0)
                throw HeuristicOptimizationError("Cooling rate alpha must be in (0, 1)");
        }

        Real Temperature(int iteration, Real T0) const override
        {
            return T0 * std::pow(_alpha, iteration);
        }

        Real getAlpha() const { return _alpha; }
        void setAlpha(Real alpha)
        {
            if (alpha <= 0.0 || alpha >= 1.0)
                throw HeuristicOptimizationError("Cooling rate alpha must be in (0, 1)");
            _alpha = alpha;
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                     Linear Cooling Schedule                         ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Linear cooling: T(k) = T0 * (1 - k/maxIter)
     * 
     * Temperature decreases linearly to zero at maxIter.
     */
    class LinearCooling : public ICoolingSchedule
    {
    private:
        int _maxIter;  ///< Maximum iterations (temperature reaches 0)

    public:
        /**
         * @brief Construct linear cooling schedule
         * @param maxIter Maximum iterations
         */
        explicit LinearCooling(int maxIter) : _maxIter(maxIter)
        {
            if (maxIter <= 0)
                throw HeuristicOptimizationError("maxIter must be positive");
        }

        Real Temperature(int iteration, Real T0) const override
        {
            Real ratio = 1.0 - static_cast<Real>(iteration) / _maxIter;
            return T0 * std::max(REAL(0.0), ratio);
        }

        int getMaxIter() const { return _maxIter; }
        void setMaxIter(int maxIter)
        {
            if (maxIter <= 0)
                throw HeuristicOptimizationError("maxIter must be positive");
            _maxIter = maxIter;
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                   Logarithmic Cooling Schedule                      ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Logarithmic (slow) cooling: T(k) = T0 / (1 + c * ln(1 + k))
     * 
     * Very slow cooling that theoretically guarantees convergence to
     * the global minimum, but may be impractically slow.
     */
    class LogarithmicCooling : public ICoolingSchedule
    {
    private:
        Real _c;  ///< Cooling constant

    public:
        /**
         * @brief Construct logarithmic cooling schedule
         * @param c Cooling constant (default 1.0)
         */
        explicit LogarithmicCooling(Real c = 1.0) : _c(c)
        {
            if (c <= 0.0)
                throw HeuristicOptimizationError("Cooling constant c must be positive");
        }

        Real Temperature(int iteration, Real T0) const override
        {
            return T0 / (1.0 + _c * std::log(1.0 + iteration));
        }

        Real getC() const { return _c; }
        void setC(Real c)
        {
            if (c <= 0.0)
                throw HeuristicOptimizationError("Cooling constant c must be positive");
            _c = c;
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                      Adaptive Cooling Schedule                      ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Adaptive cooling that adjusts based on acceptance rate
     * 
     * Slows cooling when acceptance rate is low (stuck),
     * speeds up when acceptance rate is high (too hot).
     */
    class AdaptiveCooling : public ICoolingSchedule
    {
    private:
        Real _alphaFast;   ///< Fast cooling rate
        Real _alphaSlow;   ///< Slow cooling rate
        Real _targetAcceptRate; ///< Target acceptance rate

        mutable Real _currentAlpha;
        mutable Real _currentTemp;
        mutable int _lastIter;

    public:
        /**
         * @brief Construct adaptive cooling schedule
         * @param alphaFast Fast cooling rate (default 0.99)
         * @param alphaSlow Slow cooling rate (default 0.8)
         * @param targetAcceptRate Target acceptance rate (default 0.3)
         */
        AdaptiveCooling(Real alphaFast = 0.99, Real alphaSlow = 0.8, 
                        Real targetAcceptRate = 0.3)
            : _alphaFast(alphaFast), _alphaSlow(alphaSlow), 
              _targetAcceptRate(targetAcceptRate),
              _currentAlpha(alphaFast), _currentTemp(0), _lastIter(-1) {}

        Real Temperature(int iteration, Real T0) const override
        {
            if (iteration == 0 || _lastIter < 0)
            {
                _currentTemp = T0;
                _lastIter = 0;
            }
            
            // Simple exponential decay with current alpha
            while (_lastIter < iteration)
            {
                _currentTemp *= _currentAlpha;
                _lastIter++;
            }
            
            return _currentTemp;
        }

        /**
         * @brief Update cooling rate based on actual acceptance rate
         * @param acceptRate Current acceptance rate
         */
        void UpdateRate(Real acceptRate)
        {
            if (acceptRate > _targetAcceptRate)
                _currentAlpha = _alphaFast;  // Cool faster
            else
                _currentAlpha = _alphaSlow;  // Cool slower
        }

        void reset()
        {
            _currentAlpha = _alphaFast;
            _currentTemp = 0;
            _lastIter = -1;
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                     Neighbor Generator Interface                    ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Interface for generating neighbor solutions
     */
    class INeighborGenerator
    {
    public:
        virtual ~INeighborGenerator() = default;
        
        /**
         * @brief Generate a neighbor of the current solution
         * @param current Current solution
         * @param temperature Current temperature (may affect step size)
         * @return Neighbor solution
         */
        virtual Vector<Real> Generate(const Vector<Real>& current, Real temperature) = 0;
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                    Uniform Random Neighbor Generator                ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Generate neighbors by uniform random perturbation
     * 
     * Each component is perturbed by a uniform random value in [-delta, delta]
     * where delta can optionally scale with temperature.
     */
    class UniformNeighborGenerator : public INeighborGenerator
    {
    private:
        Real _delta;          ///< Maximum perturbation per component
        bool _scaleWithTemp;  ///< Whether to scale delta with temperature
        Real _T0;             ///< Reference temperature for scaling
        
        std::mt19937 _rng;
        std::uniform_real_distribution<Real> _dist;

        Vector<Real> _lowerBounds;  ///< Lower bounds (optional)
        Vector<Real> _upperBounds;  ///< Upper bounds (optional)
        bool _hasBounds;

    public:
        /**
         * @brief Construct uniform neighbor generator
         * @param delta Maximum perturbation magnitude
         * @param scaleWithTemp Scale delta proportionally to temperature
         * @param T0 Reference temperature (initial temperature)
         * @param seed Random seed (0 for random)
         */
        UniformNeighborGenerator(Real delta = 1.0, bool scaleWithTemp = false, 
                                  Real T0 = 1.0, unsigned int seed = 0)
            : _delta(delta), _scaleWithTemp(scaleWithTemp), _T0(T0),
              _dist(-1.0, 1.0), _hasBounds(false)
        {
            if (seed == 0)
                _rng.seed(std::random_device{}());
            else
                _rng.seed(seed);
        }

        /**
         * @brief Set bounds for the search space
         */
        void SetBounds(const Vector<Real>& lower, const Vector<Real>& upper)
        {
            _lowerBounds = lower;
            _upperBounds = upper;
            _hasBounds = true;
        }

        void ClearBounds() { _hasBounds = false; }

        Vector<Real> Generate(const Vector<Real>& current, Real temperature) override
        {
            Vector<Real> neighbor(current.size());
            Real scale = _scaleWithTemp ? _delta * (temperature / _T0) : _delta;
            
            for (int i = 0; i < current.size(); ++i)
            {
                neighbor[i] = current[i] + scale * _dist(_rng);
                
                // Apply bounds if set
                if (_hasBounds)
                {
                    if (neighbor[i] < _lowerBounds[i])
                        neighbor[i] = _lowerBounds[i];
                    if (neighbor[i] > _upperBounds[i])
                        neighbor[i] = _upperBounds[i];
                }
            }
            
            return neighbor;
        }

        Real getDelta() const { return _delta; }
        void setDelta(Real delta) { _delta = delta; }
        void setT0(Real T0) { _T0 = T0; }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                  Gaussian Neighbor Generator                        ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Generate neighbors by Gaussian perturbation
     * 
     * Each component is perturbed by a Gaussian random value with 
     * standard deviation sigma.
     */
    class GaussianNeighborGenerator : public INeighborGenerator
    {
    private:
        Real _sigma;          ///< Standard deviation of perturbation
        bool _scaleWithTemp;  ///< Whether to scale sigma with temperature
        Real _T0;             ///< Reference temperature for scaling
        
        std::mt19937 _rng;
        std::normal_distribution<Real> _dist;

        Vector<Real> _lowerBounds;
        Vector<Real> _upperBounds;
        bool _hasBounds;

    public:
        /**
         * @brief Construct Gaussian neighbor generator
         * @param sigma Standard deviation of perturbation
         * @param scaleWithTemp Scale sigma proportionally to sqrt(temperature)
         * @param T0 Reference temperature
         * @param seed Random seed (0 for random)
         */
        GaussianNeighborGenerator(Real sigma = 1.0, bool scaleWithTemp = false,
                                   Real T0 = 1.0, unsigned int seed = 0)
            : _sigma(sigma), _scaleWithTemp(scaleWithTemp), _T0(T0),
              _dist(0.0, 1.0), _hasBounds(false)
        {
            if (seed == 0)
                _rng.seed(std::random_device{}());
            else
                _rng.seed(seed);
        }

        void SetBounds(const Vector<Real>& lower, const Vector<Real>& upper)
        {
            _lowerBounds = lower;
            _upperBounds = upper;
            _hasBounds = true;
        }

        void ClearBounds() { _hasBounds = false; }

        Vector<Real> Generate(const Vector<Real>& current, Real temperature) override
        {
            Vector<Real> neighbor(current.size());
            Real scale = _scaleWithTemp ? _sigma * std::sqrt(temperature / _T0) : _sigma;
            
            for (int i = 0; i < current.size(); ++i)
            {
                neighbor[i] = current[i] + scale * _dist(_rng);
                
                if (_hasBounds)
                {
                    if (neighbor[i] < _lowerBounds[i])
                        neighbor[i] = _lowerBounds[i];
                    if (neighbor[i] > _upperBounds[i])
                        neighbor[i] = _upperBounds[i];
                }
            }
            
            return neighbor;
        }

        Real getSigma() const { return _sigma; }
        void setSigma(Real sigma) { _sigma = sigma; }
        void setT0(Real T0) { _T0 = T0; }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                      Simulated Annealing                            ///
    ///////////////////////////////////////////////////////////////////////////
    /**
     * @brief Simulated Annealing optimization algorithm
     * 
     * Simulated Annealing is a probabilistic metaheuristic for global optimization.
     * It mimics the physical process of heating and slowly cooling a material
     * to decrease defects (minimizing energy).
     * 
     * Algorithm:
     * 1. Start with initial solution x and temperature T
     * 2. Generate neighbor x' of current solution
     * 3. If f(x') < f(x), accept x' (downhill move)
     * 4. If f(x') >= f(x), accept with probability exp(-(f(x')-f(x))/T)
     * 5. Reduce temperature according to cooling schedule
     * 6. Repeat until stopping criterion met
     * 
     * The key insight is that at high temperatures, uphill moves are likely
     * accepted (allowing escape from local minima), while at low temperatures
     * the algorithm behaves like hill-climbing.
     * 
     * Reference: Kirkpatrick, Gelatt, Vecchi (1983)
     */
    class SimulatedAnnealing
    {
    public:
        /// Stopping criteria
        enum class StopCriteria
        {
            MaxIterations,   ///< Stop after maxIter iterations
            MinTemperature,  ///< Stop when temperature drops below threshold
            NoImprovement,   ///< Stop after N iterations without improvement
            Combined         ///< Use all criteria
        };

    private:
        Real _T0;                ///< Initial temperature
        Real _Tmin;              ///< Minimum temperature (stopping criterion)
        int  _maxIter;           ///< Maximum iterations
        int  _stagnationLimit;   ///< Iterations without improvement to stop
        StopCriteria _stopCrit;  ///< Stopping criterion to use

        // Components
        std::unique_ptr<ICoolingSchedule> _coolingSchedule;
        std::unique_ptr<INeighborGenerator> _neighborGen;

        // Random number generation for acceptance
        mutable std::mt19937 _rng;
        mutable std::uniform_real_distribution<Real> _acceptDist;

    public:
        /**
         * @brief Construct Simulated Annealing optimizer with default components
         * @param T0 Initial temperature (default 100.0)
         * @param Tmin Minimum temperature (default 1e-8)
         * @param maxIter Maximum iterations (default 10000)
         * @param stagnationLimit Iterations without improvement (default 1000)
         * @param stopCrit Stopping criterion (default Combined)
         * @param seed Random seed (0 for random)
         */
        SimulatedAnnealing(Real T0 = 100.0, Real Tmin = 1e-8, int maxIter = 10000,
                           int stagnationLimit = 1000, 
                           StopCriteria stopCrit = StopCriteria::Combined,
                           unsigned int seed = 0)
            : _T0(T0), _Tmin(Tmin), _maxIter(maxIter), 
              _stagnationLimit(stagnationLimit), _stopCrit(stopCrit),
              _acceptDist(0.0, 1.0)
        {
            // Default cooling schedule: exponential with alpha=0.995 (slow cooling)
            _coolingSchedule = std::make_unique<ExponentialCooling>(0.995);
            
            // Default neighbor generator: Gaussian with moderate sigma
            // Pass through the provided seed so neighbor generation is reproducible
            auto gen = std::make_unique<GaussianNeighborGenerator>(0.5, true, T0, seed);
            _neighborGen = std::move(gen);

            if (seed == 0)
                _rng.seed(std::random_device{}());
            else
                _rng.seed(seed);
        }

        /**
         * @brief Construct with custom cooling schedule and neighbor generator
         */
        SimulatedAnnealing(std::unique_ptr<ICoolingSchedule> cooling,
                           std::unique_ptr<INeighborGenerator> neighbor,
                           Real T0 = 100.0, Real Tmin = 1e-8, int maxIter = 10000,
                           int stagnationLimit = 1000,
                           StopCriteria stopCrit = StopCriteria::Combined,
                           unsigned int seed = 0)
            : _T0(T0), _Tmin(Tmin), _maxIter(maxIter),
              _stagnationLimit(stagnationLimit), _stopCrit(stopCrit),
              _coolingSchedule(std::move(cooling)),
              _neighborGen(std::move(neighbor)),
              _acceptDist(0.0, 1.0)
        {
            if (seed == 0)
                _rng.seed(std::random_device{}());
            else
                _rng.seed(seed);
        }

        /**
         * @brief Minimize a function using simulated annealing
         * @param func Function to minimize (callable: Vector<Real> -> Real)
         * @param x0 Initial solution
         * @return Optimization result
         */
        template<typename Func>
        HeuristicOptimizationResult Minimize(Func& func, const Vector<Real>& x0) const
        {
            int n = x0.size();
            
            // Initialize
            Vector<Real> x = x0;
            Real fx = func(x);
            
            Vector<Real> xbest = x;
            Real fbest = fx;
            
            int funcEvals = 1;
            int acceptedMoves = 0;
            int iterSinceImprovement = 0;
            
            // Main loop
            for (int iter = 0; iter < _maxIter; ++iter)
            {
                // Get current temperature
                Real T = _coolingSchedule->Temperature(iter, _T0);
                
                // Check temperature stopping criterion
                if ((_stopCrit == StopCriteria::MinTemperature || 
                     _stopCrit == StopCriteria::Combined) && T < _Tmin)
                {
                    return HeuristicOptimizationResult(xbest, fbest, iter, 
                                                        funcEvals, acceptedMoves, true);
                }
                
                // Generate neighbor
                Vector<Real> xnew = _neighborGen->Generate(x, T);
                Real fxnew = func(xnew);
                funcEvals++;
                
                // Compute acceptance probability
                Real deltaE = fxnew - fx;
                bool accept = false;
                
                if (deltaE < 0)
                {
                    // Always accept improvement
                    accept = true;
                }
                else if (T > 0)
                {
                    // Accept with Boltzmann probability
                    Real prob = std::exp(-deltaE / T);
                    accept = (_acceptDist(_rng) < prob);
                }
                
                if (accept)
                {
                    x = xnew;
                    fx = fxnew;
                    acceptedMoves++;
                    
                    // Update best solution
                    if (fx < fbest)
                    {
                        xbest = x;
                        fbest = fx;
                        iterSinceImprovement = 0;
                    }
                    else
                    {
                        iterSinceImprovement++;
                    }
                }
                else
                {
                    iterSinceImprovement++;
                }
                
                // Check stagnation stopping criterion
                if ((_stopCrit == StopCriteria::NoImprovement || 
                     _stopCrit == StopCriteria::Combined) && 
                    iterSinceImprovement >= _stagnationLimit)
                {
                    return HeuristicOptimizationResult(xbest, fbest, iter + 1,
                                                        funcEvals, acceptedMoves, true);
                }
            }
            
            // Reached max iterations
            bool converged = (_stopCrit == StopCriteria::MaxIterations);
            return HeuristicOptimizationResult(xbest, fbest, _maxIter, 
                                                funcEvals, acceptedMoves, converged);
        }

        /**
         * @brief Minimize using NEW optimization framework (with config)
         * @param func Function to minimize
         * @param x0 Initial solution
         * @param config Optimization configuration (criteria, observers, etc.)
         * @return Enhanced OptimizationResult with trajectory if configured
         */
        template<typename Func>
        OptimizationResult<Real> Minimize(Func& func, const Vector<Real>& x0,
                                           OptimizationConfig<Real>& config) const
        {
            using namespace std::chrono;
            auto startTime = steady_clock::now();
            
            int n = x0.size();
            
            // Initialize optimization state
            OptimizationState<Real> state;
            state.iteration = 0;
            state.funcEvals = 0;
            state.xCurrent = x0;
            state.fCurrent = func(x0);
            state.xBest = x0;
            state.fBest = state.fCurrent;
            state.fBestPrevious = state.fBest;
            state.iterSinceImprovement = 0;
            state.temperature = _T0;
            state.acceptedMoves = 0;
            state.rejectedMoves = 0;
            state.elapsedTime = 0.0;
            state.funcEvals = 1;
            
            // Get config components
            auto* criterion = config.GetCriterion();
            auto& observers = config.GetObservers();
            
            if (!criterion) {
                throw HeuristicOptimizationError("No termination criterion provided");
            }
            
            // Reset criterion for new run
            criterion->Reset();
            
            // Notify observers: optimization starting
            for (auto& obs : observers) {
                obs->OnStart(state);
            }
            
            // Main optimization loop
            while (true)
            {
                // Get current temperature
                Real T = _coolingSchedule->Temperature(state.iteration, _T0);
                state.temperature = T;
                
                // Check termination criterion
                if (criterion->ShouldTerminate(state)) {
                    // Notify observers: optimization complete
                    std::string reason = criterion->GetReason();
                    for (auto& obs : observers) {
                        obs->OnComplete(state, reason);
                    }
                    
                    // Create result
                    OptimizationResult<Real> result = CreateResult(state, reason, true);
                    
                    // Copy trajectory if TrajectoryObserver used
                    auto trajObs = config.GetTrajectoryObserver();
                    if (trajObs) {
                        result.trajectory = trajObs->GetTrajectory();
                    }
                    
                    return result;
                }
                
                // Generate neighbor
                Vector<Real> xnew = _neighborGen->Generate(state.xCurrent, T);
                Real fxnew = func(xnew);
                state.funcEvals++;
                
                // Compute acceptance probability
                Real deltaE = fxnew - state.fCurrent;
                bool accept = false;
                
                if (deltaE < 0)
                {
                    // Always accept improvement
                    accept = true;
                }
                else if (T > 0)
                {
                    // Accept with Boltzmann probability
                    Real prob = std::exp(-deltaE / T);
                    accept = (_acceptDist(_rng) < prob);
                }
                
                if (accept)
                {
                    state.xCurrent = xnew;
                    state.fCurrent = fxnew;
                    state.acceptedMoves++;
                    
                    // Update best solution
                    if (state.fCurrent < state.fBest)
                    {
                        state.xBest = state.xCurrent;
                        state.fBestPrevious = state.fBest;
                        state.fBest = state.fCurrent;
                        state.iterSinceImprovement = 0;
                    }
                    else
                    {
                        state.iterSinceImprovement++;
                    }
                }
                else
                {
                    state.rejectedMoves++;
                    state.iterSinceImprovement++;
                }
                
                // Update timing
                auto now = steady_clock::now();
                state.elapsedTime = duration_cast<duration<double>>(now - startTime).count();
                
                // Increment iteration
                state.iteration++;
                
                // Notify observers: iteration complete (can abort if returns false)
                bool continueOpt = true;
                for (auto& obs : observers) {
                    if (!obs->OnIteration(state)) {
                        continueOpt = false;
                        break;
                    }
                }
                
                if (!continueOpt) {
                    // Observer requested abort
                    std::string reason = "Aborted by observer";
                    for (auto& obs : observers) {
                        obs->OnComplete(state, reason);
                    }
                    
                    OptimizationResult<Real> result = CreateResult(state, reason, false);
                    
                    auto trajObs = config.GetTrajectoryObserver();
                    if (trajObs) {
                        result.trajectory = trajObs->GetTrajectory();
                    }
                    
                    return result;
                }
            }
        }

        /**
         * @brief Minimize a function with bounds
         */
        template<typename Func>
        HeuristicOptimizationResult Minimize(Func& func, const Vector<Real>& x0,
                                              const Vector<Real>& lowerBounds,
                                              const Vector<Real>& upperBounds) const
        {
            // Set bounds on neighbor generator
            if (auto* uniform = dynamic_cast<UniformNeighborGenerator*>(_neighborGen.get()))
            {
                uniform->SetBounds(lowerBounds, upperBounds);
            }
            else if (auto* gaussian = dynamic_cast<GaussianNeighborGenerator*>(_neighborGen.get()))
            {
                gaussian->SetBounds(lowerBounds, upperBounds);
            }
            
            return Minimize(func, x0);
        }

        // Accessors
        Real getT0() const { return _T0; }
        void setT0(Real T0) { _T0 = T0; }
        
        Real getTmin() const { return _Tmin; }
        void setTmin(Real Tmin) { _Tmin = Tmin; }
        
        int getMaxIter() const { return _maxIter; }
        void setMaxIter(int maxIter) { _maxIter = maxIter; }
        
        int getStagnationLimit() const { return _stagnationLimit; }
        void setStagnationLimit(int limit) { _stagnationLimit = limit; }
        
        StopCriteria getStopCriteria() const { return _stopCrit; }
        void setStopCriteria(StopCriteria crit) { _stopCrit = crit; }

        /**
         * @brief Set custom cooling schedule
         */
        void setCoolingSchedule(std::unique_ptr<ICoolingSchedule> schedule)
        {
            _coolingSchedule = std::move(schedule);
        }

        /**
         * @brief Set custom neighbor generator
         */
        void setNeighborGenerator(std::unique_ptr<INeighborGenerator> gen)
        {
            _neighborGen = std::move(gen);
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    ///                     Convenience Functions                           ///
    ///////////////////////////////////////////////////////////////////////////

    /**
     * @brief Simple simulated annealing minimization
     * @param func Function to minimize
     * @param x0 Initial solution
     * @param T0 Initial temperature (default 100)
     * @param maxIter Maximum iterations (default 10000)
     * @return Optimization result
     */
    template<typename Func>
    HeuristicOptimizationResult SimulatedAnnealingMinimize(
        Func& func, 
        const Vector<Real>& x0,
        Real T0 = 100.0,
        int maxIter = 10000)
    {
        SimulatedAnnealing sa(T0, 1e-8, maxIter);
        return sa.Minimize(func, x0);
    }

    /**
     * @brief Simulated annealing with bounds
     */
    template<typename Func>
    HeuristicOptimizationResult SimulatedAnnealingMinimize(
        Func& func,
        const Vector<Real>& x0,
        const Vector<Real>& lowerBounds,
        const Vector<Real>& upperBounds,
        Real T0 = 100.0,
        int maxIter = 10000)
    {
        SimulatedAnnealing sa(T0, 1e-8, maxIter);
        return sa.Minimize(func, x0, lowerBounds, upperBounds);
    }

    /////////////////////////////////////////////////////////////////////
    ///                     FUTURE: Genetic Algorithms                ///
    /////////////////////////////////////////////////////////////////////
    
    // TODO: Implement genetic algorithms
    // - Binary GA
    // - Real-coded GA
    // - Selection strategies (roulette, tournament, rank)
    // - Crossover operators (single-point, multi-point, uniform)
    // - Mutation operators
    // - Elitism

} // namespace MML


///////////////////////////   mml/algorithms/FunctionsAnalyzer.h   ///////////////////////////






// Undefine Windows.h macros that conflict with our enum values
#ifdef _WIN32
#ifdef INFINITE
#undef INFINITE
#endif
#ifdef DOMAIN
#undef DOMAIN
#endif
#endif


namespace MML
{
	// Critical point classification
	enum class CriticalPointType
	{
		LOCAL_MINIMUM,
		LOCAL_MAXIMUM,
		SADDLE_POINT    // For 1D functions, this would be a point where f'=0 but f'' changes sign (rare)
	};

	struct CriticalPoint
	{
		Real x;
		CriticalPointType type;
		Real value;  // f(x)
	};

	// Discontinuity classification
	enum class DiscontinuityType
	{
		JUMP,           // Left and right limits exist but differ (e.g., step function)
		REMOVABLE,      // Limits exist and agree, but f(x) is different or undefined
		INFINITE,       // At least one limit is infinite (e.g., 1/x at x=0)
		OSCILLATORY,    // Limit does not exist due to oscillation (e.g., sin(1/x) at x=0)
		UNKNOWN         // Unable to classify
	};

	struct DiscontinuityPoint
	{
		Real x;
		DiscontinuityType type;
		Real leftLimit;       // lim(xâ†’aâ») f(x)
		Real rightLimit;      // lim(xâ†’aâº) f(x)
		Real valueAtPoint;    // f(a), may be NaN if undefined
		Real jumpSize;        // |rightLimit - leftLimit| for jump discontinuities
	};
	class RealFunctionAnalyzer
	{
		const IRealFunction& _f;
		std::string _funcName;
	public:
		RealFunctionAnalyzer(const IRealFunction& f) : _f(f) {}
		RealFunctionAnalyzer(const IRealFunction& f, std::string inName) : _f(f), _funcName(inName) {}

		void PrintPointAnalysis(Real x, Real eps = 1e-6)
		{
			std::cout << "Function analysis at point: " << x << ":" << std::endl;
			std::cout << "  Defined at point:      " << (isDefinedAtPoint(x) ? "yes" : "no") << std::endl;
			std::cout << "  Continuous at point:   " << (isContinuousAtPoint(x, eps) ? "yes" : "no") << std::endl;
			std::cout << "  Derivative defined:    " << (isDerivativeDefinedAtPoint(x, eps) ? "yes" : "no") << std::endl;
			std::cout << "  Is inflection point:   " << (isInflectionPoint(x, eps) ? "yes" : "no") << std::endl;
		}

		void PrintIntervalAnalysis(Real x1, Real x2, int numPoints, Real eps = 1e-6)
		{
			if (_funcName != "")
				std::cout << std::fixed << "f(x) = " << _funcName << " - Function analysis in interval [" << x1 << ", " << x2 << "] with " << numPoints << " points:" << std::endl;
			else
				std::cout << std::fixed << "Function analysis in interval [" << x1 << ", " << x2 << "] with " << numPoints << " points:" << std::endl;

			bool isDef = true;
			bool isCont = true;
			std::vector<Real> _notDefinedPoints;
			std::vector<Real> _notContinuousPoints;

			for (int i = 0; i < numPoints; i++)
			{
				Real x = x1 + i * (x2 - x1) / numPoints;
				if (!isDefinedAtPoint(x))
				{
					isDef = false;
					_notDefinedPoints.push_back(x);
				}
				else if (!isContinuousAtPoint(x, eps))
				{
					isCont = false;
					_notContinuousPoints.push_back(x);
				}
			}

			std::cout << "  Defined    : " << (isDef ? "yes" : "no");
			if (!_notDefinedPoints.empty())
			{
				std::cout << "  Not defined at points: ";
				for (int i = 0; i < _notDefinedPoints.size(); i++)
					std::cout << _notDefinedPoints[i] << " ";
				std::cout << std::endl;
			}
			else
				std::cout << std::endl;
			std::cout << "  Continuous : " << (isCont ? "yes" : "no");
			if (!_notContinuousPoints.empty())
			{
				std::cout << "  Not continuous at points: ";
				for (int i = 0; i < _notContinuousPoints.size(); i++)
					std::cout << _notContinuousPoints[i] << " ";
				std::cout << std::endl;
			}
			else
				std::cout << std::endl;
			std::cout << "  Monotonic  : " << (isMonotonic(x1, x2, numPoints) ? "yes" : "no") << std::endl;
			std::cout << "  Min        : " << MinInNPoints(x1, x2, numPoints) << std::endl;
			std::cout << "  Max        : " << MaxInNPoints(x1, x2, numPoints) << std::endl;
		}
		void PrintDetailedIntervalAnalysis(Real x1, Real x2, int numPoints, Real eps = 1e-6)
		{
			std::cout << std::fixed << "Function analysis in interval [" << x1 << ", " << x2 << "] with " << numPoints << " points:" << std::endl;
			std::cout << " Point " << "           Value     " << "         First.der.     " << "     Sec.der.     " << "Defined " << " Continuous " << " Deriv.Def. " << " Inflection " << std::endl;
			for (int i = 0; i < numPoints; i++)
			{
				Real x = x1 + i * (x2 - x1) / numPoints;

				std::cout << std::setw(6) << x << " :  ";
				std::cout << std::setw(16) << _f(x) << " :  ";
				std::cout << std::setw(16) << Derivation::NDer1(_f, x) << " :  ";
				std::cout << std::setw(16) << Derivation::NSecDer2(_f, x) << " :  ";
				std::cout << (isDefinedAtPoint(x) ? "   yes   " : "    no   ");
				std::cout << (isContinuousAtPoint(x, eps) ? "   yes   " : "    no   ");
				std::cout << (isDerivativeDefinedAtPoint(x, eps) ? "   yes   " : "    no   ");
				std::cout << (isInflectionPoint(x, eps) ? "     yes   " : "      no   ") << std::endl;
			}
		}

		std::vector<Real> GetRoots(Real x1, Real x2, Real eps)
		{
			std::vector<Real> roots;
			Real step = (x2 - x1) / 1000;
			
			// Check if x1 is a root (within tolerance)
			Real val_x1 = _f(x1);
			if (std::abs(val_x1) < eps)
				roots.push_back(x1);
			
			Real prev = val_x1;
			for (int i = 1; i <= 1000; i++)
			{
				Real x_curr = x1 + i * step;
				Real curr = _f(x_curr);
				
				// Check if current point is a root
				if (std::abs(curr) < eps && (roots.empty() || std::abs(x_curr - roots.back()) > eps))
				{
					roots.push_back(x_curr);
				}
				// Check for sign change (bracket around root)
				else if (prev * curr < 0)
				{
					Real root = RootFinding::FindRootBisection(_f, x1 + (i - 1) * step, x_curr, eps);
					// Avoid duplicate roots
					if (roots.empty() || std::abs(root - roots.back()) > eps)
						roots.push_back(root);
				}
				prev = curr;
			}
			return roots;
		}
		Vector<Real> GetLocalOptimums(Real x1, Real x2, Real eps = 1e-6)
		{
			Vector<Real> optimums;

			// Create a wrapper for f'(x) to find critical points where f'(x) = 0
			std::function<Real(Real)> derivative = [this](Real x) -> Real {
				return Derivation::NDer4(_f, x);
			};
			RealFunctionFromStdFunc derivativeFunc(derivative);
			RealFunctionAnalyzer derivAnalyzer(derivativeFunc);

			// Find roots of f'(x) - these are potential critical points
			std::vector<Real> criticalPoints = derivAnalyzer.GetRoots(x1, x2, eps);

			// For each critical point, verify it's a local optimum using second derivative test
			for (Real x : criticalPoints)
			{
				if (isLocalOptimum(x, eps))
				{
					optimums.push_back(x);
				}
			}

			return optimums;
		}
		std::vector<CriticalPoint> GetLocalOptimumsClassified(Real x1, Real x2, Real eps = 1e-6)
		{
			std::vector<CriticalPoint> classified;

			// Create a wrapper for f'(x) to find critical points where f'(x) = 0
			std::function<Real(Real)> derivative = [this](Real x) -> Real {
				return Derivation::NDer4(_f, x);
			};
			RealFunctionFromStdFunc derivativeFunc(derivative);
			RealFunctionAnalyzer derivAnalyzer(derivativeFunc);

			// Find roots of f'(x) - these are potential critical points
			std::vector<Real> criticalPoints = derivAnalyzer.GetRoots(x1, x2, eps);

			// For each critical point, verify it's a local optimum and classify
			for (Real x : criticalPoints)
			{
				if (isLocalOptimum(x, eps))
				{
					CriticalPoint cp;
					cp.x = x;
					cp.value = _f(x);
					
					// Classify using second derivative test
					Real secDeriv = Derivation::NSecDer4(_f, x);
					
					if (secDeriv > eps)
						cp.type = CriticalPointType::LOCAL_MINIMUM;
					else if (secDeriv < -eps)
						cp.type = CriticalPointType::LOCAL_MAXIMUM;
					else
						cp.type = CriticalPointType::SADDLE_POINT;  // Very rare in 1D
					
					classified.push_back(cp);
				}
			}

			return classified;
		}
		Vector<Real> GetInflectionPoints(Real x1, Real x2, Real eps = 1e-6)
		{
			Vector<Real> inflection_points;

			// Create a wrapper for f''(x) to find inflection points where f''(x) = 0
			std::function<Real(Real)> secondDerivative = [this](Real x) -> Real {
				return Derivation::NSecDer4(_f, x);
			};
			RealFunctionFromStdFunc secondDerivFunc(secondDerivative);
			RealFunctionAnalyzer secDerivAnalyzer(secondDerivFunc);

			// Find roots of f''(x) - these are potential inflection points
			std::vector<Real> candidates = secDerivAnalyzer.GetRoots(x1, x2, eps);

			// For each candidate, verify it's an inflection point (concavity changes)
			for (Real x : candidates)
			{
				if (isInflectionPoint(x, eps))
				{
					inflection_points.push_back(x);
				}
			}

			return inflection_points;
		}
		
		bool isDefinedAtPoint(Real x) const
		{
			Real y = _f(x);
			return !std::isnan(y) && !std::isinf(y);
		}
		bool isDerivativeDefinedAtPoint(Real x, Real eps = 1e-6)
		{
			// Derivative exists at x if left and right derivatives exist and are equal
			// Left derivative:  lim (hâ†’0-) [f(x+h) - f(x)] / h
			// Right derivative: lim (hâ†’0+) [f(x+h) - f(x)] / h
			
			if (!isDefinedAtPoint(x))
				return false;

			// Check if function is defined in a neighborhood
			Real h = eps * 10;
			if (!isDefinedAtPoint(x - h) || !isDefinedAtPoint(x + h))
				return false;

			// Compute left and right derivatives using NDer2
			Real leftDeriv = Derivation::NDer2Left(_f, x, eps);
			Real rightDeriv = Derivation::NDer2Right(_f, x, eps);

			// Check if both derivatives are defined (not NaN or Inf)
			if (std::isnan(leftDeriv) || std::isinf(leftDeriv) ||
				std::isnan(rightDeriv) || std::isinf(rightDeriv))
				return false;

			// Check if left and right derivatives match (within tolerance)
			Real deriv_diff = std::abs(leftDeriv - rightDeriv);
			Real avg_deriv = (std::abs(leftDeriv) + std::abs(rightDeriv)) / 2.0;
			
			// Use relative tolerance for large derivatives, absolute for small
			Real tolerance = eps * 100 + eps * 100 * avg_deriv;
			
			return deriv_diff < tolerance;
		}
		bool isContinuousAtPoint(Real x, Real eps)
		{
			// Function is continuous at x if:
			// lim(hâ†’0) f(x+h) = f(x) and lim(hâ†’0) f(x-h) = f(x)
			// 
			// We use epsilon-delta definition: for any eps > 0, there exists delta > 0
			// such that |x - y| < delta => |f(x) - f(y)| < eps
			
			if (!isDefinedAtPoint(x))
				return false;

			Real val = _f(x);
			
			// Adaptive tolerance: use absolute tolerance for small values, 
			// relative tolerance for large values
			Real abs_tol = eps * 100;  // Base absolute tolerance
			Real rel_tol = eps * 100;  // Base relative tolerance
			
			// Test with progressively smaller h values
			// If function is continuous, |f(xÂ±h) - f(x)| should decrease as h decreases
			Real h = eps * 10;
			Real prev_max_diff = std::numeric_limits<Real>::max();
			
			for (int i = 0; i < 5; i++)
			{
				Real left = _f(x - h);
				Real right = _f(x + h);
				
				// Check if left and right values are defined
				if (!isDefinedAtPoint(x - h) || !isDefinedAtPoint(x + h))
					return false;
				
				// Calculate differences
				Real diff_left = std::abs(left - val);
				Real diff_right = std::abs(right - val);
				Real max_diff = std::max(diff_left, diff_right);
				
				// For continuity, the difference should be getting smaller
				// Use combined absolute and relative tolerance
				Real tolerance = abs_tol + rel_tol * std::abs(val);
				
				if (max_diff < tolerance)
					return true;  // Close enough
				
				// If difference is not decreasing, it's likely discontinuous
				if (i > 0 && max_diff >= prev_max_diff * 0.9)
					return false;
				
				prev_max_diff = max_diff;
				h /= 2.0;  // Try with smaller h
			}
			
			return false;
		}
		bool isLocalOptimum(Real x, Real eps)
		{
			// For a local optimum:
			// 1. First derivative must be (approximately) zero: f'(x) â‰ˆ 0
			// 2. Second derivative must be non-zero with consistent sign: f''(x) â‰  0
			//    - f''(x) > 0 => local minimum
			//    - f''(x) < 0 => local maximum
			
			// Check first derivative is near zero
			Real first_der = Derivation::NDer4(_f, x);
			if (std::abs(first_der) > eps)
				return false;  // Not a stationary point

			// Check second derivative has consistent sign (non-zero)
			Real left_sec_der = Derivation::NSecDer4(_f, x - 4 * eps);
			Real right_sec_der = Derivation::NSecDer4(_f, x + 4 * eps);

			// Both should have the same sign AND be non-zero
			return left_sec_der * right_sec_der > 0;
		}
		bool isInflectionPoint(Real x, Real eps)
		{
			// Inflection point: second derivative changes sign (concavity changes)
			// Note: First derivative does NOT need to be zero (that's for stationary points)
			Real left_sec_der = Derivation::NSecDer4(_f, x - 4 * eps);
			Real right_sec_der = Derivation::NSecDer4(_f, x + 4 * eps);

			// Check if second derivatives have opposite signs (sign change)
			return left_sec_der * right_sec_der < 0;
		}
		bool isContinuous(Real x1, Real x2, int numPoints, Real eps = 1e-6, std::vector<Real>* discontinuities = nullptr)
		{
			// Multi-stage approach to detect discontinuities:
			// 1) Sample at numPoints
			// 2) Check continuity at each point using isContinuousAtPoint()
			// 3) Adaptive refinement where suspicious behavior detected
			
			bool allContinuous = true;
			Real step = (x2 - x1) / numPoints;
			std::vector<Real> suspiciousPoints;
			
			// Stage 1: Initial sampling
			for (int i = 0; i <= numPoints; i++)
			{
				Real x = x1 + i * step;
				if (!isContinuousAtPoint(x, eps))
				{
					allContinuous = false;
					suspiciousPoints.push_back(x);
				}
			}
			
			// Stage 2: Check for sign changes in derivative (potential discontinuities)
			// Sample derivative at midpoints to catch jump discontinuities
			for (int i = 0; i < numPoints; i++)
			{
				Real x_left = x1 + i * step;
				Real x_right = x1 + (i + 1) * step;
				Real x_mid = (x_left + x_right) / 2.0;
				
				// Check for large derivative changes (potential discontinuity)
				Real der_left = Derivation::NDer2(_f, x_left);
				Real der_right = Derivation::NDer2(_f, x_right);
				
				// If derivative changes dramatically or function value jumps
				Real val_left = _f(x_left);
				Real val_right = _f(x_right);
				Real val_mid = _f(x_mid);
				
				// Check for non-smooth behavior (jump or cusp)
				bool potentialJump = std::abs(val_right - val_left) > 10 * eps * std::abs(val_left + val_right);
				bool derivativeJump = !std::isnan(der_left) && !std::isnan(der_right) && 
					                   std::abs(der_right - der_left) > 100 * eps;
				
				if (potentialJump || derivativeJump)
				{
					// Refine search in this interval
					if (!isContinuousAtPoint(x_mid, eps))
					{
						allContinuous = false;
						// Avoid duplicates
						if (std::find(suspiciousPoints.begin(), suspiciousPoints.end(), x_mid) == suspiciousPoints.end())
						{
							suspiciousPoints.push_back(x_mid);
						}
					}
				}
			}
			
			// Return discontinuity locations if requested
			if (discontinuities != nullptr && !suspiciousPoints.empty())
			{
				*discontinuities = suspiciousPoints;
			}
			
			return allContinuous;
		}
		bool isMonotonic(Real x1, Real x2, int numPoints)
		{
			Real step = (x2 - x1) / numPoints;
			Real prev = _f(x1 + step);
			if (_f(x1) < _f(x1 + step))
			{
				for (int i = 2; i < numPoints; i++)
				{
					Real curr = _f(x1 + i * step);
					if (curr < prev)
						return false;
					prev = curr;
				}
			}
			else
			{
				for (int i = 2; i < numPoints; i++)
				{
					Real curr = _f(x1 + i * step);
					if (curr > prev)
						return false;
					prev = curr;
				}
			}
			return true;
		}
		Real MinInNPoints(Real x1, Real x2, int numPoints)
		{
			Real step = (x2 - x1) / numPoints;
			Real min = _f(x1);

			for (int i = 1; i <= numPoints; i++)
			{
				Real curr = _f(x1 + i * step);
				if (curr < min)
					min = curr;
			}
			return min;
		}
		Real MaxInNPoints(Real x1, Real x2, int numPoints)
		{
			Real step = (x2 - x1) / numPoints;
			Real max = _f(x1);

			for (int i = 1; i < numPoints; i++)
			{
				Real curr = _f(x1 + i * step);
				if (curr > max)
					max = curr;
			}
			return max;
		}

		//////////////////////////////////////////////////////////////////////////
		// CONTINUITY ANALYSIS METHODS
		//////////////////////////////////////////////////////////////////////////

		// Compute left limit: lim(xâ†’aâ») f(x)
		Real ComputeLeftLimit(Real x, Real eps = 1e-6, int maxSteps = 20) const
		{
			// Approach from the left with decreasing step sizes
			Real h = eps * 100;
			Real prevValue = std::numeric_limits<Real>::quiet_NaN();
			int stableCount = 0;

			for (int i = 0; i < maxSteps; i++)
			{
				Real testPoint = x - h;
				if (!isDefinedAtPoint(testPoint))
					return std::numeric_limits<Real>::quiet_NaN();

				Real value = _f(testPoint);
				
				// Check for convergence
				if (!std::isnan(prevValue))
				{
					Real diff = std::abs(value - prevValue);
					Real tolerance = eps * (1.0 + std::abs(value));
					
					if (diff < tolerance)
					{
						stableCount++;
						if (stableCount >= 3)  // Require 3 stable iterations
							return value;
					}
					else
					{
						stableCount = 0;
					}
				}
				
				prevValue = value;
				h /= 2.0;
			}
			
			return prevValue;  // Best approximation
		}

		// Compute right limit: lim(xâ†’aâº) f(x)
		Real ComputeRightLimit(Real x, Real eps = 1e-6, int maxSteps = 20) const
		{
			// Approach from the right with decreasing step sizes
			Real h = eps * 100;
			Real prevValue = std::numeric_limits<Real>::quiet_NaN();
			int stableCount = 0;

			for (int i = 0; i < maxSteps; i++)
			{
				Real testPoint = x + h;
				if (!isDefinedAtPoint(testPoint))
					return std::numeric_limits<Real>::quiet_NaN();

				Real value = _f(testPoint);
				
				// Check for convergence
				if (!std::isnan(prevValue))
				{
					Real diff = std::abs(value - prevValue);
					Real tolerance = eps * (1.0 + std::abs(value));
					
					if (diff < tolerance)
					{
						stableCount++;
						if (stableCount >= 3)  // Require 3 stable iterations
							return value;
					}
					else
					{
						stableCount = 0;
					}
				}
				
				prevValue = value;
				h /= 2.0;
			}
			
			return prevValue;  // Best approximation
		}

		// Classify a discontinuity at point x
		DiscontinuityPoint ClassifyDiscontinuity(Real x, Real eps = 1e-6) const
		{
			DiscontinuityPoint disc;
			disc.x = x;
			disc.valueAtPoint = isDefinedAtPoint(x) ? _f(x) : std::numeric_limits<Real>::quiet_NaN();
			disc.leftLimit = ComputeLeftLimit(x, eps);
			disc.rightLimit = ComputeRightLimit(x, eps);
			disc.jumpSize = 0.0;

			// Check if limits exist (are finite)
			bool leftLimitExists = !std::isnan(disc.leftLimit) && !std::isinf(disc.leftLimit);
			bool rightLimitExists = !std::isnan(disc.rightLimit) && !std::isinf(disc.rightLimit);
			
			// Check if limits are very large (approaching infinity)
			const Real largeThreshold = 1e10;
			bool leftLimitVeryLarge = std::abs(disc.leftLimit) > largeThreshold;
			bool rightLimitVeryLarge = std::abs(disc.rightLimit) > largeThreshold;

			// Classify discontinuity type
			if (!leftLimitExists && !rightLimitExists)
			{
				disc.type = DiscontinuityType::OSCILLATORY;  // Or could be UNKNOWN
			}
			else if (!leftLimitExists || !rightLimitExists || leftLimitVeryLarge || rightLimitVeryLarge)
			{
				// At least one limit is infinite or doesn't exist
				disc.type = DiscontinuityType::INFINITE;
			}
			else if (std::abs(disc.leftLimit - disc.rightLimit) > eps * 1000 * (1.0 + std::abs(disc.leftLimit)))
			{
				// Limits exist but differ significantly - JUMP discontinuity
				disc.type = DiscontinuityType::JUMP;
				disc.jumpSize = std::abs(disc.rightLimit - disc.leftLimit);
			}
			else
			{
				// Limits exist and agree
				Real limitValue = (disc.leftLimit + disc.rightLimit) / 2.0;
				
				if (!isDefinedAtPoint(x))
				{
					disc.type = DiscontinuityType::REMOVABLE;  // Undefined at point
				}
				else if (std::abs(_f(x) - limitValue) > eps * 1000 * (1.0 + std::abs(limitValue)))
				{
					disc.type = DiscontinuityType::REMOVABLE;  // Value differs from limit
				}
				else
				{
					// This shouldn't happen - if we're here, it should be continuous
					disc.type = DiscontinuityType::UNKNOWN;
				}
			}

			return disc;
		}

		// Find all discontinuities in an interval
		std::vector<DiscontinuityPoint> FindDiscontinuities(Real x1, Real x2, int numPoints = 1000, Real eps = 1e-6)
		{
			std::vector<DiscontinuityPoint> discontinuities;
			Real step = (x2 - x1) / numPoints;

			// Stage 1: Check each sample point for continuity
			std::vector<Real> candidates;
			for (int i = 0; i <= numPoints; i++)
			{
				Real x = x1 + i * step;
				if (!isContinuousAtPoint(x, eps))
				{
					candidates.push_back(x);
				}
			}

			// Stage 2: Check between sample points for rapid changes (potential jumps)
			for (int i = 0; i < numPoints; i++)
			{
				Real x_left = x1 + i * step;
				Real x_right = x1 + (i + 1) * step;
				Real x_mid = (x_left + x_right) / 2.0;

				if (!isDefinedAtPoint(x_left) || !isDefinedAtPoint(x_right))
				{
					// If points aren't defined, check the midpoint
					if (!isContinuousAtPoint(x_mid, eps))
					{
						bool alreadyFound = false;
						for (const auto& candX : candidates)
						{
							if (std::abs(candX - x_mid) < step / 2.0)
							{
								alreadyFound = true;
								break;
							}
						}
						if (!alreadyFound)
							candidates.push_back(x_mid);
					}
					continue;
				}

				Real val_left = _f(x_left);
				Real val_right = _f(x_right);

				// Check for large jump between consecutive points
				// Use a more sensitive threshold for detecting jumps
				Real jumpThreshold = eps * 100;  // More sensitive
				
				// Also check relative changes for functions with large values
				Real maxVal = std::max(std::abs(val_left), std::abs(val_right));
				if (maxVal > 1.0)
					jumpThreshold = std::max(jumpThreshold, maxVal * eps * 10);

				if (std::abs(val_right - val_left) > jumpThreshold)
				{
					// Potential discontinuity - check multiple points in this interval
					for (int j = 1; j <= 4; j++)
					{
						Real x_test = x_left + (j / 5.0) * (x_right - x_left);
						if (!isContinuousAtPoint(x_test, eps))
						{
							// Avoid duplicates
							bool alreadyFound = false;
							for (const auto& candX : candidates)
							{
								if (std::abs(candX - x_test) < step / 5.0)
								{
									alreadyFound = true;
									break;
								}
							}
							if (!alreadyFound)
								candidates.push_back(x_test);
						}
					}
				}
			}

			// Stage 3: Classify each candidate discontinuity
			for (Real x : candidates)
			{
				DiscontinuityPoint disc = ClassifyDiscontinuity(x, eps);
				discontinuities.push_back(disc);
			}

			// Sort by x coordinate
			std::sort(discontinuities.begin(), discontinuities.end(),
				[](const DiscontinuityPoint& a, const DiscontinuityPoint& b) {
					return a.x < b.x;
				});

			return discontinuities;
		}

		// Print detailed continuity analysis for an interval
		void PrintContinuityAnalysis(Real x1, Real x2, int numPoints = 1000, Real eps = 1e-6)
		{
			std::cout << std::fixed << std::setprecision(6);
			std::cout << "\n=== CONTINUITY ANALYSIS ===" << std::endl;
			std::cout << "Interval: [" << x1 << ", " << x2 << "]" << std::endl;
			std::cout << "Sample points: " << numPoints << std::endl;
			std::cout << "Tolerance: " << eps << "\n" << std::endl;

			auto discontinuities = FindDiscontinuities(x1, x2, numPoints, eps);

			if (discontinuities.empty())
			{
				std::cout << "âœ“ Function is CONTINUOUS throughout the interval." << std::endl;
			}
			else
			{
				std::cout << "âœ— Function has " << discontinuities.size() << " discontinuity point(s):\n" << std::endl;

				for (size_t i = 0; i < discontinuities.size(); i++)
				{
					const auto& disc = discontinuities[i];
					std::cout << "Discontinuity #" << (i + 1) << " at x = " << disc.x << std::endl;
					
					// Print type
					std::cout << "  Type: ";
					switch (disc.type)
					{
					case DiscontinuityType::JUMP:
						std::cout << "JUMP (jump size: " << disc.jumpSize << ")" << std::endl;
						break;
					case DiscontinuityType::REMOVABLE:
						std::cout << "REMOVABLE" << std::endl;
						break;
					case DiscontinuityType::INFINITE:
						std::cout << "INFINITE" << std::endl;
						break;
					case DiscontinuityType::OSCILLATORY:
						std::cout << "OSCILLATORY (limit does not exist)" << std::endl;
						break;
					case DiscontinuityType::UNKNOWN:
						std::cout << "UNKNOWN" << std::endl;
						break;
					}

					// Print limits
					std::cout << "  Left limit:  ";
					if (std::isnan(disc.leftLimit))
						std::cout << "undefined (NaN)" << std::endl;
					else if (std::isinf(disc.leftLimit))
						std::cout << (disc.leftLimit > 0 ? "+âˆž" : "-âˆž") << std::endl;
					else
						std::cout << disc.leftLimit << std::endl;

					std::cout << "  Right limit: ";
					if (std::isnan(disc.rightLimit))
						std::cout << "undefined (NaN)" << std::endl;
					else if (std::isinf(disc.rightLimit))
						std::cout << (disc.rightLimit > 0 ? "+âˆž" : "-âˆž") << std::endl;
					else
						std::cout << disc.rightLimit << std::endl;

					std::cout << "  f(" << disc.x << "):      ";
					if (std::isnan(disc.valueAtPoint))
						std::cout << "undefined" << std::endl;
					else if (std::isinf(disc.valueAtPoint))
						std::cout << (disc.valueAtPoint > 0 ? "+âˆž" : "-âˆž") << std::endl;
					else
						std::cout << disc.valueAtPoint << std::endl;

					std::cout << std::endl;
				}
			}
		}
	
		// If given a periodic function, calculates the average period of the roots
		// of the function in the given interval
		Real calcRootsPeriod(Real t1, Real t2, int numPoints)
		{
			Vector<Real> root_brack_x1(10), root_brack_x2(10);
			int	numFoundRoots = RootFinding::FindRootBrackets(_f, t1, t2, numPoints, root_brack_x1, root_brack_x2);

			if( numFoundRoots == 0 )
				return 0.0;

			Vector<Real> roots(numFoundRoots);
			Vector<Real> rootDiffs(numFoundRoots - 1);
			for (int i = 0; i < numFoundRoots; i++)
			{
				roots[i] = RootFinding::FindRootBisection(_f, root_brack_x1[i], root_brack_x2[i], 1e-7);

				if (i > 0)
					rootDiffs[i - 1] = roots[i] - roots[i - 1];
			}

			if( numFoundRoots == 1 )
				return 0.0; // only one root found, no period

			return Statistics::Avg(rootDiffs);
		}
	};

	class RealFunctionComparer
	{
		IRealFunction& _f1;
		IRealFunction& _f2;

	public:
		RealFunctionComparer(IRealFunction& f1, IRealFunction& f2) : _f1(f1), _f2(f2) {}

		Real getAbsDiffSum(Real a, Real b, int numPoints)
		{
			Real step = (b - a) / numPoints;
			Real sum = 0.0;

			for (int i = 0; i < numPoints; i++)
				sum += std::abs(_f1(a + i * step) - _f2(a + i * step));

			return sum;
		}
		Real getAbsDiffAvg(Real a, Real b, int numPoints)
		{
			return getAbsDiffSum(a, b, numPoints) / numPoints;
		}
		Real getAbsDiffMax(Real a, Real b, int numPoints)
		{
			Real step = (b - a) / numPoints;
			Real max = std::abs(_f1(a) - _f2(a));

			for (int i = 0; i < numPoints; i++)
			{
				Real diff = std::abs(_f1(a + i * step) - _f2(a + i * step));
				if (diff > max)
					max = diff;
			}
			return max;
		}
		Real getRelDiffSum(Real a, Real b, int numPoints)
		{
			Real step = (b - a) / numPoints;
			Real sum = 0.0;

			for (int i = 0; i < numPoints; i++)
				if (_f1(a + i * step) != 0.0)
					sum += std::abs(_f1(a + i * step) - _f2(a + i * step)) / std::abs(_f1(a + i * step));

			return sum;
		}
		Real getRelDiffAvg(Real a, Real b, int numPoints)
		{
			return getRelDiffSum(a, b, numPoints) / numPoints;
		}
		Real getRelDiffMax(Real a, Real b, int numPoints)
		{
			Real step = (b - a) / numPoints;
			Real max = 0.0;

			for (int i = 0; i < numPoints; i++)
			{
				if (_f1(a + i * step) != 0.0)
				{
					Real diff = std::abs(_f1(a + i * step) - _f2(a + i * step)) / std::abs(_f1(a + i * step));
					if (diff > max)
						max = diff;
				}
			}
			return max;
		}

		///////////                  Integration measures                /////////
		Real getIntegratedDiff(Real a, Real b, IntegrationMethod method = IntegrationMethod::TRAP)
		{
			return getIntegratedDiff(_f1, _f2, a, b, method);
		}
		static Real getIntegratedDiff(IRealFunction& f1, IRealFunction& f2, Real a, Real b, IntegrationMethod method = IntegrationMethod::TRAP)
		{
			RealFuncDiffHelper helper(f1, f2);

			switch (method)
			{
			case IntegrationMethod::SIMPSON:
				return IntegrateSimpson(helper, a, b);
			case IntegrationMethod::ROMBERG:
				return IntegrateRomberg(helper, a, b);
			default:
				return IntegrateTrap(helper, a, b);
			}
		}

		Real getIntegratedAbsDiff(Real a, Real b, IntegrationMethod method = IntegrationMethod::TRAP)
		{
			return getIntegratedAbsDiff(_f1, _f2, a, b, method);
		}
		static Real getIntegratedAbsDiff(IRealFunction& f1, IRealFunction& f2, Real a, Real b, IntegrationMethod method = IntegrationMethod::TRAP)
		{
			RealFuncAbsDiffHelper helper(f1, f2);

			switch (method)
			{
			case IntegrationMethod::SIMPSON:
				return IntegrateSimpson(helper, a, b);
			case IntegrationMethod::ROMBERG:
				return IntegrateRomberg(helper, a, b);
			default:
				return IntegrateTrap(helper, a, b);
			}
		}

		Real getIntegratedSqrDiff(Real a, Real b, IntegrationMethod method = IntegrationMethod::TRAP)
		{
			return getIntegratedSqrDiff(_f1, _f2, a, b, method);
		}
		static Real getIntegratedSqrDiff(IRealFunction& f1, IRealFunction& f2, Real a, Real b, IntegrationMethod method = IntegrationMethod::TRAP)
		{
			RealFuncDiffSqrHelper helper(f1, f2);

			switch (method)
			{
			case IntegrationMethod::SIMPSON:
				return IntegrateSimpson(helper, a, b);
			case IntegrationMethod::ROMBERG:
				return IntegrateRomberg(helper, a, b);
			default:
				return IntegrateTrap(helper, a, b);
			}
		}
	};
}

///////////////////////////   mml/algorithms/FieldAnalyzers.h   ///////////////////////////




namespace MML
{
	/////////////////////////////////////////////////////////////////////////////////////
	///                           SCALAR FIELD ANALYZER                               ///
	/////////////////////////////////////////////////////////////////////////////////////
	
	// Analyzes properties of scalar fields in 3D space
	class ScalarFieldAnalyzer
	{
		const IScalarFunction<3>& _field;
		
	public:
		ScalarFieldAnalyzer(const IScalarFunction<3>& f) : _field(f) {}

		// Get the gradient at a point
		Vec3Cart GradientAt(const Vec3Cart& pos) const
		{
			return ScalarFieldOperations::GradientCart(_field, pos);
		}

		// Check if gradient is zero at a point (critical point)
		bool IsCriticalPoint(const Vec3Cart& pos, Real tol = 1e-6) const
		{
			Vec3Cart grad = GradientAt(pos);
			return grad.NormL2() < tol;
		}

		// Find approximate critical points by sampling a region
		std::vector<Vec3Cart> FindCriticalPoints(const Vec3Cart& minCorner, const Vec3Cart& maxCorner, 
		                                          int samplesPerDim = 10, Real tol = 1e-4) const
		{
			std::vector<Vec3Cart> criticalPoints;
			
			Real dx = (maxCorner.X() - minCorner.X()) / samplesPerDim;
			Real dy = (maxCorner.Y() - minCorner.Y()) / samplesPerDim;
			Real dz = (maxCorner.Z() - minCorner.Z()) / samplesPerDim;
			
			for (int i = 0; i <= samplesPerDim; ++i) {
				for (int j = 0; j <= samplesPerDim; ++j) {
					for (int k = 0; k <= samplesPerDim; ++k) {
						Vec3Cart pos(minCorner.X() + i * dx,
						             minCorner.Y() + j * dy,
						             minCorner.Z() + k * dz);
						if (IsCriticalPoint(pos, tol)) {
							criticalPoints.push_back(pos);
						}
					}
				}
			}
			return criticalPoints;
		}

		// Compute Laplacian at a point (âˆ‡Â²f = âˆ‚Â²f/âˆ‚xÂ² + âˆ‚Â²f/âˆ‚yÂ² + âˆ‚Â²f/âˆ‚zÂ²)
		Real LaplacianAt(const Vec3Cart& pos) const
		{
			return ScalarFieldOperations::LaplacianCart(_field, pos);
		}

		// Check if field satisfies Laplace equation (harmonic) in a region
		bool IsHarmonic(const Vec3Cart& minCorner, const Vec3Cart& maxCorner, 
		                int samplesPerDim = 5, Real tol = 1e-4) const
		{
			Real dx = (maxCorner.X() - minCorner.X()) / samplesPerDim;
			Real dy = (maxCorner.Y() - minCorner.Y()) / samplesPerDim;
			Real dz = (maxCorner.Z() - minCorner.Z()) / samplesPerDim;
			
			for (int i = 0; i <= samplesPerDim; ++i) {
				for (int j = 0; j <= samplesPerDim; ++j) {
					for (int k = 0; k <= samplesPerDim; ++k) {
						Vec3Cart pos(minCorner.X() + i * dx,
						             minCorner.Y() + j * dy,
						             minCorner.Z() + k * dz);
						if (std::abs(LaplacianAt(pos)) > tol) {
							return false;
						}
					}
				}
			}
			return true;
		}
	};

	/////////////////////////////////////////////////////////////////////////////////////
	///                           VECTOR FIELD ANALYZER                               ///
	/////////////////////////////////////////////////////////////////////////////////////
	
	// Analyzes properties of vector fields in 3D space
	class VectorFieldAnalyzer
	{
		const IVectorFunction<3>& _field;
		
	public:
		VectorFieldAnalyzer(const IVectorFunction<3>& f) : _field(f) {}

		// Get divergence at a point
		Real DivergenceAt(const Vec3Cart& pos) const
		{
			return VectorFieldOperations::DivCart(_field, pos);
		}

		// Get curl at a point
		Vec3Cart CurlAt(const Vec3Cart& pos) const
		{
			return VectorFieldOperations::CurlCart(_field, pos);
		}

		// Check if field is solenoidal (divergence-free) at a point
		bool IsSolenoidalAt(const Vec3Cart& pos, Real tol = 1e-6) const
		{
			return std::abs(DivergenceAt(pos)) < tol;
		}

		// Check if field is irrotational (curl-free) at a point
		bool IsIrrotationalAt(const Vec3Cart& pos, Real tol = 1e-6) const
		{
			return CurlAt(pos).NormL2() < tol;
		}

		// Check if field is solenoidal throughout a region (sampling-based)
		// Solenoidal fields have âˆ‡Â·F = 0 (no sources or sinks)
		bool IsSolenoidal(const Vec3Cart& minCorner, const Vec3Cart& maxCorner, 
		                  int samplesPerDim = 5, Real tol = 1e-4) const
		{
			Real dx = (maxCorner.X() - minCorner.X()) / samplesPerDim;
			Real dy = (maxCorner.Y() - minCorner.Y()) / samplesPerDim;
			Real dz = (maxCorner.Z() - minCorner.Z()) / samplesPerDim;
			
			for (int i = 0; i <= samplesPerDim; ++i) {
				for (int j = 0; j <= samplesPerDim; ++j) {
					for (int k = 0; k <= samplesPerDim; ++k) {
						Vec3Cart pos(minCorner.X() + i * dx,
						             minCorner.Y() + j * dy,
						             minCorner.Z() + k * dz);
						if (!IsSolenoidalAt(pos, tol)) {
							return false;
						}
					}
				}
			}
			return true;
		}

		// Check if field is irrotational throughout a region (sampling-based)
		// Irrotational fields have âˆ‡Ã—F = 0
		bool IsIrrotational(const Vec3Cart& minCorner, const Vec3Cart& maxCorner, 
		                    int samplesPerDim = 5, Real tol = 1e-4) const
		{
			Real dx = (maxCorner.X() - minCorner.X()) / samplesPerDim;
			Real dy = (maxCorner.Y() - minCorner.Y()) / samplesPerDim;
			Real dz = (maxCorner.Z() - minCorner.Z()) / samplesPerDim;
			
			for (int i = 0; i <= samplesPerDim; ++i) {
				for (int j = 0; j <= samplesPerDim; ++j) {
					for (int k = 0; k <= samplesPerDim; ++k) {
						Vec3Cart pos(minCorner.X() + i * dx,
						             minCorner.Y() + j * dy,
						             minCorner.Z() + k * dz);
						if (!IsIrrotationalAt(pos, tol)) {
							return false;
						}
					}
				}
			}
			return true;
		}

		// Check if field is conservative (path-independent)
		// For simply-connected regions, conservative âŸº irrotational
		bool IsConservative(const Vec3Cart& minCorner, const Vec3Cart& maxCorner, 
		                    int samplesPerDim = 5, Real tol = 1e-4) const
		{
			// In simply-connected domains, conservative = irrotational
			return IsIrrotational(minCorner, maxCorner, samplesPerDim, tol);
		}

		// Get maximum divergence magnitude in a region
		Real MaxDivergence(const Vec3Cart& minCorner, const Vec3Cart& maxCorner, 
		                   int samplesPerDim = 5) const
		{
			Real maxDiv = 0.0;
			Real dx = (maxCorner.X() - minCorner.X()) / samplesPerDim;
			Real dy = (maxCorner.Y() - minCorner.Y()) / samplesPerDim;
			Real dz = (maxCorner.Z() - minCorner.Z()) / samplesPerDim;
			
			for (int i = 0; i <= samplesPerDim; ++i) {
				for (int j = 0; j <= samplesPerDim; ++j) {
					for (int k = 0; k <= samplesPerDim; ++k) {
						Vec3Cart pos(minCorner.X() + i * dx,
						             minCorner.Y() + j * dy,
						             minCorner.Z() + k * dz);
						maxDiv = std::max(maxDiv, std::abs(DivergenceAt(pos)));
					}
				}
			}
			return maxDiv;
		}

		// Get maximum curl magnitude in a region
		Real MaxCurlMagnitude(const Vec3Cart& minCorner, const Vec3Cart& maxCorner, 
		                      int samplesPerDim = 5) const
		{
			Real maxCurl = 0.0;
			Real dx = (maxCorner.X() - minCorner.X()) / samplesPerDim;
			Real dy = (maxCorner.Y() - minCorner.Y()) / samplesPerDim;
			Real dz = (maxCorner.Z() - minCorner.Z()) / samplesPerDim;
			
			for (int i = 0; i <= samplesPerDim; ++i) {
				for (int j = 0; j <= samplesPerDim; ++j) {
					for (int k = 0; k <= samplesPerDim; ++k) {
						Vec3Cart pos(minCorner.X() + i * dx,
						             minCorner.Y() + j * dy,
						             minCorner.Z() + k * dz);
						maxCurl = std::max(maxCurl, CurlAt(pos).NormL2());
					}
				}
			}
			return maxCurl;
		}

		// Compute circulation around a closed circular path
		Real CirculationAroundCircle(const Vec3Cart& center, const Vec3Cart& normal, 
		                             Real radius, int numPoints = 100) const
		{
			// Create orthonormal basis for the plane
			Vec3Cart n = normal.GetAsUnitVector();
			Vec3Cart u, v;
			
			// Find a vector not parallel to n
			if (std::abs(n.X()) < 0.9) {
				u = VectorProduct(n, Vec3Cart(1, 0, 0)).GetAsUnitVector();
			} else {
				u = VectorProduct(n, Vec3Cart(0, 1, 0)).GetAsUnitVector();
			}
			v = VectorProduct(n, u);
			
			// Integrate FÂ·dr around the circle
			Real circulation = 0.0;
			Real dtheta = 2.0 * Constants::PI / numPoints;
			
			for (int i = 0; i < numPoints; ++i) {
				Real theta = i * dtheta;
				Real theta_next = (i + 1) * dtheta;
				
				// Current and next points on circle
				Vec3Cart p1 = center + u * (radius * std::cos(theta)) + v * (radius * std::sin(theta));
				Vec3Cart p2 = center + u * (radius * std::cos(theta_next)) + v * (radius * std::sin(theta_next));
				
				// Tangent direction (dr)
				Vec3Cart dr = p2 - p1;
				
				// Midpoint for field evaluation
				Vec3Cart midpoint = (p1 + p2) * 0.5;
				VectorN<Real, 3> F = _field(midpoint);
				
				// Add contribution FÂ·dr
				circulation += F[0] * dr.X() + F[1] * dr.Y() + F[2] * dr.Z();
			}
			
			return circulation;
		}
	};

} // end namespace MML


///////////////////////////   mml/algorithms/MonteCarloIntegration.h   ///////////////////////////




namespace MML
{
    //////////////////////////////////////////////////////////////////////////
    /// @brief Result of a Monte Carlo integration
    /// @note For production code, check error_estimate, variance, and converged!
    //////////////////////////////////////////////////////////////////////////
    struct MonteCarloResult
    {
        Real value;              ///< Estimated integral value
        Real error_estimate;     ///< Statistical error estimate (standard error)
        Real variance;           ///< Sample variance
        size_t samples_used;     ///< Number of samples actually used
        bool converged;          ///< Whether error is below requested tolerance
        
        MonteCarloResult(Real val = 0.0, Real err = 0.0, Real var = 0.0, 
                         size_t n = 0, bool conv = false)
            : value(val), error_estimate(err), variance(var), 
              samples_used(n), converged(conv) {}
        
        /// Implicit conversion to Real for backward compatibility
        /// @warning Silently discards error_estimate, variance, samples_used, and converged!
        /// @deprecated Prefer explicit .value access in new code
        operator Real() const { return value; }
    };
    
    //////////////////////////////////////////////////////////////////////////
    /// @brief Configuration for Monte Carlo integration
    //////////////////////////////////////////////////////////////////////////
    struct MonteCarloConfig
    {
        size_t num_samples = 100000;     ///< Number of random samples
        Real target_error = 1e-3;         ///< Target relative error (for adaptive)
        unsigned int seed = 0;            ///< Random seed (0 = use random_device)
        bool use_antithetic = false;      ///< Use antithetic variates for variance reduction
        
        MonteCarloConfig& samples(size_t n) { num_samples = n; return *this; }
        MonteCarloConfig& error(Real e) { target_error = e; return *this; }
        MonteCarloConfig& randomSeed(unsigned int s) { seed = s; return *this; }
        MonteCarloConfig& antithetic(bool a) { use_antithetic = a; return *this; }
    };

    //////////////////////////////////////////////////////////////////////////
    /// @brief Plain Monte Carlo integrator for N-dimensional integrals
    /// 
    /// Estimates âˆ«âˆ«...âˆ« f(x) dx over a hyperrectangular domain [a,b]^N
    /// using simple random sampling.
    /// 
    /// Error scales as O(1/âˆšN) regardless of dimension - this is the key
    /// advantage over deterministic methods for high dimensions.
    //////////////////////////////////////////////////////////////////////////
    template<int N>
    class MonteCarloIntegrator
    {
    private:
        std::mt19937_64 _rng;
        std::uniform_real_distribution<Real> _uniform{0.0, 1.0};
        
    public:
        /// Initialize with optional seed (0 = random)
        explicit MonteCarloIntegrator(unsigned int seed = 0)
        {
            if (seed == 0) {
                std::random_device rd;
                _rng.seed(rd());
            } else {
                _rng.seed(seed);
            }
        }
        
        /// Set the random seed
        void seed(unsigned int s) { _rng.seed(s); }
        
        /// @brief Integrate f over hyperrectangle [lower, upper]
        /// @param func The N-dimensional scalar function to integrate
        /// @param lower Lower bounds for each dimension
        /// @param upper Upper bounds for each dimension
        /// @param config Integration configuration
        /// @return MonteCarloResult with value, error estimate, and diagnostics
        MonteCarloResult integrate(
            const IScalarFunction<N>& func,
            const VectorN<Real, N>& lower,
            const VectorN<Real, N>& upper,
            const MonteCarloConfig& config = MonteCarloConfig())
        {
            // Compute volume of integration domain
            Real volume = 1.0;
            for (int i = 0; i < N; ++i) {
                volume *= (upper[i] - lower[i]);
            }
            
            if (volume == 0.0) {
                return MonteCarloResult(0.0, 0.0, 0.0, 0, true);
            }
            
            // Reseed if specified
            if (config.seed != 0) {
                _rng.seed(config.seed);
            }
            
            // Accumulate sum and sum of squares for variance estimation
            Real sum = 0.0;
            Real sum_sq = 0.0;
            size_t n = config.num_samples;
            
            VectorN<Real, N> point;
            
            if (config.use_antithetic) {
                // Antithetic variates: use both x and (1-x) to reduce variance
                n = (n / 2) * 2;  // Ensure even number
                for (size_t i = 0; i < n; i += 2) {
                    // Generate random point
                    for (int d = 0; d < N; ++d) {
                        Real u = _uniform(_rng);
                        point[d] = lower[d] + u * (upper[d] - lower[d]);
                    }
                    Real f1 = func(point);
                    
                    // Antithetic point
                    for (int d = 0; d < N; ++d) {
                        point[d] = lower[d] + upper[d] - point[d];  // Reflect
                    }
                    Real f2 = func(point);
                    
                    // Average the pair
                    Real f_avg = 0.5 * (f1 + f2);
                    sum += f_avg;
                    sum_sq += f_avg * f_avg;
                }
                n /= 2;  // We have n/2 averaged samples
            } else {
                // Standard Monte Carlo
                for (size_t i = 0; i < n; ++i) {
                    // Generate uniform random point in [lower, upper]
                    for (int d = 0; d < N; ++d) {
                        Real u = _uniform(_rng);
                        point[d] = lower[d] + u * (upper[d] - lower[d]);
                    }
                    
                    Real f_val = func(point);
                    sum += f_val;
                    sum_sq += f_val * f_val;
                }
            }
            
            // Compute statistics
            Real mean = sum / n;
            Real mean_sq = sum_sq / n;
            Real variance = mean_sq - mean * mean;
            
            // Standard error of the mean
            Real std_error = std::sqrt(variance / n);
            
            // Integral estimate = volume * mean
            Real integral = volume * mean;
            Real error = volume * std_error;
            
            // Check convergence against target
            bool converged = (std::abs(integral) < PrecisionValues<Real>::DivisionSafetyThreshold) || 
                             (error / std::abs(integral) < config.target_error);
            
            return MonteCarloResult(integral, error, variance, 
                                    config.use_antithetic ? n * 2 : n, converged);
        }
        
        /// @brief Convenience overload for unit hypercube [0,1]^N
        MonteCarloResult integrate(
            const IScalarFunction<N>& func,
            const MonteCarloConfig& config = MonteCarloConfig())
        {
            VectorN<Real, N> lower, upper;
            for (int i = 0; i < N; ++i) {
                lower[i] = 0.0;
                upper[i] = 1.0;
            }
            return integrate(func, lower, upper, config);
        }
    };
    
    //////////////////////////////////////////////////////////////////////////
    /// @brief Convenience function for 1D Monte Carlo integration
    //////////////////////////////////////////////////////////////////////////
    inline MonteCarloResult IntegrateMonteCarlo1D(
        const IRealFunction& func,
        Real a, Real b,
        const MonteCarloConfig& config = MonteCarloConfig())
    {
        // Wrap IRealFunction in IScalarFunction<1>
        class Wrapper : public IScalarFunction<1> {
            const IRealFunction& _f;
        public:
            Wrapper(const IRealFunction& f) : _f(f) {}
            Real operator()(const VectorN<Real, 1>& x) const override {
                return _f(x[0]);
            }
        };
        
        Wrapper wrapper(func);
        MonteCarloIntegrator<1> integrator(config.seed);
        
        VectorN<Real, 1> lower, upper;
        lower[0] = a;
        upper[0] = b;
        
        return integrator.integrate(wrapper, lower, upper, config);
    }
    
    //////////////////////////////////////////////////////////////////////////
    /// @brief Stratified sampling Monte Carlo for variance reduction
    /// 
    /// Divides the domain into strata and samples proportionally from each.
    /// Reduces variance when the function varies differently across regions.
    //////////////////////////////////////////////////////////////////////////
    template<int N>
    class StratifiedMonteCarloIntegrator
    {
    private:
        std::mt19937_64 _rng;
        std::uniform_real_distribution<Real> _uniform{0.0, 1.0};
        
    public:
        explicit StratifiedMonteCarloIntegrator(unsigned int seed = 0)
        {
            if (seed == 0) {
                std::random_device rd;
                _rng.seed(rd());
            } else {
                _rng.seed(seed);
            }
        }
        
        void seed(unsigned int s) { _rng.seed(s); }
        
        /// @brief Integrate using stratified sampling
        /// @param func Function to integrate
        /// @param lower Lower bounds
        /// @param upper Upper bounds
        /// @param strata_per_dim Number of strata per dimension (total = strata^N)
        /// @param samples_per_stratum Samples per stratum
        MonteCarloResult integrate(
            const IScalarFunction<N>& func,
            const VectorN<Real, N>& lower,
            const VectorN<Real, N>& upper,
            int strata_per_dim = 10,
            int samples_per_stratum = 10,
            unsigned int seed = 0)
        {
            if (seed != 0) {
                _rng.seed(seed);
            }
            
            // Compute total volume
            Real volume = 1.0;
            VectorN<Real, N> delta;
            for (int d = 0; d < N; ++d) {
                delta[d] = (upper[d] - lower[d]) / strata_per_dim;
                volume *= (upper[d] - lower[d]);
            }
            
            if (volume == 0.0) {
                return MonteCarloResult(0.0, 0.0, 0.0, 0, true);
            }
            
            // Volume per stratum
            Real stratum_volume = volume;
            for (int d = 0; d < N; ++d) {
                stratum_volume /= strata_per_dim;
            }
            
            // Total number of strata
            size_t total_strata = 1;
            for (int d = 0; d < N; ++d) {
                total_strata *= strata_per_dim;
            }
            
            Real sum = 0.0;
            Real sum_sq = 0.0;
            size_t total_samples = 0;
            
            // Iterate over all strata using N-digit base-strata_per_dim counter
            std::vector<int> stratum_idx(N, 0);
            
            for (size_t s = 0; s < total_strata; ++s) {
                // Compute stratum bounds
                VectorN<Real, N> stratum_lower, stratum_upper;
                for (int d = 0; d < N; ++d) {
                    stratum_lower[d] = lower[d] + stratum_idx[d] * delta[d];
                    stratum_upper[d] = stratum_lower[d] + delta[d];
                }
                
                // Sample within stratum
                Real stratum_sum = 0.0;
                VectorN<Real, N> point;
                
                for (int i = 0; i < samples_per_stratum; ++i) {
                    for (int d = 0; d < N; ++d) {
                        Real u = _uniform(_rng);
                        point[d] = stratum_lower[d] + u * delta[d];
                    }
                    stratum_sum += func(point);
                }
                
                Real stratum_mean = stratum_sum / samples_per_stratum;
                sum += stratum_mean;
                sum_sq += stratum_mean * stratum_mean;
                total_samples += samples_per_stratum;
                
                // Increment stratum index (N-digit counter)
                for (int d = 0; d < N; ++d) {
                    stratum_idx[d]++;
                    if (stratum_idx[d] < strata_per_dim) break;
                    stratum_idx[d] = 0;
                }
            }
            
            // Compute result
            Real mean = sum / total_strata;
            Real mean_sq = sum_sq / total_strata;
            Real variance = (mean_sq - mean * mean) / total_strata;
            Real std_error = std::sqrt(variance);
            
            Real integral = volume * mean;
            Real error = volume * std_error;
            
            bool converged = (std::abs(integral) < PrecisionValues<Real>::DivisionSafetyThreshold) || 
                             (error / std::abs(integral) < PrecisionValues<Real>::DefaultToleranceRelaxed);
            
            return MonteCarloResult(integral, error, variance, total_samples, converged);
        }
    };

    //////////////////////////////////////////////////////////////////////////
    /// @brief Hit-or-miss Monte Carlo for computing area/volume
    /// 
    /// Classic method: count fraction of random points that fall inside
    /// a region defined by an indicator function.
    //////////////////////////////////////////////////////////////////////////
    template<int N>
    class HitOrMissIntegrator
    {
    private:
        std::mt19937_64 _rng;
        std::uniform_real_distribution<Real> _uniform{0.0, 1.0};
        
    public:
        explicit HitOrMissIntegrator(unsigned int seed = 0)
        {
            if (seed == 0) {
                std::random_device rd;
                _rng.seed(rd());
            } else {
                _rng.seed(seed);
            }
        }
        
        void seed(unsigned int s) { _rng.seed(s); }
        
        /// @brief Estimate volume of region where indicator(x) returns true
        /// @param indicator Function returning true if point is inside region
        /// @param lower Lower bounds of bounding box
        /// @param upper Upper bounds of bounding box
        /// @param num_samples Number of random samples
        /// @return MonteCarloResult with estimated volume
        MonteCarloResult estimateVolume(
            std::function<bool(const VectorN<Real, N>&)> indicator,
            const VectorN<Real, N>& lower,
            const VectorN<Real, N>& upper,
            size_t num_samples = 100000,
            unsigned int seed = 0)
        {
            if (seed != 0) {
                _rng.seed(seed);
            }
            
            Real bounding_volume = 1.0;
            for (int d = 0; d < N; ++d) {
                bounding_volume *= (upper[d] - lower[d]);
            }
            
            size_t hits = 0;
            VectorN<Real, N> point;
            
            for (size_t i = 0; i < num_samples; ++i) {
                for (int d = 0; d < N; ++d) {
                    Real u = _uniform(_rng);
                    point[d] = lower[d] + u * (upper[d] - lower[d]);
                }
                if (indicator(point)) {
                    ++hits;
                }
            }
            
            Real p = static_cast<Real>(hits) / num_samples;
            Real volume = bounding_volume * p;
            
            // Binomial standard error
            Real variance = p * (1.0 - p);
            Real std_error = std::sqrt(variance / num_samples);
            Real error = bounding_volume * std_error;
            
            return MonteCarloResult(volume, error, variance, num_samples, true);
        }
    };

    //////////////////////////////////////////////////////////////////////////
    /// @brief Classic example: Estimate Ï€ using Monte Carlo
    /// 
    /// Textbook application: estimate Ï€ by computing area of unit circle
    /// inscribed in [-1,1]Â² square.
    //////////////////////////////////////////////////////////////////////////
    inline MonteCarloResult EstimatePi(size_t num_samples = 100000, unsigned int seed = 0)
    {
        HitOrMissIntegrator<2> integrator(seed);
        
        VectorN<Real, 2> lower, upper;
        lower[0] = lower[1] = -1.0;
        upper[0] = upper[1] = 1.0;
        
        auto inside_circle = [](const VectorN<Real, 2>& p) {
            return p[0]*p[0] + p[1]*p[1] <= 1.0;
        };
        
        auto result = integrator.estimateVolume(inside_circle, lower, upper, num_samples, seed);
        
        // Area of circle = Ï€, so result directly gives Ï€ estimate
        return result;
    }
    
    //////////////////////////////////////////////////////////////////////////
    /// @brief Estimate volume of N-dimensional unit ball
    //////////////////////////////////////////////////////////////////////////
    template<int N>
    MonteCarloResult EstimateUnitBallVolume(size_t num_samples = 100000, unsigned int seed = 0)
    {
        HitOrMissIntegrator<N> integrator(seed);
        
        VectorN<Real, N> lower, upper;
        for (int d = 0; d < N; ++d) {
            lower[d] = -1.0;
            upper[d] = 1.0;
        }
        
        auto inside_ball = [](const VectorN<Real, N>& p) {
            Real r_sq = 0.0;
            for (int d = 0; d < N; ++d) {
                r_sq += p[d] * p[d];
            }
            return r_sq <= 1.0;
        };
        
        return integrator.estimateVolume(inside_ball, lower, upper, num_samples, seed);
    }

}  // namespace MML


///////////////////////////   mml/algorithms/Fourier/FFT.h   ///////////////////////////



namespace MML {
	///////////////////////////////////////////////////////////////////////////////////////////
	// FFT - Fast Fourier Transform
	//
	// Cooley-Tukey radix-2 FFT algorithm - O(n log n) complexity
	//
	// Forward transform:  X[k] = Î£_{n=0}^{N-1} x[n] * exp(-2Ï€i*k*n/N)
	// Inverse transform:  x[n] = (1/N) * Î£_{k=0}^{N-1} X[k] * exp(2Ï€i*k*n/N)
	//
	// Requirements:
	// - Input size must be a power of 2 (use NextPowerOfTwo to pad if needed)
	// - For arbitrary sizes, use DFT or zero-pad to next power of 2
	//
	// Algorithm: Decimation-in-time (DIT) with bit-reversal permutation
	//
	// Performance: ~100x faster than DFT for n=1024, ~1000x for n=4096
	///////////////////////////////////////////////////////////////////////////////////////////
	class FFT {
	public:
		///////////////////////////////////////////////////////////////////////////////////////////
		// Core FFT algorithms
		///////////////////////////////////////////////////////////////////////////////////////////

		// In-place FFT (modifies input array)
		// isign: +1 for forward, -1 for inverse (caller must normalize by 1/N)
		static void Transform(Vector<Complex>& data, int isign = 1) {
			int n = data.size();

			if (n == 0) {
				throw std::invalid_argument("FFT::Transform - empty input vector");
			}

			if (!IsPowerOfTwo(n)) {
				throw std::invalid_argument("FFT::Transform - size must be power of 2");
			}

			// Bit-reversal permutation
			BitReversalPermute(data);

			// Cooley-Tukey FFT with iterative decimation-in-time
			int mmax = 1;
			while (n > mmax) {
				int istep = mmax << 1;						// istep = 2 * mmax
				Real theta = -isign * Constants::PI / mmax; // Negative sign for DIT

				// Complex exponential for twiddle factor
				Complex wp(std::cos(theta), std::sin(theta));
				Complex w(1.0, 0.0);

				for (int m = 0; m < mmax; m++) {
					for (int i = m; i < n; i += istep) {
						int j = i + mmax;

						// Butterfly operation
						Complex temp = w * data[j];
						Complex u = data[i];
						data[j] = u - temp;
						data[i] = u + temp;
					}
					w *= wp; // Update twiddle factor
				}
				mmax = istep;
			}
		}

		// Forward FFT: time domain -> frequency domain
		static Vector<Complex> Forward(const Vector<Complex>& data) {
			Vector<Complex> result = data; // Copy input
			Transform(result, 1);
			return result;
		}

		// Inverse FFT: frequency domain -> time domain
		static Vector<Complex> Inverse(const Vector<Complex>& spectrum) {
			Vector<Complex> result = spectrum; // Copy input
			Transform(result, -1);			   // Inverse transform

			// Normalize by 1/N
			Real norm = 1.0 / result.size();
			for (int i = 0; i < result.size(); i++) {
				result[i] *= norm;
			}

			return result;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		// Utility functions
		///////////////////////////////////////////////////////////////////////////////////////////

		// Check if n is a power of 2
		static bool IsPowerOfTwo(int n) { return (n > 0) && ((n & (n - 1)) == 0); }

		// Find next power of 2 >= n
		static int NextPowerOfTwo(int n) {
			if (n <= 0)
				return 1;
			if (IsPowerOfTwo(n))
				return n;

			int power = 1;
			while (power < n) {
				power <<= 1;
			}
			return power;
		}

		// Zero-pad vector to next power of 2
		static Vector<Complex> ZeroPad(const Vector<Complex>& data) {
			int n = data.size();
			int padded_size = NextPowerOfTwo(n);

			if (padded_size == n) {
				return data; // Already power of 2
			}

			Vector<Complex> padded(padded_size, Complex(0.0, 0.0));
			for (int i = 0; i < n; i++) {
				padded[i] = data[i];
			}

			return padded;
		}

		// Compute log2 of n (assumes n is power of 2)
		static int Log2(int n) {
			int log = 0;
			while (n > 1) {
				n >>= 1;
				log++;
			}
			return log;
		}

	private:
		///////////////////////////////////////////////////////////////////////////////////////////
		// Internal helper functions
		///////////////////////////////////////////////////////////////////////////////////////////

		// Bit-reversal permutation (in-place)
		static void BitReversalPermute(Vector<Complex>& data) {
			int n = data.size();
			int j = 0;

			for (int i = 0; i < n - 1; i++) {
				if (i < j) {
					std::swap(data[i], data[j]);
				}

				// Bit-reversal increment
				int k = n >> 1;
				while (k <= j) {
					j -= k;
					k >>= 1;
				}
				j += k;
			}
		}
	};

} // namespace MML


///////////////////////////   mml/algorithms/Fourier/DFT.h   ///////////////////////////



namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // DFT - Discrete Fourier Transform
    //
    // Naive O(nÂ²) implementation of DFT for reference and testing purposes.
    // 
    // Forward transform:  X[k] = Î£_{n=0}^{N-1} x[n] * exp(-2Ï€i*k*n/N)
    // Inverse transform:  x[n] = (1/N) * Î£_{k=0}^{N-1} X[k] * exp(2Ï€i*k*n/N)
    //
    // Features:
    // - Works for any size (not just power of 2)
    // - Reference for FFT correctness testing
    // - Educational value - clear implementation of DFT formula
    //
    // WARNING: This is O(nÂ²) - use FFT for production code!
    ///////////////////////////////////////////////////////////////////////////////////////////
    class DFT
    {
    public:
        // Forward DFT: time domain -> frequency domain
        static Vector<Complex> Forward(const Vector<Complex>& data)
        {
            int N = data.size();
            if (N == 0) {
                throw std::invalid_argument("DFT::Forward - empty input vector");
            }

            Vector<Complex> result(N);
            const Real two_pi = 2.0 * Constants::PI;

            for (int k = 0; k < N; k++)
            {
                Complex sum(0.0, 0.0);
                for (int n = 0; n < N; n++)
                {
                    Real angle = -two_pi * k * n / N;
                    Complex twiddle(std::cos(angle), std::sin(angle));
                    sum += data[n] * twiddle;
                }
                result[k] = sum;
            }

            return result;
        }

        // Forward DFT for real-valued input (converts to complex internally)
        static Vector<Complex> Forward(const Vector<Real>& data)
        {
            int N = data.size();
            if (N == 0) {
                throw std::invalid_argument("DFT::Forward - empty input vector");
            }

            Vector<Complex> complex_data(N);
            for (int i = 0; i < N; i++) {
                complex_data[i] = Complex(data[i], 0.0);
            }

            return Forward(complex_data);
        }

        // Inverse DFT: frequency domain -> time domain
        static Vector<Complex> Inverse(const Vector<Complex>& spectrum)
        {
            int N = spectrum.size();
            if (N == 0) {
                throw std::invalid_argument("DFT::Inverse - empty input vector");
            }

            Vector<Complex> result(N);
            const Real two_pi = 2.0 * Constants::PI;

            for (int n = 0; n < N; n++)
            {
                Complex sum(0.0, 0.0);
                for (int k = 0; k < N; k++)
                {
                    Real angle = two_pi * k * n / N;  // Positive sign for inverse
                    Complex twiddle(std::cos(angle), std::sin(angle));
                    sum += spectrum[k] * twiddle;
                }
                result[n] = sum / static_cast<Real>(N);  // Normalization by 1/N
            }

            return result;
        }

        // Extract real part from inverse DFT (for real-valued signals)
        static Vector<Real> InverseReal(const Vector<Complex>& spectrum)
        {
            Vector<Complex> complex_result = Inverse(spectrum);
            int N = complex_result.size();
            
            Vector<Real> result(N);
            for (int i = 0; i < N; i++) {
                result[i] = complex_result[i].real();
            }

            return result;
        }

        // Utility: Check if DFT size is reasonable (warn if too large)
        static bool IsReasonableSize(int n)
        {
            // DFT is O(nÂ²), so even moderate sizes get slow
            // n=1024 -> ~1M operations
            // n=4096 -> ~16M operations
            return n <= 4096;
        }

        // Utility: Compute single frequency bin (useful for testing)
        static Complex ComputeBin(const Vector<Complex>& data, int k)
        {
            int N = data.size();
            if (k < 0 || k >= N) {
                throw std::invalid_argument("DFT::ComputeBin - invalid frequency bin index");
            }

            Complex sum(0.0, 0.0);
            const Real two_pi = 2.0 * Constants::PI;

            for (int n = 0; n < N; n++)
            {
                Real angle = -two_pi * k * n / N;
                Complex twiddle(std::cos(angle), std::sin(angle));
                sum += data[n] * twiddle;
            }

            return sum;
        }
    };

} // namespace MML


///////////////////////////   mml/algorithms/Fourier/DCT.h   ///////////////////////////


namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // DCT - Discrete Cosine Transform
    //
    // The DCT is widely used in signal processing, image compression (JPEG), and spectral
    // methods. It's closely related to the Discrete Fourier Transform but operates on real
    // values and has better energy compaction properties for many real-world signals.
    //
    // KEY MATHEMATICAL CONNECTION:
    // DCT-II is the transform used to compute Chebyshev polynomial coefficients when
    // sampling at Chebyshev nodes: x_k = cos(Ï€(k+0.5)/N). This is because Chebyshev
    // polynomials T_n(cos Î¸) = cos(nÎ¸) form an orthogonal basis, and the DCT implements
    // the discrete orthogonality relation.
    //
    // TYPES IMPLEMENTED:
    // - DCT-II: Standard "DCT" used in JPEG, spectral methods, Chebyshev approximation
    // - DCT-III: Inverse of DCT-II (scaled)
    // - DST-I: Discrete Sine Transform (boundary conditions for PDEs)
    //
    // APPLICATIONS:
    // - Image/audio compression (JPEG, MP3)
    // - Spectral methods (Chebyshev approximation, PDE solving)
    // - Feature extraction and dimensionality reduction
    // - Lossy data compression
    //
    // PERFORMANCE:
    // Current implementation is O(NÂ²) naive evaluation.
    // TODO: Implement fast DCT via FFT (O(N log N)) for large N.
    //
    // REFERENCE: 
    // - Numerical Recipes 3rd Ed., Chapter 5 (Chebyshev approximation)
    // - Discrete Cosine Transform (Wikipedia)
    // - ISO/IEC JPEG standard
    ///////////////////////////////////////////////////////////////////////////////////////////
    class DCT
    {
    public:
        ///////////////////////////////////////////////////////////////////////////////////////////
        // ForwardII - DCT Type-II (standard "DCT")
        //
        // FORMULA:
        //   X[k] = (2/N) * Î£_{n=0}^{N-1} x[n] * cos(Ï€ * k * (n + 0.5) / N)
        //
        // OUTPUT LENGTH: N (same as input)
        //
        // PROPERTIES:
        // - Most commonly used DCT variant
        // - Used in JPEG compression (8Ã—8 blocks)
        // - Computes Chebyshev polynomial coefficients at Chebyshev nodes
        // - Real-to-real transform
        // - Good energy compaction (most energy in low frequencies)
        //
        // NOTE: Some definitions omit the 2/N factor or apply it differently.
        //       This implementation matches Chebyshev approximation convention.
        //
        // EXAMPLE:
        //   Vector<Real> signal = {1.0, 2.0, 3.0, 4.0};
        //   Vector<Real> dctCoeffs = DCT::ForwardII(signal);
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> ForwardII(const Vector<Real>& data)
        {
            int N = data.size();
            if (N == 0) {
                throw std::invalid_argument("DCT::ForwardII - empty input");
            }

            const Real pi = Constants::PI;
            Real fac = 2.0 / N;
            
            Vector<Real> result(N);
            for (int k = 0; k < N; k++)
            {
                Real sum = 0.0;
                for (int n = 0; n < N; n++)
                {
                    sum += data[n] * std::cos(pi * k * (n + 0.5) / N);
                }
                result[k] = fac * sum;
            }
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // InverseII - DCT Type-III (inverse of DCT-II)
        //
        // FORMULA:
        //   x[n] = X[0]/2 + Î£_{k=1}^{N-1} X[k] * cos(Ï€ * k * (n + 0.5) / N)
        //
        // OUTPUT LENGTH: N (same as input)
        //
        // PROPERTIES:
        // - Inverse transform of DCT-II
        // - Used in JPEG decompression
        // - Reconstructs signal from DCT coefficients
        // - Real-to-real transform
        //
        // NOTE: This is DCT-III scaled to be the exact inverse of our ForwardII.
        //       The first coefficient is halved to maintain orthogonality.
        //
        // EXAMPLE:
        //   Vector<Real> coeffs = DCT::ForwardII(signal);
        //   Vector<Real> recovered = DCT::InverseII(coeffs);
        //   // recovered â‰ˆ signal (within numerical precision)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> InverseII(const Vector<Real>& coefficients)
        {
            int N = coefficients.size();
            if (N == 0) {
                throw std::invalid_argument("DCT::InverseII - empty input");
            }

            const Real pi = Constants::PI;
            
            Vector<Real> result(N);
            for (int n = 0; n < N; n++)
            {
                // First term: DC component (halved for orthogonality)
                Real sum = coefficients[0] / 2.0;
                
                // Remaining terms
                for (int k = 1; k < N; k++)
                {
                    sum += coefficients[k] * std::cos(pi * k * (n + 0.5) / N);
                }
                result[n] = sum;
            }
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // ForwardDST - DST Type-I (Discrete Sine Transform)
        //
        // FORMULA:
        //   X[k] = sqrt(2/(N+1)) * Î£_{n=0}^{N-1} x[n] * sin(Ï€ * (k+1) * (n+1) / (N+1))
        //
        // OUTPUT LENGTH: N (same as input)
        //
        // PROPERTIES:
        // - Uses orthonormal basis (self-adjoint transform)
        // - Used for problems with Dirichlet boundary conditions (x[0] = x[N+1] = 0)
        // - Common in PDE solving (finite difference methods)
        // - Sine basis instead of cosine
        // - Real-to-real transform
        //
        // APPLICATIONS:
        // - Solving Poisson equation with boundary conditions
        // - Heat equation on finite domains
        // - Wave equation discretization
        //
        // EXAMPLE:
        //   Vector<Real> u = {0.5, 1.0, 0.5};  // Interior points
        //   Vector<Real> dstCoeffs = DCT::ForwardDST(u);
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> ForwardDST(const Vector<Real>& data)
        {
            int N = data.size();
            if (N == 0) {
                throw std::invalid_argument("DCT::ForwardDST - empty input");
            }

            const Real pi = Constants::PI;
            Real norm = std::sqrt(2.0 / (N + 1));  // Orthonormal basis
            
            Vector<Real> result(N);
            for (int k = 0; k < N; k++)
            {
                Real sum = 0.0;
                for (int n = 0; n < N; n++)
                {
                    sum += data[n] * std::sin(pi * (k + 1) * (n + 1) / (N + 1));
                }
                result[k] = norm * sum;
            }
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // InverseDST - DST Type-I inverse
        //
        // FORMULA:
        //   x[n] = sqrt(2/(N+1)) * Î£_{k=0}^{N-1} X[k] * sin(Ï€ * (k+1) * (n+1) / (N+1))
        //
        // PROPERTIES:
        // - DST-I with orthonormal basis is self-adjoint (its own inverse)
        // - Used to reconstruct signal from DST coefficients
        //
        // EXAMPLE:
        //   Vector<Real> coeffs = DCT::ForwardDST(data);
        //   Vector<Real> recovered = DCT::InverseDST(coeffs);
        //   // recovered â‰ˆ data
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> InverseDST(const Vector<Real>& coefficients)
        {
            // DST-I with orthonormal basis is self-adjoint - inverse is the same as forward
            return ForwardDST(coefficients);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // HELPER: Verify DCT-II/III round-trip
        //
        // Tests that InverseII(ForwardII(x)) â‰ˆ x within tolerance
        ///////////////////////////////////////////////////////////////////////////////////////////
        static bool VerifyRoundTrip(const Vector<Real>& data, Real tolerance = 1e-12)
        {
            Vector<Real> coeffs = ForwardII(data);
            Vector<Real> recovered = InverseII(coeffs);
            
            if (recovered.size() != data.size()) return false;
            
            for (int i = 0; i < data.size(); i++)
            {
                if (std::abs(recovered[i] - data[i]) > tolerance)
                    return false;
            }
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // FUTURE ENHANCEMENTS:
        //
        // 1. Fast DCT via FFT (O(N log N))
        //    DCT can be computed using FFT with pre/post-processing
        //    See: Makhoul, "A fast cosine transform in one and two dimensions" (1980)
        //
        // 2. 2D DCT for image compression
        //    static Matrix<Real> Forward2D(const Matrix<Real>& image);
        //    static Matrix<Real> Inverse2D(const Matrix<Real>& dctImage);
        //    Apply 1D DCT to rows, then columns (separable transform)
        //
        // 3. Other DCT types (DCT-IV used in MDCT for audio)
        //    static Vector<Real> ForwardIV(const Vector<Real>& data);
        //
        // 4. Block DCT (8Ã—8 blocks for JPEG)
        //    static Matrix<Real> BlockDCT(const Matrix<Real>& image, int blockSize = 8);
        ///////////////////////////////////////////////////////////////////////////////////////////
    };

} // namespace MML


///////////////////////////   mml/algorithms/Fourier/RealFFT.h   ///////////////////////////



namespace MML 
{
	///////////////////////////////////////////////////////////////////////////////////////////
	// RealFFT - Optimized FFT for real-valued data using conjugate symmetry
	//
	// PERFORMANCE:
	//   - ~2x faster than complex FFT for real data
	//   - Uses packed storage format (n real -> n/2+1 complex)
	//
	// THEORY:
	//   Real signals have conjugate-symmetric spectra: X[k] = X*[N-k]
	//   Only need to compute/store half the spectrum + DC and Nyquist terms
	//
	// REFERENCE: Numerical Recipes fourier.h realft()
	///////////////////////////////////////////////////////////////////////////////////////////

	class RealFFT {
	public:
		///////////////////////////////////////////////////////////////////////////////////////////
		// Forward - Real to complex transform
		//
		// INPUT:  n real samples
		// OUTPUT: n/2+1 complex frequency components
		//         spectrum[0] = DC component (k=0)
		//         spectrum[k] = positive frequencies (k=1 to n/2-1)
		//         spectrum[n/2] = Nyquist frequency (k=n/2)
		//
		// CONJUGATE SYMMETRY:
		//   For k > n/2: X[k] = conj(X[n-k])
		//   This is implicit - we don't store negative frequencies
		///////////////////////////////////////////////////////////////////////////////////////////
		static Vector<Complex> Forward(const Vector<Real>& data) {
			int n = data.size();
			if (n < 2 || !FFT::IsPowerOfTwo(n))
				throw std::invalid_argument("RealFFT::Forward requires power-of-2 size >= 2");

			// Pack real data into complex vector (treating pairs as complex numbers)
			int n2 = n / 2;
			Vector<Complex> temp(n2);
			for (int i = 0; i < n2; i++)
				temp[i] = Complex(data[2 * i], data[2 * i + 1]);

			// Complex FFT of packed data
			FFT::Transform(temp, 1);

			// Unpack using conjugate symmetry to get real FFT result
			Vector<Complex> result(n2 + 1);

			// DC component (sum of even + i*sum of odd)
			result[0] = Complex(temp[0].real() + temp[0].imag(), 0);

			// Nyquist component (difference of even - i*odd)
			result[n2] = Complex(temp[0].real() - temp[0].imag(), 0);

			// Middle components using symmetry relations
			Real theta = -Constants::PI / n2; // -pi/n for positive frequencies
			for (int k = 1; k < n2; k++) {
				Complex w = std::exp(Complex(0, k * theta)); // exp(-i*2*pi*k/n)

				// Get symmetric pairs
				Complex z1 = temp[k];
				Complex z2 = std::conj(temp[n2 - k]);

				// Even part (real DFT of even samples)
				Complex even = Real(0.5) * (z1 + z2);

				// Odd part (real DFT of odd samples)
				Complex odd = Complex(0, -0.5) * (z1 - z2);

				// Combine with twiddle factor
				result[k] = even + w * odd;
			}

			return result;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		// Inverse - Complex to real transform
		//
		// INPUT:  n/2+1 complex frequency components (conjugate-symmetric spectrum)
		// OUTPUT: n real samples
		//
		// NOTE: Input must satisfy conjugate symmetry for real output
		///////////////////////////////////////////////////////////////////////////////////////////
		static Vector<Real> Inverse(const Vector<Complex>& spectrum) {
			int n2p1 = spectrum.size();
			int n2 = n2p1 - 1;
			int n = 2 * n2;

			if (n2 < 1)
				throw std::invalid_argument("RealFFT::Inverse requires spectrum size >= 2");

			// Pack spectrum back into complex vector using reverse process
			Vector<Complex> temp(n2);

			// Reconstruct DC and Nyquist into temp[0]
			temp[0] =
				Complex(Real(0.5) * (spectrum[0].real() + spectrum[n2].real()), Real(0.5) * (spectrum[0].real() - spectrum[n2].real()));

			// Reconstruct middle components
			Real theta = Constants::PI / n2; // pi/n for inverse
			for (int k = 1; k < n2; k++) {
				Complex w = std::exp(Complex(0, k * theta)); // exp(i*2*pi*k/n)

				// Get spectrum values and conjugate pair
				Complex z1 = spectrum[k];
				Complex z2 = std::conj(spectrum[n2 - k]);

				// Even and odd parts
				Complex even = Real(0.5) * (z1 + z2);
				Complex odd = Complex(0, 0.5) * (z1 - z2);

				// Recombine
				temp[k] = even + w * odd;
			}

			// Inverse complex FFT
			FFT::Transform(temp, -1);

			// Unpack complex to real (interleaved real/imag become consecutive reals)
			Vector<Real> result(n);
			for (int i = 0; i < n2; i++) {
				result[2 * i] = temp[i].real();
				result[2 * i + 1] = temp[i].imag();
			}

			// Apply normalization
			for (int i = 0; i < n; i++)
				result[i] /= n2;

			return result;
		}

		///////////////////////////////////////////////////////////////////////////////////////////
		// In-place transform (memory-efficient packed format)
		//
		// INPUT/OUTPUT: data vector
		//   isign =  1: Real->Complex (input: n real, output: packed format)
		//   isign = -1: Complex->Real (input: packed format, output: n real)
		//
		// PACKED FORMAT (NR convention):
		//   data[0] = DC component
		//   data[1] = Nyquist component
		//   data[2*k] = real part of X[k] for k=1..n/2-1
		//   data[2*k+1] = imag part of X[k] for k=1..n/2-1
		///////////////////////////////////////////////////////////////////////////////////////////
		static void Transform(Vector<Real>& data, int isign = 1) {
			int n = data.size();
			if (n < 2 || !FFT::IsPowerOfTwo(n))
				throw std::invalid_argument("RealFFT::Transform requires power-of-2 size >= 2");

			int n2 = n / 2;

			// Pack into complex and do complex FFT
			Vector<Complex> temp(n2);
			for (int i = 0; i < n2; i++)
				temp[i] = Complex(data[2 * i], data[2 * i + 1]);

			FFT::Transform(temp, isign);

			if (isign == 1) // Real to complex
			{
				// Unpack into NR format
				data[0] = temp[0].real() + temp[0].imag(); // DC
				data[1] = temp[0].real() - temp[0].imag(); // Nyquist

				Real theta = -Constants::PI / n2;
				for (int k = 1; k < n2; k++) {
					Complex w = std::exp(Complex(0, k * theta));
					Complex z1 = temp[k];
					Complex z2 = std::conj(temp[n2 - k]);

					Complex even = Real(0.5) * (z1 + z2);
					Complex odd = Complex(0, -0.5) * (z1 - z2);
					Complex result = even + w * odd;

					data[2 * k] = result.real();
					data[2 * k + 1] = result.imag();
				}
			} else // Complex to real (inverse)
			{
				// Reconstruct temp from packed format
				temp[0] = Complex(Real(0.5) * (data[0] + data[1]), Real(0.5) * (data[0] - data[1]));

				Real theta = Constants::PI / n2;
				for (int k = 1; k < n2; k++) {
					Complex spectrum_k(data[2 * k], data[2 * k + 1]);
					Complex spectrum_nk(data[n - 2 * k], -data[n - 2 * k + 1]); // Conjugate

					Complex w = std::exp(Complex(0, k * theta));
					Complex even = Real(0.5) * (spectrum_k + spectrum_nk);
					Complex odd = Complex(0, 0.5) * (spectrum_k - spectrum_nk);

					temp[k] = even + w * odd;
				}

				FFT::Transform(temp, -1);

				// Unpack and normalize
				for (int i = 0; i < n2; i++) {
					data[2 * i] = temp[i].real() / n2;
					data[2 * i + 1] = temp[i].imag() / n2;
				}
			}
		}
	};

} // namespace MML


///////////////////////////   mml/algorithms/Fourier/Correlation.h   ///////////////////////////





namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // Correlation - Fast correlation using FFT
    //
    // CORRELATION THEOREM:
    //   corr(x,y)[k] = Î£ x[i] * conj(y[i+k])  (discrete cross-correlation)
    //   corr(x,y) = IFFT(FFT(x) âŠ™ conj(FFT(y)))
    //
    // COMPLEXITY: O(n log n) using FFT vs O(nÂ²) naive
    //
    // APPLICATIONS:
    //   - Signal processing (template matching, echo detection)
    //   - Time series analysis (lag detection, similarity)
    //   - Image processing (pattern recognition)
    //   - Neuroscience (spike train analysis)
    ///////////////////////////////////////////////////////////////////////////////////////////
    class Correlation
    {
    public:
        ///////////////////////////////////////////////////////////////////////////////////////////
        // Cross - Cross-correlation of two real signals
        //
        // OUTPUT LENGTH: n + m - 1 (same as linear convolution)
        //   - Negative lags: [0, m-2]
        //   - Zero lag: [m-1]
        //   - Positive lags: [m, n+m-2]
        //
        // ALGORITHM:
        //   Correlation = Convolution with time-reversed signal
        //   1. Reverse y â†’ y_rev
        //   2. Convolve(x, y_rev) using FFT
        //
        // NOTE: Result is NOT symmetric unless x == y
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> Cross(const Vector<Real>& x, const Vector<Real>& y)
        {
            int n = x.size();
            int m = y.size();
            if (n == 0 || m == 0)
                throw std::invalid_argument("Correlation::Cross requires non-empty inputs");
            
            // Reverse y for correlation (correlation = convolution with reversed y)
            Vector<Real> y_reversed(m);
            for (int i = 0; i < m; i++)
                y_reversed[i] = y[m - 1 - i];
            
            // Output length same as linear convolution
            int result_length = n + m - 1;
            int fft_size = FFT::NextPowerOfTwo(result_length);
            
            // Convert to complex and zero-pad
            Vector<Complex> x_complex(fft_size, Complex(0, 0));
            Vector<Complex> y_complex(fft_size, Complex(0, 0));
            for (int i = 0; i < n; i++)
                x_complex[i] = Complex(x[i], 0);
            for (int i = 0; i < m; i++)
                y_complex[i] = Complex(y_reversed[i], 0);
            
            // FFT both signals
            FFT::Transform(x_complex, 1);
            FFT::Transform(y_complex, 1);
            
            // Element-wise multiply (no conjugate needed - already reversed y)
            for (int i = 0; i < fft_size; i++)
                x_complex[i] *= y_complex[i];
            
            // IFFT
            FFT::Transform(x_complex, -1);
            
            // Normalize by 1/N
            Real norm = 1.0 / fft_size;
            for (int i = 0; i < fft_size; i++)
                x_complex[i] *= norm;
            
            // Extract real part (result_length elements)
            Vector<Real> result(result_length);
            for (int i = 0; i < result_length; i++)
                result[i] = x_complex[i].real();
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Cross (complex version)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Complex> Cross(const Vector<Complex>& x, const Vector<Complex>& y)
        {
            int n = x.size();
            int m = y.size();
            if (n == 0 || m == 0)
                throw std::invalid_argument("Correlation::Cross requires non-empty inputs");
            
            // Reverse y for correlation
            Vector<Complex> y_reversed(m);
            for (int i = 0; i < m; i++)
                y_reversed[i] = y[m - 1 - i];
            
            int result_length = n + m - 1;
            int fft_size = FFT::NextPowerOfTwo(result_length);
            
            // Zero-pad
            Vector<Complex> x_padded(fft_size, Complex(0, 0));
            Vector<Complex> y_padded(fft_size, Complex(0, 0));
            for (int i = 0; i < n; i++)
                x_padded[i] = x[i];
            for (int i = 0; i < m; i++)
                y_padded[i] = y_reversed[i];
            
            // FFT
            FFT::Transform(x_padded, 1);
            FFT::Transform(y_padded, 1);
            
            // Multiply (no conjugate needed - already reversed)
            for (int i = 0; i < fft_size; i++)
                x_padded[i] *= y_padded[i];
            
            // IFFT
            FFT::Transform(x_padded, -1);
            
            // Normalize
            Real norm = 1.0 / fft_size;
            for (int i = 0; i < fft_size; i++)
                x_padded[i] *= norm;
            
            // Extract result
            Vector<Complex> result(result_length);
            for (int i = 0; i < result_length; i++)
                result[i] = x_padded[i];
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Auto - Auto-correlation (correlation of signal with itself)
        //
        // PROPERTIES:
        //   - Symmetric around zero lag
        //   - Maximum at zero lag (lag = n-1 in output)
        //   - Decays as lag increases (for non-periodic signals)
        //
        // APPLICATIONS:
        //   - Periodicity detection
        //   - Signal energy estimation
        //   - Power spectral density (Wiener-Khinchin theorem)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> Auto(const Vector<Real>& x)
        {
            return Cross(x, x);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // CrossNormalized - Normalized cross-correlation coefficient
        //
        // RANGE: [-1, 1]
        //   -1: Perfect anti-correlation
        //    0: No correlation
        //   +1: Perfect correlation
        //
        // FORMULA:
        //   Ï[k] = corr(x,y)[k] / sqrt(E_x * E_y)
        //   where E_x = Î£ x[i]Â², E_y = Î£ y[i]Â²
        //
        // APPLICATIONS:
        //   - Template matching (find best lag for similarity)
        //   - Signal comparison (measure similarity independent of scale)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> CrossNormalized(const Vector<Real>& x, const Vector<Real>& y)
        {
            // Compute raw cross-correlation
            Vector<Real> corr = Cross(x, y);
            
            // Compute signal energies
            Real energy_x = 0.0;
            Real energy_y = 0.0;
            for (int i = 0; i < x.size(); i++)
                energy_x += x[i] * x[i];
            for (int i = 0; i < y.size(); i++)
                energy_y += y[i] * y[i];
            
            // Normalize
            Real norm = std::sqrt(energy_x * energy_y);
            if (norm > 1e-10)  // Avoid division by zero
            {
                for (int i = 0; i < corr.size(); i++)
                    corr[i] /= norm;
            }
            
            return corr;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // FindPeakLag - Find lag with maximum correlation
        //
        // RETURNS: Lag index where correlation is maximum
        //
        // NOTE: For output of length n+m-1:
        //   - Lag = 0 is at index n-1
        //   - Negative lags: indices [0, n-2]
        //   - Positive lags: indices [n, n+m-2]
        ///////////////////////////////////////////////////////////////////////////////////////////
        static int FindPeakLag(const Vector<Real>& correlation)
        {
            if (correlation.size() == 0)
                throw std::invalid_argument("Correlation::FindPeakLag requires non-empty input");
            
            int max_idx = 0;
            Real max_val = correlation[0];
            for (int i = 1; i < correlation.size(); i++)
            {
                if (correlation[i] > max_val)
                {
                    max_val = correlation[i];
                    max_idx = i;
                }
            }
            
            return max_idx;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // ConvertLagToIndex - Convert lag value to index in correlation output
        //
        // For signals x[n] and y[m]:
        //   - Output length: n + m - 1
        //   - Zero lag at: index n - 1
        //   - Negative lag k: index (n-1) - k
        //   - Positive lag k: index (n-1) + k
        ///////////////////////////////////////////////////////////////////////////////////////////
        static int ConvertLagToIndex(int lag, int x_size)
        {
            return (x_size - 1) + lag;
        }
    };

} // namespace MML


///////////////////////////   mml/algorithms/Fourier/Convolution.h   ///////////////////////////


namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // Convolution - Fast convolution and deconvolution via FFT
    //
    // CONVOLUTION THEOREM:
    //   x * y = IFFT(FFT(x) âŠ™ FFT(y))
    //
    // PERFORMANCE:
    //   - Direct convolution: O(nÂ²)
    //   - FFT convolution: O(n log n)
    //   - Speedup: ~100x for n=1024
    //
    // REFERENCE: Numerical Recipes convlv.h
    ///////////////////////////////////////////////////////////////////////////////////////////

    class Convolution
    {
    public:
        ///////////////////////////////////////////////////////////////////////////////////////////
        // Linear - Linear convolution (standard discrete convolution)
        //
        // OUTPUT LENGTH: n + m - 1
        //   - For signal of length n and kernel of length m
        //   - Produces complete convolution with no wraparound
        //
        // ALGORITHM:
        //   1. Zero-pad both to next power of 2 >= n+m-1
        //   2. FFT both
        //   3. Element-wise multiply
        //   4. IFFT
        //   5. Extract result (first n+m-1 samples)
        //
        // APPLICATIONS:
        //   - Filtering (FIR filters)
        //   - Smoothing
        //   - Edge detection
        //   - Pattern matching
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> Linear(const Vector<Real>& signal, const Vector<Real>& kernel)
        {
            int n = signal.size();
            int m = kernel.size();
            if (n == 0 || m == 0)
                throw std::invalid_argument("Convolution::Linear requires non-empty inputs");
            
            int result_length = n + m - 1;
            int fft_size = FFT::NextPowerOfTwo(result_length);
            
            // Convert to complex and zero-pad
            Vector<Complex> signal_complex(fft_size, Complex(0, 0));
            Vector<Complex> kernel_complex(fft_size, Complex(0, 0));
            for (int i = 0; i < n; i++)
                signal_complex[i] = Complex(signal[i], 0);
            for (int i = 0; i < m; i++)
                kernel_complex[i] = Complex(kernel[i], 0);
            
            // FFT both
            FFT::Transform(signal_complex, 1);
            FFT::Transform(kernel_complex, 1);
            
            // Element-wise multiply
            for (int i = 0; i < fft_size; i++)
                signal_complex[i] *= kernel_complex[i];
            
            // IFFT
            FFT::Transform(signal_complex, -1);
            
            // Normalize by 1/N
            Real norm = 1.0 / fft_size;
            for (int i = 0; i < fft_size; i++)
                signal_complex[i] *= norm;
            
            // Extract real part (first n+m-1 samples)
            Vector<Real> result(result_length);
            for (int i = 0; i < result_length; i++)
                result[i] = signal_complex[i].real();
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Linear (complex version)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Complex> Linear(const Vector<Complex>& x, const Vector<Complex>& y)
        {
            int n = x.size();
            int m = y.size();
            if (n == 0 || m == 0)
                throw std::invalid_argument("Convolution::Linear requires non-empty inputs");
            
            int result_length = n + m - 1;
            int fft_size = FFT::NextPowerOfTwo(result_length);
            
            // Zero-pad
            Vector<Complex> x_padded(fft_size, Complex(0, 0));
            Vector<Complex> y_padded(fft_size, Complex(0, 0));
            for (int i = 0; i < n; i++)
                x_padded[i] = x[i];
            for (int i = 0; i < m; i++)
                y_padded[i] = y[i];
            
            // FFT
            FFT::Transform(x_padded, 1);
            FFT::Transform(y_padded, 1);
            
            // Multiply
            for (int i = 0; i < fft_size; i++)
                x_padded[i] *= y_padded[i];
            
            // IFFT
            FFT::Transform(x_padded, -1);
            
            // Normalize by 1/N
            Real norm = 1.0 / fft_size;
            for (int i = 0; i < fft_size; i++)
                x_padded[i] *= norm;
            
            // Extract result
            Vector<Complex> result(result_length);
            for (int i = 0; i < result_length; i++)
                result[i] = x_padded[i];
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Circular - Circular convolution (periodic convolution)
        //
        // OUTPUT LENGTH: max(n, m)
        //   - Same length as longer input
        //   - Wraparound at boundaries (periodic)
        //
        // ALGORITHM:
        //   1. Pad both to same length (next power of 2)
        //   2. FFT both
        //   3. Element-wise multiply
        //   4. IFFT
        //
        // APPLICATIONS:
        //   - Periodic signals
        //   - Spectral analysis
        //   - Fast polynomial multiplication (mod x^n - 1)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> Circular(const Vector<Real>& x, const Vector<Real>& y)
        {
            int n = x.size();
            int m = y.size();
            if (n == 0 || m == 0)
                throw std::invalid_argument("Convolution::Circular requires non-empty inputs");
            
            int max_len = std::max(n, m);
            int fft_size = FFT::NextPowerOfTwo(max_len);
            
            // Convert to complex and zero-pad
            Vector<Complex> x_complex(fft_size, Complex(0, 0));
            Vector<Complex> y_complex(fft_size, Complex(0, 0));
            for (int i = 0; i < n; i++)
                x_complex[i] = Complex(x[i], 0);
            for (int i = 0; i < m; i++)
                y_complex[i] = Complex(y[i], 0);
            
            // FFT both
            FFT::Transform(x_complex, 1);
            FFT::Transform(y_complex, 1);
            
            // Element-wise multiply
            for (int i = 0; i < fft_size; i++)
                x_complex[i] *= y_complex[i];
            
            // IFFT
            FFT::Transform(x_complex, -1);
            
            // Normalize by 1/N
            Real norm = 1.0 / fft_size;
            for (int i = 0; i < fft_size; i++)
                x_complex[i] *= norm;
            
            // Extract real part (length = max_len)
            Vector<Real> result(max_len);
            for (int i = 0; i < max_len; i++)
                result[i] = x_complex[i].real();
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Deconvolve - Inverse filtering (deconvolution)
        //
        // PROBLEM: Given y = x * h, recover x given y and h
        // SOLUTION: x = IFFT(FFT(y) / FFT(h))
        //
        // WARNING:
        //   - Unstable if kernel has small frequency components
        //   - May amplify noise
        //   - Consider regularization for real applications
        //
        // PARAMETERS:
        //   signal - Convolved signal y
        //   kernel - Known kernel h
        //   epsilon - Regularization parameter (prevents division by zero)
        //
        // APPLICATIONS:
        //   - Image deblurring
        //   - Channel equalization
        //   - System identification
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> Deconvolve(const Vector<Real>& signal, 
                                      const Vector<Real>& kernel,
                                      Real epsilon = 1e-10)
        {
            int n = signal.size();
            int m = kernel.size();
            if (n == 0 || m == 0)
                throw std::invalid_argument("Convolution::Deconvolve requires non-empty inputs");
            
            // Use FFT size matching signal length
            int fft_size = FFT::NextPowerOfTwo(n);
            
            // Convert to complex and zero-pad
            Vector<Complex> signal_complex(fft_size, Complex(0, 0));
            Vector<Complex> kernel_complex(fft_size, Complex(0, 0));
            for (int i = 0; i < n; i++)
                signal_complex[i] = Complex(signal[i], 0);
            for (int i = 0; i < m; i++)
                kernel_complex[i] = Complex(kernel[i], 0);
            
            // FFT both
            FFT::Transform(signal_complex, 1);
            FFT::Transform(kernel_complex, 1);
            
            // Divide with regularization
            for (int i = 0; i < fft_size; i++)
            {
                Real kernel_mag_sq = std::norm(kernel_complex[i]);
                if (kernel_mag_sq > epsilon)
                    signal_complex[i] /= kernel_complex[i];
                else
                    signal_complex[i] = Complex(0, 0);  // Zero out unstable frequencies
            }
            
            // IFFT
            FFT::Transform(signal_complex, -1);
            
            // Normalize by 1/N
            Real norm = 1.0 / fft_size;
            for (int i = 0; i < fft_size; i++)
                signal_complex[i] *= norm;
            
            // Extract real part
            Vector<Real> result(n);
            for (int i = 0; i < n; i++)
                result[i] = signal_complex[i].real();
            
            return result;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Deconvolve (complex version)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Complex> Deconvolve(const Vector<Complex>& signal,
                                         const Vector<Complex>& kernel,
                                         Real epsilon = 1e-10)
        {
            int n = signal.size();
            int m = kernel.size();
            if (n == 0 || m == 0)
                throw std::invalid_argument("Convolution::Deconvolve requires non-empty inputs");
            
            int fft_size = FFT::NextPowerOfTwo(n);
            
            // Zero-pad
            Vector<Complex> signal_padded(fft_size, Complex(0, 0));
            Vector<Complex> kernel_padded(fft_size, Complex(0, 0));
            for (int i = 0; i < n; i++)
                signal_padded[i] = signal[i];
            for (int i = 0; i < m; i++)
                kernel_padded[i] = kernel[i];
            
            // FFT
            FFT::Transform(signal_padded, 1);
            FFT::Transform(kernel_padded, 1);
            
            // Divide with regularization
            for (int i = 0; i < fft_size; i++)
            {
                Real kernel_mag_sq = std::norm(kernel_padded[i]);
                if (kernel_mag_sq > epsilon)
                    signal_padded[i] /= kernel_padded[i];
                else
                    signal_padded[i] = Complex(0, 0);
            }
            
            // IFFT
            FFT::Transform(signal_padded, -1);
            
            // Normalize by 1/N
            Real norm = 1.0 / fft_size;
            for (int i = 0; i < fft_size; i++)
                signal_padded[i] *= norm;
            
            // Extract result
            Vector<Complex> result(n);
            for (int i = 0; i < n; i++)
                result[i] = signal_padded[i];
            
            return result;
        }
    };

} // namespace MML


///////////////////////////   mml/algorithms/Fourier/Windowing.h   ///////////////////////////





namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // Windows - Collection of window functions for spectral analysis
    //
    // PURPOSE:
    //   Window functions reduce spectral leakage in FFT by tapering signal edges.
    //   They smooth the transition to zero at signal boundaries, minimizing artifacts.
    //
    // APPLICATIONS:
    //   - FFT analysis (reduce spectral leakage)
    //   - Filter design (finite impulse response filters)
    //   - Audio processing (smooth transitions)
    //   - Signal segmentation (overlapping windows)
    //
    // TRADE-OFFS:
    //   - Main lobe width: Narrower = better frequency resolution
    //   - Side lobe level: Lower = less spectral leakage
    //   - Each window optimizes different characteristics
    //
    // REFERENCE: Numerical Recipes spectrum.h, Harris (1978) "On the use of windows"
    ///////////////////////////////////////////////////////////////////////////////////////////
    namespace Windows
    {
        ///////////////////////////////////////////////////////////////////////////////////////////
        // Rectangular - No windowing (box window)
        //
        // PROPERTIES:
        //   - Narrowest main lobe (best frequency resolution)
        //   - Highest side lobes (worst spectral leakage: -13 dB)
        //   - Use when signal exactly matches FFT period
        //
        // FORMULA: w[n] = 1 for all n
        ///////////////////////////////////////////////////////////////////////////////////////////
        inline Vector<Real> Rectangular(int n)
        {
            if (n <= 0)
                throw std::invalid_argument("Window size must be positive");
            
            return Vector<Real>(n, 1.0);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Hann (Hanning) - Raised cosine window
        //
        // PROPERTIES:
        //   - Moderate main lobe width
        //   - Good side lobe suppression (-31 dB)
        //   - General-purpose window, widely used
        //
        // FORMULA: w[n] = 0.5 * (1 - cos(2Ï€n/(N-1)))
        ///////////////////////////////////////////////////////////////////////////////////////////
        inline Vector<Real> Hann(int n)
        {
            if (n <= 0)
                throw std::invalid_argument("Window size must be positive");
            
            if (n == 1)
                return Vector<Real>(1, 1.0);
            
            Vector<Real> window(n);
            for (int i = 0; i < n; i++)
                window[i] = 0.5 * (1.0 - std::cos(2.0 * Constants::PI * i / (n - 1)));
            
            return window;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Hamming - Optimized raised cosine window
        //
        // PROPERTIES:
        //   - Slightly wider main lobe than Hann
        //   - Better side lobe suppression (-43 dB)
        //   - Optimized for minimizing first side lobe
        //
        // FORMULA: w[n] = 0.54 - 0.46 * cos(2Ï€n/(N-1))
        ///////////////////////////////////////////////////////////////////////////////////////////
        inline Vector<Real> Hamming(int n)
        {
            if (n <= 0)
                throw std::invalid_argument("Window size must be positive");
            
            if (n == 1)
                return Vector<Real>(1, 1.0);
            
            Vector<Real> window(n);
            for (int i = 0; i < n; i++)
                window[i] = 0.54 - 0.46 * std::cos(2.0 * Constants::PI * i / (n - 1));
            
            return window;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Blackman - Three-term cosine window
        //
        // PROPERTIES:
        //   - Wide main lobe (worst frequency resolution)
        //   - Excellent side lobe suppression (-58 dB)
        //   - Use when minimizing spectral leakage is critical
        //
        // FORMULA: w[n] = 0.42 - 0.5*cos(2Ï€n/(N-1)) + 0.08*cos(4Ï€n/(N-1))
        ///////////////////////////////////////////////////////////////////////////////////////////
        inline Vector<Real> Blackman(int n)
        {
            if (n <= 0)
                throw std::invalid_argument("Window size must be positive");
            
            if (n == 1)
                return Vector<Real>(1, 1.0);
            
            Vector<Real> window(n);
            for (int i = 0; i < n; i++)
            {
                Real angle = 2.0 * Constants::PI * i / (n - 1);
                window[i] = 0.42 - 0.5 * std::cos(angle) + 0.08 * std::cos(2.0 * angle);
            }
            
            return window;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Bartlett (Triangular) - Linear taper window
        //
        // PROPERTIES:
        //   - Moderate main lobe width
        //   - Moderate side lobe suppression (-25 dB)
        //   - Simple triangular shape
        //
        // FORMULA: w[n] = 1 - |2n/(N-1) - 1|
        ///////////////////////////////////////////////////////////////////////////////////////////
        inline Vector<Real> Bartlett(int n)
        {
            if (n <= 0)
                throw std::invalid_argument("Window size must be positive");
            
            if (n == 1)
                return Vector<Real>(1, 1.0);
            
            Vector<Real> window(n);
            for (int i = 0; i < n; i++)
                window[i] = 1.0 - std::abs(2.0 * i / (n - 1) - 1.0);
            
            return window;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Welch - Parabolic window
        //
        // PROPERTIES:
        //   - Similar to Bartlett but smoother
        //   - Continuous first derivative (Bartlett has kink at peak)
        //   - Side lobe suppression: -21 dB
        //
        // FORMULA: w[n] = 1 - (2n/(N-1) - 1)Â²
        ///////////////////////////////////////////////////////////////////////////////////////////
        inline Vector<Real> Welch(int n)
        {
            if (n <= 0)
                throw std::invalid_argument("Window size must be positive");
            
            if (n == 1)
                return Vector<Real>(1, 1.0);
            
            Vector<Real> window(n);
            for (int i = 0; i < n; i++)
            {
                Real x = 2.0 * i / (n - 1) - 1.0;
                window[i] = 1.0 - x * x;
            }
            
            return window;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Kaiser - Parametric window using modified Bessel function
        //
        // PARAMETERS:
        //   beta: Shape parameter controlling window properties
        //     - beta = 0: Rectangular window
        //     - beta = 5: Hamming-like
        //     - beta = 8.6: Blackman-like (-60 dB side lobes)
        //     - Higher beta: Wider main lobe, better side lobe suppression
        //
        // PROPERTIES:
        //   - Adjustable trade-off between main lobe width and side lobe level
        //   - Near-optimal in terms of energy concentration
        //
        // FORMULA: w[n] = Iâ‚€(Î²âˆš(1-(2n/(N-1)-1)Â²)) / Iâ‚€(Î²)
        //   where Iâ‚€ is the zeroth-order modified Bessel function of the first kind
        ///////////////////////////////////////////////////////////////////////////////////////////
        inline Vector<Real> Kaiser(int n, Real beta)
        {
            if (n <= 0)
                throw std::invalid_argument("Window size must be positive");
            if (beta < 0)
                throw std::invalid_argument("Kaiser beta parameter must be non-negative");
            
            // Modified Bessel function I0(x) using series expansion
            auto bessel_i0 = [](Real x) -> Real {
                Real sum = 1.0;
                Real term = 1.0;
                Real x_half = x / 2.0;
                
                for (int k = 1; k <= 50; k++)  // Sufficient for typical accuracy
                {
                    term *= (x_half / k);
                    term *= (x_half / k);
                    sum += term;
                    
                    if (term < 1e-12 * sum)  // Convergence check
                        break;
                }
                
                return sum;
            };
            
            Real i0_beta = bessel_i0(beta);
            Vector<Real> window(n);
            
            for (int i = 0; i < n; i++)
            {
                Real x = 2.0 * i / (n - 1) - 1.0;  // Normalize to [-1, 1]
                Real arg = beta * std::sqrt(1.0 - x * x);
                window[i] = bessel_i0(arg) / i0_beta;
            }
            
            return window;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Gaussian - Gaussian-shaped window
        //
        // PARAMETERS:
        //   sigma: Standard deviation (larger = narrower window)
        //     - Typical: sigma = 0.4 to 0.5
        //     - sigma = 0.4: Side lobes at -60 dB
        //
        // PROPERTIES:
        //   - Smooth, bell-shaped taper
        //   - Minimal overshoot in time and frequency domains
        //   - Good for signals with Gaussian statistics
        //
        // FORMULA: w[n] = exp(-0.5 * ((n - (N-1)/2) / (Ïƒ * (N-1)/2))Â²)
        ///////////////////////////////////////////////////////////////////////////////////////////
        inline Vector<Real> Gaussian(int n, Real sigma)
        {
            if (n <= 0)
                throw std::invalid_argument("Window size must be positive");
            if (sigma <= 0)
                throw std::invalid_argument("Gaussian sigma must be positive");
            
            Vector<Real> window(n);
            Real center = (n - 1) / 2.0;
            Real denominator = sigma * (n - 1) / 2.0;
            
            for (int i = 0; i < n; i++)
            {
                Real x = (i - center) / denominator;
                window[i] = std::exp(-0.5 * x * x);
            }
            
            return window;
        }
    }
}


///////////////////////////   mml/algorithms/Fourier/Spectrum.h   ///////////////////////////





namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // PowerSpectrum - Power spectral density estimation
    //
    // PURPOSE:
    //   Compute power spectrum (squared magnitude of FFT) for signal analysis.
    //   Estimates how signal power distributes across frequency components.
    //
    // METHODS:
    //   1. Periodogram: Direct FFT -> |X[k]|Â² / N
    //   2. Welch: Averaged periodogram with overlapping segments (reduces variance)
    //
    // APPLICATIONS:
    //   - Identify dominant frequencies in signals
    //   - Noise analysis and characterization
    //   - System identification
    //   - Vibration analysis
    //
    // REFERENCE: Numerical Recipes spectrum.h, Welch (1967)
    ///////////////////////////////////////////////////////////////////////////////////////////
    class PowerSpectrum
    {
    public:
        ///////////////////////////////////////////////////////////////////////////////////////////
        // Compute - Simple periodogram (direct FFT method)
        //
        // INPUT:
        //   - data: Time-domain signal (real-valued)
        //   - window: Window function (optional, default = Hann)
        //            If empty, Hann window of data.size() is used
        //
        // OUTPUT:
        //   - Power spectrum: P[k] = |X[k]|Â² / N
        //   - Length: N/2 + 1 (DC to Nyquist frequency)
        //
        // NOTES:
        //   - Returns only positive frequencies (real signal -> symmetric spectrum)
        //   - DC component at index 0, Nyquist at index N/2
        //   - For two-sided spectrum, use FFT directly
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> Compute(const Vector<Real>& data, const Vector<Real>& window = Vector<Real>())
        {
            int N = data.size();
            if (N == 0) {
                throw std::invalid_argument("PowerSpectrum::Compute - empty input vector");
            }

            // Apply window (default to Hann if not provided)
            Vector<Real> windowed = data;
            Vector<Real> win = window;
            if (win.size() == 0) {
                win = Windows::Hann(N);
            }
            if (win.size() != N) {
                throw std::invalid_argument("PowerSpectrum::Compute - window size mismatch");
            }

            // Window normalization factor (compensate for window energy loss)
            Real windowNorm = 0.0;
            for (int i = 0; i < N; i++) {
                windowed[i] *= win[i];
                windowNorm += win[i] * win[i];
            }
            windowNorm /= N;

            // Compute FFT
            Vector<Complex> spectrum = RealFFT::Forward(windowed);

            // Compute power spectrum: |X[k]|Â² / (N * windowNorm)
            int halfN = N / 2 + 1;
            Vector<Real> power(halfN);
            
            Real scale = 1.0 / (N * windowNorm);
            for (int i = 0; i < halfN; i++) {
                Real mag = std::abs(spectrum[i]);
                power[i] = mag * mag * scale;
            }

            return power;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Welch - Averaged periodogram method (reduced variance)
        //
        // INPUT:
        //   - data: Time-domain signal (real-valued)
        //   - segmentSize: Length of each segment (should be power of 2)
        //   - overlap: Number of overlapping samples between segments
        //   - window: Window function (optional, default = Hann)
        //
        // OUTPUT:
        //   - Averaged power spectrum with reduced variance
        //   - Length: segmentSize/2 + 1
        //
        // ALGORITHM:
        //   1. Divide signal into overlapping segments
        //   2. Apply window to each segment
        //   3. Compute periodogram for each segment
        //   4. Average all periodograms
        //
        // BENEFITS:
        //   - Reduced variance compared to simple periodogram
        //   - Trade-off: Reduced frequency resolution (shorter segments)
        //   - Typical overlap: 50% (segmentSize/2)
        //
        // EXAMPLE:
        //   auto spectrum = PowerSpectrum::Welch(signal, 1024, 512);
        //   // 1024-point segments with 50% overlap
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> Welch(const Vector<Real>& data, int segmentSize, int overlap, 
                                  const Vector<Real>& window = Vector<Real>())
        {
            int N = data.size();
            if (N == 0) {
                throw std::invalid_argument("PowerSpectrum::Welch - empty input vector");
            }
            if (segmentSize <= 0 || segmentSize > N) {
                throw std::invalid_argument("PowerSpectrum::Welch - invalid segment size");
            }
            if (overlap < 0 || overlap >= segmentSize) {
                throw std::invalid_argument("PowerSpectrum::Welch - invalid overlap");
            }

            // Generate window (default to Hann)
            Vector<Real> win = window;
            if (win.size() == 0) {
                win = Windows::Hann(segmentSize);
            }
            if (win.size() != segmentSize) {
                throw std::invalid_argument("PowerSpectrum::Welch - window size must match segment size");
            }

            // Calculate number of segments
            int hop = segmentSize - overlap;
            int numSegments = 1 + (N - segmentSize) / hop;
            
            if (numSegments < 1) {
                throw std::invalid_argument("PowerSpectrum::Welch - signal too short for given parameters");
            }

            // Initialize averaged spectrum
            int halfSize = segmentSize / 2 + 1;
            Vector<Real> avgSpectrum(halfSize, 0.0);

            // Process each segment
            for (int seg = 0; seg < numSegments; seg++) {
                int start = seg * hop;
                
                // Extract segment
                Vector<Real> segment(segmentSize);
                for (int i = 0; i < segmentSize; i++) {
                    segment[i] = data[start + i];
                }

                // Compute periodogram for this segment
                Vector<Real> segmentSpectrum = Compute(segment, win);

                // Accumulate
                for (int i = 0; i < halfSize; i++) {
                    avgSpectrum[i] += segmentSpectrum[i];
                }
            }

            // Average
            for (int i = 0; i < halfSize; i++) {
                avgSpectrum[i] /= numSegments;
            }

            return avgSpectrum;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // FrequencyAxis - Generate frequency axis for power spectrum
        //
        // INPUT:
        //   - n: FFT size (number of time-domain samples)
        //   - sampleRate: Sampling rate in Hz
        //
        // OUTPUT:
        //   - Frequency values in Hz for each bin
        //   - Length: n/2 + 1 (DC to Nyquist)
        //
        // NOTES:
        //   - Frequency resolution: Î”f = sampleRate / n
        //   - Nyquist frequency: fâ‚™ = sampleRate / 2
        //   - Frequencies: [0, Î”f, 2Î”f, ..., fâ‚™]
        //
        // EXAMPLE:
        //   auto freqs = PowerSpectrum::FrequencyAxis(1024, 44100);
        //   // freqs[0] = 0 Hz, freqs[512] = 22050 Hz (Nyquist)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> FrequencyAxis(int n, Real sampleRate)
        {
            if (n <= 0) {
                throw std::invalid_argument("PowerSpectrum::FrequencyAxis - n must be positive");
            }
            if (sampleRate <= 0) {
                throw std::invalid_argument("PowerSpectrum::FrequencyAxis - sampleRate must be positive");
            }

            int halfN = n / 2 + 1;
            Vector<Real> freqs(halfN);
            Real df = sampleRate / n;

            for (int i = 0; i < halfN; i++) {
                freqs[i] = i * df;
            }

            return freqs;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // ToDB - Convert power to decibels
        //
        // INPUT:
        //   - power: Power spectrum (linear scale)
        //   - reference: Reference power level (default = 1.0)
        //
        // OUTPUT:
        //   - Power in dB: 10 * logâ‚â‚€(power / reference)
        //
        // NOTES:
        //   - Common references:
        //     * 1.0 for normalized power
        //     * Maximum power value for relative dB
        //   - Zero/negative values clamped to -âˆž dB (in practice, very negative value)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> ToDB(const Vector<Real>& power, Real reference = 1.0)
        {
            if (reference <= 0) {
                throw std::invalid_argument("PowerSpectrum::ToDB - reference must be positive");
            }

            int n = power.size();
            Vector<Real> dB(n);
            const Real minDB = -200.0;  // Practical floor for dB

            for (int i = 0; i < n; i++) {
                if (power[i] > 0) {
                    dB[i] = 10.0 * std::log10(power[i] / reference);
                } else {
                    dB[i] = minDB;
                }
            }

            return dB;
        }
    };

    ///////////////////////////////////////////////////////////////////////////////////////////
    // Spectrogram - Short-Time Fourier Transform (STFT)
    //
    // PURPOSE:
    //   Compute time-frequency representation of signal.
    //   Shows how frequency content changes over time.
    //
    // ALGORITHM:
    //   1. Slide window across signal
    //   2. Compute FFT at each window position
    //   3. Stack results to create 2D time-frequency matrix
    //
    // APPLICATIONS:
    //   - Audio analysis (speech, music)
    //   - Transient detection
    //   - Time-varying system analysis
    //   - Chirp and modulated signal analysis
    //
    // REFERENCE: Numerical Recipes, Spectral analysis texts
    ///////////////////////////////////////////////////////////////////////////////////////////
    class Spectrogram
    {
    public:
        ///////////////////////////////////////////////////////////////////////////////////////////
        // STFT - Short-Time Fourier Transform
        //
        // INPUT:
        //   - data: Time-domain signal (real-valued)
        //   - windowSize: FFT window size (should be power of 2)
        //   - hopSize: Number of samples to advance between windows
        //   - window: Window function (optional, default = Hann)
        //
        // OUTPUT:
        //   - Matrix of complex spectra: rows = time frames, cols = frequency bins
        //   - Rows: Number of time windows
        //   - Cols: windowSize/2 + 1 (positive frequencies only)
        //
        // NOTES:
        //   - Typical overlap: 50-75% (hopSize = windowSize/4 to windowSize/2)
        //   - Time resolution: hopSize / sampleRate
        //   - Frequency resolution: sampleRate / windowSize
        //   - Trade-off: Larger window = better frequency res, worse time res
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Matrix<Complex> STFT(const Vector<Real>& data, int windowSize, int hopSize,
                                     const Vector<Real>& window = Vector<Real>())
        {
            int N = data.size();
            if (N == 0) {
                throw std::invalid_argument("Spectrogram::STFT - empty input vector");
            }
            if (windowSize <= 0 || windowSize > N) {
                throw std::invalid_argument("Spectrogram::STFT - invalid window size");
            }
            if (hopSize <= 0 || hopSize > windowSize) {
                throw std::invalid_argument("Spectrogram::STFT - invalid hop size");
            }

            // Generate window (default to Hann)
            Vector<Real> win = window;
            if (win.size() == 0) {
                win = Windows::Hann(windowSize);
            }
            if (win.size() != windowSize) {
                throw std::invalid_argument("Spectrogram::STFT - window size mismatch");
            }

            // Calculate number of frames
            int numFrames = 1 + (N - windowSize) / hopSize;
            int numFreqs = windowSize / 2 + 1;

            // Initialize result matrix
            Matrix<Complex> stft(numFrames, numFreqs);

            // Process each frame
            for (int frame = 0; frame < numFrames; frame++) {
                int start = frame * hopSize;

                // Extract and window segment
                Vector<Real> segment(windowSize);
                for (int i = 0; i < windowSize; i++) {
                    segment[i] = data[start + i] * win[i];
                }

                // Compute FFT
                Vector<Complex> spectrum = RealFFT::Forward(segment);

                // Store in matrix
                for (int k = 0; k < numFreqs; k++) {
                    stft(frame, k) = spectrum[k];
                }
            }

            return stft;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // PowerSpectrogram - Magnitude-squared STFT (power over time-frequency)
        //
        // INPUT:
        //   - data: Time-domain signal
        //   - windowSize, hopSize: Same as STFT
        //
        // OUTPUT:
        //   - Matrix of power values: |STFT|Â²
        //   - Suitable for visualization (log scale recommended)
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Matrix<Real> PowerSpectrogram(const Vector<Real>& data, int windowSize, int hopSize)
        {
            Matrix<Complex> stft = STFT(data, windowSize, hopSize);
            
            int numFrames = stft.RowNum();
            int numFreqs = stft.ColNum();
            Matrix<Real> power(numFrames, numFreqs);

            for (int i = 0; i < numFrames; i++) {
                for (int j = 0; j < numFreqs; j++) {
                    Real mag = std::abs(stft(i, j));
                    power(i, j) = mag * mag;
                }
            }

            return power;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // TimeAxis - Generate time axis for spectrogram
        //
        // INPUT:
        //   - numFrames: Number of time frames in spectrogram
        //   - hopSize: Hop size used in STFT
        //   - sampleRate: Sampling rate in Hz
        //
        // OUTPUT:
        //   - Time values in seconds for each frame center
        ///////////////////////////////////////////////////////////////////////////////////////////
        static Vector<Real> TimeAxis(int numFrames, int hopSize, Real sampleRate)
        {
            if (numFrames <= 0) {
                throw std::invalid_argument("Spectrogram::TimeAxis - numFrames must be positive");
            }
            if (hopSize <= 0) {
                throw std::invalid_argument("Spectrogram::TimeAxis - hopSize must be positive");
            }
            if (sampleRate <= 0) {
                throw std::invalid_argument("Spectrogram::TimeAxis - sampleRate must be positive");
            }

            Vector<Real> times(numFrames);
            for (int i = 0; i < numFrames; i++) {
                times[i] = (i * hopSize) / sampleRate;
            }

            return times;
        }
    };

} // namespace MML


///////////////////////////   mml/algorithms/Fourier/FourierSeries.h   ///////////////////////////




namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // FourierSeries - Continuous Fourier series representation
    //
    // Represents a periodic function as:
    //   f(x) = aâ‚€/2 + Î£[aâ‚™Â·cos(nÏ€x/L) + bâ‚™Â·sin(nÏ€x/L)]  for n = 1, 2, ..., N
    //
    // where:
    //   - L is the half-period (function is 2L-periodic)
    //   - aâ‚™ are cosine coefficients
    //   - bâ‚™ are sine coefficients
    //
    // Key features:
    //   - Approximates periodic functions with spectral convergence (for smooth functions)
    //   - Closed-form derivatives and integrals
    //   - Parseval's theorem for energy computation
    //   - Conversion to/from complex exponential form
    //
    // Usage:
    //   auto sin_func = [](Real x) { return std::sin(x); };
    //   FourierSeries fs(sin_func, Constants::PI, 10);  // Approximate sin(x) on [-Ï€, Ï€]
    //   Real value = fs(0.5);  // Evaluate at x=0.5
    ///////////////////////////////////////////////////////////////////////////////////////////
    class FourierSeries : public IRealFunction
    {
    private:
        Vector<Real> _a;    // Cosine coefficients [aâ‚€, aâ‚, aâ‚‚, ..., aâ‚™]
        Vector<Real> _b;    // Sine coefficients [bâ‚, bâ‚‚, ..., bâ‚™]  (bâ‚€ = 0 by definition)
        Real         _L;    // Half-period (function has period 2L)
        int          _N;    // Number of terms

    public:
        ///////////////////////////////////////////////////////////////////////////////////////////
        // Constructors
        ///////////////////////////////////////////////////////////////////////////////////////////

        // Default constructor - zero series
        FourierSeries() : _L(Constants::PI), _N(0) {}

        // Construct from coefficients
        FourierSeries(const Vector<Real>& a, const Vector<Real>& b, Real L)
            : _a(a), _b(b), _L(L)
        {
            if (_a.size() == 0)
                throw std::invalid_argument("FourierSeries: coefficient vector _a must have at least aâ‚€");
            if (_b.size() != _a.size() - 1)
                throw std::invalid_argument("FourierSeries: _b must have size = _a.size() - 1");
            
            _N = static_cast<int>(_a.size()) - 1;  // N terms (excluding aâ‚€)
        }

        // Construct from function by computing Fourier coefficients
        // Uses adaptive quadrature for coefficient computation
        FourierSeries(const IRealFunction& func, Real L, int N, Real eps = 1e-10)
            : _L(L), _N(N)
        {
            if (L <= 0.0)
                throw std::invalid_argument("FourierSeries: L must be positive");
            if (N < 0)
                throw std::invalid_argument("FourierSeries: N must be non-negative");

            _a.Resize(N + 1);  // aâ‚€, aâ‚, ..., aâ‚™
            _b.Resize(N);      // bâ‚, ..., bâ‚™

            // Compute aâ‚€ = (1/L) âˆ«[-L,L] f(x) dx
            Real sum_a0 = IntegrateTrap(func, -L, L, eps).value;
            _a[0] = sum_a0 / L;

            // Compute aâ‚™ = (1/L) âˆ«[-L,L] f(x)Â·cos(nÏ€x/L) dx
            // and bâ‚™ = (1/L) âˆ«[-L,L] f(x)Â·sin(nÏ€x/L) dx
            for (int n = 1; n <= N; n++)
            {
                // Cosine coefficient using helper class
                class CosIntegrand : public IRealFunction {
                    const IRealFunction& _f;
                    Real _L;
                    int _n;
                public:
                    CosIntegrand(const IRealFunction& f, Real L, int n) : _f(f), _L(L), _n(n) {}
                    Real operator()(Real x) const override {
                        return _f(x) * std::cos(_n * Constants::PI * x / _L);
                    }
                };
                CosIntegrand cos_integrand(func, L, n);
                _a[n] = IntegrateTrap(cos_integrand, -L, L, eps).value / L;

                // Sine coefficient using helper class
                class SinIntegrand : public IRealFunction {
                    const IRealFunction& _f;
                    Real _L;
                    int _n;
                public:
                    SinIntegrand(const IRealFunction& f, Real L, int n) : _f(f), _L(L), _n(n) {}
                    Real operator()(Real x) const override {
                        return _f(x) * std::sin(_n * Constants::PI * x / _L);
                    }
                };
                SinIntegrand sin_integrand(func, L, n);
                _b[n - 1] = IntegrateTrap(sin_integrand, -L, L, eps).value / L;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Evaluation
        ///////////////////////////////////////////////////////////////////////////////////////////

        // Evaluate Fourier series at x
        Real operator()(Real x) const override
        {
            if (_N == 0)
                return _a[0] / 2.0;

            Real sum = _a[0] / 2.0;
            
            for (int n = 1; n <= _N; n++)
            {
                Real arg = n * Constants::PI * x / _L;
                sum += _a[n] * std::cos(arg) + _b[n - 1] * std::sin(arg);
            }
            
            return sum;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Calculus Operations (closed-form for Fourier series!)
        ///////////////////////////////////////////////////////////////////////////////////////////

        // Derivative: d/dx[aâ‚™cos(nÏ€x/L) + bâ‚™sin(nÏ€x/L)]
        //           = -aâ‚™(nÏ€/L)sin(nÏ€x/L) + bâ‚™(nÏ€/L)cos(nÏ€x/L)
        // Maps to: a'â‚™ = bâ‚™(nÏ€/L), b'â‚™ = -aâ‚™(nÏ€/L)
        FourierSeries Derivative() const
        {
            if (_N == 0)
            {
                // Derivative of constant is zero
                Vector<Real> new_a(1, 0.0);
                Vector<Real> new_b(0);
                return FourierSeries(new_a, new_b, _L);
            }

            Vector<Real> new_a(_N + 1);
            Vector<Real> new_b(_N);

            new_a[0] = 0.0;  // Derivative of constant term is zero

            for (int n = 1; n <= _N; n++)
            {
                Real factor = n * Constants::PI / _L;
                new_a[n] = _b[n - 1] * factor;       // a'â‚™ = bâ‚™Â·(nÏ€/L)
                new_b[n - 1] = -_a[n] * factor;      // b'â‚™ = -aâ‚™Â·(nÏ€/L)
            }

            return FourierSeries(new_a, new_b, _L);
        }

        // Integral: âˆ«[aâ‚™cos(nÏ€x/L) + bâ‚™sin(nÏ€x/L)]dx
        //         = aâ‚™(L/nÏ€)sin(nÏ€x/L) - bâ‚™(L/nÏ€)cos(nÏ€x/L)
        // Maps to: A'â‚™ = -bâ‚™(L/nÏ€), B'â‚™ = aâ‚™(L/nÏ€)
        // Note: aâ‚€ term integrates to (aâ‚€/2)x, but we drop it (indefinite integral constant)
        FourierSeries Integral() const
        {
            if (_N == 0)
            {
                // Integral of constant is a linear function (not in Fourier series space)
                // Return zero series (or throw exception)
                Vector<Real> new_a(1, 0.0);
                Vector<Real> new_b(0);
                return FourierSeries(new_a, new_b, _L);
            }

            Vector<Real> new_a(_N + 1);
            Vector<Real> new_b(_N);

            new_a[0] = 0.0;  // Integration constant (arbitrary)

            for (int n = 1; n <= _N; n++)
            {
                Real factor = _L / (n * Constants::PI);
                new_a[n] = -_b[n - 1] * factor;      // Aâ‚™ = -bâ‚™Â·(L/nÏ€)
                new_b[n - 1] = _a[n] * factor;       // Bâ‚™ = aâ‚™Â·(L/nÏ€)
            }

            return FourierSeries(new_a, new_b, _L);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Coefficient Access
        ///////////////////////////////////////////////////////////////////////////////////////////

        const Vector<Real>& CosineCoefficients() const { return _a; }
        const Vector<Real>& SineCoefficients() const { return _b; }
        Real HalfPeriod() const { return _L; }
        Real Period() const { return 2.0 * _L; }
        int NumTerms() const { return _N; }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Complex Exponential Form
        ///////////////////////////////////////////////////////////////////////////////////////////

        // Convert to complex exponential form: f(x) = Î£ câ‚™Â·e^(inÏ€x/L)
        // Relationship: câ‚™ = (aâ‚™ - iÂ·bâ‚™)/2 for n > 0
        //               câ‚€ = aâ‚€/2
        //               câ‚‹â‚™ = (aâ‚™ + iÂ·bâ‚™)/2 = cÌ„â‚™ (complex conjugate)
        Vector<Complex> ComplexCoefficients() const
        {
            Vector<Complex> c(2 * _N + 1);
            
            c[_N] = Complex(_a[0] / 2.0, 0.0);  // câ‚€
            
            for (int n = 1; n <= _N; n++)
            {
                Complex cn(_a[n] / 2.0, -_b[n - 1] / 2.0);  // câ‚™ = (aâ‚™ - iÂ·bâ‚™)/2
                c[_N + n] = cn;                              // Positive frequencies
                c[_N - n] = std::conj(cn);                   // Negative frequencies (conjugate)
            }
            
            return c;
        }

        // Construct from complex coefficients
        // Input: c = [câ‚‹â‚™, ..., câ‚‹â‚, câ‚€, câ‚, ..., câ‚™] (length 2N+1)
        static FourierSeries FromComplexCoefficients(const Vector<Complex>& c, Real L)
        {
            int len = static_cast<int>(c.size());
            if (len % 2 == 0)
                throw std::invalid_argument("FromComplexCoefficients: c must have odd length");
            
            int N = (len - 1) / 2;
            Vector<Real> a(N + 1);
            Vector<Real> b(N);
            
            a[0] = 2.0 * c[N].real();  // aâ‚€ = 2Â·Re(câ‚€)
            
            for (int n = 1; n <= N; n++)
            {
                Complex cn = c[N + n];
                a[n] = 2.0 * cn.real();     // aâ‚™ = 2Â·Re(câ‚™)
                b[n - 1] = -2.0 * cn.imag(); // bâ‚™ = -2Â·Im(câ‚™)
            }
            
            return FourierSeries(a, b, L);
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Energy and Norms (Parseval's Theorem)
        ///////////////////////////////////////////////////////////////////////////////////////////

        // Parseval's theorem: âˆ«[-L,L] |f(x)|Â² dx = LÂ·(aâ‚€Â²/2 + Î£(aâ‚™Â² + bâ‚™Â²))
        Real Energy() const
        {
            Real energy = (_a[0] * _a[0]) / 2.0;  // aâ‚€Â²/2
            
            for (int n = 1; n <= _N; n++)
            {
                energy += _a[n] * _a[n] + _b[n - 1] * _b[n - 1];
            }
            
            return _L * energy;
        }

        // LÂ² norm: ||f||â‚‚ = âˆš(Energy/2L)
        Real L2Norm() const
        {
            return std::sqrt(Energy() / (2.0 * _L));
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Series Operations
        ///////////////////////////////////////////////////////////////////////////////////////////

        // Truncate to M terms (M < N)
        FourierSeries Truncate(int M) const
        {
            if (M < 0)
                throw std::invalid_argument("Truncate: M must be non-negative");
            if (M > _N)
                return *this;
            
            Vector<Real> new_a(M + 1);
            Vector<Real> new_b(M);
            
            for (int i = 0; i <= M; i++)
                new_a[i] = _a[i];
            
            for (int i = 0; i < M; i++)
                new_b[i] = _b[i];
            
            return FourierSeries(new_a, new_b, _L);
        }

        // Addition
        FourierSeries operator+(const FourierSeries& other) const
        {
            if (std::abs(_L - other._L) > 1e-10)
                throw std::invalid_argument("FourierSeries::operator+: periods must match");
            
            int max_N = std::max(_N, other._N);
            Vector<Real> new_a(max_N + 1, 0.0);
            Vector<Real> new_b(max_N, 0.0);
            
            for (int i = 0; i <= _N; i++)
                new_a[i] = _a[i];
            for (int i = 0; i < _N; i++)
                new_b[i] = _b[i];
            
            for (int i = 0; i <= other._N; i++)
                new_a[i] += other._a[i];
            for (int i = 0; i < other._N; i++)
                new_b[i] += other._b[i];
            
            return FourierSeries(new_a, new_b, _L);
        }

        // Subtraction
        FourierSeries operator-(const FourierSeries& other) const
        {
            if (std::abs(_L - other._L) > 1e-10)
                throw std::invalid_argument("FourierSeries::operator-: periods must match");
            
            int max_N = std::max(_N, other._N);
            Vector<Real> new_a(max_N + 1, 0.0);
            Vector<Real> new_b(max_N, 0.0);
            
            for (int i = 0; i <= _N; i++)
                new_a[i] = _a[i];
            for (int i = 0; i < _N; i++)
                new_b[i] = _b[i];
            
            for (int i = 0; i <= other._N; i++)
                new_a[i] -= other._a[i];
            for (int i = 0; i < other._N; i++)
                new_b[i] -= other._b[i];
            
            return FourierSeries(new_a, new_b, _L);
        }

        // Scalar multiplication
        FourierSeries operator*(Real scalar) const
        {
            Vector<Real> new_a(_N + 1);
            Vector<Real> new_b(_N);
            
            for (int i = 0; i <= _N; i++)
                new_a[i] = _a[i] * scalar;
            for (int i = 0; i < _N; i++)
                new_b[i] = _b[i] * scalar;
            
            return FourierSeries(new_a, new_b, _L);
        }

        friend FourierSeries operator*(Real scalar, const FourierSeries& fs)
        {
            return fs * scalar;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Convergence Analysis
        ///////////////////////////////////////////////////////////////////////////////////////////

        // Get magnitude of nth coefficient (for convergence analysis)
        Real CoefficientMagnitude(int n) const
        {
            if (n == 0)
                return std::abs(_a[0]);
            if (n > _N)
                return 0.0;
            
            return std::sqrt(_a[n] * _a[n] + _b[n - 1] * _b[n - 1]);
        }

        // Maximum coefficient magnitude (indicator of convergence)
        Real MaxCoefficientMagnitude() const
        {
            Real max_mag = std::abs(_a[0]);
            
            for (int n = 1; n <= _N; n++)
            {
                Real mag = std::sqrt(_a[n] * _a[n] + _b[n - 1] * _b[n - 1]);
                if (mag > max_mag)
                    max_mag = mag;
            }
            
            return max_mag;
        }
    };

} // namespace MML


///////////////////////////   mml/algorithms/Fourier/FourierBasis.h   ///////////////////////////






namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    // FourierBasis - Fourier trigonometric basis on [-L, L]
    //
    // Basis functions (indexed from 0):
    //   Ï†â‚€(x) = 1                     (constant)
    //   Ï†â‚(x) = cos(Ï€x/L)             (first cosine)
    //   Ï†â‚‚(x) = sin(Ï€x/L)             (first sine)
    //   Ï†â‚ƒ(x) = cos(2Ï€x/L)            (second cosine)
    //   Ï†â‚„(x) = sin(2Ï€x/L)            (second sine)
    //   ...
    //
    // Indexing scheme:
    //   n = 0:       constant
    //   n = 2k-1:    cos(kÏ€x/L)  for k = 1, 2, 3, ...
    //   n = 2k:      sin(kÏ€x/L)  for k = 1, 2, 3, ...
    //
    // Orthogonality: âˆ«[-L,L] Ï†â‚˜(x)Ï†â‚™(x) dx = 0 for m â‰  n
    // Normalization: 
    //   ||Ï†â‚€||Â² = 2L
    //   ||Ï†â‚™||Â² = L for n > 0
    ///////////////////////////////////////////////////////////////////////////////////////////
    class FourierBasis : public OrthogonalBasis
    {
    private:
        Real _L;  // Half-period (domain is [-L, L])

    public:
        explicit FourierBasis(Real L = Constants::PI) : _L(L)
        {
            if (L <= 0.0)
                throw std::invalid_argument("FourierBasis: L must be positive");
        }

        Real HalfPeriod() const { return _L; }
        Real Period() const { return 2.0 * _L; }

        // Domain bounds
        Real DomainMin() const override { return -_L; }
        Real DomainMax() const override { return _L; }

        // Weight function (uniform for Fourier)
        Real WeightFunction(Real /*x*/) const override { return 1.0; }

        // Normalization: ||Ï†â‚™||Â² = âˆ«[-L,L] Ï†â‚™Â²(x) dx
        Real Normalization(int n) const override
        {
            if (n < 0)
                throw std::invalid_argument("FourierBasis::Normalization: n must be non-negative");
            
            if (n == 0)
                return 2.0 * _L;  // âˆ«[-L,L] 1Â² dx = 2L
            else
                return _L;        // âˆ«[-L,L] cosÂ²(kÏ€x/L) dx = L (also for sinÂ²)
        }

        // Evaluate basis function Ï†â‚™ at x
        Real Evaluate(int n, Real x) const override
        {
            if (n < 0)
                throw std::invalid_argument("FourierBasis::Evaluate: n must be non-negative");
            
            if (n == 0)
                return 1.0;
            
            int k = (n + 1) / 2;  // Harmonic number
            Real arg = k * Constants::PI * x / _L;
            
            if (n % 2 == 1)  // Odd index â†’ cosine
                return std::cos(arg);
            else             // Even index â†’ sine
                return std::sin(arg);
        }

        // Get harmonic number for basis index
        static int HarmonicNumber(int n)
        {
            if (n <= 0) return 0;
            return (n + 1) / 2;
        }

        // Is cosine basis function?
        static bool IsCosine(int n)
        {
            return (n == 0) || (n % 2 == 1);
        }

        // Is sine basis function?
        static bool IsSine(int n)
        {
            return (n > 0) && (n % 2 == 0);
        }

        // Convert to traditional (aâ‚™, bâ‚™) indexing
        // n=0 â†’ (a, 0), n=1 â†’ (a, 1), n=2 â†’ (b, 1), n=3 â†’ (a, 2), n=4 â†’ (b, 2), ...
        static std::pair<char, int> ToTraditionalIndex(int n)
        {
            if (n == 0) return {'a', 0};
            int k = (n + 1) / 2;
            return (n % 2 == 1) ? std::make_pair('a', k) : std::make_pair('b', k);
        }

        // Convert from traditional indexing to basis index
        static int FromTraditionalIndex(char type, int k)
        {
            if (type == 'a' && k == 0) return 0;
            if (type == 'a') return 2 * k - 1;
            if (type == 'b') return 2 * k;
            throw std::invalid_argument("FromTraditionalIndex: type must be 'a' or 'b'");
        }

        ///////////////////////////////////////////////////////////////////////////////////////////
        // Expansion Methods
        ///////////////////////////////////////////////////////////////////////////////////////////

        // Expand function in Fourier basis up to N terms (2N+1 basis functions)
        Vector<Real> Expand(const IRealFunction& f, int N, Real eps = 1e-10) const
        {
            int num_terms = 2 * N + 1;  // Ï†â‚€, Ï†â‚, Ï†â‚‚, ..., Ï†â‚‚â‚™
            Vector<Real> coefficients(num_terms);
            
            for (int n = 0; n < num_terms; n++)
            {
                coefficients[n] = ComputeCoefficient(f, n, eps);
            }
            
            return coefficients;
        }

        // Evaluate expansion at point x
        Real EvaluateExpansion(const Vector<Real>& coefficients, Real x) const
        {
            Real sum = 0.0;
            for (int n = 0; n < static_cast<int>(coefficients.size()); n++)
            {
                sum += coefficients[n] * Evaluate(n, x);
            }
            return sum;
        }

        // Convert expansion to FourierSeries object
        FourierSeries ToFourierSeries(const Vector<Real>& coefficients) const
        {
            int num_terms = static_cast<int>(coefficients.size());
            int N = (num_terms - 1) / 2;  // Number of harmonics
            
            Vector<Real> a(N + 1);  // aâ‚€, aâ‚, ..., aâ‚™
            Vector<Real> b(N);      // bâ‚, bâ‚‚, ..., bâ‚™
            
            // aâ‚€ = 2 * câ‚€ (because FourierSeries stores aâ‚€, not aâ‚€/2)
            a[0] = 2.0 * coefficients[0];
            
            for (int k = 1; k <= N; k++)
            {
                int cos_idx = 2 * k - 1;
                int sin_idx = 2 * k;
                
                if (cos_idx < num_terms)
                    a[k] = coefficients[cos_idx];
                else
                    a[k] = 0.0;
                
                if (sin_idx < num_terms)
                    b[k - 1] = coefficients[sin_idx];
                else
                    b[k - 1] = 0.0;
            }
            
            return FourierSeries(a, b, _L);
        }

        // Create expansion from FourierSeries
        Vector<Real> FromFourierSeries(const FourierSeries& fs) const
        {
            if (std::abs(fs.HalfPeriod() - _L) > 1e-10)
                throw std::invalid_argument("FromFourierSeries: period mismatch");
            
            int N = fs.NumTerms();
            int num_terms = 2 * N + 1;
            Vector<Real> coefficients(num_terms);
            
            const auto& a = fs.CosineCoefficients();
            const auto& b = fs.SineCoefficients();
            
            // câ‚€ = aâ‚€/2 (FourierSeries stores full aâ‚€)
            coefficients[0] = a[0] / 2.0;
            
            for (int k = 1; k <= N; k++)
            {
                coefficients[2 * k - 1] = a[k];  // Cosine coefficient
                coefficients[2 * k] = b[k - 1]; // Sine coefficient
            }
            
            return coefficients;
        }
    };

    ///////////////////////////////////////////////////////////////////////////////////////////
    // ComplexFourierBasis - Complex exponential basis on [-L, L]
    //
    // Basis functions: Ï†â‚™(x) = e^(inÏ€x/L) for n = ..., -2, -1, 0, 1, 2, ...
    //
    // Orthogonality: âˆ«[-L,L] Ï†â‚˜*(x)Ï†â‚™(x) dx = 2LÂ·Î´â‚˜â‚™
    //
    // This basis uses complex inner product: âŸ¨f,gâŸ© = âˆ« f*(x)g(x) dx
    ///////////////////////////////////////////////////////////////////////////////////////////
    class ComplexFourierBasis
    {
    private:
        Real _L;  // Half-period

    public:
        explicit ComplexFourierBasis(Real L = Constants::PI) : _L(L)
        {
            if (L <= 0.0)
                throw std::invalid_argument("ComplexFourierBasis: L must be positive");
        }

        Real HalfPeriod() const { return _L; }
        Real DomainMin() const { return -_L; }
        Real DomainMax() const { return _L; }

        // Evaluate basis function e^(inÏ€x/L)
        Complex Evaluate(int n, Real x) const
        {
            Real arg = n * Constants::PI * x / _L;
            return Complex(std::cos(arg), std::sin(arg));
        }

        // Normalization (all basis functions have same norm)
        Real Normalization() const { return 2.0 * _L; }

        // Expand function in complex exponential basis
        // Returns coefficients câ‚‹â‚™, ..., câ‚‹â‚, câ‚€, câ‚, ..., câ‚™
        Vector<Complex> Expand(const IRealFunction& f, int N, Real eps = 1e-10) const
        {
            int num_terms = 2 * N + 1;
            Vector<Complex> coefficients(num_terms);
            
            Real norm = Normalization();
            
            for (int n = -N; n <= N; n++)
            {
                // câ‚™ = (1/2L) âˆ«[-L,L] f(x)Â·e^(-inÏ€x/L) dx
                class RealPart : public IRealFunction {
                    const IRealFunction& _f;
                    Real _L;
                    int _n;
                public:
                    RealPart(const IRealFunction& f, Real L, int n) : _f(f), _L(L), _n(n) {}
                    Real operator()(Real x) const override {
                        return _f(x) * std::cos(-_n * Constants::PI * x / _L);
                    }
                };
                
                class ImagPart : public IRealFunction {
                    const IRealFunction& _f;
                    Real _L;
                    int _n;
                public:
                    ImagPart(const IRealFunction& f, Real L, int n) : _f(f), _L(L), _n(n) {}
                    Real operator()(Real x) const override {
                        return _f(x) * std::sin(-_n * Constants::PI * x / _L);
                    }
                };
                
                RealPart real_integrand(f, _L, n);
                ImagPart imag_integrand(f, _L, n);
                
                Real real_part = IntegrateTrap(real_integrand, -_L, _L, eps).value / norm;
                Real imag_part = IntegrateTrap(imag_integrand, -_L, _L, eps).value / norm;
                
                coefficients[n + N] = Complex(real_part, imag_part);
            }
            
            return coefficients;
        }

        // Evaluate expansion at point x
        Complex EvaluateExpansion(const Vector<Complex>& coefficients, Real x) const
        {
            int N = (static_cast<int>(coefficients.size()) - 1) / 2;
            Complex sum(0.0, 0.0);
            
            for (int n = -N; n <= N; n++)
            {
                sum += coefficients[n + N] * Evaluate(n, x);
            }
            
            return sum;
        }

        // Convert to real form FourierSeries
        // Using: aâ‚™ = 2Â·Re(câ‚™), bâ‚™ = -2Â·Im(câ‚™), aâ‚€ = 2Â·Re(câ‚€)
        FourierSeries ToFourierSeries(const Vector<Complex>& coefficients) const
        {
            return FourierSeries::FromComplexCoefficients(coefficients, _L);
        }
    };

} // namespace MML


///////////////////////////   mml/algorithms/ChebyshevApproximation.h   ///////////////////////////



namespace MML
{
    ///////////////////////////////////////////////////////////////////////////////////////////
    ///                         CHEBYSHEV POLYNOMIAL EVALUATION                             ///
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Evaluate Chebyshev polynomial of the first kind T_n(x) using recurrence relation.
    // T_0(x) = 1
    // T_1(x) = x
    // T_{n+1}(x) = 2x * T_n(x) - T_{n-1}(x)
    //
    // Properties:
    // - T_n(1) = 1 for all n
    // - T_n(-1) = (-1)^n
    // - T_n(cos(Î¸)) = cos(nÎ¸)
    // - |T_n(x)| â‰¤ 1 for x âˆˆ [-1, 1]
    inline Real ChebyshevT(int n, Real x)
    {
        if (n < 0)
            throw std::invalid_argument("ChebyshevT: n must be non-negative");
        
        if (n == 0) return 1.0;
        if (n == 1) return x;
        
        Real T_prev2 = 1.0;   // T_0
        Real T_prev1 = x;     // T_1
        Real T_curr = 0.0;
        
        for (int k = 2; k <= n; k++)
        {
            T_curr = 2.0 * x * T_prev1 - T_prev2;
            T_prev2 = T_prev1;
            T_prev1 = T_curr;
        }
        
        return T_curr;
    }

    // Evaluate Chebyshev polynomial of the second kind U_n(x) using recurrence relation.
    // U_0(x) = 1
    // U_1(x) = 2x
    // U_{n+1}(x) = 2x * U_n(x) - U_{n-1}(x)
    //
    // Properties:
    // - U_n(1) = n + 1
    // - U_n(-1) = (-1)^n * (n + 1)
    // - U_n(cos(Î¸)) = sin((n+1)Î¸) / sin(Î¸)
    //
    // Relationship to T_n:
    // - dT_n/dx = n * U_{n-1}(x)
    inline Real ChebyshevU(int n, Real x)
    {
        if (n < 0)
            throw std::invalid_argument("ChebyshevU: n must be non-negative");
        
        if (n == 0) return 1.0;
        if (n == 1) return 2.0 * x;
        
        Real U_prev2 = 1.0;       // U_0
        Real U_prev1 = 2.0 * x;   // U_1
        Real U_curr = 0.0;
        
        for (int k = 2; k <= n; k++)
        {
            U_curr = 2.0 * x * U_prev1 - U_prev2;
            U_prev2 = U_prev1;
            U_prev1 = U_curr;
        }
        
        return U_curr;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
    ///                           CHEBYSHEV APPROXIMATION CLASS                             ///
    ///////////////////////////////////////////////////////////////////////////////////////////

    // ChebyshevApproximation - Represents a function as a Chebyshev series expansion.
    //
    // A function f(x) on [a,b] is approximated as:
    //   f(x) â‰ˆ Î£_{j=0}^{n-1} c_j * T_j(y)
    // where y = (2x - a - b) / (b - a) maps [a,b] to [-1,1]
    //
    // Key features:
    // - Near-minimax polynomial approximation
    // - Numerically stable Clenshaw evaluation
    // - Spectral convergence for smooth functions
    // - Implements IRealFunction for seamless integration
    //
    // Reference: Numerical Recipes 3rd Edition, Chapter 5
    class ChebyshevApproximation : public IRealFunction
    {
    private:
        Vector<Real> _coef;    // Chebyshev coefficients c_0, c_1, ..., c_{n-1}
        Real _a, _b;           // Domain [a, b]
        int _m;                // Truncation degree (number of terms used in evaluation, â‰¤ n)

    public:
        // Default constructor - creates empty approximation
        ChebyshevApproximation() : _coef(), _a(-1.0), _b(1.0), _m(0) {}

        // Construct from a function on interval [a, b] using n Chebyshev coefficients.
        // Uses DCT-like transform at Chebyshev nodes for coefficient computation.
        //
        // Parameters:
        //   func - Function to approximate (implements IRealFunction)
        //   a, b - Domain interval [a, b]
        //   n    - Number of Chebyshev coefficients (default 50)
        //
        // Algorithm:
        // 1. Sample function at Chebyshev nodes: x_k = cos(Ï€(k+0.5)/n)
        // 2. Compute coefficients via discrete cosine transform
        ChebyshevApproximation(const IRealFunction& func, Real a, Real b, int n = 50)
            : _coef(n), _a(a), _b(b), _m(n)
        {
            if (n <= 0)
                throw std::invalid_argument("ChebyshevApproximation: n must be positive");
            if (a >= b)
                throw std::invalid_argument("ChebyshevApproximation: require a < b");

            const Real pi = Constants::PI;
            Real bma = 0.5 * (b - a);  // half-width
            Real bpa = 0.5 * (b + a);  // midpoint

            // Sample function at Chebyshev nodes
            Vector<Real> f(n);
            for (int k = 0; k < n; k++)
            {
                Real y = std::cos(pi * (k + 0.5) / n);  // Chebyshev node on [-1,1]
                f[k] = func(y * bma + bpa);             // Map to [a,b] and evaluate
            }

            // Compute Chebyshev coefficients via DCT-II
            // This implements the discrete orthogonality relation for Chebyshev polynomials
            _coef = DCT::ForwardII(f);
        }

        // Construct from std::function for convenience (lambdas, etc.)
        ChebyshevApproximation(std::function<Real(Real)> func, Real a, Real b, int n = 50)
            : _coef(n), _a(a), _b(b), _m(n)
        {
            if (n <= 0)
                throw std::invalid_argument("ChebyshevApproximation: n must be positive");
            if (a >= b)
                throw std::invalid_argument("ChebyshevApproximation: require a < b");

            const Real pi = Constants::PI;
            Real bma = 0.5 * (b - a);
            Real bpa = 0.5 * (b + a);

            Vector<Real> f(n);
            for (int k = 0; k < n; k++)
            {
                Real y = std::cos(pi * (k + 0.5) / n);
                f[k] = func(y * bma + bpa);
            }

            // Compute Chebyshev coefficients via DCT-II
            _coef = DCT::ForwardII(f);
        }

        // Construct from existing Chebyshev coefficients.
        // Useful for creating approximations from known coefficient sequences,
        // or from results of derivative/integral operations.
        //
        // Parameters:
        //   coefficients - Vector of Chebyshev coefficients
        //   a, b         - Domain interval [a, b]
        ChebyshevApproximation(const Vector<Real>& coefficients, Real a, Real b)
            : _coef(coefficients), _a(a), _b(b), _m(coefficients.size())
        {
            if (coefficients.size() == 0)
                throw std::invalid_argument("ChebyshevApproximation: coefficients cannot be empty");
            if (a >= b)
                throw std::invalid_argument("ChebyshevApproximation: require a < b");
        }

        // Copy constructor
        ChebyshevApproximation(const ChebyshevApproximation& other) = default;

        // Move constructor
        ChebyshevApproximation(ChebyshevApproximation&& other) noexcept = default;

        // Copy assignment
        ChebyshevApproximation& operator=(const ChebyshevApproximation& other) = default;

        // Move assignment
        ChebyshevApproximation& operator=(ChebyshevApproximation&& other) noexcept = default;

        // Destructor
        virtual ~ChebyshevApproximation() = default;

        ///////////////////////////          EVALUATION          ///////////////////////////

        // Evaluate the Chebyshev approximation at point x using Clenshaw recurrence.
        // This is the IRealFunction interface implementation.
        //
        // The Clenshaw algorithm provides numerically stable O(n) evaluation
        // without explicitly computing Chebyshev polynomials.
        //
        // Algorithm:
        // 1. Map x from [a,b] to y in [-1,1]
        // 2. Apply backward Clenshaw recurrence
        // 3. Return final sum
        //
        // Throws if x is outside [a, b] (can be relaxed for extrapolation)
        Real operator()(Real x) const override
        {
            // Check domain (comment out for extrapolation)
            if ((x - _a) * (x - _b) > 0.0)
                throw std::domain_error("ChebyshevApproximation: x not in range [a, b]");

            if (_m == 0) return 0.0;

            // Map x from [a,b] to y in [-1,1]
            Real y = (2.0 * x - _a - _b) / (_b - _a);
            Real y2 = 2.0 * y;

            // Clenshaw recurrence (backward)
            Real d = 0.0, dd = 0.0;
            for (int j = _m - 1; j > 0; j--)
            {
                Real sv = d;
                d = y2 * d - dd + _coef[j];
                dd = sv;
            }

            return y * d - dd + 0.5 * _coef[0];
        }

        // Evaluate using only the first m terms (m â‰¤ _m)
        Real Eval(Real x, int m) const
        {
            if (m <= 0 || m > _m)
                throw std::invalid_argument("ChebyshevApproximation::Eval: invalid m");

            if ((x - _a) * (x - _b) > 0.0)
                throw std::domain_error("ChebyshevApproximation::Eval: x not in range [a, b]");

            Real y = (2.0 * x - _a - _b) / (_b - _a);
            Real y2 = 2.0 * y;

            Real d = 0.0, dd = 0.0;
            for (int j = m - 1; j > 0; j--)
            {
                Real sv = d;
                d = y2 * d - dd + _coef[j];
                dd = sv;
            }

            return y * d - dd + 0.5 * _coef[0];
        }

        ///////////////////////////         ACCESSORS           ///////////////////////////

        // Get the full degree (number of coefficients - 1)
        int Degree() const { return static_cast<int>(_coef.size()) - 1; }

        // Get the truncation degree (number of terms used - 1)
        int TruncatedDegree() const { return _m - 1; }

        // Get number of coefficients stored
        int NumCoefficients() const { return static_cast<int>(_coef.size()); }

        // Get number of terms used in evaluation
        int NumTerms() const { return _m; }

        // Get the coefficient vector (read-only)
        const Vector<Real>& Coefficients() const { return _coef; }

        // Get individual coefficient
        Real Coefficient(int j) const
        {
            if (j < 0 || j >= static_cast<int>(_coef.size()))
                throw std::out_of_range("ChebyshevApproximation::Coefficient: index out of range");
            return _coef[j];
        }

        // Get domain endpoints
        Real DomainMin() const { return _a; }
        Real DomainMax() const { return _b; }

        ///////////////////////////       TRUNCATION            ///////////////////////////

        // Set the number of terms to use in evaluation.
        // Allows trading accuracy for speed.
        void SetNumTerms(int m)
        {
            if (m <= 0 || m > static_cast<int>(_coef.size()))
                throw std::invalid_argument("ChebyshevApproximation::SetNumTerms: invalid m");
            _m = m;
        }

        // Automatically truncate based on coefficient magnitude threshold.
        // Returns the new number of terms.
        //
        // Chebyshev coefficients of smooth functions decay rapidly.
        // This method finds the smallest m such that |c_j| < threshold for all j â‰¥ m.
        int Truncate(Real threshold)
        {
            while (_m > 1 && std::abs(_coef[_m - 1]) < threshold)
                _m--;
            return _m;
        }

        ///////////////////////////     CALCULUS OPERATIONS     ///////////////////////////

        // Compute the derivative of this Chebyshev approximation.
        // Returns a new ChebyshevApproximation representing f'(x).
        //
        // The derivative of a Chebyshev series has a simple recurrence formula:
        //   c'_{n-1} = 0
        //   c'_{n-2} = 2(n-1) * c_{n-1}
        //   c'_{j-1} = c'_{j+1} + 2j * c_j   for j = n-2, ..., 1
        // Then scale by 2/(b-a) for domain mapping.
        ChebyshevApproximation Derivative() const
        {
            int n = static_cast<int>(_coef.size());
            if (n <= 1)
            {
                // Derivative of constant is zero
                Vector<Real> zero_coef(1);
                zero_coef[0] = 0.0;
                return ChebyshevApproximation(zero_coef, _a, _b);
            }

            Vector<Real> cder(n);
            cder[n - 1] = 0.0;
            cder[n - 2] = 2.0 * (n - 1) * _coef[n - 1];

            for (int j = n - 2; j > 0; j--)
                cder[j - 1] = cder[j + 1] + 2.0 * j * _coef[j];

            // Scale for domain mapping: d/dx = (2/(b-a)) * d/dy
            Real con = 2.0 / (_b - _a);
            for (int j = 0; j < n; j++)
                cder[j] *= con;

            return ChebyshevApproximation(cder, _a, _b);
        }

        // Compute the indefinite integral of this Chebyshev approximation.
        // Returns a new ChebyshevApproximation representing âˆ«f(x)dx.
        // The constant of integration is chosen so that the integral is zero at x = a.
        //
        // The integral of a Chebyshev series:
        //   c''_j = (con) * (c_{j-1} - c_{j+1}) / j   for j = 1, ..., n-2
        //   c''_{n-1} = (con) * c_{n-2} / (n-1)
        //   c''_0 chosen to make integral(a) = 0
        // where con = (b-a)/4.
        ChebyshevApproximation Integral() const
        {
            int n = static_cast<int>(_coef.size());

            Vector<Real> cint(n);
            Real sum = 0.0;
            Real fac = 1.0;
            Real con = 0.25 * (_b - _a);

            for (int j = 1; j < n - 1; j++)
            {
                cint[j] = con * (_coef[j - 1] - _coef[j + 1]) / j;
                sum += fac * cint[j];
                fac = -fac;
            }

            cint[n - 1] = con * _coef[n - 2] / (n - 1);
            sum += fac * cint[n - 1];

            // c_0 chosen so integral(a) = 0
            cint[0] = 2.0 * sum;

            return ChebyshevApproximation(cint, _a, _b);
        }

        ///////////////////////////   POLYNOMIAL CONVERSION     ///////////////////////////

        // Convert Chebyshev coefficients to power series (polynomial) coefficients.
        // Returns polynomial on [-1, 1]: p(y) = Î£ d_j * y^j
        //
        // Note: For use on original domain [a,b], apply the substitution
        //       y = (2x - a - b) / (b - a)
        //
        // Uses backward recurrence algorithm from Numerical Recipes.
        Polynom<Real> ToPolynomial() const
        {
            return ToPolynomial(_m);
        }

        // Convert using only the first m terms
        Polynom<Real> ToPolynomial(int m) const
        {
            if (m <= 0 || m > static_cast<int>(_coef.size()))
                throw std::invalid_argument("ChebyshevApproximation::ToPolynomial: invalid m");

            std::vector<Real> d(m, 0.0);
            std::vector<Real> dd(m, 0.0);

            d[0] = _coef[m - 1];

            for (int j = m - 2; j > 0; j--)
            {
                for (int k = m - j; k > 0; k--)
                {
                    Real sv = d[k];
                    d[k] = 2.0 * d[k - 1] - dd[k];
                    dd[k] = sv;
                }
                Real sv = d[0];
                d[0] = -dd[0] + _coef[j];
                dd[0] = sv;
            }

            for (int j = m - 1; j > 0; j--)
                d[j] = d[j - 1] - dd[j];

            d[0] = -dd[0] + 0.5 * _coef[0];

            return Polynom<Real>(d);
        }

        // Create ChebyshevApproximation from a polynomial.
        // Evaluates the polynomial at Chebyshev nodes and computes coefficients.
        static ChebyshevApproximation FromPolynomial(const Polynom<Real>& poly, Real a, Real b, int n = 0)
        {
            // If n not specified, use polynomial degree + 1
            if (n <= 0)
                n = poly.GetDegree() + 1;

            // Create a wrapper function and use standard constructor
            return ChebyshevApproximation(
                [&poly](Real x) { return poly(x); },
                a, b, n
            );
        }

        ///////////////////////////         UTILITIES           ///////////////////////////

        // Compute maximum absolute error compared to a reference function
        // by sampling at many points
        Real MaxError(const IRealFunction& func, int numSamples = 1000) const
        {
            Real maxErr = 0.0;
            for (int i = 0; i <= numSamples; i++)
            {
                Real x = _a + i * (_b - _a) / numSamples;
                Real err = std::abs((*this)(x) - func(x));
                if (err > maxErr)
                    maxErr = err;
            }
            return maxErr;
        }

        Real MaxError(std::function<Real(Real)> func, int numSamples = 1000) const
        {
            Real maxErr = 0.0;
            for (int i = 0; i <= numSamples; i++)
            {
                Real x = _a + i * (_b - _a) / numSamples;
                Real err = std::abs((*this)(x) - func(x));
                if (err > maxErr)
                    maxErr = err;
            }
            return maxErr;
        }

        // Print coefficients for debugging
        void PrintCoefficients(std::ostream& os = std::cout, int precision = 10) const
        {
            os << "ChebyshevApproximation on [" << _a << ", " << _b << "]" << std::endl;
            os << "Coefficients (" << _coef.size() << " stored, " << _m << " used):" << std::endl;
            os << std::scientific << std::setprecision(precision);
            for (int j = 0; j < static_cast<int>(_coef.size()); j++)
            {
                os << "  c[" << j << "] = " << _coef[j];
                if (j >= _m)
                    os << " (truncated)";
                os << std::endl;
            }
        }
    };

    ///////////////////////////////////////////////////////////////////////////////////////////
    ///                           UTILITY FUNCTIONS                                         ///
    ///////////////////////////////////////////////////////////////////////////////////////////

    // Compute the zeros (roots) of Chebyshev polynomial T_n
    // These are optimal interpolation nodes.
    // x_k = cos((2k + 1)Ï€ / (2n))  for k = 0, 1, ..., n-1
    inline Vector<Real> ChebyshevRoots(int n)
    {
        if (n <= 0)
            throw std::invalid_argument("ChebyshevRoots: n must be positive");

        Vector<Real> roots(n);
        const Real pi = Constants::PI;

        for (int k = 0; k < n; k++)
            roots[k] = std::cos(pi * (2 * k + 1) / (2.0 * n));

        return roots;
    }

    // Compute the extrema of Chebyshev polynomial T_n (Chebyshev-Lobatto points)
    // These include the endpoints and are used in Clenshaw-Curtis quadrature.
    // x_k = cos(kÏ€ / n)  for k = 0, 1, ..., n
    inline Vector<Real> ChebyshevExtrema(int n)
    {
        if (n <= 0)
            throw std::invalid_argument("ChebyshevExtrema: n must be positive");

        Vector<Real> extrema(n + 1);
        const Real pi = Constants::PI;

        for (int k = 0; k <= n; k++)
            extrema[k] = std::cos(pi * k / n);

        return extrema;
    }

} // namespace MML


///////////////////////////   mml/tools/ConsolePrinter.h   ///////////////////////////



namespace MML {

	///////////////////////////       MODERN API       ///////////////////////////

	// Format type enumeration
	enum class FormatType {
		General,	 // Default formatting
		Fixed,		 // std::fixed
		Scientific,	 // std::scientific
		Hexadecimal, // std::hex
		Integer		 // No decimal point
	};

	// Alignment enumeration
	enum class Alignment { Left, Right, Center };

	// Border style enumeration
	enum class BorderStyle {
		None,	  // No borders
		Simple,	  // ASCII: + - |
		Markdown, // | - |
		Rounded,  // Unicode: â•­â”€â•®â”‚â•°â”€â•¯
		Double,	  // Unicode: â•”â•â•—â•‘â•šâ•â•
		Bold	  // Unicode: â”â”â”“â”ƒâ”—â”â”›
	};

	// Export format enumeration
	enum class ExportFormat {
		Console,  // Pretty-printed to console
		CSV,	  // Comma-separated values
		TSV,	  // Tab-separated values
		Markdown, // Markdown table
		LaTeX,	  // LaTeX tabular
		HTML	  // HTML table
	};

	///////////////////////////       RAII Stream Guard       ///////////////////////////

	// RAII Stream State Guard - preserves stream state across operations
	class StreamStateGuard {
	private:
		std::ostream& m_stream;
		std::ios_base::fmtflags m_flags;
		std::streamsize m_precision;
		std::streamsize m_width;

	public:
		explicit StreamStateGuard(std::ostream& os)
			: m_stream(os)
			, m_flags(os.flags())
			, m_precision(os.precision())
			, m_width(os.width()) {}

		~StreamStateGuard() {
			m_stream.flags(m_flags);
			m_stream.precision(m_precision);
			m_stream.width(m_width);
		}

		// Non-copyable, non-movable
		StreamStateGuard(const StreamStateGuard&) = delete;
		StreamStateGuard& operator=(const StreamStateGuard&) = delete;
		StreamStateGuard(StreamStateGuard&&) = delete;
		StreamStateGuard& operator=(StreamStateGuard&&) = delete;
	};

	///////////////////////////       Column Format       ///////////////////////////

	// Column Format Class with Builder Pattern
	class ColumnFormat {
	private:
		std::string m_name;
		int m_width;
		int m_precision;
		FormatType m_formatType;
		Alignment m_alignment;
		int m_calculatedWidth; // -1 means use m_width

	public:
		static constexpr int AUTO_WIDTH = -1;

		// Constructor
		explicit ColumnFormat(std::string name)
			: m_name(std::move(name))
			, m_width(12)
			, m_precision(6)
			, m_formatType(FormatType::General)
			, m_alignment(Alignment::Right)
			, m_calculatedWidth(-1) {}

		// Legacy compatibility constructor
		ColumnFormat(std::string name, int width, int precision, char format)
			: m_name(std::move(name))
			, m_width(width)
			, m_precision(precision)
			, m_formatType(format == 'F'   ? FormatType::Fixed
						   : format == 'S' ? FormatType::Scientific
										   : FormatType::General)
			, m_alignment(Alignment::Right)
			, m_calculatedWidth(-1) {}

		// Builder pattern methods
		ColumnFormat& width(int w) {
			m_width = w;
			return *this;
		}

		ColumnFormat& precision(int p) {
			m_precision = p;
			return *this;
		}

		ColumnFormat& format(FormatType fmt) {
			m_formatType = fmt;
			return *this;
		}

		ColumnFormat& align(Alignment a) {
			m_alignment = a;
			return *this;
		}

		ColumnFormat& autoWidth() {
			m_width = AUTO_WIDTH;
			return *this;
		}

		// Accessors
		const std::string& name() const { return m_name; }
		int width() const { return m_calculatedWidth >= 0 ? m_calculatedWidth : m_width; }
		int rawWidth() const { return m_width; }
		int precision() const { return m_precision; }
		FormatType formatType() const { return m_formatType; }
		Alignment alignment() const { return m_alignment; }

		// Internal - for auto-width calculation
		void setCalculatedWidth(int w) { m_calculatedWidth = w; }

		// Helper to format a value according to this column's settings
		template<typename T>
		std::string formatValue(const T& value) const {
			std::ostringstream oss;

			// Apply format type
			switch (m_formatType) {
			case FormatType::Fixed:
				oss << std::fixed;
				break;
			case FormatType::Scientific:
				oss << std::scientific;
				break;
			case FormatType::Hexadecimal:
				oss << std::hex;
				break;
			case FormatType::Integer:
				// No decimal formatting
				break;
			case FormatType::General:
			default:
				// Use default formatting
				break;
			}

			// Apply precision
			if (m_formatType != FormatType::Integer && m_formatType != FormatType::Hexadecimal) {
				oss << std::setprecision(m_precision);
			}

			// Output value
			oss << value;
			return oss.str();
		}

		// Helper to format with alignment and width
		std::string formatAligned(const std::string& content) const {
			int w = width();
			if (content.length() >= static_cast<size_t>(w)) {
				return content;
			}

			int padding = w - static_cast<int>(content.length());

			switch (m_alignment) {
			case Alignment::Left:
				return content + std::string(padding, ' ');
			case Alignment::Right:
				return std::string(padding, ' ') + content;
			case Alignment::Center: {
				int leftPad = padding / 2;
				int rightPad = padding - leftPad;
				return std::string(leftPad, ' ') + content + std::string(rightPad, ' ');
			}
			default:
				return content;
			}
		}
	};

	///////////////////////////       Table Style       ///////////////////////////

	// Table Style Class
	class TableStyle {
	private:
		BorderStyle m_border;
		bool m_showHeader;
		bool m_showRowSeparators;
		bool m_compactMode;

	public:
		TableStyle()
			: m_border(BorderStyle::Simple)
			, m_showHeader(true)
			, m_showRowSeparators(false)
			, m_compactMode(false) {}

		// Builder pattern methods
		TableStyle& border(BorderStyle style) {
			m_border = style;
			return *this;
		}

		TableStyle& header(bool show) {
			m_showHeader = show;
			return *this;
		}

		TableStyle& rowSeparators(bool show) {
			m_showRowSeparators = show;
			return *this;
		}

		TableStyle& compact(bool enable) {
			m_compactMode = enable;
			return *this;
		}

		// Accessors
		BorderStyle borderStyle() const { return m_border; }
		bool showHeader() const { return m_showHeader; }
		bool showRowSeparators() const { return m_showRowSeparators; }
		bool compactMode() const { return m_compactMode; }

		// Border characters
		struct BorderChars {
			std::string topLeft, topRight, bottomLeft, bottomRight;
			std::string horizontal, vertical;
			std::string leftT, rightT, topT, bottomT, cross;
		};

		BorderChars getChars() const {
			switch (m_border) {
			case BorderStyle::None:
				return {"", "", "", "", "", "", "", "", "", "", ""};
			case BorderStyle::Simple:
				return {"+", "+", "+", "+", "-", "|", "+", "+", "+", "+", "+"};
			case BorderStyle::Markdown:
				return {"|", "|", "|", "|", "-", "|", "|", "|", "|", "|", "|"};
			case BorderStyle::Rounded:
				return {"â•­", "â•®", "â•°", "â•¯", "â”€", "â”‚", "â”œ", "â”¤", "â”¬", "â”´", "â”¼"};
			case BorderStyle::Double:
				return {"â•”", "â•—", "â•š", "â•", "â•", "â•‘", "â• ", "â•£", "â•¦", "â•©", "â•¬"};
			case BorderStyle::Bold:
				return {"â”", "â”“", "â”—", "â”›", "â”", "â”ƒ", "â”£", "â”«", "â”³", "â”»", "â•‹"};
			default:
				return {"+", "+", "+", "+", "-", "|", "+", "+", "+", "+", "+"};
			}
		}
	};

	///////////////////////////       Table Printer       ///////////////////////////

	// Modern TablePrinter with full features
	template<typename RowTag, typename CellValue>
	class TablePrinter {
	private:
		std::string m_tagColumnName;
		ColumnFormat m_tagFormat;
		std::vector<ColumnFormat> m_columnFormats;
		std::vector<RowTag> m_rowTags;
		std::vector<std::vector<CellValue>> m_data;
		TableStyle m_style;

	public:
		// Construction with simple column names
		TablePrinter(std::string tagName, std::vector<std::string> columnNames)
			: m_tagColumnName(std::move(tagName))
			, m_tagFormat(m_tagColumnName) {
			for (const auto& name : columnNames) {
				m_columnFormats.emplace_back(name);
			}
		}

		// Construction with explicit tag format
		TablePrinter(ColumnFormat tagFormat, std::vector<ColumnFormat> columnFormats)
			: m_tagColumnName(tagFormat.name())
			, m_tagFormat(std::move(tagFormat))
			, m_columnFormats(std::move(columnFormats)) {}

		// Legacy constructor for backward compatibility
		TablePrinter(std::string tagName, int tagWidth, int tagPrecision, std::vector<std::string> valueNames,
					 std::vector<std::tuple<int, int, char>> formatSpecs)
			: m_tagColumnName(std::move(tagName))
			, m_tagFormat(m_tagColumnName, tagWidth, tagPrecision, 'D') {
			for (size_t i = 0; i < valueNames.size(); ++i) {
				auto [w, p, f] = formatSpecs[i];
				m_columnFormats.emplace_back(valueNames[i], w, p, f);
			}
		}

		// Builder pattern for configuration
		TablePrinter& style(const TableStyle& s) {
			m_style = s;
			return *this;
		}

		TablePrinter& tagFormat(const ColumnFormat& fmt) {
			m_tagFormat = fmt;
			return *this;
		}

		TablePrinter& columnFormat(size_t col, const ColumnFormat& fmt) {
			if (col < m_columnFormats.size()) {
				m_columnFormats[col] = fmt;
			}
			return *this;
		}

		// Data manipulation
		void addRow(RowTag tag, std::vector<CellValue> values) {
			if (values.size() != m_columnFormats.size()) {
				throw VectorDimensionError("Number of values does not match number of columns", 
				                           static_cast<int>(m_columnFormats.size()), static_cast<int>(values.size()));
			}
			m_rowTags.push_back(std::move(tag));
			m_data.push_back(std::move(values));
		}

		void clear() {
			m_rowTags.clear();
			m_data.clear();
		}

		void reserve(size_t rows) {
			m_rowTags.reserve(rows);
			m_data.reserve(rows);
		}

		// Query
		size_t rowCount() const { return m_data.size(); }
		size_t columnCount() const { return m_columnFormats.size(); }

		// Output to console (default)
		void print(std::ostream& os = std::cout) const { exportTo(os, ExportFormat::Console); }

		// Legacy compatibility - Print() with capital P
		void Print() const { print(); }

		// Print to file
		void printToFile(const std::string& filename) const {
			std::ofstream file(filename);
			if (!file) {
				throw FileIOError("Cannot open file: " + filename, filename);
			}
			print(file);
		}

		// Convert to string
		std::string toString() const {
			std::ostringstream oss;
			print(oss);
			return oss.str();
		}

		// Legacy API compatibility - capital P
		void Print() { print(std::cout); }

		// Export to different formats
		void exportTo(std::ostream& os, ExportFormat format) const {
			StreamStateGuard guard(os);

			switch (format) {
			case ExportFormat::Console:
				exportConsole(os);
				break;
			case ExportFormat::CSV:
				exportCSV(os);
				break;
			case ExportFormat::TSV:
				exportTSV(os);
				break;
			case ExportFormat::Markdown:
				exportMarkdown(os);
				break;
			case ExportFormat::LaTeX:
				exportLaTeX(os);
				break;
			case ExportFormat::HTML:
				exportHTML(os);
				break;
			}
		}

		void exportToFile(const std::string& filename, ExportFormat format) const {
			std::ofstream file(filename);
			if (!file) {
				throw FileIOError("Cannot open file: " + filename, filename);
			}
			exportTo(file, format);
		}

	private:
		// Console export with borders and styling
		void exportConsole(std::ostream& os) const {
			auto bc = m_style.getChars();
			bool hasBorders = m_style.borderStyle() != BorderStyle::None;

			// Calculate auto-widths if needed
			calculateAutoWidths();

			// Print top border
			if (hasBorders && m_style.showHeader()) {
				printHorizontalLine(os, bc.topLeft, bc.horizontal, bc.topT, bc.topRight);
			}

			// Print header
			if (m_style.showHeader()) {
				if (hasBorders)
					os << bc.vertical << " ";
				os << m_tagFormat.formatAligned(m_tagFormat.name());

				for (const auto& fmt : m_columnFormats) {
					if (hasBorders)
						os << " " << bc.vertical << " ";
					else
						os << "  ";
					os << fmt.formatAligned(fmt.name());
				}

				if (hasBorders)
					os << " " << bc.vertical;
				os << "\n";

				// Header separator
				if (hasBorders) {
					printHorizontalLine(os, bc.leftT, bc.horizontal, bc.cross, bc.rightT);
				}
			}

			// Print data rows
			for (size_t row = 0; row < m_data.size(); ++row) {
				if (hasBorders)
					os << bc.vertical << " ";
				os << m_tagFormat.formatAligned(m_tagFormat.formatValue(m_rowTags[row]));

				for (size_t col = 0; col < m_columnFormats.size(); ++col) {
					if (hasBorders)
						os << " " << bc.vertical << " ";
					else
						os << "  ";
					os << m_columnFormats[col].formatAligned(m_columnFormats[col].formatValue(m_data[row][col]));
				}

				if (hasBorders)
					os << " " << bc.vertical;
				os << "\n";

				// Row separator
				if (hasBorders && m_style.showRowSeparators() && row < m_data.size() - 1) {
					printHorizontalLine(os, bc.leftT, bc.horizontal, bc.cross, bc.rightT);
				}
			}

			// Print bottom border
			if (hasBorders) {
				printHorizontalLine(os, bc.bottomLeft, bc.horizontal, bc.bottomT, bc.bottomRight);
			}
		}

		// CSV export
		void exportCSV(std::ostream& os) const {
			// Header
			os << m_tagFormat.name();
			for (const auto& fmt : m_columnFormats) {
				os << "," << fmt.name();
			}
			os << "\n";

			// Data
			for (size_t row = 0; row < m_data.size(); ++row) {
				os << m_rowTags[row];
				for (const auto& value : m_data[row]) {
					os << "," << value;
				}
				os << "\n";
			}
		}

		// TSV export
		void exportTSV(std::ostream& os) const {
			// Header
			os << m_tagFormat.name();
			for (const auto& fmt : m_columnFormats) {
				os << "\t" << fmt.name();
			}
			os << "\n";

			// Data
			for (size_t row = 0; row < m_data.size(); ++row) {
				os << m_rowTags[row];
				for (const auto& value : m_data[row]) {
					os << "\t" << value;
				}
				os << "\n";
			}
		}

		// Markdown export
		void exportMarkdown(std::ostream& os) const {
			// Header
			os << "| " << m_tagFormat.name();
			for (const auto& fmt : m_columnFormats) {
				os << " | " << fmt.name();
			}
			os << " |\n";

			// Separator
			os << "|" << std::string(m_tagFormat.name().length() + 2, '-');
			for (const auto& fmt : m_columnFormats) {
				os << "|" << std::string(fmt.name().length() + 2, '-');
			}
			os << "|\n";

			// Data
			for (size_t row = 0; row < m_data.size(); ++row) {
				os << "| " << m_rowTags[row];
				for (const auto& value : m_data[row]) {
					os << " | " << value;
				}
				os << " |\n";
			}
		}

		// LaTeX export
		void exportLaTeX(std::ostream& os) const {
			// Begin tabular
			os << "\\begin{tabular}{|";
			for (size_t i = 0; i <= m_columnFormats.size(); ++i) {
				os << "c|";
			}
			os << "}\n\\hline\n";

			// Header
			os << m_tagFormat.name();
			for (const auto& fmt : m_columnFormats) {
				os << " & " << fmt.name();
			}
			os << " \\\\\n\\hline\n";

			// Data
			for (size_t row = 0; row < m_data.size(); ++row) {
				os << m_rowTags[row];
				for (const auto& value : m_data[row]) {
					os << " & " << value;
				}
				os << " \\\\\n";
			}

			// End tabular
			os << "\\hline\n\\end{tabular}\n";
		}

		// HTML export
		void exportHTML(std::ostream& os) const {
			os << "<table border=\"1\">\n";

			// Header
			os << "  <thead>\n    <tr>\n";
			os << "      <th>" << m_tagFormat.name() << "</th>\n";
			for (const auto& fmt : m_columnFormats) {
				os << "      <th>" << fmt.name() << "</th>\n";
			}
			os << "    </tr>\n  </thead>\n";

			// Body
			os << "  <tbody>\n";
			for (size_t row = 0; row < m_data.size(); ++row) {
				os << "    <tr>\n";
				os << "      <td>" << m_rowTags[row] << "</td>\n";
				for (const auto& value : m_data[row]) {
					os << "      <td>" << value << "</td>\n";
				}
				os << "    </tr>\n";
			}
			os << "  </tbody>\n";

			os << "</table>\n";
		}

		// Helper: print horizontal line for borders
		void printHorizontalLine(std::ostream& os, const std::string& left, const std::string& horiz, const std::string& cross,
								 const std::string& right) const {
			os << left;
			os << std::string(static_cast<size_t>(m_tagFormat.width() + 2), horiz[0]);

			for (size_t i = 0; i < m_columnFormats.size(); ++i) {
				os << cross;
				os << std::string(static_cast<size_t>(m_columnFormats[i].width() + 2), horiz[0]);
			}

			os << right << "\n";
		}

		// Helper: calculate auto-widths
		void calculateAutoWidths() const {
			// Mutable to allow calculation during const operations
			auto& tagFmt = const_cast<ColumnFormat&>(m_tagFormat);
			auto& colFmts = const_cast<std::vector<ColumnFormat>&>(m_columnFormats);

			// Tag column
			if (tagFmt.rawWidth() == ColumnFormat::AUTO_WIDTH) {
				int maxWidth = static_cast<int>(tagFmt.name().length());
				for (const auto& tag : m_rowTags) {
					std::string formatted = tagFmt.formatValue(tag);
					maxWidth = std::max(maxWidth, static_cast<int>(formatted.length()));
				}
				tagFmt.setCalculatedWidth(maxWidth);
			}

			// Value columns
			for (size_t col = 0; col < colFmts.size(); ++col) {
				if (colFmts[col].rawWidth() == ColumnFormat::AUTO_WIDTH) {
					int maxWidth = static_cast<int>(colFmts[col].name().length());
					for (const auto& row : m_data) {
						std::string formatted = colFmts[col].formatValue(row[col]);
						maxWidth = std::max(maxWidth, static_cast<int>(formatted.length()));
					}
					colFmts[col].setCalculatedWidth(maxWidth);
				}
			}
		}
	};

	///////////////////////////       Vector Table Printer       ///////////////////////////

	// Specialized printer for vectors
	class VectorTablePrinter {
	private:
		std::vector<ColumnFormat> m_formats;
		std::vector<const Vector<Real>*> m_vectors;
		TableStyle m_style;
		size_t m_maxLength;

	public:
		VectorTablePrinter()
			: m_maxLength(0) {}

		// Constructor that accepts formats and vectors
		VectorTablePrinter(std::vector<ColumnFormat> formats, std::vector<Vector<Real>*> vectors)
			: m_maxLength(0) {
			for (size_t i = 0; i < vectors.size(); ++i) {
				if (i < formats.size()) {
					addVector(formats[i], *vectors[i]);
				} else {
					addVector("Column" + std::to_string(i), *vectors[i]);
				}
			}
		}

		void addVector(const std::string& name, const Vector<Real>& vec) {
			m_formats.emplace_back(name);
			m_vectors.push_back(&vec);
			m_maxLength = std::max(m_maxLength, static_cast<size_t>(vec.size()));
		}

		void addVector(const ColumnFormat& format, const Vector<Real>& vec) {
			m_formats.push_back(format);
			m_vectors.push_back(&vec);
			m_maxLength = std::max(m_maxLength, static_cast<size_t>(vec.size()));
		}

		VectorTablePrinter& style(const TableStyle& s) {
			m_style = s;
			return *this;
		}

		void print(std::ostream& os = std::cout) const {
			StreamStateGuard guard(os);

			auto bc = m_style.getChars();
			bool hasBorders = m_style.borderStyle() != BorderStyle::None;

			// Print top border
			if (hasBorders && m_style.showHeader()) {
				printHorizontalLine(os, bc.topLeft, bc.horizontal, bc.topT, bc.topRight);
			}

			// Print header
			if (m_style.showHeader()) {
				if (hasBorders)
					os << bc.vertical << " ";

				for (size_t i = 0; i < m_formats.size(); ++i) {
					if (i > 0) {
						if (hasBorders)
							os << " " << bc.vertical << " ";
						else
							os << "  ";
					}
					os << m_formats[i].formatAligned(m_formats[i].name());
				}

				if (hasBorders)
					os << " " << bc.vertical;
				os << "\n";

				// Header separator
				if (hasBorders) {
					printHorizontalLine(os, bc.leftT, bc.horizontal, bc.cross, bc.rightT);
				}
			}

			// Print data rows
			for (size_t row = 0; row < m_maxLength; ++row) {
				if (hasBorders)
					os << bc.vertical << " ";

				for (size_t col = 0; col < m_vectors.size(); ++col) {
					if (col > 0) {
						if (hasBorders)
							os << " " << bc.vertical << " ";
						else
							os << "  ";
					}

					if (row < static_cast<size_t>(m_vectors[col]->size())) {
						Real value = (*m_vectors[col])[row];
						os << m_formats[col].formatAligned(m_formats[col].formatValue(value));
					} else {
						os << m_formats[col].formatAligned("");
					}
				}

				if (hasBorders)
					os << " " << bc.vertical;
				os << "\n";
			}

			// Print bottom border
			if (hasBorders) {
				printHorizontalLine(os, bc.bottomLeft, bc.horizontal, bc.bottomT, bc.bottomRight);
			}
		}

		std::string toString() const {
			std::ostringstream oss;
			print(oss);
			return oss.str();
		}

	private:
		void printHorizontalLine(std::ostream& os, const std::string& left, const std::string& horiz, const std::string& cross,
								 const std::string& right) const {
			os << left;

			for (size_t i = 0; i < m_formats.size(); ++i) {
				if (i > 0)
					os << cross;
				os << std::string(static_cast<size_t>(m_formats[i].width() + 2), horiz[0]);
			}

			os << right << "\n";
		}
	};

	///////////////////////////       LEGACY API (Deprecated)       ///////////////////////////

	// Legacy ColDesc - aliased to ColumnFormat for compatibility
	using ColDesc [[deprecated("Use ColumnFormat instead")]] = ColumnFormat;

} // namespace MML


///////////////////////////   mml/tools/Serializer.h   ///////////////////////////





namespace MML
{
	class Serializer
	{
	public:
		/// Error codes for serialization operations
		enum class SerializeError
		{
			OK,                      ///< Operation succeeded
			FILE_NOT_OPENED,         ///< Failed to open/create file
			INVALID_PARAMETERS,      ///< Invalid input parameters
			WRITE_FAILED             ///< Write operation failed
		};

		/// Result of a serialization operation
		struct SerializeResult
		{
			bool success;                    ///< true if successful, false otherwise
			SerializeError error;            ///< Error code (if any)
			std::string message;             ///< Human-readable error message
		};

		/**
		 * @brief Serialize a real function to file at equally-spaced points
		 * @details Saves function values at equally-spaced points in an interval to file with
		 *          format: [x, f(x)] pairs, one per line. Useful for plotting and data analysis.
		 * @param f The real function to serialize
		 * @param title Display title for the data (written to file header)
		 * @param x1 Start of parameter range
		 * @param x2 End of parameter range
		 * @param numPoints Number of evaluation points (must be >= 2)
		 * @param fileName Output file path where data will be written
		 * @param precision Decimal places for output (default: 15)
		 * @return SerializeResult with success flag and error details
		 * @pre x1 < x2, numPoints >= 2, !fileName.empty()
		 * @post File is closed and flushed; existing file is overwritten
		 * @example
		 *   IRealFunction& f = ...;
		 *   auto result = Serializer::SaveRealFunc(f, "sin(x)", 0, 2*M_PI, 100, "output.txt", 8);
		 *   if (!result.success) std::cerr << result.message << std::endl;
		 * @see SaveRealFunc(const IRealFunction&, std::string, Vector<Real>, std::string, int)
		 */
		// Real function serialization 
		// serializing values at equally spaced points in given interval
		static SerializeResult SaveRealFunc(const IRealFunction& f, std::string title,
										 Real x1, Real x2, int numPoints, std::string fileName, int precision = 15)
		{
			// Validate parameters
			if (numPoints < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "numPoints must be >= 2"};
			if (x1 >= x2)
				return {false, SerializeError::INVALID_PARAMETERS, "x1 must be less than x2"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				file.precision(precision);
				WriteRealFuncHeader(file, "REAL_FUNCTION", title, x1, x2, numPoints);

				Real step = (x2 - x1) / (numPoints - 1);
				for (int i = 0; i < numPoints; i++)
				{
					Real x = x1 + i * step;
					file << x << " " << f(x) << std::endl;
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		/**
		 * @brief Serialize a real function to file at specified points
		 * @details Saves function values at arbitrary (non-equally-spaced) points to file.
		 *          Format: [x, f(x)] pairs, one per line, with bounds from points vector.
		 * @param f The real function to serialize
		 * @param title Display title for the data (written to file header)
		 * @param points Vector of x-coordinates where function is evaluated (must be sorted)
		 * @param fileName Output file path where data will be written
		 * @param precision Decimal places for output (default: 15)
		 * @return SerializeResult with success flag and error details
		 * @pre points.size() >= 2, !fileName.empty()
		 * @post File is closed and flushed; existing file is overwritten
		 * @example
		 *   Vector<Real> points = {0, 1.5, 3.14, 6.28};
		 *   auto result = Serializer::SaveRealFunc(f, "sine", points, "sine_points.txt", 6);
		 * @see SaveRealFunc(const IRealFunction&, std::string, Real, Real, int, std::string, int)
		 */
		// serializing values at given list of points
		static SerializeResult SaveRealFunc(const IRealFunction& f, std::string title,
										 Vector<Real> points, std::string fileName, int precision = 15)
		{
			// Validate parameters
			if (points.size() < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "points vector must have at least 2 elements"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				file.precision(precision);
				WriteRealFuncHeader(file, "REAL_FUNCTION", title, points[0], points[points.size() - 1], static_cast<int>(points.size()));

				for (int i = 0; i < points.size(); i++)
				{
					Real x = points[i];
					file << x << " " << f(x) << std::endl;
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		/**
		 * @brief Serialize a real function saving only function values (space-optimized)
		 * @details Like SaveRealFunc but omits explicit x-coordinates from file since they can be
		 *          reconstructed from x1, x2, and numPoints. File contains only f(x) values.
		 * @param f The real function to serialize
		 * @param title Display title for the data
		 * @param x1 Start of parameter range
		 * @param x2 End of parameter range
		 * @param numPoints Number of equally-spaced evaluation points (must be >= 2)
		 * @param fileName Output file path
		 * @param precision Decimal places for output (default: 15)
		 * @return SerializeResult with success flag and error details
		 * @pre x1 < x2, numPoints >= 2, !fileName.empty()
		 * @post File is closed and flushed; reduced file size vs SaveRealFunc
		 * @note Format: values only (one per line); x-values must be reconstructed by reader
		 * @see SaveRealFunc(const IRealFunction&, std::string, Real, Real, int, std::string, int)
		 */
		// same as SaveRealFunc, but points are not explicitly written in file
		// (as they can be calculated from x1, x2 and numPoints)
		static SerializeResult SaveRealFuncEquallySpaced(const IRealFunction& f, std::string title,
																				Real x1, Real x2, int numPoints, std::string fileName, int precision = 15)
		{
			// Validate parameters
			if (numPoints < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "numPoints must be >= 2"};
			if (x1 >= x2)
				return {false, SerializeError::INVALID_PARAMETERS, "x1 must be less than x2"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				file.precision(precision);
				WriteRealFuncHeader(file, "REAL_FUNCTION_EQUALLY_SPACED", title, x1, x2, numPoints);

				Real step = (x2 - x1) / (numPoints - 1);
				for (int i = 0; i < numPoints; i++)
				{
					Real x = x1 + i * step;
					file << f(x) << std::endl;
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		// Helper function for writing real function headers
		static bool WriteRealFuncHeader(std::ofstream& file, std::string type, std::string title,
																Real x1, Real x2, int numPoints)
		{
			if (!file.is_open())
				return false;

			file << type << std::endl;
			file << title << std::endl;
			file << "x1: " << x1 << std::endl;
			file << "x2: " << x2 << std::endl;
			file << "NumPoints: " << numPoints << std::endl;

			return true;
		}

		// serializing multiple functions in a single files
		static bool WriteRealMultiFuncHeader(std::ofstream& file, std::string title, int numFuncs,
																				 std::vector<std::string> legend, Real x1, Real x2, int numPoints)
		{
			if (!file.is_open())
				return false;

			file << "MULTI_REAL_FUNCTION" << std::endl;

			file << title << std::endl;
			file << numFuncs << std::endl;
			for (int i = 0; i < numFuncs; i++)
				file << legend[i] << std::endl;

			file << "x1: " << x1 << std::endl;
			file << "x2: " << x2 << std::endl;
			file << "NumPoints: " << numPoints << std::endl;

			return true;
		}

		/**
		 * @brief Serialize multiple real functions to a single file
		 * @details Saves multiple function values at the same equally-spaced x-coordinates to file.
		 *          Each row contains: [x, f1(x), f2(x), ..., fn(x)]. Supports function pointers,
		 *          linear interpolation, polynomial interpolation, and spline interpolation functions.
		 * @param funcs Vector of real function pointers to serialize
		 * @param title Display title for the data set
		 * @param legend Vector of labels for each function (must match funcs.size())
		 * @param x1 Start of parameter range
		 * @param x2 End of parameter range
		 * @param numPoints Number of equally-spaced evaluation points (must be >= 2)
		 * @param fileName Output file path
		 * @param precision Decimal places for output (default: 15)
		 * @return SerializeResult with success flag and error details
		 * @pre x1 < x2, numPoints >= 2, funcs.size() == legend.size(), all funcs non-null, !fileName.empty()
		 * @post File is closed and flushed with header + data in columnar format
		 * @example
		 *   std::vector<IRealFunction*> funcs = {&f1, &f2};
		 *   std::vector<std::string> legend = {"sin(x)", "cos(x)"};
		 *   auto result = Serializer::SaveRealMultiFunc(funcs, "Trig", legend, 0, M_PI, 50, "trig.txt", 6);
		 * @see SaveRealMultiFunc(const std::vector<LinearInterpRealFunc>&, std::string, ...)
		 */
		static SerializeResult SaveRealMultiFunc(const std::vector<IRealFunction*> &funcs, std::string title,
												std::vector<std::string> legend, 
												Real x1, Real x2, int numPoints, std::string fileName, int precision = 15)
		{
			// Validate parameters
			if (funcs.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "funcs vector cannot be empty"};
			if (numPoints < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "numPoints must be >= 2"};
			if (x1 >= x2)
				return {false, SerializeError::INVALID_PARAMETERS, "x1 must be less than x2"};
			if (funcs.size() != legend.size())
				return {false, SerializeError::INVALID_PARAMETERS, "funcs and legend sizes must match"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				file.precision(precision);
				WriteRealMultiFuncHeader(file, title, funcs.size(), legend, x1, x2, numPoints);

				for (int i = 0; i < numPoints; i++)
				{
					Real x = x1 + (x2 - x1) * i / (numPoints - 1);
					file << x << " ";

					for (int j = 0; j < funcs.size(); j++)
						file << (*(funcs[j]))(x) << " ";

					file << std::endl;
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}		static SerializeResult SaveRealMultiFunc(const std::vector<LinearInterpRealFunc>& funcs, std::string title,
																	std::vector<std::string> legend,
																	Real x1, Real x2, int numPoints, std::string fileName)
		{
			// Validate parameters
			if (funcs.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "funcs vector cannot be empty"};
			if (numPoints < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "numPoints must be >= 2"};
			if (x1 >= x2)
				return {false, SerializeError::INVALID_PARAMETERS, "x1 must be less than x2"};
			if (funcs.size() != legend.size())
				return {false, SerializeError::INVALID_PARAMETERS, "funcs and legend sizes must match"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteRealMultiFuncHeader(file, title, funcs.size(), legend, x1, x2, numPoints);

				for (int i = 0; i < numPoints; i++)
				{
					Real x = x1 + (x2 - x1) * i / (numPoints - 1);
					file << x << " ";

					for (int j = 0; j < funcs.size(); j++)
						file << funcs[j](x) << " ";

					file << std::endl;
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}
		static SerializeResult SaveRealMultiFunc(const std::vector<PolynomInterpRealFunc>& funcs, std::string title,
																	std::vector<std::string> legend,
																	Real x1, Real x2, int numPoints, std::string fileName)
		{
			// Validate parameters
			if (funcs.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "funcs vector cannot be empty"};
			if (numPoints < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "numPoints must be >= 2"};
			if (x1 >= x2)
				return {false, SerializeError::INVALID_PARAMETERS, "x1 must be less than x2"};
			if (funcs.size() != legend.size())
				return {false, SerializeError::INVALID_PARAMETERS, "funcs and legend sizes must match"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteRealMultiFuncHeader(file, title, funcs.size(), legend, x1, x2, numPoints);

				for (int i = 0; i < numPoints; i++)
				{
					Real x = x1 + (x2 - x1) * i / (numPoints - 1);
					file << x << " ";

					for (int j = 0; j < funcs.size(); j++)
						file << funcs[j](x) << " ";

					file << std::endl;
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}
		static SerializeResult SaveRealMultiFunc(const std::vector<SplineInterpRealFunc>& funcs, std::string title,
																	std::vector<std::string> legend,
																	Real x1, Real x2, int numPoints, std::string fileName)
		{
			// Validate parameters
			if (funcs.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "funcs vector cannot be empty"};
			if (numPoints < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "numPoints must be >= 2"};
			if (x1 >= x2)
				return {false, SerializeError::INVALID_PARAMETERS, "x1 must be less than x2"};
			if (funcs.size() != legend.size())
				return {false, SerializeError::INVALID_PARAMETERS, "funcs and legend sizes must match"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteRealMultiFuncHeader(file, title, funcs.size(), legend, x1, x2, numPoints);

				for (int i = 0; i < numPoints; i++)
				{
					Real x = x1 + (x2 - x1) * i / (numPoints - 1);
					file << x << " ";

					for (int j = 0; j < funcs.size(); j++)
						file << funcs[j](x) << " ";

					file << std::endl;
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		// Helper function for writing parametric curve headers
		static bool WriteParamCurveHeader(std::ofstream& file, std::string type, std::string title,
																			Real t1, Real t2, int numPoints)
		{
			if (!file.is_open())
				return false;

			file << type << std::endl;
			if (!title.empty())
				file << title << std::endl;
			file << "t1: " << t1 << std::endl;
			file << "t2: " << t2 << std::endl;
			file << "NumPoints: " << numPoints << std::endl;

			return true;
		}

		// Parametric curve serialization
		template<int N>
		static bool SaveParamCurve(const IRealToVectorFunction<N>& f, std::string inType, std::string title, 
															 Real t1, Real t2, int numPoints, std::string fileName)
		{
			std::ofstream file(fileName);
			if (!file.is_open())
				return false;

			WriteParamCurveHeader(file, inType, title, t1, t2, numPoints);

			Real delta = (t2 - t1) / (numPoints - 1);
			for (Real t = t1; t <= t2; t += delta)
			{
				file << t << " ";
				for (int i = 0; i < N; i++)
					file << f(t)[i] << " ";
				file << std::endl;
			}
			file.close();
			return true;
		}

		template<int N>
		static bool SaveParamCurve(const IRealToVectorFunction<N>& f, std::string inType, std::string title, 
															 Vector<Real> points, std::string fileName)
		{
			std::ofstream file(fileName);
			if (!file.is_open())
				return false;

			WriteParamCurveHeader(file, inType, title, points[0], points[points.size() - 1], static_cast<int>(points.size()));

			for (int i = 0; i < points.size(); i++)
			{
				Real t = points[i];
				file << t << " ";
				for (int i = 0; i < N; i++)
					file << f(t)[i] << " ";
				file << std::endl;
			}

			file.close();
			return true;
		}

		template<int N>
		static bool SaveAsParamCurve(std::vector<VectorN<Real, N>> vals, std::string inType, std::string title, 
																 Real t1, Real t2, int numPoints, std::string fileName)
		{
			std::ofstream file(fileName);
			if (!file.is_open())
				return false;

			WriteParamCurveHeader(file, inType, title, t1, t2, numPoints);

			Real delta = (t2 - t1) / (numPoints - 1);
			for (int i = 0; i < numPoints; i++)
			{
				Real t = t1 + i * delta;
				file << t << " ";
				for (int j = 0; j < N; j++)
					file << vals[i][j] << " ";
				file << std::endl;
			}
			file.close();
			return true;
		}

		template<int N>
		static bool SaveAsParamCurve(std::vector<VectorN<Real, N>> vals, std::string inType, std::string title,
																 Vector<Real> points, std::string fileName)
		{
			std::ofstream file(fileName);
			if (!file.is_open())
				return false;

			WriteParamCurveHeader(file, inType, title, points[0], points[points.size() - 1], static_cast<int>(points.size()));

			for (int i = 0; i < points.size(); i++)
			{
				Real t = points[i];
				file << t << " ";
				for (int j = 0; j < N; j++)
					file << vals[i][j] << " ";
				file << std::endl;
			}
			file.close();
			return true;
		}

		/**
		 * @brief Serialize a parametric 2D curve from component vectors
		 * @details Saves a 2D parametric curve (x(t), y(t)) from explicit vector pairs to file.
		 *          Useful for plotting trajectories and curves defined by separate x and y vectors.
		 *          Format: [t, x(t), y(t)] triplets, one per line.
		 * @param vec_x Vector of x-coordinates (must be same size as vec_y)
		 * @param vec_y Vector of y-coordinates (must be same size as vec_x)
		 * @param fileName Output file path for the parametric curve
		 * @param t1 Start of parameter range (default: 0.0, used to label parameter axis)
		 * @param t2 End of parameter range (default: 1.0, used to label parameter axis)
		 * @return SerializeResult with success flag and error details
		 * @pre vec_x.size() >= 2, vec_x.size() == vec_y.size(), t1 < t2, !fileName.empty()
		 * @post File is closed and flushed; parameter range [t1, t2] mapped across vector indices
		 * @note Parameter values are computed linearly from t1 to t2 across indices
		 * @example
		 *   Vector<Real> xs = {0, 1, 2, 1, 0};
		 *   Vector<Real> ys = {0, 1.732, 0, -1.732, 0};
		 *   auto result = Serializer::SaveAsParamCurve2D(xs, ys, "Pentagon", "curve.txt", 0, 2*M_PI);
		 */
		// save parametric curve in 2D as a list of points
		static SerializeResult SaveAsParamCurve2D(const Vector<Real>& vec_x, const Vector<Real>& vec_y, 
													std::string title, std::string fileName, Real t1 = 0.0, Real t2 = 1.0)
		{
			// Validate parameters
			if (fileName.empty()) {
				return { false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty" };
			}
			if (vec_x.size() < 2) {
				return { false, SerializeError::INVALID_PARAMETERS, "vec_x must have at least 2 elements" };
			}
			if (vec_x.size() != vec_y.size()) {
				return { false, SerializeError::INVALID_PARAMETERS, "vec_x and vec_y must have same size" };
			}
			if (t1 >= t2) {
				return { false, SerializeError::INVALID_PARAMETERS, "t1 must be < t2" };
			}

			std::ofstream file(fileName);
			if (!file.is_open()) {
				return { false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName };
			}

			try {
				WriteParamCurveHeader(file, "PARAMETRIC_CURVE_CARTESIAN_2D", title, t1, t2, static_cast<int>(vec_x.size()));

				for (int i = 0; i < vec_x.size(); i++)
				{
					Real t = t1 + (t2 - t1) * i / (vec_x.size() - 1);
					file << t << " " << vec_x[i] << " " << vec_y[i] << std::endl;
				}
				file.close();
				return { true, SerializeError::OK, "Successfully saved parametric curve 2D" };
			}
			catch (const std::exception& e) {
				file.close();
				return { false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what() };
			}
		}

		// Helper/forwarding functions
		static bool SaveParamCurveCartesian2D(const IRealToVectorFunction<2>& f, std::string title, 
																					Real t1, Real t2, int numPoints, std::string fileName)
		{
			return SaveParamCurve<2>(f, "PARAMETRIC_CURVE_CARTESIAN_2D", title, t1, t2, numPoints, fileName);
		}
		
		static bool SaveParamCurveCartesian3D(const IRealToVectorFunction<3>& f, std::string title, 
																					Real t1, Real t2, int numPoints, std::string fileName)
		{
			return SaveParamCurve<3>(f, "PARAMETRIC_CURVE_CARTESIAN_3D", title, t1, t2, numPoints, fileName);
		}

		/**
		 * @brief Serialize a 2D scalar function (z=f(x,y)) to a grid file
		 * @details Saves a 2D scalar function evaluated on a rectangular grid to file.
		 *          Format: Header with grid parameters, then value rows (one per y-line, varying x).
		 *          Ideal for surface plots and heatmaps.
		 * @param f The 2D scalar function to serialize
		 * @param title Display title for the surface data
		 * @param x1 Start of x parameter range
		 * @param x2 End of x parameter range
		 * @param numPointsX Number of grid points along x (must be >= 2)
		 * @param y1 Start of y parameter range
		 * @param y2 End of y parameter range
		 * @param numPointsY Number of grid points along y (must be >= 2)
		 * @param fileName Output file path
		 * @return SerializeResult with success flag and error details
		 * @pre x1 < x2, y1 < y2, numPointsX >= 2, numPointsY >= 2, !fileName.empty()
		 * @post File contains grid layout with f(x,y) values; suitable for surface visualization
		 * @example
		 *   auto result = Serializer::SaveScalarFunc2DCartesian(f, "z=x*y", 0, 10, 20, 0, 10, 20, "surface.txt");
		 * @see SaveScalarFunc3DCartesian
		 */
		// Scalar function serialization
		static SerializeResult SaveScalarFunc2DCartesian(const IScalarFunction<2>& f, std::string title,
																				Real x1, Real x2, int numPointsX, 
																				Real y1, Real y2, int numPointsY, std::string fileName)
		{
			// Validate parameters
			if (numPointsX < 2 || numPointsY < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "numPointsX and numPointsY must be >= 2"};
			if (x1 >= x2 || y1 >= y2)
				return {false, SerializeError::INVALID_PARAMETERS, "x1 < x2 and y1 < y2 required"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				file << "SCALAR_FUNCTION_CARTESIAN_2D" << std::endl;
				file << title << std::endl;
				file << "x1: " << x1 << std::endl;
				file << "x2: " << x2 << std::endl;
				file << "NumPointsX: " << numPointsX << std::endl;
				file << "y1: " << y1 << std::endl;
				file << "y2: " << y2 << std::endl;
				file << "NumPointsY: " << numPointsY << std::endl;

				Real stepX = (x2 - x1) / (numPointsX - 1);
				Real stepY = (y2 - y1) / (numPointsY - 1);
				for (int i = 0; i < numPointsX; i++)
				{
					for (int j = 0; j < numPointsY; j++)
					{
						Real x = x1 + i * stepX;
						Real y = y1 + j * stepY;
						file << x << " " << y << " " << f(VectorN<Real, 2>{x, y}) << std::endl;
					}
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		/**
		 * @brief Serialize a 3D scalar function (w=f(x,y,z)) to a grid file
		 * @details Saves a 3D scalar function evaluated on a rectangular 3D grid to file.
		 *          Format: Header with grid parameters, then value rows (one per point in 3D grid).
		 *          Useful for volumetric data and 3D scalar field visualization.
		 * @param f The 3D scalar function to serialize
		 * @param title Display title for the volumetric data
		 * @param x1 Start of x parameter range
		 * @param x2 End of x parameter range
		 * @param numPointsX Number of grid points along x (must be >= 2)
		 * @param y1 Start of y parameter range
		 * @param y2 End of y parameter range
		 * @param numPointsY Number of grid points along y (must be >= 2)
		 * @param z1 Start of z parameter range
		 * @param z2 End of z parameter range
		 * @param numPointsZ Number of grid points along z (must be >= 2)
		 * @param fileName Output file path
		 * @return SerializeResult with success flag and error details
		 * @pre All bounds ordered, all numPoints >= 2, !fileName.empty()
		 * @post File contains volumetric grid with f(x,y,z) values; large for dense grids
		 * @note Consider using coarse grids initially to manage file size
		 * @see SaveScalarFunc2DCartesian
		 */
		static SerializeResult SaveScalarFunc3DCartesian(const IScalarFunction<3>& f, std::string title, 
																				Real x1, Real x2, int numPointsX, 
																				Real y1, Real y2, int numPointsY, 
																				Real z1, Real z2, int numPointsZ, std::string fileName)
		{
			// Validate parameters
			if (numPointsX < 2 || numPointsY < 2 || numPointsZ < 2)
				return {false, SerializeError::INVALID_PARAMETERS, "numPointsX, numPointsY, and numPointsZ must be >= 2"};
			if (x1 >= x2 || y1 >= y2 || z1 >= z2)
				return {false, SerializeError::INVALID_PARAMETERS, "x1 < x2, y1 < y2, and z1 < z2 required"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				file << "SCALAR_FUNCTION_CARTESIAN_3D" << std::endl;
				file << title << std::endl;
				file << "x1: " << x1 << std::endl;
				file << "x2: " << x2 << std::endl;
				file << "NumPointsX: " << numPointsX << std::endl;
				file << "y1: " << y1 << std::endl;
				file << "y2: " << y2 << std::endl;
				file << "NumPointsY: " << numPointsY << std::endl;
				file << "z1: " << z1 << std::endl;
				file << "z2: " << z2 << std::endl;
				file << "NumPointsZ: " << numPointsZ << std::endl;

				Real stepX = (x2 - x1) / (numPointsX - 1);
				Real stepY = (y2 - y1) / (numPointsY - 1);
				Real stepZ = (z2 - z1) / (numPointsZ - 1);
				for (int i = 0; i < numPointsX; i++)
				{
					for (int j = 0; j < numPointsY; j++)
					{
						for (int k = 0; k < numPointsZ; k++)
						{
							Real x = x1 + i * stepX;
							Real y = y1 + j * stepY;
							Real z = z1 + k * stepZ;
							file << x << " " << y << " " << z << " " << f(VectorN<Real, 3>{x, y, z}) << std::endl;
						}
					}
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////
		// Vector field header writer - centralizes header generation for all vector field types
		///////////////////////////////////////////////////////////////////////////////////////
		static void WriteVectorFieldHeader(std::ofstream& file, const std::string& type, const std::string& title)
		{
			file << type << std::endl;
			file << title << std::endl;
		}

		// 2D vector function serialization
		static SerializeResult SaveVectorFunc2D( const IVectorFunction<2>& f, std::string inType, std::string title,
																	Real x1_start, Real x1_end, int numPointsX1,
																	Real x2_start, Real x2_end, int numPointsX2, std::string fileName)
		{
			// Validate parameters
			if (numPointsX1 < 1 || numPointsX2 < 1)
				return {false, SerializeError::INVALID_PARAMETERS, "numPointsX1 and numPointsX2 must be >= 1"};
			if (x1_start >= x1_end || x2_start >= x2_end)
				return {false, SerializeError::INVALID_PARAMETERS, "x1_start < x1_end and x2_start < x2_end required"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteVectorFieldHeader(file, inType, title);

				Real stepX = (x1_end - x1_start) / (numPointsX1 - 1);
				Real stepY = (x2_end - x2_start) / (numPointsX2 - 1);
				for (int i = 0; i < numPointsX1; i++)
					for (int j = 0; j < numPointsX2; j++)
					{
						Real x = x1_start + i * stepX;
						Real y = x2_start + j * stepY;
						auto val = f(VectorN<Real, 2>{x, y});
						file << x << " " << y << " " << val[0] << " " << val[1] << std::endl;
					}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		static SerializeResult SaveVectorFunc2D( const IVectorFunction<2>& f, std::string inType, std::string title,
																	Real x1_start, Real x1_end, int numPointsX1,
																	Real x2_start, Real x2_end, int numPointsX2,
																	std::string fileName, Real upper_threshold)
		{
			// Validate parameters
			if (numPointsX1 < 1 || numPointsX2 < 1)
				return {false, SerializeError::INVALID_PARAMETERS, "numPointsX1 and numPointsX2 must be >= 1"};
			if (x1_start >= x1_end || x2_start >= x2_end)
				return {false, SerializeError::INVALID_PARAMETERS, "x1_start < x1_end and x2_start < x2_end required"};
			if (upper_threshold <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "upper_threshold must be positive"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteVectorFieldHeader(file, inType, title);

				Real stepX = (x1_end - x1_start) / (numPointsX1 - 1);
				Real stepY = (x2_end - x2_start) / (numPointsX2 - 1);
				for (int i = 0; i < numPointsX1; i++)
					for (int j = 0; j < numPointsX2; j++)
					{
						Real x = x1_start + i * stepX;
						Real y = x2_start + j * stepY;
						auto val = f(VectorN<Real, 2>{x, y});
						if (val.NormL2() < upper_threshold)
							file << x << " " << y << " " << val[0] << " " << val[1] << std::endl;
					}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		static SerializeResult SaveVectorFunc2DCartesian(const IVectorFunction<2>& f, std::string title,
																				Real x1, Real x2, int numPointsX,
																				Real y1, Real y2, int numPointsY, std::string fileName)
		{
			return SaveVectorFunc2D(f, "VECTOR_FIELD_2D_CARTESIAN", title, x1, x2, numPointsX, y1, y2, numPointsY, fileName);
		}

		static SerializeResult SaveVectorFunc2DCartesian(const IVectorFunction<2>& f, std::string title,
																				Real x1, Real x2, int numPointsX,
																				Real y1, Real y2, int numPointsY, std::string fileName, 
																				Real upper_threshold)
		{
			return SaveVectorFunc2D(f, "VECTOR_FIELD_2D_CARTESIAN", title, x1, x2, numPointsX, y1, y2, numPointsY, fileName, upper_threshold);
		}

		// 3D vector function serialization
		static SerializeResult SaveVectorFunc3D(const IVectorFunction<3>& f, std::string inType, std::string title,
																 Real x1_start, Real x1_end, int numPointsX1, 
																 Real x2_start, Real x2_end, int numPointsX2, 
																 Real x3_start, Real x3_end, int numPointsX3, std::string fileName)
		{
			// Validate parameters
			if (numPointsX1 < 1 || numPointsX2 < 1 || numPointsX3 < 1)
				return {false, SerializeError::INVALID_PARAMETERS, "all numPoints must be >= 1"};
			if (x1_start >= x1_end || x2_start >= x2_end || x3_start >= x3_end)
				return {false, SerializeError::INVALID_PARAMETERS, "all start bounds must be less than end bounds"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteVectorFieldHeader(file, inType, title);

				Real stepX = (x1_end - x1_start) / (numPointsX1 - 1);
				Real stepY = (x2_end - x2_start) / (numPointsX2 - 1);
				Real stepZ = (x3_end - x3_start) / (numPointsX3 - 1);
				for (int i = 0; i < numPointsX1; i++)
					for (int j = 0; j < numPointsX2; j++)
						for (int k = 0; k < numPointsX3; k++)
						{
							Real x = x1_start + i * stepX;
							Real y = x2_start + j * stepY;
							Real z = x3_start + k * stepZ;
							auto val = f(VectorN<Real, 3>{x, y, z});
							file << x << " " << y << " " << z << " " << val[0] << " " << val[1] << " " << val[2] << std::endl;
						}

				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		static SerializeResult SaveVectorFunc3D(const IVectorFunction<3>& f, std::string inType, std::string title, 
																 Real x1_start, Real x1_end, int numPointsX1, 
																 Real x2_start, Real x2_end, int numPointsX2, 
																 Real x3_start, Real x3_end, int numPointsX3, 
																 std::string fileName, Real upper_threshold)
		{
			// Validate parameters
			if (numPointsX1 < 1 || numPointsX2 < 1 || numPointsX3 < 1)
				return {false, SerializeError::INVALID_PARAMETERS, "all numPoints must be >= 1"};
			if (x1_start >= x1_end || x2_start >= x2_end || x3_start >= x3_end)
				return {false, SerializeError::INVALID_PARAMETERS, "all start bounds must be less than end bounds"};
			if (upper_threshold <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "upper_threshold must be positive"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteVectorFieldHeader(file, inType, title);

				Real stepX = (x1_end - x1_start) / (numPointsX1 - 1);
				Real stepY = (x2_end - x2_start) / (numPointsX2 - 1);
				Real stepZ = (x3_end - x3_start) / (numPointsX3 - 1);
				for (int i = 0; i < numPointsX1; i++)
					for (int j = 0; j < numPointsX2; j++)
						for (int k = 0; k < numPointsX3; k++)
						{
							Real x = x1_start + i * stepX;
							Real y = x2_start + j * stepY;
							Real z = x3_start + k * stepZ;
							auto val = f(VectorN<Real, 3>{x, y, z});

							if (val.NormL2() < upper_threshold)
								file << x << " " << y << " " << z << " " << val[0] << " " << val[1] << " " << val[2] << std::endl;
						}

				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		static SerializeResult SaveVectorFunc3DCartesian(const IVectorFunction<3>& f, std::string title, 
																					Real x1, Real x2, int numPointsX, 
																					Real y1, Real y2, int numPointsY, 
																					Real z1, Real z2, int numPointsZ, std::string fileName)
		{
			return SaveVectorFunc3D(f, "VECTOR_FIELD_3D_CARTESIAN", title, x1, x2, numPointsX, y1, y2, numPointsY, z1, z2, numPointsZ, fileName);
		}
		static SerializeResult SaveVectorFunc3DCartesian(const IVectorFunction<3>& f, std::string title, 
																					Real x1, Real x2, int numPointsX, 
																					Real y1, Real y2, int numPointsY, 
																					Real z1, Real z2, int numPointsZ, std::string fileName, 
																					Real upper_threshold)
		{
			return SaveVectorFunc3D(f, "VECTOR_FIELD_3D_CARTESIAN", title, x1, x2, numPointsX, y1, y2, numPointsY, z1, z2, numPointsZ, fileName, upper_threshold);
		}
		
		static SerializeResult SaveVectorFuncSpherical(const IVectorFunction<3>& f, std::string title, Real r1, Real r2, int numPointsR, Real theta1, Real theta2, int numPointsTheta, Real phi1, Real phi2, int numPointsPhi, std::string fileName)
		{
			return SaveVectorFunc3D(f, "VECTOR_FIELD_SPHERICAL", title, r1, r2, numPointsR, theta1, theta2, numPointsTheta, phi1, phi2, numPointsPhi, fileName);
		}
		static SerializeResult SaveVectorFuncSpherical(const IVectorFunction<3>& f, std::string title, Real r1, Real r2, int numPointsR, Real theta1, Real theta2, int numPointsTheta, Real phi1, Real phi2, int numPointsPhi, std::string fileName, Real upper_threshold)
		{
			return SaveVectorFunc3D(f, "VECTOR_FIELD_SPHERICAL", title, r1, r2, numPointsR, theta1, theta2, numPointsTheta, phi1, phi2, numPointsPhi, fileName, upper_threshold);
		}

		// ODESolution serialization
		static SerializeResult SaveODESolutionComponentAsFunc(const ODESystemSolution& sol, int compInd, 
																							 std::string title, std::string fileName)
		{
			// Validate parameters
			if (sol.getSysDim() <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "ODE solution dimension must be positive"};
			if (compInd < 0 || compInd >= sol.getSysDim())
				return {false, SerializeError::INVALID_PARAMETERS, "component index out of range [0, " + std::to_string(sol.getSysDim() - 1) + "]"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteRealFuncHeader(file, "REAL_FUNCTION", title, sol.getT1(), sol.getT2(), sol.getTotalSavedSteps());
				
				for (int i = 0; i < sol.getTotalSavedSteps(); i++)
				{
					file << sol.getTValues()[i] << " " << sol.getXValues()[compInd][i] << std::endl;
				}
				
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		static SerializeResult SaveODESolutionAsMultiFunc(const ODESystemSolution& sol, std::string title, std::vector<std::string> legend, std::string fileName)
		{
			// Validate parameters
			if (legend.size() != sol.getSysDim())
				return {false, SerializeError::INVALID_PARAMETERS, "legend size (" + std::to_string(legend.size()) + ") must match ODE dimension (" + std::to_string(sol.getSysDim()) + ")"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteRealMultiFuncHeader(file, title, sol.getSysDim(), legend, sol.getT1(), sol.getT2(), sol.getTotalSavedSteps());

				for (int i = 0; i < sol.getTotalSavedSteps(); i++)
				{
					file << sol.getTValues()[i] << " ";
					for (int j = 0; j < sol.getSysDim(); j++)
					{
						file << sol.getXValues()[j][i] << " ";
					}
					file << std::endl;
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		static SerializeResult SaveODESolAsParametricCurve2D(const ODESystemSolution& sol, std::string fileName, 
																							int ind1, int ind2, std::string title)
		{
			// Validate parameters
			if (sol.getSysDim() <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "ODE solution dimension must be positive"};
			if (ind1 < 0 || ind1 >= sol.getSysDim() || ind2 < 0 || ind2 >= sol.getSysDim())
				return {false, SerializeError::INVALID_PARAMETERS, "component indices out of range [0, " + std::to_string(sol.getSysDim() - 1) + "]"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteParamCurveHeader(file, "PARAMETRIC_CURVE_CARTESIAN_2D", title, sol.getT1(), sol.getT2(), sol.getTotalSavedSteps());
				
				for (int i = 0; i < sol.getTotalSavedSteps(); i++)
				{
					file << sol.getTValues()[i] << " ";
					file << sol.getXValues()[ind1][i] << " ";
					file << sol.getXValues()[ind2][i] << " ";
					file << std::endl;
				}
				
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}
		
		static SerializeResult SaveODESolAsParametricCurve3D(const ODESystemSolution& sol, std::string fileName, 
																							int ind1, int ind2, int ind3, std::string title)
		{
			// Validate parameters
			if (sol.getSysDim() <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "ODE solution dimension must be positive"};
			if (ind1 < 0 || ind1 >= sol.getSysDim() || ind2 < 0 || ind2 >= sol.getSysDim() || ind3 < 0 || ind3 >= sol.getSysDim())
				return {false, SerializeError::INVALID_PARAMETERS, "component indices out of range [0, " + std::to_string(sol.getSysDim() - 1) + "]"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				WriteParamCurveHeader(file, "PARAMETRIC_CURVE_CARTESIAN_3D", title, sol.getT1(), sol.getT2(), sol.getTotalSavedSteps());

				for (int i = 0; i < sol.getTotalSavedSteps(); i++)
				{
					file << sol.getTValues()[i] << " ";
					file << sol.getXValues()[ind1][i] << " ";
					file << sol.getXValues()[ind2][i] << " ";
					file << sol.getXValues()[ind3][i] << " ";
					file << std::endl;
				}

				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		// particle simulation serialization
		static SerializeResult SaveParticleSimulation2D(std::string fileName, int numBalls, Real width, Real height,
																			 std::vector<std::vector<Pnt2Cart>> ballPositions, 
																			 std::vector<std::string> ballColors, std::vector<Real> ballRadius,
																			 Real dT, int saveEveryNSteps = 1)
		{
			// Validate parameters
			if (numBalls <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "numBalls must be positive"};
			if (width <= 0 || height <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "width and height must be positive"};
			if (dT <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "dT must be positive"};
			if (ballPositions.size() != numBalls || ballColors.size() != numBalls || ballRadius.size() != numBalls)
				return {false, SerializeError::INVALID_PARAMETERS, "ballPositions, ballColors, and ballRadius sizes must equal numBalls"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				std::ostringstream buffer;
				buffer << "PARTICLE_SIMULATION_DATA_2D\n";
				buffer << "Width: " << width << "\n";
				buffer << "Height: " << height << "\n";
				buffer << "NumBalls: " << numBalls << "\n";

				for (int i=0; i<numBalls; i++)
				{
					buffer << "Ball_" << i + 1 << " " << ballColors[i] << " " << ballRadius[i] << std::endl;
				}

				int numSteps = ballPositions[0].size() ;
				buffer << "NumSteps: " << numSteps / saveEveryNSteps << std::endl;

				int realStep = 0;
				for (int i = 0; i < numSteps; i+=saveEveryNSteps, realStep++)
				{
					buffer << "Step " << realStep << " " << i * dT << std::endl;
					for (int j = 0; j < numBalls; j++)
					{
						buffer << j << " " << ballPositions[j][i].X() << " " << ballPositions[j][i].Y() << "\n";
					}
				}
				file << buffer.str();
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}

		static SerializeResult SaveParticleSimulation3D(std::string fileName, int numBalls, Real width, Real height, Real depth,
																				 std::vector<std::vector<Pnt3Cart>> ballPositions,
																				 std::vector<std::string> ballColors, std::vector<Real> ballRadius,
																				 Real dT, int saveEveryNSteps = 1)
		{
			// Validate parameters
			if (numBalls <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "numBalls must be positive"};
			if (width <= 0 || height <= 0 || depth <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "width, height, and depth must be positive"};
			if (dT <= 0)
				return {false, SerializeError::INVALID_PARAMETERS, "dT must be positive"};
			if (ballPositions.size() != numBalls || ballColors.size() != numBalls || ballRadius.size() != numBalls)
				return {false, SerializeError::INVALID_PARAMETERS, "ballPositions, ballColors, and ballRadius sizes must equal numBalls"};
			if (fileName.empty())
				return {false, SerializeError::INVALID_PARAMETERS, "fileName cannot be empty"};

			std::ofstream file(fileName);
			if (!file.is_open())
				return {false, SerializeError::FILE_NOT_OPENED, "Cannot open file: " + fileName};

			try
			{
				file << "PARTICLE_SIMULATION_DATA_3D" << std::endl;
				file << "Width: "    << width << std::endl;
				file << "Height: "   << height << std::endl;
				file << "Depth: "    << depth << std::endl;
				file << "NumBalls: " << numBalls << std::endl;

				for (int i = 0; i < numBalls; i++)
				{
					file << "Ball_" << i+1 << " " << ballColors[i] << " " << ballRadius[i] << std::endl;
				}

				int numSteps = ballPositions[0].size();
				file << "NumSteps: " << numSteps << std::endl;

				for (int i = 0; i < numSteps; i++)
				{
					file << "Step " << i << " " << i * dT << std::endl;
					for (int j = 0; j < numBalls; j++)
					{
						file << j << " " << ballPositions[j][i].X() << " " << ballPositions[j][i].Y() << " " << ballPositions[j][i].Z() << "\n";
					}
				}
				file.close();
				return {true, SerializeError::OK, "Success"};
			}
			catch (const std::exception& e)
			{
				return {false, SerializeError::WRITE_FAILED, std::string("Write error: ") + e.what()};
			}
		}
	};
}

///////////////////////////   mml/tools/Visualizer.h   ///////////////////////////






#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#else
#endif


namespace MML
{
	// Result struct for visualizer operations - provides error information
	struct VisualizerResult
	{
		bool success;
		int exitCode;
		std::string errorMessage;
		std::string dataFilePath;  // Path to the data file that was created
		
		static VisualizerResult Success(const std::string& dataPath = "") {
			return VisualizerResult{true, 0, "", dataPath};
		}
		
		static VisualizerResult Failure(const std::string& message, const std::string& dataPath = "", int code = -1) {
			return VisualizerResult{false, code, message, dataPath};
		}
		
		// Allow implicit conversion to bool for backward compatibility
		operator bool() const { return success; }
	};

	class Visualizer
	{
		// Use getter functions for cross-platform path resolution
		static inline std::string _pathResultFiles{ GetResultFilesPath() };

		static inline std::string _pathRealFuncViz{ GetRealFuncVisualizerPath() };
		static inline std::string _pathSurfaceViz{ GetSurfaceVisualizerPath() };
		static inline std::string _pathParametricCurve3DViz{ GetParametricCurve3DVisualizerPath() };
		static inline std::string _pathParametricCurve2DViz{ GetParametricCurve2DVisualizerPath() };
		static inline std::string _pathVectorField2DViz{ GetVectorField2DVisualizerPath() };
		static inline std::string _pathVectorField3DViz{ GetVectorField3DVisualizerPath() };

		static inline std::string _pathParticle2DViz{ GetParticle2DVisualizerPath() };
		static inline std::string _pathParticle3DViz{ GetParticle3DVisualizerPath() };

		// Helper: validate filename contains only safe characters
		static bool IsFilenameSafe(const std::string& filename) {
			for (char c : filename) {
				// Allow alphanumeric, underscore, hyphen, dot, path separators, and colon (for drive letters)
				if (!std::isalnum(static_cast<unsigned char>(c)) && 
					c != '_' && c != '-' && c != '.' && c != '/' && c != '\\' && c != ':') {
					return false;
				}
			}
			return true;
		}
		
		// Helper: sanitize filename by replacing unsafe characters
		static std::string SanitizeFilename(const std::string& filename) {
			std::string result = filename;
			for (char& c : result) {
				if (!std::isalnum(static_cast<unsigned char>(c)) && 
					c != '_' && c != '-' && c != '.' && c != '/' && c != '\\' && c != ':') {
					c = '_';
				}
			}
			return result;
		}

		// Helper: normalize path separators for the current platform
		static std::string NormalizePath(const std::string& path) {
			std::string result = path;
#ifdef _WIN32
			for (char& c : result) {
				if (c == '/') c = '\\';
			}
#else
			for (char& c : result) {
				if (c == '\\') c = '/';
			}
#endif
			return result;
		}

		// Safe process execution without shell - Windows implementation
#ifdef _WIN32
		static VisualizerResult ExecuteVisualizerWindows(const std::string& executable, 
														const std::vector<std::string>& args) {
			// Build command line: "exe" "arg1" "arg2" ...
			std::string cmdLine = "\"" + NormalizePath(executable) + "\"";
			for (const auto& arg : args) {
				cmdLine += " \"" + NormalizePath(arg) + "\"";
			}
			
			// Get working directory (directory containing the executable)
			std::string exePath = NormalizePath(executable);
			std::string workDir;
			auto lastSep = exePath.find_last_of("\\");
			if (lastSep != std::string::npos) {
				workDir = exePath.substr(0, lastSep);
			}
			
			STARTUPINFOA si = {};
			si.cb = sizeof(si);
			PROCESS_INFORMATION pi = {};
			
			// CreateProcess needs a modifiable string
			std::vector<char> cmdLineBuffer(cmdLine.begin(), cmdLine.end());
			cmdLineBuffer.push_back('\0');
			
			BOOL success = CreateProcessA(
				nullptr,                    // Application name (use command line)
				cmdLineBuffer.data(),       // Command line
				nullptr,                    // Process security attributes
				nullptr,                    // Thread security attributes
				FALSE,                      // Inherit handles
				0,                          // Creation flags
				nullptr,                    // Environment
				workDir.empty() ? nullptr : workDir.c_str(),  // Working directory
				&si,                        // Startup info
				&pi                         // Process info
			);
			
			if (!success) {
				DWORD error = GetLastError();
				return VisualizerResult::Failure(
					"Failed to start visualizer process. Error code: " + std::to_string(error),
					args.empty() ? "" : args[0],
					static_cast<int>(error)
				);
			}
			
			// Wait for GUI visualizer to close (use 0xFFFFFFFF for INFINITE timeout, compatible with all include orders)
			WaitForSingleObject(pi.hProcess, 0xFFFFFFFF);
			
			DWORD dwExitCode = 0;
			GetExitCodeProcess(pi.hProcess, &dwExitCode);
			
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
			
			return VisualizerResult::Success(args.empty() ? "" : args[0]);
		}
#else
		// Safe process execution without shell - POSIX implementation
		static VisualizerResult ExecuteVisualizerPosix(const std::string& executable,
													  const std::vector<std::string>& args) {
			pid_t pid = fork();
			
			if (pid < 0) {
				return VisualizerResult::Failure("Failed to fork process",
					args.empty() ? "" : args[0], -1);
			}
			
			if (pid == 0) {
				// Child process
				std::vector<char*> argv;
				std::string exePath = NormalizePath(executable);
				argv.push_back(const_cast<char*>(exePath.c_str()));
				
				std::vector<std::string> normalizedArgs;
				for (const auto& arg : args) {
					normalizedArgs.push_back(NormalizePath(arg));
				}
				for (auto& arg : normalizedArgs) {
					argv.push_back(const_cast<char*>(arg.c_str()));
				}
				argv.push_back(nullptr);
				
				execv(exePath.c_str(), argv.data());
				
				// If execv returns, it failed
				_exit(127);
			}
			
			// Parent process - don't wait for GUI visualizers
			// Let the visualizer run independently
			return VisualizerResult::Success(args.empty() ? "" : args[0]);
		}
#endif

		// Main execution dispatcher
		static VisualizerResult ExecuteVisualizer(const std::string& executable,
												 const std::vector<std::string>& args) {
			// Validate executable path
			if (executable.empty()) {
				return VisualizerResult::Failure("Visualizer executable path is empty");
			}
			
			// Validate all arguments (filenames)
			for (const auto& arg : args) {
				if (!IsFilenameSafe(arg)) {
					return VisualizerResult::Failure(
						"Invalid characters in filename: " + arg,
						arg
					);
				}
			}

#ifdef _WIN32
			return ExecuteVisualizerWindows(executable, args);
#else
			return ExecuteVisualizerPosix(executable, args);
#endif
		}

	public:
		// visualizations of Real function
		static VisualizerResult VisualizeRealFunction(const IRealFunction& f, std::string title,
																			Real x1, Real x2, int numPoints, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveRealFunc(f, title, x1, x2, numPoints, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathRealFuncViz, {name});
		}

		static VisualizerResult VisualizeRealFunction(const IRealFunction& f, std::string title,
																			Vector<Real> points, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveRealFunc(f, title, points, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathRealFuncViz, {name});
		}

		// visualizations of multiple Real functions
		static VisualizerResult VisualizeMultiRealFunction(std::vector<IRealFunction*> funcs, std::string title,
																		 std::vector<std::string> func_legend,
																		 Real x1, Real x2, int numPoints, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveRealMultiFunc(funcs, title, func_legend, x1, x2, numPoints, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathRealFuncViz, {name});
		}

		static VisualizerResult VisualizeMultiRealFunction(std::vector<LinearInterpRealFunc> funcs, std::string title,
																		 std::vector<std::string> func_legend,
																		 Real x1, Real x2, int numPoints, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveRealMultiFunc(funcs, title, func_legend, x1, x2, numPoints, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathRealFuncViz, {name});
		}

		// visualization of multiple real functions where each function is saved (and visualized) separately
		static VisualizerResult VisualizeMultiRealFunctionSeparately(std::vector<LinearInterpRealFunc> funcs, std::string title,
																										 std::vector<std::string> func_legend,
																										 Real x1, Real x2, int numPoints, std::string fileName)
		{
			// for each function, serialize data to file, with name generated from fileName
			std::vector<std::string> fileNames;
			int i = 0;
			for (auto& func : funcs)
			{
				std::string name = _pathResultFiles + SanitizeFilename(fileName) + "_" + std::to_string(i + 1) + ".txt";

				Real xLow  = x1 < funcs[i].MinX() ? funcs[i].MinX() : x1;
				Real xHigh = x2 > funcs[i].MaxX() ? funcs[i].MaxX() : x2;

				auto saveResult = Serializer::SaveRealFunc(funcs[i], func_legend[i], xLow, xHigh, numPoints, name);
				if (!saveResult.success) {
					return VisualizerResult::Failure("Failed to save function " + std::to_string(i) + ": " + saveResult.message, name);
				}
				fileNames.push_back(name);
				i++;
			}
			return ExecuteVisualizer(_pathRealFuncViz, fileNames);
		}

		static VisualizerResult VisualizeMultiRealFunction(std::vector<PolynomInterpRealFunc> funcs, std::string title,
																		 std::vector<std::string> func_legend,
																		 Real x1, Real x2, int numPoints, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveRealMultiFunc(funcs, title, func_legend, x1, x2, numPoints, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathRealFuncViz, {name});
		}

		static VisualizerResult VisualizeMultiRealFunction(std::vector<SplineInterpRealFunc> funcs, std::string title,
																		 std::vector<std::string> func_legend,
																		 Real x1, Real x2, int numPoints, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveRealMultiFunc(funcs, title, func_legend, x1, x2, numPoints, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathRealFuncViz, {name});
		}

		// visualizations of Scalar function in 2D
		static VisualizerResult VisualizeScalarFunc2DCartesian(const IScalarFunction<2>& func, std::string title,
																							 Real x1, Real x2, int numPointsX,
																							 Real y1, Real y2, int numPointsY, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveScalarFunc2DCartesian(func, title, x1, x2, numPointsX, y1, y2, numPointsY, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathSurfaceViz, {name});
		}

		// visualizations of Vector fields
		static VisualizerResult VisualizeVectorField2DCartesian(const IVectorFunction<2>& func, std::string title,
																								Real x1, Real x2, int numPointsX,
																								Real y1, Real y2, int numPointsY, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveVectorFunc2DCartesian(func, title, x1, x2, numPointsX, y1, y2, numPointsY, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathVectorField2DViz, {name});
		}

		static VisualizerResult VisualizeVectorField3DCartesian(const IVectorFunction<3>& func, std::string title,
																								Real x1, Real x2, int numPointsX,
																								Real y1, Real y2, int numPointsY,
																								Real z1, Real z2, int numPointsZ, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveVectorFunc3DCartesian(func, title, x1, x2, numPointsX, y1, y2, numPointsY, z1, z2, numPointsZ, name, 3.0);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathVectorField3DViz, {name});
		}

		// visualizations of Parametric curves
		static VisualizerResult VisualizeParamCurve2D(const IRealToVectorFunction<2>& f, std::string title, 
																			Real t1, Real t2, int numPoints, 
																			std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			bool saved = Serializer::SaveParamCurveCartesian2D(f, title, t1, t2, numPoints, name);
			if (!saved) {
				return VisualizerResult::Failure("Failed to save parametric curve data", name);
			}
			return ExecuteVisualizer(_pathParametricCurve2DViz, {name});
		}

		static VisualizerResult VisualizeMultiParamCurve2D(std::vector<IRealToVectorFunction<2>*> curves, 
																					 std::string title,
																					 Real t1, Real t2,
																					 int numPoints, std::string fileName)
		{
			// for each function, serialize data to file, with name generated from fileName
			std::vector<std::string> fileNames;
			int i = 0;
			for (auto& curve : curves)
			{
				std::string name = _pathResultFiles + SanitizeFilename(fileName) + "_" + std::to_string(i + 1) + ".txt";
				bool saved = Serializer::SaveParamCurveCartesian2D(*curve, title, t1, t2, numPoints, name);
				if (!saved) {
					return VisualizerResult::Failure("Failed to save curve " + std::to_string(i), name);
				}
				fileNames.push_back(name);
				i++;
			}
			return ExecuteVisualizer(_pathParametricCurve2DViz, fileNames);
		}

		static VisualizerResult VisualizeMultiParamCurve2D(std::vector<IRealToVectorFunction<2>*> curves,
																						std::vector<std::string> legend,
																						Real t1, Real t2,
																						int numPoints, std::string fileName)
		{
			// for each function, serialize data to file, with name generated from fileName
			std::vector<std::string> fileNames;
			int i = 0;
			for (auto& curve : curves)
			{
				std::string name = _pathResultFiles + SanitizeFilename(fileName) + "_" + std::to_string(i + 1) + ".txt";
				bool saved = Serializer::SaveParamCurveCartesian2D(*curve, legend[i], t1, t2, numPoints, name);
				if (!saved) {
					return VisualizerResult::Failure("Failed to save curve " + std::to_string(i), name);
				}
				fileNames.push_back(name);
				i++;
			}
			return ExecuteVisualizer(_pathParametricCurve2DViz, fileNames);
		}

		static VisualizerResult VisualizeMultiParamCurve2D(std::vector<std::string> fileNames)
		{
			std::vector<std::string> fullPaths;
			for (auto& name : fileNames)
			{
				std::string fullPath = _pathResultFiles + SanitizeFilename(name);
				if (!std::filesystem::exists(fullPath)) {
					return VisualizerResult::Failure("Data file not found: " + fullPath, fullPath);
				}
				fullPaths.push_back(fullPath);
			}
			return ExecuteVisualizer(_pathParametricCurve2DViz, fullPaths);
		}

		static VisualizerResult VisualizeParamCurve3D(const IRealToVectorFunction<3>& f, std::string title, 
																			Real t1, Real t2, int numPoints, 
																			std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			bool saved = Serializer::SaveParamCurveCartesian3D(f, title, t1, t2, numPoints, name);
			if (!saved) {
				return VisualizerResult::Failure("Failed to save parametric curve data", name);
			}
			return ExecuteVisualizer(_pathParametricCurve3DViz, {name});
		}

		static VisualizerResult VisualizeMultiParamCurve3D(std::vector<IRealToVectorFunction<3>*> curves, 
																					 std::string title,
																					 Real t1, Real t2, int numPoints, 
																					 std::string fileName)
		{
			// for each function, serialize data to file, with name generated from fileName
			std::vector<std::string> fileNames;
			int i = 0;
			for (auto& curve : curves)
			{
				std::string name = _pathResultFiles + SanitizeFilename(fileName) + "_" + std::to_string(i + 1) + ".txt";
				bool saved = Serializer::SaveParamCurveCartesian3D(*curve, title, t1, t2, numPoints, name);
				if (!saved) {
					return VisualizerResult::Failure("Failed to save curve " + std::to_string(i), name);
				}
				fileNames.push_back(name);
				i++;
			}
			return ExecuteVisualizer(_pathParametricCurve3DViz, fileNames);
		}

		static VisualizerResult VisualizeMultiParamCurve3D(std::vector<std::string> fileNames)
		{
			std::vector<std::string> fullPaths;
			for (auto& name : fileNames)
			{
				std::string fullPath = _pathResultFiles + SanitizeFilename(name);
				if (!std::filesystem::exists(fullPath)) {
					return VisualizerResult::Failure("Data file not found: " + fullPath, fullPath);
				}
				fullPaths.push_back(fullPath);
			}
			return ExecuteVisualizer(_pathParametricCurve3DViz, fullPaths);
		}

		// ODE Solution visualizations
		// Visualizing single variable of ODE system solution as Real function
		static VisualizerResult VisualizeODESysSolCompAsFunc(const ODESystemSolution& sol, int compInd,
																				 std::string title, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveODESolutionComponentAsFunc(sol, compInd, title, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathRealFuncViz, {name});
		}

		// Visualizing ODE system solution as a multi-function (all variables)
		static VisualizerResult VisualizeODESysSolAsMultiFunc(const ODESystemSolution& sol,
																				std::string title, std::vector<std::string> legend, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveODESolutionAsMultiFunc(sol, title, legend, name);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathRealFuncViz, {name});
		}

		// Visualizing two variables of ODE system solution as a parametric curve in 2D
		static VisualizerResult VisualizeODESysSolAsParamCurve2(const ODESystemSolution& sol,
																								int ind1, int ind2,
																								std::string title, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveODESolAsParametricCurve2D(sol, name, ind1, ind2, title);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathParametricCurve2DViz, {name});
		}

		// Visualizing three variables of ODE system solution as a parametric curve in 3D
		static VisualizerResult VisualizeODESysSolAsParamCurve3(const ODESystemSolution& sol,
																								int ind1, int ind2, int ind3,
																								std::string title, std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			auto saveResult = Serializer::SaveODESolAsParametricCurve3D(sol, name, ind1, ind2, ind3, title);
			if (!saveResult.success) {
				return VisualizerResult::Failure("Failed to save data: " + saveResult.message, name);
			}
			return ExecuteVisualizer(_pathParametricCurve3DViz, {name});
		}

		// Particle simulation visualizations
		static VisualizerResult VisualizeParticleSimulation2D(std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			if (!std::filesystem::exists(name)) {
				return VisualizerResult::Failure("Data file not found: " + name, name);
			}
			return ExecuteVisualizer(_pathParticle2DViz, {name});
		}

		static VisualizerResult VisualizeParticleSimulation3D(std::string fileName)
		{
			std::string name = _pathResultFiles + SanitizeFilename(fileName);
			if (!std::filesystem::exists(name)) {
				return VisualizerResult::Failure("Data file not found: " + name, name);
			}
			return ExecuteVisualizer(_pathParticle3DViz, {name});
		}
	};
}

///////////////////////////   mml/tools/ThreadPool.h   ///////////////////////////


namespace MML
{
	class ThreadPool {
	private:
		std::vector<std::thread> workers;
		std::queue<std::function<void()>> tasks;
		std::mutex queue_mutex;
		std::condition_variable condition;
		std::condition_variable tasks_done_condition;  // P0-2: For wait_for_tasks()
		std::atomic<bool> stop{false};                 // P0-3: Atomic to prevent data race
		std::atomic<size_t> in_flight_tasks{0};        // P0-2: Track executing tasks

	public:
		ThreadPool(size_t numThreads)
		{
			for (size_t i = 0; i < numThreads; ++i)
				workers.emplace_back([this]
					{
						while (true) {
							std::function<void()> task;
							{
								std::unique_lock<std::mutex> lock(this->queue_mutex);

								this->condition.wait(lock, [this] { return this->stop.load() || !this->tasks.empty(); });

								if (this->stop.load() && this->tasks.empty())
									return;

								task = std::move(this->tasks.front());
								this->tasks.pop();
								++this->in_flight_tasks;  // P0-2: Track task start
							}
							task();
							
							// P0-2: Track task completion and notify waiters
							if (--this->in_flight_tasks == 0) {
								std::lock_guard<std::mutex> lock(this->queue_mutex);
								if (this->tasks.empty()) {
									this->tasks_done_condition.notify_all();
								}
							}
						}
					});
		}
		~ThreadPool()
		{
			// P0-1: Set stop flag and notify under lock, then release BEFORE joining
			{
				std::lock_guard<std::mutex> lock(queue_mutex);
				stop.store(true);
			}
			condition.notify_all();
			
			// P0-1: Now safe to join - workers can acquire mutex to wake up
			for (std::thread& worker : workers)
				worker.join();
		}

		// Delete copy constructor and assignment operator
		ThreadPool(const ThreadPool&) = delete;
		ThreadPool& operator=(const ThreadPool&) = delete;

		ThreadPool(ThreadPool&&) = delete;
		ThreadPool& operator=(ThreadPool&&) = delete;

		void enqueue(std::function<void()> f) 
		{
			{
				std::lock_guard<std::mutex> lock(queue_mutex);
				tasks.push(std::move(f));
			}
			condition.notify_one();
		}
		
		// P0-2: Fixed - waits for queue empty AND all tasks completed
		void wait_for_tasks() {
			std::unique_lock<std::mutex> lock(queue_mutex);
			tasks_done_condition.wait(lock, [this] { 
				return tasks.empty() && in_flight_tasks.load() == 0; 
			});
		}
		
		bool has_tasks() {
			std::lock_guard<std::mutex> lock(queue_mutex);
			return !tasks.empty() || in_flight_tasks.load() > 0;
		}
		
		size_t pending_tasks() const {
			return in_flight_tasks.load();
		}

	};
} // namespace MML


///////////////////////////   mml/tools/Timer.h   ///////////////////////////



namespace MML
{
	class Timer
	{
	private:
		std::chrono::steady_clock::time_point _startTime;
		std::vector<std::chrono::steady_clock::time_point> _markedTimes;
		std::vector<std::string> _markedNames;

	public:
		Timer() {}
		~Timer() {}
		
		Timer(const Timer&) = delete;
		Timer& operator=(const Timer&) = delete;

		void Start()
		{
			std::chrono::steady_clock::time_point t(std::chrono::steady_clock::now());
			_startTime = t;
		}
		void MarkTime()
		{
			_markedNames.push_back("Unnamed Mark");
			_markedTimes.push_back(std::chrono::steady_clock::now());
		}
		void MarkTime(const std::string& name)
		{
			_markedNames.push_back(name);
			_markedTimes.push_back(std::chrono::steady_clock::now());
		}
		double GetIntervalTime(int index = 0) const
		{
			// handling exceptions for index out of range and empty marked times
			if (index < 0 || index >= _markedTimes.size())
				throw std::out_of_range("Index out of range for marked times.");
			if( _markedTimes.empty() && index >= 0)
				throw std::runtime_error("No marked times available. Use MarkTime() before accessing intervals.");

			if (index == 0)
				return std::chrono::duration<double>(_markedTimes[0] - _startTime).count();
			else
				return std::chrono::duration<double>(_markedTimes[index] - _markedTimes[index - 1]).count();
		}
		double GetMarkTimeFromStart(int index = 0) const
		{
			if (index < 0 || index >= _markedTimes.size())
				throw std::out_of_range("Index out of range for marked times.");
			if( _markedTimes.empty() && index >= 0)
				throw std::runtime_error("No marked times available. Use MarkTime() before accessing intervals.");
			
			return std::chrono::duration<double>(_markedTimes[index] - _startTime).count();
		}
		double GetTotalTime() const
		{
			if (_markedTimes.empty())
				throw std::runtime_error("No marked times available. Use MarkTime() before accessing total time.");
			return std::chrono::duration<double>(_markedTimes.back() - _startTime).count();
		}

		void Print()
		{
			if (_markedTimes.empty())
			{
				std::cout << "No marked times available." << std::endl;
				return;
			}
			std::cout << "Timer Results:" << std::endl;
			for (size_t i = 0; i < _markedTimes.size(); ++i)
			{
				std::cout << "Mark " << i << " (" << std::setw(25) << _markedNames[i] << "): "
									<< GetIntervalTime(i) << " seconds" << std::endl;
			}
			std::cout << "Total Time: " << GetTotalTime() << " seconds" << std::endl;
		}
	};
}

///////////////////////////   mml/tools/DataLoader.h   ///////////////////////////



namespace MML {
	namespace Data {

		/////////////////////////////////////////////////////////////////////////////////////
		///                              DATA FORMAT ENUM                                 ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Supported data file formats
		enum class DataFormat {
			CSV,      ///< Comma-separated values
			TSV,      ///< Tab-separated values
			JSON,     ///< JSON format (array of objects)
			Auto      ///< Auto-detect from file extension
		};

		/////////////////////////////////////////////////////////////////////////////////////
		///                              COLUMN TYPE ENUM                                  ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Data types for columns
		enum class ColumnType {
			REAL,     ///< Floating-point numbers
			INT,      ///< Integer numbers
			BOOL,     ///< Boolean values (true/false, yes/no, 1/0)
			STRING,   ///< Text strings
			DATE,     ///< Date (YYYY-MM-DD)
			TIME,     ///< Time (HH:MM:SS)
			DATETIME, ///< Combined date and time
			MISSING   ///< Missing/null value marker
		};

		/// @brief Convert ColumnType to string for display
		inline std::string ColumnTypeToString(ColumnType type) {
			switch (type) {
				case ColumnType::REAL:     return "Real";
				case ColumnType::INT:      return "Int";
				case ColumnType::BOOL:     return "Bool";
				case ColumnType::STRING:   return "String";
				case ColumnType::DATE:     return "Date";
				case ColumnType::TIME:     return "Time";
				case ColumnType::DATETIME: return "DateTime";
				case ColumnType::MISSING:  return "Missing";
				default:                   return "Unknown";
			}
		}

		/////////////////////////////////////////////////////////////////////////////////////
		///                              MISSING VALUE                                     ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Marker for missing values
		struct MissingValue {
			bool operator==(const MissingValue&) const { return true; }
		};

		/// @brief Check if a string represents a missing value
		inline bool IsMissingValue(const std::string& s) {
			if (s.empty()) return true;
			std::string lower = s;
			std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
			return lower == "na" || lower == "n/a" || lower == "nan" ||
			       lower == "null" || lower == "none" || lower == "." ||
			       lower == "?" || lower == "-" || lower == "";
		}

		/////////////////////////////////////////////////////////////////////////////////////
		///                              DATA COLUMN STRUCT                                ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief A single column of data with typed storage
		struct DataColumn {
			std::string name;           ///< Column name/header
			ColumnType type;            ///< Inferred or specified type
			
			// Typed storage vectors - only one is populated based on type
			Vector<Real> realData;
			Vector<int> intData;
			std::vector<bool> boolData;           // Use std::vector for bool (MML Vector issues)
			std::vector<std::string> stringData;
			std::vector<std::string> dateData;    // Stored as YYYY-MM-DD strings
			std::vector<std::string> timeData;    // Stored as HH:MM:SS strings
			std::vector<bool> missingMask;        // true where value is missing

			/// @brief Get number of rows
			size_t Size() const {
				switch (type) {
					case ColumnType::REAL:     return realData.size();
					case ColumnType::INT:      return intData.size();
					case ColumnType::BOOL:     return boolData.size();
					case ColumnType::STRING:   return stringData.size();
					case ColumnType::DATE:     return dateData.size();
					case ColumnType::TIME:     return timeData.size();
					case ColumnType::DATETIME: return dateData.size();
					default:                   return missingMask.size();
				}
			}

			/// @brief Check if value at index is missing
			bool IsMissing(size_t index) const {
				if (index >= missingMask.size()) return false;
				return missingMask[index];
			}

			/// @brief Count missing values
			size_t CountMissing() const {
				size_t count = 0;
				for (bool m : missingMask) {
					if (m) ++count;
				}
				return count;
			}

			/// @brief Get value as string (for any type)
			std::string GetAsString(size_t index) const {
				if (index >= Size()) return "";
				if (IsMissing(index)) return "NA";

				switch (type) {
					case ColumnType::REAL: {
						std::ostringstream oss;
						oss << std::setprecision(6) << realData[index];
						return oss.str();
					}
					case ColumnType::INT:
						return std::to_string(intData[index]);
					case ColumnType::BOOL:
						return boolData[index] ? "true" : "false";
					case ColumnType::STRING:
						return stringData[index];
					case ColumnType::DATE:
						return dateData[index];
					case ColumnType::TIME:
						return timeData[index];
					case ColumnType::DATETIME:
						return dateData[index] + " " + timeData[index];
					default:
						return "NA";
				}
			}

			/// @brief Get real value (converts if possible)
			Real GetReal(size_t index) const {
				if (index >= Size() || IsMissing(index))
					return std::numeric_limits<Real>::quiet_NaN();

				switch (type) {
					case ColumnType::REAL:
						return realData[index];
					case ColumnType::INT:
						return static_cast<Real>(intData[index]);
					case ColumnType::BOOL:
						return boolData[index] ? 1.0 : 0.0;
					default:
						return std::numeric_limits<Real>::quiet_NaN();
				}
			}
		};

		/////////////////////////////////////////////////////////////////////////////////////
		///                              DATASET STRUCT                                    ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief A complete dataset with multiple columns
		struct Dataset {
			std::string name;                    ///< Dataset name
			std::vector<DataColumn> columns;     ///< Column data
			size_t rowCount;                     ///< Number of rows

			/// @brief Default constructor
			Dataset() : rowCount(0) {}

			/// @brief Get number of columns
			size_t NumColumns() const { return columns.size(); }

			/// @brief Get number of rows
			size_t NumRows() const { return rowCount; }

			/// @brief Access column by index
			DataColumn& operator[](size_t index) {
				if (index >= columns.size())
					throw DataError("Dataset: Column index " + std::to_string(index) + " out of range");
				return columns[index];
			}

			const DataColumn& operator[](size_t index) const {
				if (index >= columns.size())
					throw DataError("Dataset: Column index " + std::to_string(index) + " out of range");
				return columns[index];
			}

			/// @brief Access column by name
			DataColumn& operator[](const std::string& colName) {
				for (auto& col : columns) {
					if (col.name == colName) return col;
				}
				throw DataError("Dataset: Column '" + colName + "' not found");
			}

			const DataColumn& operator[](const std::string& colName) const {
				for (const auto& col : columns) {
					if (col.name == colName) return col;
				}
				throw DataError("Dataset: Column '" + colName + "' not found");
			}

			/// @brief Check if column exists
			bool HasColumn(const std::string& colName) const {
				for (const auto& col : columns) {
					if (col.name == colName) return true;
				}
				return false;
			}

			/// @brief Get column names
			std::vector<std::string> GetColumnNames() const {
				std::vector<std::string> names;
				names.reserve(columns.size());
				for (const auto& col : columns) {
					names.push_back(col.name);
				}
				return names;
			}

			/// @brief Get real-valued column as Vector<Real>
			/// @throws DataError if column not found or not convertible to Real
			Vector<Real> GetRealColumn(const std::string& colName) const {
				const DataColumn& col = (*this)[colName];
				if (col.type != ColumnType::REAL && col.type != ColumnType::INT)
					throw DataError("Dataset: Column '" + colName + "' is not numeric");

				if (col.type == ColumnType::REAL)
					return col.realData;

				// Convert int to real
				Vector<Real> result(col.intData.size());
				for (size_t i = 0; i < col.intData.size(); ++i)
					result[i] = static_cast<Real>(col.intData[i]);
				return result;
			}

			/// @brief Get integer column
			Vector<int> GetIntColumn(const std::string& colName) const {
				const DataColumn& col = (*this)[colName];
				if (col.type != ColumnType::INT)
					throw DataError("Dataset: Column '" + colName + "' is not integer type");
				return col.intData;
			}

			/// @brief Get string column
			std::vector<std::string> GetStringColumn(const std::string& colName) const {
				const DataColumn& col = (*this)[colName];
				// Can convert any column to string
				std::vector<std::string> result;
				result.reserve(rowCount);
				for (size_t i = 0; i < rowCount; ++i)
					result.push_back(col.GetAsString(i));
				return result;
			}

			/// @brief Get bool column
			std::vector<bool> GetBoolColumn(const std::string& colName) const {
				const DataColumn& col = (*this)[colName];
				if (col.type != ColumnType::BOOL)
					throw DataError("Dataset: Column '" + colName + "' is not boolean type");
				return col.boolData;
			}

			/// @brief Print dataset summary (pandas describe() style)
			std::string PrintSummary() const {
				std::ostringstream oss;
				oss << "Dataset: " << (name.empty() ? "(unnamed)" : name) << "\n";
				oss << "Shape: " << rowCount << " rows x " << columns.size() << " columns\n\n";

				// Column info
				oss << std::left << std::setw(20) << "Column"
				    << std::setw(12) << "Type"
				    << std::setw(12) << "Non-Null"
				    << std::setw(12) << "Missing"
				    << "\n";
				oss << std::string(56, '-') << "\n";

				for (const auto& col : columns) {
					size_t missing = col.CountMissing();
					oss << std::left << std::setw(20) << col.name
					    << std::setw(12) << ColumnTypeToString(col.type)
					    << std::setw(12) << (rowCount - missing)
					    << std::setw(12) << missing
					    << "\n";
				}

				// Numeric column statistics
				oss << "\nNumeric Column Statistics:\n";
				oss << std::string(80, '-') << "\n";
				oss << std::left << std::setw(15) << "Column"
				    << std::right << std::setw(12) << "Min"
				    << std::setw(12) << "Max"
				    << std::setw(12) << "Mean"
				    << std::setw(12) << "Std"
				    << "\n";

				for (const auto& col : columns) {
					if (col.type == ColumnType::REAL || col.type == ColumnType::INT) {
						Vector<Real> data = (col.type == ColumnType::REAL) ? col.realData :
							[&col]() {
								Vector<Real> r(col.intData.size());
								for (size_t i = 0; i < col.intData.size(); ++i)
									r[i] = static_cast<Real>(col.intData[i]);
								return r;
							}();

						// Filter out NaN/missing
						std::vector<Real> valid;
						for (size_t i = 0; i < data.size(); ++i) {
							if (!col.IsMissing(i) && !std::isnan(data[i]))
								valid.push_back(data[i]);
						}

						if (!valid.empty()) {
							Real minVal = *std::min_element(valid.begin(), valid.end());
							Real maxVal = *std::max_element(valid.begin(), valid.end());
							Real sum = std::accumulate(valid.begin(), valid.end(), 0.0);
							Real mean = sum / valid.size();
							Real sqSum = 0.0;
							for (Real v : valid) sqSum += (v - mean) * (v - mean);
							Real std = std::sqrt(sqSum / valid.size());

							oss << std::left << std::setw(15) << col.name
							    << std::right << std::setw(12) << std::setprecision(4) << minVal
							    << std::setw(12) << maxVal
							    << std::setw(12) << mean
							    << std::setw(12) << std
							    << "\n";
						}
					}
				}

				return oss.str();
			}

			/// @brief Get first n rows as string representation
			std::string Head(size_t n = 5) const {
				return RowsToString(0, std::min(n, rowCount));
			}

			/// @brief Get last n rows as string representation
			std::string Tail(size_t n = 5) const {
				size_t start = rowCount > n ? rowCount - n : 0;
				return RowsToString(start, rowCount);
			}

			/// @brief Get random sample of n rows
			std::string Sample(size_t n = 5, unsigned int seed = 42) const {
				if (n >= rowCount)
					return RowsToString(0, rowCount);

				// Simple LCG random selection
				std::vector<size_t> indices;
				indices.reserve(rowCount);
				for (size_t i = 0; i < rowCount; ++i)
					indices.push_back(i);

				// Fisher-Yates shuffle first n elements
				unsigned int state = seed;
				for (size_t i = 0; i < n; ++i) {
					state = state * 1103515245u + 12345u;
					size_t j = i + (state % (rowCount - i));
					std::swap(indices[i], indices[j]);
				}

				std::ostringstream oss;
				// Header
				for (size_t c = 0; c < columns.size(); ++c) {
					if (c > 0) oss << "\t";
					oss << columns[c].name;
				}
				oss << "\n";

				// Selected rows
				for (size_t i = 0; i < n; ++i) {
					size_t row = indices[i];
					for (size_t c = 0; c < columns.size(); ++c) {
						if (c > 0) oss << "\t";
						oss << columns[c].GetAsString(row);
					}
					oss << "\n";
				}

				return oss.str();
			}

			/// @brief Filter rows by predicate on a column
			/// @param colName Column to filter on
			/// @param predicate Function returning true for rows to keep
			Dataset FilterRows(const std::string& colName,
			                   std::function<bool(const std::string&)> predicate) const {
				const DataColumn& filterCol = (*this)[colName];

				// Find indices to keep
				std::vector<size_t> keepIndices;
				for (size_t i = 0; i < rowCount; ++i) {
					if (predicate(filterCol.GetAsString(i)))
						keepIndices.push_back(i);
				}

				// Build new dataset
				Dataset result;
				result.name = name + "_filtered";
				result.rowCount = keepIndices.size();
				result.columns.reserve(columns.size());

				for (const auto& srcCol : columns) {
					DataColumn newCol;
					newCol.name = srcCol.name;
					newCol.type = srcCol.type;
					newCol.missingMask.reserve(result.rowCount);

					for (size_t idx : keepIndices) {
						newCol.missingMask.push_back(srcCol.IsMissing(idx));
					}

					switch (srcCol.type) {
						case ColumnType::REAL:
							newCol.realData = Vector<Real>(result.rowCount);
							for (size_t i = 0; i < keepIndices.size(); ++i)
								newCol.realData[i] = srcCol.realData[keepIndices[i]];
							break;
						case ColumnType::INT:
							newCol.intData = Vector<int>(result.rowCount);
							for (size_t i = 0; i < keepIndices.size(); ++i)
								newCol.intData[i] = srcCol.intData[keepIndices[i]];
							break;
						case ColumnType::BOOL:
							newCol.boolData.resize(result.rowCount);
							for (size_t i = 0; i < keepIndices.size(); ++i)
								newCol.boolData[i] = srcCol.boolData[keepIndices[i]];
							break;
						case ColumnType::STRING:
							newCol.stringData.reserve(result.rowCount);
							for (size_t idx : keepIndices)
								newCol.stringData.push_back(srcCol.stringData[idx]);
							break;
						case ColumnType::DATE:
						case ColumnType::DATETIME:
							newCol.dateData.reserve(result.rowCount);
							for (size_t idx : keepIndices)
								newCol.dateData.push_back(srcCol.dateData[idx]);
							if (srcCol.type == ColumnType::DATETIME) {
								newCol.timeData.reserve(result.rowCount);
								for (size_t idx : keepIndices)
									newCol.timeData.push_back(srcCol.timeData[idx]);
							}
							break;
						case ColumnType::TIME:
							newCol.timeData.reserve(result.rowCount);
							for (size_t idx : keepIndices)
								newCol.timeData.push_back(srcCol.timeData[idx]);
							break;
						default:
							break;
					}

					result.columns.push_back(std::move(newCol));
				}

				return result;
			}

			/// @brief Select specific columns
			Dataset SelectColumns(const std::vector<std::string>& colNames) const {
				Dataset result;
				result.name = name + "_selected";
				result.rowCount = rowCount;
				result.columns.reserve(colNames.size());

				for (const auto& colName : colNames) {
					result.columns.push_back((*this)[colName]);
				}

				return result;
			}

		private:
			/// @brief Convert range of rows to string
			std::string RowsToString(size_t startRow, size_t endRow) const {
				std::ostringstream oss;

				// Header
				for (size_t c = 0; c < columns.size(); ++c) {
					if (c > 0) oss << "\t";
					oss << columns[c].name;
				}
				oss << "\n";

				// Data rows
				for (size_t r = startRow; r < endRow; ++r) {
					for (size_t c = 0; c < columns.size(); ++c) {
						if (c > 0) oss << "\t";
						oss << columns[c].GetAsString(r);
					}
					oss << "\n";
				}

				return oss.str();
			}
		};

		/////////////////////////////////////////////////////////////////////////////////////
		///                              TYPE INFERENCE                                    ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Infer column type from string values
		/// @param values Sample of string values from the column
		/// @return Most appropriate ColumnType for the data
		inline ColumnType InferColumnType(const std::vector<std::string>& values) {
			if (values.empty()) return ColumnType::STRING;

			// Count type matches
			int intCount = 0, realCount = 0, boolCount = 0;
			int dateCount = 0, timeCount = 0, dateTimeCount = 0;
			int missingCount = 0;

			// Patterns
			std::regex intPattern(R"(^[-+]?\d+$)");
			std::regex realPattern(R"(^[-+]?(\d+\.?\d*|\.\d+)([eE][-+]?\d+)?$)");
			std::regex datePattern(R"(^\d{4}[-/]\d{1,2}[-/]\d{1,2}$)");
			std::regex timePattern(R"(^\d{1,2}:\d{2}(:\d{2})?(\.\d+)?$)");
			std::regex dateTimePattern(R"(^\d{4}[-/]\d{1,2}[-/]\d{1,2}[T ]\d{1,2}:\d{2}(:\d{2})?$)");

			for (const auto& val : values) {
				std::string trimmed = val;
				// Trim whitespace
				trimmed.erase(0, trimmed.find_first_not_of(" \t\r\n"));
				trimmed.erase(trimmed.find_last_not_of(" \t\r\n") + 1);

				if (IsMissingValue(trimmed)) {
					++missingCount;
					continue;
				}

				// Check numeric patterns FIRST (before bool, since "1"/"0" could be numeric)
				if (std::regex_match(trimmed, intPattern)) {
					++intCount;
					continue;
				}
				if (std::regex_match(trimmed, realPattern)) {
					++realCount;
					continue;
				}

				// Check bool patterns (text-based only, not 1/0 which are handled as int)
				std::string lower = trimmed;
				std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
				if (lower == "true" || lower == "false" || lower == "yes" || lower == "no" ||
				    lower == "t" || lower == "f" || lower == "y" || lower == "n") {
					++boolCount;
					continue;
				}

				// Check date/time patterns
				if (std::regex_match(trimmed, dateTimePattern)) {
					++dateTimeCount;
					continue;
				}
				if (std::regex_match(trimmed, datePattern)) {
					++dateCount;
					continue;
				}
				if (std::regex_match(trimmed, timePattern)) {
					++timeCount;
					continue;
				}
			}

			int totalNonMissing = static_cast<int>(values.size()) - missingCount;
			if (totalNonMissing == 0) return ColumnType::STRING;

			// Determine type based on majority
			double threshold = 0.9;  // 90% match required

			if (dateTimeCount >= threshold * totalNonMissing) return ColumnType::DATETIME;
			if (dateCount >= threshold * totalNonMissing) return ColumnType::DATE;
			if (timeCount >= threshold * totalNonMissing) return ColumnType::TIME;
			if (boolCount >= threshold * totalNonMissing) return ColumnType::BOOL;
			if (intCount >= threshold * totalNonMissing) return ColumnType::INT;
			if ((intCount + realCount) >= threshold * totalNonMissing) return ColumnType::REAL;

			return ColumnType::STRING;
		}

		/////////////////////////////////////////////////////////////////////////////////////
		///                              VALUE PARSING                                     ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Parse a string value to the target type
		/// @param value String value to parse
		/// @param targetType Target column type
		/// @param[out] realOut Real output (if REAL type)
		/// @param[out] intOut Integer output (if INT type)
		/// @param[out] boolOut Boolean output (if BOOL type)
		/// @param[out] stringOut String output (if STRING/DATE/TIME type)
		/// @return true if parsing succeeded, false if value should be marked as missing
		inline bool ParseValue(const std::string& value, ColumnType targetType,
		                       Real& realOut, int& intOut, bool& boolOut, std::string& stringOut) {
			std::string trimmed = value;
			trimmed.erase(0, trimmed.find_first_not_of(" \t\r\n"));
			if (!trimmed.empty())
				trimmed.erase(trimmed.find_last_not_of(" \t\r\n") + 1);

			if (IsMissingValue(trimmed))
				return false;

			try {
				switch (targetType) {
					case ColumnType::REAL: {
						realOut = std::stod(trimmed);
						return true;
					}
					case ColumnType::INT: {
						intOut = std::stoi(trimmed);
						return true;
					}
					case ColumnType::BOOL: {
						std::string lower = trimmed;
						std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
						if (lower == "true" || lower == "yes" || lower == "t" || lower == "y" || lower == "1") {
							boolOut = true;
							return true;
						}
						if (lower == "false" || lower == "no" || lower == "f" || lower == "n" || lower == "0") {
							boolOut = false;
							return true;
						}
						return false;
					}
					case ColumnType::STRING:
					case ColumnType::DATE:
					case ColumnType::TIME:
					case ColumnType::DATETIME:
						stringOut = trimmed;
						return true;
					default:
						return false;
				}
			}
			catch (...) {
				return false;  // Parse error -> missing
			}
		}

		/////////////////////////////////////////////////////////////////////////////////////
		///                              STRING UTILITIES                                  ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Split a string by delimiter, respecting quoted fields
		inline std::vector<std::string> SplitLine(const std::string& line, char delimiter) {
			std::vector<std::string> result;
			std::string field;
			bool inQuotes = false;
			bool prevWasQuote = false;

			for (size_t i = 0; i < line.size(); ++i) {
				char c = line[i];

				if (c == '"') {
					if (inQuotes && i + 1 < line.size() && line[i + 1] == '"') {
						// Escaped quote
						field += '"';
						++i;
					}
					else {
						inQuotes = !inQuotes;
					}
					prevWasQuote = true;
				}
				else if (c == delimiter && !inQuotes) {
					result.push_back(field);
					field.clear();
					prevWasQuote = false;
				}
				else {
					field += c;
					prevWasQuote = false;
				}
			}
			result.push_back(field);

			return result;
		}

		/// @brief Trim whitespace from string
		inline std::string Trim(const std::string& s) {
			size_t start = s.find_first_not_of(" \t\r\n");
			if (start == std::string::npos) return "";
			size_t end = s.find_last_not_of(" \t\r\n");
			return s.substr(start, end - start + 1);
		}

		/// @brief Remove UTF-8 BOM if present
		inline std::string RemoveBOM(const std::string& s) {
			if (s.size() >= 3 &&
			    static_cast<unsigned char>(s[0]) == 0xEF &&
			    static_cast<unsigned char>(s[1]) == 0xBB &&
			    static_cast<unsigned char>(s[2]) == 0xBF) {
				return s.substr(3);
			}
			return s;
		}

		/////////////////////////////////////////////////////////////////////////////////////
		///                              CSV/TSV LOADING                                   ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Load dataset from CSV file
		/// @param filename Path to CSV file
		/// @param hasHeader If true, first row is column names
		/// @param delimiter Field delimiter (default ',')
		/// @param inferTypes If true, automatically infer column types
		/// @return Loaded dataset
		/// @throws DataError on file/parse errors
		inline Dataset LoadCSV(const std::string& filename, bool hasHeader = true,
		                       char delimiter = ',', bool inferTypes = true) {
			std::ifstream file(filename);
			if (!file.is_open())
				throw DataError("LoadCSV: Cannot open file '" + filename + "'");

			Dataset dataset;
			dataset.name = filename;

			std::vector<std::vector<std::string>> allData;
			std::string line;
			bool firstLine = true;

			while (std::getline(file, line)) {
				// Handle BOM on first line
				if (firstLine) {
					line = RemoveBOM(line);
					firstLine = false;
				}

				// Skip empty lines
				if (Trim(line).empty()) continue;

				// Handle Windows line endings
				if (!line.empty() && line.back() == '\r')
					line.pop_back();

				std::vector<std::string> fields = SplitLine(line, delimiter);
				allData.push_back(fields);
			}

			if (allData.empty())
				throw DataError("LoadCSV: File is empty");

			// Determine column count
			size_t numCols = allData[0].size();
			size_t dataStartRow = hasHeader ? 1 : 0;

			// Setup columns
			dataset.columns.resize(numCols);

			for (size_t c = 0; c < numCols; ++c) {
				if (hasHeader) {
					dataset.columns[c].name = Trim(allData[0][c]);
					if (dataset.columns[c].name.empty())
						dataset.columns[c].name = "Column" + std::to_string(c);
				}
				else {
					dataset.columns[c].name = "Column" + std::to_string(c);
				}
			}

			// Collect string values for type inference
			if (inferTypes) {
				for (size_t c = 0; c < numCols; ++c) {
					std::vector<std::string> colValues;
					for (size_t r = dataStartRow; r < allData.size(); ++r) {
						if (c < allData[r].size())
							colValues.push_back(allData[r][c]);
						else
							colValues.push_back("");
					}
					dataset.columns[c].type = InferColumnType(colValues);
				}
			}
			else {
				// Default to STRING
				for (size_t c = 0; c < numCols; ++c)
					dataset.columns[c].type = ColumnType::STRING;
			}

			// Parse data
			dataset.rowCount = allData.size() - dataStartRow;

			for (size_t c = 0; c < numCols; ++c) {
				DataColumn& col = dataset.columns[c];
				col.missingMask.resize(dataset.rowCount, false);

				// Pre-allocate
				switch (col.type) {
					case ColumnType::REAL:
						col.realData = Vector<Real>(dataset.rowCount);
						break;
					case ColumnType::INT:
						col.intData = Vector<int>(dataset.rowCount);
						break;
					case ColumnType::BOOL:
						col.boolData.resize(dataset.rowCount);
						break;
					case ColumnType::STRING:
					case ColumnType::DATE:
					case ColumnType::TIME:
						col.stringData.resize(dataset.rowCount);
						break;
					case ColumnType::DATETIME:
						col.dateData.resize(dataset.rowCount);
						col.timeData.resize(dataset.rowCount);
						break;
					default:
						break;
				}
			}

			for (size_t r = dataStartRow; r < allData.size(); ++r) {
				size_t rowIdx = r - dataStartRow;
				const auto& row = allData[r];

				for (size_t c = 0; c < numCols; ++c) {
					DataColumn& col = dataset.columns[c];
					std::string value = (c < row.size()) ? row[c] : "";

					Real realVal = 0.0;
					int intVal = 0;
					bool boolVal = false;
					std::string strVal;

					bool parsed = ParseValue(value, col.type, realVal, intVal, boolVal, strVal);
					col.missingMask[rowIdx] = !parsed;

					switch (col.type) {
						case ColumnType::REAL:
							col.realData[rowIdx] = parsed ? realVal : std::numeric_limits<Real>::quiet_NaN();
							break;
						case ColumnType::INT:
							col.intData[rowIdx] = parsed ? intVal : 0;
							break;
						case ColumnType::BOOL:
							col.boolData[rowIdx] = parsed ? boolVal : false;
							break;
						case ColumnType::STRING:
							col.stringData[rowIdx] = parsed ? strVal : "";
							break;
						case ColumnType::DATE:
							col.dateData.resize(dataset.rowCount);
							col.dateData[rowIdx] = parsed ? strVal : "";
							break;
						case ColumnType::TIME:
							col.timeData.resize(dataset.rowCount);
							col.timeData[rowIdx] = parsed ? strVal : "";
							break;
						case ColumnType::DATETIME:
							if (parsed && !strVal.empty()) {
								// Split datetime into date and time
								size_t sep = strVal.find_first_of("T ");
								if (sep != std::string::npos) {
									col.dateData[rowIdx] = strVal.substr(0, sep);
									col.timeData[rowIdx] = strVal.substr(sep + 1);
								}
								else {
									col.dateData[rowIdx] = strVal;
									col.timeData[rowIdx] = "";
								}
							}
							break;
						default:
							break;
					}
				}
			}

			return dataset;
		}

		/// @brief Load dataset from TSV file
		inline Dataset LoadTSV(const std::string& filename, bool hasHeader = true, bool inferTypes = true) {
			return LoadCSV(filename, hasHeader, '\t', inferTypes);
		}

		/////////////////////////////////////////////////////////////////////////////////////
		///                              JSON LOADING                                      ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Simple JSON value types for parsing
		enum class JsonType { Null, Bool, Number, String, Array, Object };

		/// @brief Minimal JSON parser state
		struct JsonParser {
			const std::string& json;
			size_t pos;

			JsonParser(const std::string& s) : json(s), pos(0) {}

			void SkipWhitespace() {
				while (pos < json.size() && std::isspace(json[pos])) ++pos;
			}

			char Peek() {
				SkipWhitespace();
				return pos < json.size() ? json[pos] : '\0';
			}

			char Get() {
				SkipWhitespace();
				return pos < json.size() ? json[pos++] : '\0';
			}

			std::string ParseString() {
				if (Get() != '"')
					throw DataError("JSON: Expected '\"'");

				std::string result;
				while (pos < json.size()) {
					char c = json[pos++];
					if (c == '"') return result;
					if (c == '\\' && pos < json.size()) {
						char esc = json[pos++];
						switch (esc) {
							case 'n': result += '\n'; break;
							case 't': result += '\t'; break;
							case 'r': result += '\r'; break;
							case '"': result += '"'; break;
							case '\\': result += '\\'; break;
							case '/': result += '/'; break;
							default: result += esc; break;
						}
					}
					else {
						result += c;
					}
				}
				throw DataError("JSON: Unterminated string");
			}

			std::string ParseNumber() {
				SkipWhitespace();
				size_t start = pos;
				if (json[pos] == '-') ++pos;
				while (pos < json.size() && (std::isdigit(json[pos]) || json[pos] == '.' ||
				       json[pos] == 'e' || json[pos] == 'E' || json[pos] == '+' || json[pos] == '-')) {
					++pos;
				}
				return json.substr(start, pos - start);
			}

			bool ParseBool() {
				SkipWhitespace();
				if (json.substr(pos, 4) == "true") {
					pos += 4;
					return true;
				}
				if (json.substr(pos, 5) == "false") {
					pos += 5;
					return false;
				}
				throw DataError("JSON: Expected boolean");
			}

			void ParseNull() {
				SkipWhitespace();
				if (json.substr(pos, 4) == "null") {
					pos += 4;
					return;
				}
				throw DataError("JSON: Expected null");
			}

			JsonType PeekType() {
				char c = Peek();
				if (c == '"') return JsonType::String;
				if (c == '[') return JsonType::Array;
				if (c == '{') return JsonType::Object;
				if (c == 't' || c == 'f') return JsonType::Bool;
				if (c == 'n') return JsonType::Null;
				if (c == '-' || std::isdigit(c)) return JsonType::Number;
				throw DataError("JSON: Unexpected character");
			}

			/// @brief Parse array of objects into Dataset
			Dataset ParseArrayOfObjects() {
				Dataset dataset;

				if (Get() != '[')
					throw DataError("JSON: Expected '[' at root");

				std::map<std::string, std::vector<std::string>> columnData;
				std::vector<std::string> columnOrder;

				// Parse each object
				while (Peek() != ']') {
					if (Peek() == ',') Get();  // Skip comma

					if (Get() != '{')
						throw DataError("JSON: Expected '{' for object");

					// Parse object key-value pairs
					while (Peek() != '}') {
						if (Peek() == ',') Get();

						std::string key = ParseString();
						if (Get() != ':')
							throw DataError("JSON: Expected ':' after key");

						// Track column order
						if (columnData.find(key) == columnData.end()) {
							columnOrder.push_back(key);
						}

						// Parse value as string
						std::string value;
						switch (PeekType()) {
							case JsonType::String:
								value = ParseString();
								break;
							case JsonType::Number:
								value = ParseNumber();
								break;
							case JsonType::Bool:
								value = ParseBool() ? "true" : "false";
								break;
							case JsonType::Null:
								ParseNull();
								value = "";
								break;
							default:
								throw DataError("JSON: Unsupported value type (nested objects/arrays not supported)");
						}

						columnData[key].push_back(value);
					}

					if (Get() != '}')
						throw DataError("JSON: Expected '}'");

					// Fill missing columns with empty for this row
					size_t maxRows = 0;
					for (const auto& col : columnOrder) {
						maxRows = std::max(maxRows, columnData[col].size());
					}
					for (const auto& col : columnOrder) {
						while (columnData[col].size() < maxRows)
							columnData[col].push_back("");
					}
				}

				if (Get() != ']')
					throw DataError("JSON: Expected ']'");

				// Build dataset
				if (!columnOrder.empty()) {
					dataset.rowCount = columnData[columnOrder[0]].size();
					dataset.columns.reserve(columnOrder.size());

					for (const auto& colName : columnOrder) {
						DataColumn col;
						col.name = colName;
						col.type = InferColumnType(columnData[colName]);
						col.missingMask.resize(dataset.rowCount, false);

						// Parse values
						const auto& values = columnData[colName];
						for (size_t i = 0; i < values.size(); ++i) {
							Real realVal = 0.0;
							int intVal = 0;
							bool boolVal = false;
							std::string strVal;

							bool parsed = ParseValue(values[i], col.type, realVal, intVal, boolVal, strVal);
							col.missingMask[i] = !parsed;

							switch (col.type) {
								case ColumnType::REAL:
									if (i == 0) col.realData = Vector<Real>(values.size());
									col.realData[i] = parsed ? realVal : std::numeric_limits<Real>::quiet_NaN();
									break;
								case ColumnType::INT:
									if (i == 0) col.intData = Vector<int>(values.size());
									col.intData[i] = parsed ? intVal : 0;
									break;
								case ColumnType::BOOL:
									if (i == 0) col.boolData.resize(values.size());
									col.boolData[i] = parsed ? boolVal : false;
									break;
								default:
									if (i == 0) col.stringData.resize(values.size());
									col.stringData[i] = parsed ? strVal : "";
									break;
							}
						}

						dataset.columns.push_back(std::move(col));
					}
				}

				return dataset;
			}
		};

		/// @brief Load dataset from JSON file (array of objects format)
		/// @param filename Path to JSON file
		/// @return Loaded dataset
		/// @throws DataError on file/parse errors
		inline Dataset LoadJSON(const std::string& filename) {
			std::ifstream file(filename);
			if (!file.is_open())
				throw DataError("LoadJSON: Cannot open file '" + filename + "'");

			std::stringstream buffer;
			buffer << file.rdbuf();
			std::string content = buffer.str();

			// Remove BOM if present
			content = RemoveBOM(content);

			JsonParser parser(content);
			Dataset dataset = parser.ParseArrayOfObjects();
			dataset.name = filename;

			return dataset;
		}

		/////////////////////////////////////////////////////////////////////////////////////
		///                              STRING LOADING                                    ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Load dataset from string content
		/// @param content String containing data
		/// @param format Data format
		/// @param hasHeader If true, first row is column names
		/// @return Loaded dataset
		inline Dataset LoadFromString(const std::string& content, DataFormat format,
		                              bool hasHeader = true) {
			// Create a temporary stringstream
			std::string cleanContent = RemoveBOM(content);

			if (format == DataFormat::JSON) {
				JsonParser parser(cleanContent);
				return parser.ParseArrayOfObjects();
			}

			// CSV/TSV parsing
			char delimiter = (format == DataFormat::TSV) ? '\t' : ',';

			Dataset dataset;
			std::vector<std::vector<std::string>> allData;
			std::istringstream iss(cleanContent);
			std::string line;

			while (std::getline(iss, line)) {
				if (Trim(line).empty()) continue;
				if (!line.empty() && line.back() == '\r')
					line.pop_back();
				allData.push_back(SplitLine(line, delimiter));
			}

			if (allData.empty())
				throw DataError("LoadFromString: Content is empty");

			size_t numCols = allData[0].size();
			size_t dataStartRow = hasHeader ? 1 : 0;

			dataset.columns.resize(numCols);

			for (size_t c = 0; c < numCols; ++c) {
				if (hasHeader) {
					dataset.columns[c].name = Trim(allData[0][c]);
					if (dataset.columns[c].name.empty())
						dataset.columns[c].name = "Column" + std::to_string(c);
				}
				else {
					dataset.columns[c].name = "Column" + std::to_string(c);
				}

				// Type inference
				std::vector<std::string> colValues;
				for (size_t r = dataStartRow; r < allData.size(); ++r) {
					if (c < allData[r].size())
						colValues.push_back(allData[r][c]);
				}
				dataset.columns[c].type = InferColumnType(colValues);
			}

			dataset.rowCount = allData.size() - dataStartRow;

			// Parse data (same as LoadCSV)
			for (size_t c = 0; c < numCols; ++c) {
				DataColumn& col = dataset.columns[c];
				col.missingMask.resize(dataset.rowCount, false);

				switch (col.type) {
					case ColumnType::REAL:
						col.realData = Vector<Real>(dataset.rowCount);
						break;
					case ColumnType::INT:
						col.intData = Vector<int>(dataset.rowCount);
						break;
					case ColumnType::BOOL:
						col.boolData.resize(dataset.rowCount);
						break;
					default:
						col.stringData.resize(dataset.rowCount);
						break;
				}
			}

			for (size_t r = dataStartRow; r < allData.size(); ++r) {
				size_t rowIdx = r - dataStartRow;
				const auto& row = allData[r];

				for (size_t c = 0; c < numCols; ++c) {
					DataColumn& col = dataset.columns[c];
					std::string value = (c < row.size()) ? row[c] : "";

					Real realVal = 0.0;
					int intVal = 0;
					bool boolVal = false;
					std::string strVal;

					bool parsed = ParseValue(value, col.type, realVal, intVal, boolVal, strVal);
					col.missingMask[rowIdx] = !parsed;

					switch (col.type) {
						case ColumnType::REAL:
							col.realData[rowIdx] = parsed ? realVal : std::numeric_limits<Real>::quiet_NaN();
							break;
						case ColumnType::INT:
							col.intData[rowIdx] = parsed ? intVal : 0;
							break;
						case ColumnType::BOOL:
							col.boolData[rowIdx] = parsed ? boolVal : false;
							break;
						default:
							col.stringData[rowIdx] = parsed ? strVal : "";
							break;
					}
				}
			}

			return dataset;
		}

		/////////////////////////////////////////////////////////////////////////////////////
		///                              AUTO-FORMAT LOADING                               ///
		/////////////////////////////////////////////////////////////////////////////////////

		/// @brief Detect format from file extension
		inline DataFormat DetectFormat(const std::string& filename) {
			size_t dotPos = filename.rfind('.');
			if (dotPos == std::string::npos)
				return DataFormat::CSV;  // Default

			std::string ext = filename.substr(dotPos + 1);
			std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);

			if (ext == "csv") return DataFormat::CSV;
			if (ext == "tsv" || ext == "tab") return DataFormat::TSV;
			if (ext == "json") return DataFormat::JSON;

			return DataFormat::CSV;  // Default
		}

		/// @brief Load dataset with auto-detected format
		/// @param filename Path to file
		/// @param hasHeader If true, first row is column names (for CSV/TSV)
		/// @return Loaded dataset
		inline Dataset LoadData(const std::string& filename, bool hasHeader = true) {
			DataFormat format = DetectFormat(filename);

			switch (format) {
				case DataFormat::JSON:
					return LoadJSON(filename);
				case DataFormat::TSV:
					return LoadTSV(filename, hasHeader);
				case DataFormat::CSV:
				default:
					return LoadCSV(filename, hasHeader);
			}
		}

	}  // namespace Data
}  // namespace MML


#endif   //MML.h 
